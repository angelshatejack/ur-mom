-- x2hub fixed

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("x2hub premium", "Midnight")
local Tab = Window:NewTab("Converted scripts")
local Section = Tab:NewSection("These were SS scripts converted to FE")
local Section = Tab:NewSection("*SOME* scripts have just grass compatibility")
-- local Section = Tab:NewSection("Unlike Croaxer we actually put time and effort into our scripts")

Section:NewButton("FE Maddox Lightning Cannon", "Does what your typical lightning cannon would do", function()
    print("Clicked")
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart")  then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(-7,0,-40)
end)
end
end
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,999,0)
Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
loadstring(game:GetObjects("rbxassetid://8770171778")[1].Source)()																	--]]
workspace.non.HumanoidRootPart.CFrame = CFrame.new(0,10,0)

local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Transparency = 0.6
	bullet.Massless = true
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end
local e = Instance.new("SelectionBox", bullet)
e.Adornee = bullet
	bbv = Instance.new("BodyPosition",bullet)
    bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
coroutine.wrap(function()
	while true do
		if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
		if StateMover then
			bbv.Position = playerss.Torso.CFrame.p - Vector3.new(0,16,0)
    		bullet.Position = playerss.Torso.CFrame.p - Vector3.new(0,16,0)
		end
		game:GetService("RunService").RenderStepped:wait()
	end
end)()
end

local CDDF = {}
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
	CDDF[DmgPer] = true; StateMover = false
    bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 1000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
    game:GetService("Debris"):AddItem(bbav,0.1)
    bullet.Rotation = playerss.Torso.Rotation
	
		bbv.Position = (DmgPer:FindFirstChildOfClass("BasePart") and DmgPer:FindFirstChildOfClass("BasePart").CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
		bullet.Position = (DmgPer:FindFirstChildOfClass("BasePart") and DmgPer:FindFirstChildOfClass("BasePart").CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
        wait(0.03)

	bbv.Position = playerss.Torso.CFrame.p - Vector3.new(0,16,0)
    bullet.Position = playerss.Torso.CFrame.p - Vector3.new(0,16,0)
	CDDF[DmgPer] = false; StateMover = true
end


local function AlignHat(p1,p2,nomesh)
    pcall(function()
    p1:FindFirstChildOfClass("Weld"):Destroy()
    if nomesh then 
        p1:FindFirstChildOfClass("SpecialMesh"):Destroy()
    end
    end)
     A1 = Instance.new("Attachment", p1) 
     A2 = Instance.new("Attachment", p2)
     Mover = Instance.new("AlignPosition", p1)
     Mover.RigidityEnabled = false
    Mover.Attachment0 = A1
    Mover.Attachment1 = A2
    Mover.Responsiveness = 200
    Mover.MaxVelocity = math.huge
    Mover.MaxForce = 2.0000002045924e+34
     Rotater = Instance.new("AlignOrientation", p1)
     Rotater.RigidityEnabled = false
    Rotater.Attachment0 = A1
    Rotater.Attachment1 = A2
    Rotater.Responsiveness = 200
    Rotater.MaxAngularVelocity = math.huge
    Rotater.MaxTorque = math.huge
end

--Fixed
--LC By LuaQuack, Edit By MrMaddox32
--THIS SCRIPT IS NOT FOR LEAK
--No Trades
--Not Rare                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    aa
--Discord: MrMaddox32#5426                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  skid
--fAaqREDijrhuYRGkhgrv
--Shield Function By HoneyDevx
--Shield Edit By MrMaddox32
--Don't Leak pls is not easy to make edits
--don't trade
--don't save in inventory
--bean LC is shit.

--updates:
--removed antikick key because is shit
--removed killall key
--removed shutdown key because missclick
--added Skid taunt
--added fly speed with walkspeed speed
--added new tp effect
--added old MLC mode
--nothing more lol
------------------

local script = game:GetObjects("rbxassetid://9116011877")[1]

print("MrMaddox32 is not english")
local stopeverything = false
local MAINRUINCOLOR = Color3.fromRGB(0,0,0) -- Custom Color
local CurrentColor = Color3.fromRGB(0,0,0) -- Don't Change This
VT=Vector3.new
CF=CFrame.new
Animation_Speed=3
SIN=math.sin
ANGLES=CFrame.Angles
angles=CFrame.Angles
RAD=math.rad
COS=math.cos
MRANDOM=math.random
Cos=math.cos
Sin=math.sin
local inf = "inf"
local change = 1
local CHATFUNCTEXT = "Not USC | Maddox LC By MrMaddox32" -- THE VERSION LOL
print(CHATFUNCTEXT)
game:GetService("RunService").RenderStepped:Wait()

local function randomstring()
	local length = math.random(10,20)
	local array = {}
	for i = 1,length do
		array[i] = string.char(math.random(32,126))
	end
	return table.concat(array)
end
local HipVal = 3
local lplr = game:GetService("Players").LocalPlayer
local sine = 0
local walksine = 10
local walkc = 1
local sine2 = -10
local c2 = 2 / Animation_Speed
local LOOPx = 0
local USERNAME = lplr.Name
local creator = {1308783007,1710676584,1442214824,1615916525,1442218084,1673231425,1310685079,1087181414,984151503,1442167487,1587587028,1441994738,1129585258,1129586211,275036820,1087264812,1087241085,1318469264,1622394251,663322373,1664828681,930999813,1442217078,1442208195,1340979865,1444403544,1664860157,1442285617,1442213697,1442218738,1442229346,1442213021,1124518548,1129587486,873439757}
local peoplez = {1527159577,1588949918,115542329,1039485759,5692671904,4849301958,507004875,1532973409,561307703,1818239823,556191187,1840583733,905597056,263874560,30212718,16540295,236988943,503184974,121439200,321272852,342306771,285969486,1731267347,971145259,1850668236,117871633,1550034461,55630148,111290520,1505962447,335228723,825398259,1191576743,87867914,112192467,732341111,115130006}
local iscreator = false

local Player = game:GetService("Players"):FindFirstChild(USERNAME)
function swait(num)
if num==0 or num==nil then
game:service'RunService'.Stepped:wait(0)
else
for i=0,num do
game:service'RunService'.Stepped:wait(0)
end
end
end
 

local AnimSync = Instance.new("NumberValue")
AnimSync.Name = "AnimSync"
AnimSync.Value = 0

local taunt = Instance.new("StringValue")
taunt.Value = "None"

local Shield = Instance.new("BoolValue")
local songid = Instance.new("StringValue")
songid.Value = "rbxassetid://679355361"
local ballsize = Instance.new("NumberValue")
ballsize.Value = 25
local ballmaterial = Instance.new("StringValue")
ballmaterial.Value = "Neon"
local attack = false
local cannecksnap = true


local walkspeed = 50
local TauntRemote = Instance.new("BindableEvent")

local songvolume = Instance.new("NumberValue")
songvolume.Name = "SongVolume"
songvolume.Value = 1
local songpitch=Instance.new("NumberValue")
songpitch.Name = "SongPitch"
songpitch.Value = 1
local eeevol=songvolume.Value
if true then
	eeevol=songvolume.Value/2
end
local eeepitch  = songpitch.Value
local ISFLYING = false
songvolume:GetPropertyChangedSignal("Value"):Connect(function()
if stopeverything then wait(math.huge) end
	eeevol=songvolume.Value/2
end)
songpitch:GetPropertyChangedSignal("Value"):Connect(function()
if stopeverything then wait(math.huge) end
	eeepitch=songpitch.Value
end)
local antivoid = nil
local savedchar = script.dumi
savedchar.Parent = nil
local Character = workspace.non

local eeeblock = Instance.new("Part")
local Humanoid = Character.Humanoid

local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local Neck = Torso["Neck"]
local RightShoulder = Torso["Right Shoulder"]
local LeftShoulder = Torso["Left Shoulder"]
local RightHip = Torso["Right Hip"]
local LeftHip = Torso["Left Hip"]
--
local hum = Character.Humanoid
local root = Character.HumanoidRootPart
local rootj = RootPart.RootJoint
local RW = Torso["Right Shoulder"]
local LW = Torso["Left Shoulder"]
local RH = Torso["Right Hip"]
local LH = Torso["Left Hip"]
--
local outerm = savedchar.Visualizer.Mesh
outerm.Parent = Character
local outerm2 = savedchar.Visualizer2.Mesh
outerm2.Parent = Character
local Effects = Instance.new("Folder",Character)
local BallFolder = Instance.new("Folder")
BallFolder.Parent = workspace.Terrain
BallFolder.Name = randomstring()
local HipValLock = false
local Parents = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"}

TauntRemote.Event:connect(function(one, two)
taunt.Value = one
songid.Value = "rbxassetid://"..two
end)

local GUN = savedchar.MegaGunnModel
local GunJoint = GUN.Joint.Weld
local Hole = GUN.Hole
local Holetwo = GUN.Hole2
GUN.Parent = Character
GUN.Joint.Weld.Part0 = Character["Right Arm"]
Hole.Weld.C1 = Hole.Weld.C1*CFrame.new(0,.635,-2)
Holetwo.Weld.C1 = Hole.Weld.C1*CFrame.new(0,0,4)
Character.Animate:Destroy()
Character.Humanoid.Animator:Destroy()
local GUN2 = savedchar.gun
GUN2.Parent = Character

GUN2.Hole.Weld.Part0 = Character["Right Arm"]
pcall(function()
    
    	Railgun = workspace.non["Starslayer Railgun"].Handle
	AlignHat(Railgun,GUN.Joint,false)
Railgun.Attachment.CFrame = CFrame.new(-1.29999995, 0.200000003, 0, -4.37113883e-08, 0.707106829, -0.707106829, 0, 0.707106829, 0.707106829, 1, 3.09086232e-08, -3.09086197e-08)

    end)
local alreadyfixing = false
local shieldblock = Instance.new("Part")
shieldblock.Color = CurrentColor
shieldblock.Name = "Garcello "..randomstring()
shieldblock.CanCollide = false
shieldblock.Anchored = true
shieldblock.Transparency = 0
shieldblock.CFrame = Torso.CFrame
shieldblock.Parent = nil
shieldblock.Shape = "Ball"
shieldblock.Size = Vector3.new(25+1*math.sin(sine/25),25+1*math.sin(sine/25),25+1*math.sin(sine/25))
shieldblock.Material = "ForceField"
local eeeblock = Instance.new("Part")
eeeblock.Name = randomstring()
eeeblock.CanCollide = false
eeeblock.Anchored = true
eeeblock.Transparency = 1
eeeblock.CFrame = Torso.CFrame
eeeblock.Parent = workspace
eeeblock.Shape = "Ball"
eeeblock.Size = Vector3.new(12,12,12)
local eee = Instance.new("Sound",eeeblock)
eee.Volume = eeevol
eee.Pitch = eeepitch
eee.SoundId = songid.Value
eee:Play()
eee.Name = randomstring()
eee.Looped = true
eee.TimePosition = 0
eee.DescendantAdded:Connect(function(v)
if stopeverything then wait(math.huge) end
	if v:IsA("DistortionSoundEffect") then 
		return 
	end
	if v:IsA("SoundEffect") then
		v.Enabled = false
		v:GetPropertyChangedSignal("Enabled"):Connect(function()
if stopeverything then wait(math.huge) end
			if v.Enabled ~= false then
				v.Enabled = false
			end
		end)
	end
	game:GetService("Debris"):AddItem(v,.01)
end)
songid:GetPropertyChangedSignal("Value"):Connect(function()
if stopeverything then wait(math.huge) end
	eee.SoundId = songid.Value
	eee.TimePosition = 0
end)
local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(1,1,1)
FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(1,1,1)
FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(1,1,1)
FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(1,1,1)
FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(1,1,1)
function chatfunc(textt,glitchy)
	local text = string.gsub(string.gsub(textt,"​",""),"%c","")
	if string.lower(text) == "/e g/r" then
	
		return
	end
	if string.sub(text,1,3) == "/e " or string.sub(text,1,3) == "/w " or string.sub(text,1,3) == "/c " then
		return
	end
	local chat = coroutine.wrap(function()
		local oldthing = eeeblock:FindFirstChild("TalkingBillBoard")
		if oldthing then
			oldthing:Destroy()
		end
		local sayingstuff = Instance.new("BillboardGui",eeeblock)
		sayingstuff.Size = UDim2.new(0,9999,2,0)
		sayingstuff.StudsOffset = Vector3.new(0,5,0)
		sayingstuff.Adornee = eeeblock
		sayingstuff.Name = "TalkingBillBoard"
		local sayingstuff2 = Instance.new("TextLabel",sayingstuff)
		sayingstuff2.BackgroundTransparency = 1
		sayingstuff2.BorderSizePixel = 0
		sayingstuff2.Text = ""
		sayingstuff2.Font = "Arcade"
		sayingstuff2.TextScaled = true
		sayingstuff2.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while not stopeverything and sayingstuff2:IsDescendantOf(game) do
				local hBRUH,sBRUH,vBRUH = Color3.toHSV(GUN.NeonParts.Color)
				sayingstuff2.TextColor3 = Color3.fromHSV(hBRUH,sBRUH,vBRUH/2)
				swait()
			end
		end))
		sayingstuff2.TextStrokeColor3 = MAINRUINCOLOR
		sayingstuff2.Size = UDim2.new(1,0,1,0)
		local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
		sayingstuff3.BackgroundTransparency = 1
		sayingstuff3.BorderSizePixel = 0
		sayingstuff3.Text = ""
		sayingstuff3.Font = "Arcade"
		sayingstuff3.TextScaled = true
		sayingstuff3.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while not stopeverything and sayingstuff3:IsDescendantOf(game) do
				sayingstuff3.TextColor3 = GUN.NeonParts.Color
				swait()
			end
		end))
		sayingstuff3.TextStrokeColor3 = MAINRUINCOLOR
		sayingstuff3.Size = UDim2.new(1,0,1,0)
		coroutine.resume(coroutine.create(function()
			while not stopeverything and sayingstuff ~= nil do
				swait()
				if glitchy then
					local fonts = {"Antique","Arcade","Arial","ArialBold","Bodoni","Cartoon","Code","Fantasy","Garamond","Gotham","GothamBlack","GothamBold","GothamSemibold","Highway","SciFi","SourceSans","SourceSansBold","SourceSansItalic","SourceSansLight","SourceSansSemibold"}
					local randomfont = fonts[math.random(1,#fonts)]
					sayingstuff2.Font = randomfont
					sayingstuff3.Font = randomfont
				end
				sayingstuff2.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				sayingstuff3.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				sayingstuff3.Rotation = math.random(-1,1)	
				sayingstuff2.Rotation = math.random(-1,1)
			end
		end))
		for i = 1,string.len(text) do
			swait(2)
			sayingstuff2.Text = string.sub(text,1,i)
			sayingstuff3.Text = string.sub(text,1,i)
		end
		swait(120)
		for i = 1,50 do
			swait()
			sayingstuff2.TextStrokeTransparency = i/50
			sayingstuff2.TextTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextStrokeTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextTransparency = sayingstuff2.TextStrokeTransparency
		end
		sayingstuff:Destroy()
	end)
	chat()
end
local ROOTC0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local NECKC0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
--
local RootCF = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local necko = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
--
local RIGHTSHOULDERC0 = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local LEFTSHOULDERC0 = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local BG = nil
local BV = nil
local soundfixing = false
local function shieldfixer()
	pcall(function()
		shieldblock:Destroy()
	end)
	local shieldblock = Instance.new("Part")
	shieldblock.Color = CurrentColor
	shieldblock.Name = "Garcello "..randomstring()
	shieldblock.CanCollide = false
	shieldblock.Anchored = true
	shieldblock.Transparency = 0
	shieldblock.CFrame = Torso.CFrame
	shieldblock.Parent = workspace
	shieldblock.Shape = "Ball"
	shieldblock.Size = Vector3.new(25+1*math.sin(sine/25),25+1*math.sin(sine/25),25+1*math.sin(sine/25))
	shieldblock.Material = "ForceField"
	shieldblock:ClearAllChildren()
end
local function soundfixer()
	soundfixing = true
	pcall(function()
		eeeblock:Destroy()
	end)
	pcall(function()
		eee:Destroy()
	end)
	eeeblock = Instance.new("Part")
	eeeblock.Name = randomstring()
	eeeblock.CanCollide = false
	eeeblock.Anchored = true
	eeeblock.Transparency = 1
	if not alreadyfixing then
		eeeblock.CFrame = Torso.CFrame
	end
	eeeblock.Parent = workspace
	eeeblock.Shape = "Ball"
	eeeblock.Size = Vector3.new(12,12,12)
	eee = Instance.new("Sound",eeeblock)
	eee.Volume = eeevol
	eee.Pitch = eeepitch
	eee.SoundId = songid.Value
	eee:Play()
	eee.Name = randomstring()
	eee.Looped = true
	eee.TimePosition = 0
	eee.DescendantAdded:Connect(function(v)
if stopeverything then wait(math.huge) end
		if v:IsA("DistortionSoundEffect") then 
			return 
		end
		if v:IsA("SoundEffect") then
			v.Enabled = false
			v:GetPropertyChangedSignal("Enabled"):Connect(function()
if stopeverything then wait(math.huge) end
				if v.Enabled ~= false then
					v.Enabled = false
				end
			end)
		end
		game:GetService("Debris"):AddItem(v,.01)
	end)
	soundfixing = false
end
function KKAKAKKAKAAJFNBHREJIKDJFDJFNBHUEIJFHBJEJDHFJENBFHUEJDBFHUEJDFBHUDEJDFHDEJNDBFHUDEJHDFUEJHF()
	mdmg(Head.Position,5000)
end
if lplr.Name == USERNAME then
	local moveval = Instance.new("CFrameValue")
	moveval.Value = RootPart.CFrame
	coroutine.resume(coroutine.create(function()
		while not stopeverything do
			game:GetService("RunService").RenderStepped:Wait()
			local lookvec = workspace.CurrentCamera.CFrame.LookVector
			moveval.Value = RootPart.CFrame
			moveval.Value = CFrame.new(moveval.Value.p,Vector3.new(lookvec.X*9999,lookvec.Y,lookvec.Z*9999))
		end
	end))
	local WDown,ADown,SDown,DDown,SpaceDown = false,false,false,false,false
	game:GetService("UserInputService").InputBegan:Connect(function(k,processed)
		if stopeverything then
			wait(9e9)
		end
		if not processed then
			local k = k.KeyCode
			if k == Enum.KeyCode.W then
				WDown = true
			end
			if k == Enum.KeyCode.A then
				ADown = true
			end
			if k == Enum.KeyCode.S then
				SDown = true
			end
			if k == Enum.KeyCode.D then
				DDown = true
			end
		end
	end)
	game:GetService("UserInputService").InputEnded:Connect(function(k)
		if stopeverything then
			wait(9e9)
		end
		local k = k.KeyCode
		if k == Enum.KeyCode.W then
			WDown = false
		end
		if k == Enum.KeyCode.A then
			ADown = false
		end
		if k == Enum.KeyCode.S then
			SDown = false
		end
		if k == Enum.KeyCode.D then
			DDown = false
		end
	end)
	local function MoveClone(X,Y,Z)
		if stopeverything then
			wait(9e9)
		end
		moveval.Value = moveval.Value * CFrame.new(-X,Y,-Z)
		Humanoid.WalkToPoint = moveval.Value.p
	end

	coroutine.resume(coroutine.create(function()
		while not stopeverything do
			game:GetService("RunService").RenderStepped:Wait()
			if WDown then
				MoveClone(0,0,1e4)
			end
			if ADown then
				MoveClone(1e4,0,0)
			end
			if SDown then
				MoveClone(0,0,-1e4)
			end
			if DDown then
				MoveClone(-1e4,0,0)
			end
			if not WDown and not ADown and not SDown and not DDown then
				Humanoid.WalkToPoint = RootPart.Position
			end
		end
	end))
end

function fly()

function weld(p0,p1,c0,c1,par)
	local w = Instance.new("Weld",p0 or par)
	w.Part0 = p0
	w.Part1 = p1
	w.C0 = c0 or CFrame.new()
	w.C1 = c1 or CFrame.new()
	return w
end
local motors = {}
function motor(p0,p1,c0,c1,des,vel,par)
	local w = Instance.new("Motor6D",p0 or par)
	w.Part0 = p0
	w.Part1 = p1
	w.C0 = c0 or CFrame.new()
	w.C1 = c1 or CFrame.new()
	w.MaxVelocity = tonumber(vel) or .05
	w.DesiredAngle = tonumber(des) or 0
	return w
end
function lerp(a,b,c)
	return a+(b-a)*c
end
function clerp(c1,c2,alBRUH)
	local al = .05
	local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
	local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
	for i,v in pairs(com1) do
		com1[i] = lerp(v,com2[i],al)
	end
	return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end
function ccomplerp(c1,c2,alBRUH)
	local al = .05
	local com1 = {c1:components()}
	local com2 = {c2:components()}
	for i,v in pairs(com1) do
		com1[i] = lerp(v,com2[i],al)
	end
	return CFrame.new(unpack(com1))
end
local max = 0
local min = 0
function tickwave(time,length,offset)
	return .2*math.sin(sine/20)
end
function invcol(c)
	c = c.Color
	return BrickColor.new(MAINRUINCOLOR)
end
local oc = oc or function(...) return ... end
local mod = Instance.new("Folder",Character)
mod.Name = "Wings"
mod.ChildAdded:Connect(function(v)
if stopeverything then wait(math.huge) end
	if v.Name == "Part" and not v:FindFirstChild("WingTrail") then
		swait()
		local top = Instance.new("Attachment")
		top.Name = "Top"
		top.Position = Vector3.new(0,v.Size.Y/2,0)
		top.Parent = v
		local bottom = Instance.new("Attachment")
		bottom.Name = "Bottom"
		bottom.Position = Vector3.new(0,-v.Size.Y/2,0)
		bottom.Parent = v
		local vtrail = Instance.new("Trail")
		vtrail.Name = "WingTrail"
		vtrail.Attachment0 = top
		vtrail.Attachment1 = bottom
		vtrail.Lifetime = .5
		vtrail.MinLength = 0
		vtrail.LightEmission = .5
		vtrail.LightInfluence = 5
		vtrail.Texture = ""
		vtrail.Color = ColorSequence.new(CurrentColor)
		vtrail.Transparency = NumberSequence.new(0,1)
		vtrail.Parent = v
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				vtrail.Color = ColorSequence.new(CurrentColor)
			end
		end))
	end
end)
local char = Character
local tor = Torso
local hum = Humanoid
local special = {
}
local topcolor = invcol(Character.Torso.BrickColor)
local feacolor = topcolor
local ptrans = 0
local pref = 0
local fire = false
local fmcol = Color3.new()
local fscol = Color3.new()
local part = Instance.new("Part")
part.FormFactor = "Custom"
part.Size = Vector3.new(.2,.2,.2)
part.TopSurface,part.BottomSurface = 0,0
part.CanCollide = false
part.BrickColor = topcolor
part.Transparency = 1
part.Reflectance = pref
part.Material = Enum.Material.Neon
local ef = Instance.new("Fire",fire and part or nil)
ef.Heat = 0
ef.Size = .15
ef.Color = fmcol or Color3.new()
ef.SecondaryColor = fscol or Color3.new()
part:BreakJoints()
function newpart()
	local clone = part:Clone()
	clone.Parent = mod
	clone:BreakJoints()
	return clone
end
local feath = newpart()
feath.BrickColor = feacolor
feath.Transparency = 0
Instance.new("SpecialMesh",feath).MeshType = "Brick"
function newfeather()
	local clone = feath:Clone()
	clone.Transparency = 0
	clone.Parent = mod
	clone:BreakJoints()
	return clone
end
local r1 = newpart()
r1.Size = Vector3.new(.3,1.5,.3)*1.2
local rm1 = motor(tor,r1,CFrame.new(.35,.6,.4) * CFrame.Angles(0,0,math.rad(-60)) * CFrame.Angles(math.rad(30),math.rad(-25),0),CFrame.new(0,-.8,0),.1)
local r2 = newpart()
r2.Size = Vector3.new(.4,1.5,.4)*1.2
local rm2 = motor(r1,r2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(-30),math.rad(15),0),CFrame.new(0,-.9,0),.1)
local r3 = newpart()
r3.Size = Vector3.new(.3,2,.3)*1.2
local rm3 = motor(r2,r3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-1.1,0),.1)
local r4 = newpart()
r4.Size = Vector3.new(.25,1.2,.25)*1.2
local rm4 = motor(r3,r4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-.6,0),.1)
local feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,3,.3)
weld(r4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,2.3,.3)
weld(r4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.35,2.2,.25)
weld(r4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))
local rf3 = {}
for i = 0,7 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2,.35)
	table.insert(rf3,motor(r3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rf2 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2-i*.08,.3)
	table.insert(rf2,motor(r2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rf1 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.37,1.65-i*.06,.25)
	table.insert(rf1,motor(r1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local l1 = newpart()
l1.Size = Vector3.new(.3,1.5,.3)*1.2
local lm1 = motor(tor,l1,CFrame.new(-.35,.6,.4) * CFrame.Angles(0,0,math.rad(60)) * CFrame.Angles(math.rad(30),math.rad(25),0) * CFrame.Angles(0,-math.pi,0),CFrame.new(0,-.8,0) ,.1)
local l2 = newpart()
l2.Size = Vector3.new(.4,1.5,.4)*1.2
local lm2 = motor(l1,l2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(30),math.rad(-15),0),CFrame.new(0,-.9,0),.1)
local l3 = newpart()
l3.Size = Vector3.new(.3,2,.3)*1.2
local lm3 = motor(l2,l3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-1.1,0),.1)
local l4 = newpart()
l4.Size = Vector3.new(.25,1.2,.25)*1.2
local lm4 = motor(l3,l4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-.6,0),.1)
local feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,3,.3)
weld(l4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,2.3,.3)
weld(l4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.35,2.2,.25)
weld(l4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))
local lf3 = {}
for i = 0,7 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2,.35)
	table.insert(lf3,motor(l3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local lf2 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2-i*.08,.3)
	table.insert(lf2,motor(l2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local lf1 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.37,1.65-i*.06,.25)
	table.insert(lf1,motor(l1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rwing = {rm1,rm2,rm3,rm4}
local lwing = {lm1,lm2,lm3,lm4}
local oc0 = {}
for i,v in pairs(rwing) do
	oc0[v] = v.C0
end
for i,v in pairs(lwing) do
	oc0[v] = v.C0
end
function gotResized()
	if lastsize then
		if tor.Size == lastsize then return end
		local scaleVec = tor.Size/lastsize
		for i,v in pairs(oc0) do
			oc0[i] = v-v.p+scaleVec*v.p
		end
		lastsize = tor.Size
	end
	lastsize = tor.Size
end
tor:GetPropertyChangedSignal("Size"):Connect(function()
if stopeverything then wait(math.huge) end
	gotResized()
end)
gotResized()
local idle = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local outlow = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local outhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local veryhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local flap1 = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local divebomb = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
function setwings(tab,time)
	time = time or 10
	for i = 1,4 do
		rwing[i].DesiredAngle = tab[i]
		lwing[i].DesiredAngle = tab[i]
		rwing[i].MaxVelocity = math.abs(tab[i]-rwing[i].CurrentAngle)/time
		lwing[i].MaxVelocity = math.abs(tab[i]-lwing[i].CurrentAngle)/time
		local rcf = oc0[rwing[i]] * (tab[12+i] or CFrame.new())
		local lcf = oc0[lwing[i]] * (tab[12+i] or CFrame.new())
	end
	for i,v in pairs(rf1) do
		v.DesiredAngle = tab[9]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(lf1) do
		v.DesiredAngle = tab[9]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(rf2) do
		v.DesiredAngle = tab[10]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(lf2) do
		v.DesiredAngle = tab[10]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(rf3) do
		v.DesiredAngle = tab[11]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(lf3) do
		v.DesiredAngle = tab[11]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
end
setwings(outhigh,1)
flying = false
moving = false
for i,v in pairs(tor:GetChildren()) do
	if v.ClassName:lower():match("body") then
		v:Destroy()
	end
end
local ctor = tor:Clone()
ctor:ClearAllChildren()
ctor.Name = "cTorso"
ctor.Transparency = 1
ctor.CanCollide = false
ctor.FormFactor = "Custom"
ctor.Size = Vector3.new(.2,.2,.2)
ctor.Parent = mod
weld(tor,ctor)
local bg = Instance.new("BodyGyro",ctor)
bg.maxTorque = Vector3.new()
bg.P = 15000
bg.D = 1000
local bv = Instance.new("BodyVelocity",ctor)
bv.maxForce = Vector3.new()
bv.P = 15000
vel = Vector3.new()
cf = CFrame.new()
flspd = 0
keysdown = {}
keypressed = {}
ktime = {}
descendtimer = 0
jumptime = tick()
hum.Jumping:connect(function()
if stopeverything then wait(math.huge) end
	jumptime = tick()
end)
cam = workspace.CurrentCamera
function mid(a,b,c)
	return math.max(a,math.min(b,c or -a))
end
function bn(a)
	return a and 1 or 0
end
function gm(tar)
	local m = 0
	for i,v in pairs(tar:GetChildren()) do
		if v:IsA("BasePart") then
			m = m + v:GetMass()
		end
		m = m + gm(v)
	end
	return m
end
reqrotx = 0
local grav = 196.2
local con
alreadyfixing = false
while not stopeverything and not alreadyfixing do
local obvel = tor.CFrame:vectorToObjectSpace(tor.Velocity)
local sspd,uspd,fspd = obvel.X,obvel.Y,obvel.Z
flying = true
if flying then
	local lfldir = fldir
	fldir = cam.CoordinateFrame:vectorToWorldSpace(Vector3.new(bn(keysdown.d)-bn(keysdown.a),0,bn(keysdown.s)-bn(keysdown.w))).unit
	local lmoving = moving
	moving = fldir.Magnitude > .1
	if lmoving and not moving then
		idledir = lfldir*Vector3.new(1,0,1)
		descendtimer = tick()
	end
	local dbomb = fldir.Y < -.6 or (moving and keysdown["1"])
	if moving and keysdown["0"] and lmoving then
		fldir = (Vector3.new(lfldir.X,math.min(fldir.Y,lfldir.Y+.01)-.1,lfldir.Z)+(fldir*Vector3.new(1,0,1))*.05).unit
	end
	local down = tor.CFrame:vectorToWorldSpace(Vector3.new(0,-1,0))
local descending = (not moving and keysdown["q"] and not keysdown[" "])
cf = ccomplerp(cf,CFrame.new(tor.Position,tor.Position+(not moving and idledir or fldir)),keysdown["0"] and .02 or .07)
local gdown = not dbomb and cf.lookVector.Y < -.2 and tor.Velocity.unit.Y < .05
local rotvel = CFrame.new(Vector3.new(),tor.Velocity):toObjectSpace(CFrame.new(Vector3.new(),fldir)).lookVector
bg.cframe = cf * CFrame.Angles(not moving and -.1 or -math.pi/2+.2,moving and mid(-2.5,rotvel.X/1.5) + reqrotx or 0,0)
reqrotx = reqrotx - reqrotx/10
local ani = tickwave(1.5,1)
vel = moving and cf.lookVector*flspd or Vector3.new()
flspd = math.min(120,lerp(flspd,moving and (fldir.Y<0 and flspd+(-fldir.Y)*grav/60 or math.max(50,flspd-fldir.Y*grav/300)) or 60,.4))
setwings(moving and (gdown and outlow or dbomb and divebomb) or (descending and veryhigh or flap1),15)
for i=1,4 do
rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-.5+bn(i==3)*.4+bn(i==4)*.5,.1+bn(i==2)*.5-bn(i==3)*1.1,bn(i==3)*.1) or descending and CFrame.Angles(.3,0,0) or CFrame.Angles((i*.1+1.5)*ani,ani*-.5,1*ani)),descending and .8 or .2)
lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-(-.5+bn(i==3)*.4+bn(i==4)*.5),-(.1+bn(i==2)*.5-bn(i==3)*1.1),bn(i==3)*.1) or descending and CFrame.Angles(-.3,0,0) or CFrame.Angles(-(i*.1+1.5)*ani,ani*.5,1*ani)),descending and .8 or .2)
end
local hit,ray = workspace:FindPartOnRayWithIgnoreList(Ray.new(tor.Position,Vector3.new(0,-3.5+math.min(0,bv.velocity.y)/30,0)),{Character})
else
bg.maxTorque = Vector3.new()
bv.maxForce = Vector3.new()
local ani = tickwave(walking and .8 or 4.5,1)
setwings(idle,10)
local x,y,z = fspd/160,uspd/700,sspd/900
for i=1,4 do
rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * CFrame.Angles(ani*.1 + -mid(-.1,x),0 + -mid(-.1,y) + bn(i==2)*.6,ani*.02 + -mid(-.1,z)),.2)
lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * CFrame.Angles(ani*-.05 + mid(-.1,x),0 + mid(-.1,y) + -bn(i==2)*.6,ani*.02 + mid(-.1,z)),.2)
end
if keypressed[" "] and not flying and (tick()-jumptime > .05 and (tick()-jumptime < 3 or hum.Jump)) then
vel = Vector3.new(0,50,0)
bv.velocity = vel
idledir = cam.CoordinateFrame.lookVector*Vector3.new(1,0,1)
cf = tor.CFrame * CFrame.Angles(-.01,0,0)
bg.cframe = cf
flystart = tick()
flying = true
end
end
keypressed = {}
swait()
end
end
coroutine.resume(coroutine.create(function()
fly()
end))


local fixinggui = false
local gui = nil
local exitbutton = nil
if lplr.Name == USERNAME then
	gui = Instance.new("ScreenGui")
	gui.Name = randomstring()
	exitbutton = Instance.new("TextButton",gui)
	exitbutton.TextScaled = true
	exitbutton.Font = "Arcade"
	exitbutton.Name = randomstring()
	exitbutton.BorderSizePixel = 0
	exitbutton.BackgroundTransparency = .5
	exitbutton.TextStrokeColor3 = MAINRUINCOLOR
	exitbutton.TextStrokeTransparency = 0
	exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
	exitbutton.Text = "Leave Game"
	exitbutton.Size = UDim2.new(.25,0,0,36)
	exitbutton.AnchorPoint = Vector2.new(.5,1)
	exitbutton.Position = UDim2.new(.5,0,0,0)
	gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
	exitbutton.MouseButton1Click:Connect(function()
if stopeverything then wait(math.huge) end
	game:Shutdown()
	end)
	local function fixgui()
		fixinggui = true
		local oldcolor = exitbutton.TextColor3
		pcall(function()
			gui:Destroy()
		end)
		gui = Instance.new("ScreenGui")
		gui.Name = randomstring()
		exitbutton = Instance.new("TextButton",gui)
		exitbutton.TextScaled = true
		exitbutton.Font = "Arcade"
		exitbutton.Name = randomstring()
		exitbutton.BorderSizePixel = 0
		exitbutton.BackgroundTransparency = .5
		exitbutton.TextStrokeColor3 = MAINRUINCOLOR
		exitbutton.TextStrokeTransparency = 0
		exitbutton.TextColor3 = oldcolor
		exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
		exitbutton.Text = "Leave Game"
		exitbutton.Size = UDim2.new(.25,0,0,36)
		exitbutton.AnchorPoint = Vector2.new(.5,1)
		exitbutton.Position = UDim2.new(.5,0,0,0)
		gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
		exitbutton.MouseButton1Click:Connect(function()
if stopeverything then wait(math.huge) end
			game:Shutdown()
		end)
		fixinggui = false
	end
	Player:FindFirstChildOfClass("PlayerGui").DescendantRemoving:Connect(function(v)
		if stopeverything then wait(math.huge) end
		if not fixinggui then
			if v == gui or v:IsDescendantOf(gui) then
				fixgui()
			end
		end
	end)
	coroutine.resume(coroutine.create(function()
		local noob = tick()
		repeat 
			if stopeverything then wait(math.huge) end 
			game:GetService("RunService").RenderStepped:Wait() 
		until tick()-noob >= .1
		while not stopeverything do
			if not fixinggui and not alreadyfixing then
				exitbutton.TextColor3 = GUN.NeonParts.Color
			end
			swait()
		end
	end))
end
local restartingscript = false


local Mouse = lplr:GetMouse()
Mouse.Button1Down:Connect(function()
     DamageFling(Mouse.Target.Parent)
end)
if lplr.Name == USERNAME then
	workspace.CurrentCamera.CameraSubject = Humanoid
	workspace.CurrentCamera.CameraType = "Custom"
	workspace.CurrentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
if stopeverything then wait(math.huge) end
		if not alreadyfixing and workspace.CurrentCamera.CameraSubject ~= Humanoid then
			workspace.CurrentCamera.CameraSubject = Humanoid
		end
	end)
	workspace.ChildRemoved:Connect(function(v)
if stopeverything then wait(math.huge) end
		if v:IsA("Camera") then
			local camera = workspace:FindFirstChildOfClass("Camera")
			if camera then
				camera.CameraSubject = Humanoid
				camera.CameraType = "Custom"
				camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
if stopeverything then wait(math.huge) end
					if not alreadyfixing and camera.CameraSubject ~= Humanoid then
						camera.CameraSubject = Humanoid
					end
				end)
			else
				local newcamerafound = false
				while not stopeverything and not newcamerafound do
					camera = workspace.ChildAdded:Wait()
					if camera:IsA("Camera") then
						newcamerafound = true
						camera.CameraSubject = Humanoid
						camera.CameraType = "Custom"
						camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
if stopeverything then wait(math.huge) end
							if not alreadyfixing and camera.CameraSubject ~= Humanoid then
								camera.CameraSubject = Humanoid
							end
						end)
					end
				end
			end
		end
	end)
end
spawn(function()


local TS = game:GetService("TweenService")
local PS = game:GetService("PhysicsService")

--[[ArtificialHB = Instance.new("BindableEvent",script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:Connect(function(s,p)
if stopeverything then wait(math.huge) end
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1,math.floor(tf/frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf/frame)
		end
	end
end)]]--

end)
local Anim = "Idle"
local attacktype = 1
local delays = false
local play = true
local Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).Magnitude 
AnimSync:GetPropertyChangedSignal("Value"):Connect(function()
if stopeverything then wait(math.huge) end
	sine = AnimSync.Value
end)

local doe = 0
Humanoid.WalkSpeed = walkspeed
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

function QFCF(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = .5/s
		return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * .5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = .5/s
			return .5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = .5/s
			return (m01 + m10) * recip,.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = .5/s return (m02 + m20) * recip,(m12 + m21) * recip,.5 * s,(m10 - m01) * recip
		end
	end
end
 
function QTCF(px,py,pz,x,y,z,w)
	local xs,ys,zs = x + x,y + y,z + z
	local wx,wy,wz = w * xs,w * ys,w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
end
 
function QS(a,b,t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp,finishInterp;
	if cosTheta >= .0001 then
		if (1 - cosTheta) > .0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > .0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a,b,t)
	local qa = {QFCF(a)}
	local qb = {QFCF(b)}
	local ax,ay,az = a.x,a.y,a.z
	local bx,by,bz = b.x,b.y,b.z
	local _t = 1 - t
	return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
end

--[[ArtificialHB = Instance.new("BindableEvent",script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1/30
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:Connect(function(s,p)
if stopeverything then wait(math.huge) end
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1,math.floor(tf/frame) do
				if not stopeverything then
					script.Heartbeat:Fire()
				end
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf/frame)
		end
	end
end)]]--

function CreateConnection(TYPE,PARENT,PART0,PART1,C0,C1)
if stopeverything then wait(math.huge) end
	local NEWWELD = Instance.new(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end	

function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = randomstring()
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function CreatePart2(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = CurrentColor
	coroutine.resume(coroutine.create(function()
		while true do
			Swait()
			NEWPART.Color = CurrentColor
		end
	end))
	NEWPART.Name = randomstring()
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = Instance.new("Sound")
function CreateSound(ID,PARENT,VOLUME,PITCH,DOESLOOP) -- Fixed
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

local function weldBetween(a,b)
	local weldd = Instance.new("Weld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = b
	return weldd
end
function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 		

function mdmg(centerofeffect,range)
	pcall(function()
		if lplr.Name == USERNAME then
		--	MainFolder.AreaDamageRemote:FireServer(centerofeffect,range)
		end
		for i,v in pairs(workspace:GetDescendants()) do
			if not v:IsDescendantOf(Character) and v:IsA("Humanoid") and v.RootPart and (v.RootPart.Position - centerofeffect).Magnitude <= range + v.RootPart.Size.Magnitude then
				local rootsize = v.RootPart.Size.X
				if rootsize < v.RootPart.Size.Y then
					rootsize  = v.RootPart.Size.Y
				end
				if rootsize < v.RootPart.Size.Z then
					rootsize = v.RootPart.Size.Z
				end
				DamageFling(v.Parent)
				for o = 1,25 do
					local hitm = script.SomeEffectIDK:Clone()
					hitm.Color = CurrentColor
					hitm.Trail.Color = ColorSequence.new(CurrentColor)
					hitm.CFrame = a.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))*CFrame.new(0,1,0)
					hitm.Parent = Effects
					hitm.Velocity = CFrame.new(hitm.Position,a.Position).LookVector*250
					hitm.Anchored = false
					game:GetService("TweenService"):Create(hitm,TweenInfo.new(1.33,Enum.EasingStyle.Linear),{Transparency = 1}):Play()
					coroutine.resume(coroutine.create(function()
						while true do
							Swait()
							hitm.Color = CurrentColor
							hitm.Trail.Color = ColorSequence.new(CurrentColor)
						end
					end))
					coroutine.resume(coroutine.create(function()
						local timepassed = 0
						local bruh = nil
						local function stopbruh()
							if bruh then
							
							end
						end
						bruh = game:GetService("RunService").RenderStepped:Connect(function(frame)
							timepassed = timepassed + frame
							if timepassed >= 1.33 or not hitm:IsDescendantOf(game) then
								
							else
								hitm.Trail.Transparency = NumberSequence.new(timepassed/1.33)
							end
						end)
					end))
					game:GetService("Debris"):AddItem(hitm,1.33)						
				end
			
				if v:IsDescendantOf(game) and v.Parent ~= workspace and v.Parent ~= workspace.Terrain then
				
					local maxparent = v
					repeat if stopeverything then wait(math.huge) end maxparent = maxparent.Parent until maxparent.Parent == workspace or maxparent.Parent == workspace.Terrain
					coroutine.resume(coroutine.create(function()
						local waitthing = tick()
						repeat if stopeverything then wait(math.huge) end
							game:GetService("RunService").RenderStepped:Wait()
						until tick()-waitthing >= 3
					
					end))
					if maxparent == lplr.Character then
						game:GetService("TweenService"):Create(workspace.CurrentCamera,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,1),{CFrame = CFrame.new(workspace.CurrentCamera.Focus.p,Head.Position)}):Play()
					end
					maxparent:Destroy()
				elseif v:IsDescendantOf(game) then
				
				end
			end
		end
	end)
end

function lcv2mg(centerofeffect,range)
	if lplr.Name == USERNAME then
	--	MainFolder.AreaDamageRemote:FireServer(centerofeffect,range)
	end
	pcall(function()
		for i=1,#Parents do
			for i,v in pairs(game:GetService(Parents[i]):GetDescendants()) do
				if not v:IsDescendantOf(Character) and v:IsA("BasePart") and v ~= eeeblock and v ~= shieldblock and (v.Position - centerofeffect).Magnitude <= range + v.Size.Magnitude then
					for g,h in pairs(v:GetDescendants()) do
						if h:IsA("Trail") then
							h.Attachment0 = nil
							h.Attachment1 = nil
						end 
					end
					v.CFrame = CFrame.new(-9999999,50,0)
					v:GetPropertyChangedSignal("CFrame"):Connect(function()
						if v.CFrame ~= CFrame.new(-9999999,50,0) then
							v.CFrame = CFrame.new(-9999999,50,0) 
						end
					end)
				end 
				if not v:IsDescendantOf(Character) and v:IsA("FlagStand") and v ~= eeeblock and v.Name ~= "Base" and (v.Position - centerofeffect).Magnitude <= range + v.Size.Magnitude then
					local w = v.CFrame
					for g,h in pairs(v:GetDescendants()) do
						if h:IsA("Trail") then
							h.Attachment0 = nil
							h.Attachment1 = nil
						end 
					end
					v.CFrame = CFrame.new(-9999999,50,0)
					v:GetPropertyChangedSignal("CFrame"):Connect(function()
						if v.CFrame ~= CFrame.new(-9999999,50,0) then
							v.CFrame = CFrame.new(-9999999,50,0) 
						end
					end)	
				end 
			end
		end
	end)
end

function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or MAINRUINCOLOR)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,MAINRUINCOLOR,"Effect",Vector3.new(1,1,1),true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = GUN.NeonParts.Color
					swait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
  local magz = (Part0 - Part1).Magnitude
	local Times = math.floor(math.clamp(magz/10,1,20))
  local curpos = Part0
  local trz = {
    -Offset,
    Offset
  }
  for i = 1,Times do
    local li = Instance.new("Part",Effects)
    li.Name = randomstring()
    li.TopSurface = 0
    li.Material = "Neon"
    li.BottomSurface = 0
    li.Anchored = true
    li.Locked = true
    li.Transparency = 0
    li.Color = Color
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(.1,.1,magz/Times)
    local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
    local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
    if Times == i then
      local magz2 = (curpos - Part1).Magnitude
      li.Size = Vector3.new(.1,.1,magz2)
      li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
    else
      li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
    end
    curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
    li:Destroy()
	Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
	swait()
  end
end

function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
    if DoesCourontine == false then
        local Direction = CFrame.new(Part.Position,ToLocation)
        local Distance = (Part.Position - ToLocation).Magnitude
        for i = 1,AmountOfTime do
            swait()
            Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
            Direction = Part.CFrame
        end
    elseif DoesCourontine == true then
        coroutine.resume(coroutine.create(function()
            local Direction = CFrame.new(Part.Position,ToLocation)
            local Distance = (Part.Position - ToLocation).Magnitude
            for i = 1,AmountOfTime do
                swait()
                Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
                Direction = Part.CFrame
            end
        end))
    end
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = Instance.new("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function AttackGyro()
	local GYRO = Instance.new("BodyGyro",RootPart)
	GYRO.D = 25
	GYRO.P = 20000
	GYRO.MaxTorque = Vector3.new(0,4000000,0)
	GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
	coroutine.resume(coroutine.create(function()
		repeat if stopeverything then wait(math.huge) end
			swait()
			GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
		until not attack
		GYRO:Destroy()
	end))
end
function CreatePartb(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BrickColor.new(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = Instance.new(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

godcatparts = Instance.new("Model", Character)
local Hue = 0
coroutine.resume(coroutine.create(function()
	while not stopeverything do
		for i = 0,1,(1/60) do
			swait()
			if not alreadyfixing then
				GUN2.Base.Color = MAINRUINCOLOR
				GUN2.NeonParts.Color = GUN.NeonParts.Color
				----------------------
				for i,v in pairs(savedchar.NeonParts:GetChildren()) do
					if v.Name == "1" then
						v.Color = MAINRUINCOLOR
					end
					if v.Name == "2" then
						v.Color = GUN.NeonParts.Color
						v.Light.Color = GUN.NeonParts.Color
						v.Light.Range = 2
						v.Light.Shadows = true
					end
				end
				GUN2.ReColor.Color = GUN2.NeonParts.Color
				GUN2.ReColor.Transparency = GUN2.NeonParts.Transparency
				GUN.ReColor.Transparency = GUN.Base.Transparency
				GUN.ReColor.Color = GUN.NeonParts.Color
				----------------------
				if taunt.Value == "aEa" then
					local sesk=math.random(0,255)
					GUN.NeonParts.Color = Color3.new(sesk/255,sesk/355,0)
				elseif taunt.Value == "N4N" then
					GUN.NeonParts.Color = Color3.fromRGB(255,255,255) -- Lol
				elseif taunt.Value == "|" then
					GUN.NeonParts.Color = Color3.fromRGB(math.random(99,149),0,0) -- Lol
				elseif taunt.Value == "Insanity" then
					local z = math.random(0,255)
					GUN.NeonParts.Color = Color3.fromRGB(z,z,z)
				elseif taunt.Value == "uncolored" or taunt.Value == "None2" or taunt.Value == "mlc" then
					GUN.NeonParts.Color = Color3.new(math.min(1,eee.PlaybackLoudness/500),math.min(1,eee.PlaybackLoudness/500),math.min(1,eee.PlaybackLoudness/500))
				elseif taunt.Value == "Err0r" then
					GUN.NeonParts.Color = Color3.fromRGB(225,225,225,math.clamp(eee.PlaybackLoudness-0,0,0),0,0,0)
				elseif taunt.Value == "Err0r2" then
					GUN.NeonParts.Color = Color3.fromRGB(math.clamp(eee.PlaybackLoudness-191,0,255),math.clamp(eee.PlaybackLoudness-191,0,255),0)
				elseif taunt.Value == "FAST BOIII" or taunt.Value == "idkw" then
					GUN.NeonParts.Color = Color3.fromRGB(0,0,math.clamp(eee.PlaybackLoudness-191,0,255))
				elseif taunt.Value == "N0X" then
					GUN.NeonParts.Color = Color3.fromRGB(255,255,255)
				elseif taunt.Value == "idk" then
					GUN.NeonParts.Color = Color3.fromRGB(0,math.clamp(eee.PlaybackLoudness-191,0,255),math.clamp(eee.PlaybackLoudness-191,0,255))
				elseif taunt.Value == "error?" then
					GUN.NeonParts.Color = Color3.fromRGB(0,math.random(0,255),0)
				elseif taunt.Value == "Glitch" then
					GUN.NeonParts.Color = Color3.fromHSV(i,1,math.clamp((eee.PlaybackLoudness/200)-.5,0,1))
				elseif taunt.Value == "unholy" or taunt.Value == "X⁔X" then
					GUN.NeonParts.Color = Color3.fromRGB(0+178*eee.PlaybackLoudness/100,0,0)
				elseif taunt.Value == "Banisher2" then
					GUN.NeonParts.Color = Color3.fromHSV(Hue/360,1,math.clamp(255,0,1))
				else
					GUN.NeonParts.Color = Color3.fromHSV(i,1,1)
				end
				GUN.Base.Color = MAINRUINCOLOR
				GUN.GunAdditions.Color = MAINRUINCOLOR
				GUN.NeonParts.Light.Color = GUN.NeonParts.Color
				GUN.NeonParts.Light.Brightness = 1
				if GUN.NeonParts.Transparency == 1 then
					GUN.NeonParts.Light.Enabled = false
				else
					GUN.NeonParts.Light.Enabled = true
				end 
				if GUN2.NeonParts.Transparency == 1 then
					GUN2.NeonParts.Light1.Light.Enabled = false
					GUN2.NeonParts.Light2.Light.Enabled = false
				else
					GUN2.NeonParts.Light1.Light.Enabled = true
					GUN2.NeonParts.Light2.Light.Enabled = true
				end
				if taunt.Value == "Banisher" or taunt.Value == "Banisher2" then
					GUN2.Base.Transparency = 0
					GUN2.NeonParts.Transparency = 0
				else
					GUN2.Base.Transparency = 1
					GUN2.NeonParts.Transparency = 1
				end
				GUN2.NeonParts.Light1.Light.Shadows = true
				GUN2.NeonParts.Light2.Light.Shadows = true
				GUN2.NeonParts.Light1.Light.Range = 2
				GUN2.NeonParts.Light2.Light.Range = 2
				GUN.NeonParts.Light.Shadows = true
			end
		end
	end
end))

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or MAINRUINCOLOR)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,MAINRUINCOLOR,"Effect",Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = GUN.NeonParts.Color
					swait()
				end
			end))
		end
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopeverything then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopeverything then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end
function GODCATEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Color3.new(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BrickColor.new("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end
function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Trail", VT(10,10,10))
	MakeForm(TRAIL,"Cyl")
	game:GetService("RunService").Heartbeat:Connect(function()
		TRAIL.Color = CurrentColor
	end)
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 55 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.01
		end
		TRAIL:remove()
	end))
end
function Ka_Boom()
	attack = true
	walkspeed = 0
	coroutine.wrap(function()
		for i = 0,2 do
			swait(12)
			CreateSound(199145095,GUN.Joint,10,1)
		end
	end)()
	for i = 0,2,.1 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	for i = 0,1.5,.1 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	for i = 0,.5,.1 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,-.2,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end		
	end
	local BEAM = CreatePart(3,Effects,"Neon",0,0,CurrentColor,"Beam",Vector3.new())
	local BEAM2 = CreatePart(3,Effects,"Neon",0,0,CurrentColor,"Beam",Vector3.new())
	MakeForm(BEAM,"Ball")
	MakeForm(BEAM2,"Ball")
	BEAM.CFrame = CFrame.new(RootPart.Position)
	BEAM2.CFrame = CFrame.new(RootPart.Position)
	local boooom = CreateSound(415700134,RootPart,10,1,false)
	boooom.EmitterSize = 100
	for i=1,140 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,-.2,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,-.2,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end
		BEAM.Size = BEAM.Size + Vector3.new(.7,8,.7)
		BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
		BEAM.Color = GUN.NeonParts.Color
		BEAM2.Color = GUN.NeonParts.Color
		BEAM.CFrame = CFrame.new(RootPart.Position)
		BEAM2.CFrame = CFrame.new(RootPart.Position)
		Effect({EffectType = "Slash", Size = Vector3.new(0,0,0), Size2 = Vector3.new(5,.05,5), Transparency = 0, Transparency2 = 1, CFrame = BEAM.CFrame*CFrame.new(0,-1.3,0) * CFrame.Angles(math.rad(math.random(-90,90)), math.rad(math.random(-90,90)) ,math.rad(math.random(-90,90))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end
	mdmg(RootPart.Position,BEAM2.Size.Y/2)
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(),Transparency = 0,Transparency2 = .6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	for i,v in pairs(Effects:GetChildren()) do
		v.Color = MAINRUINCOLOR
		v:GetPropertyChangedSignal("Color"):Connect(function()
			if stopeverything then wait(math.huge) end
			v.Color = MAINRUINCOLOR
		end)
	end
	BEAM2:Destroy()
	BEAM:Destroy()
	attack = false
	walkspeed = 50
end

function attackone()
	attack = true
	walkspeed = 16
	AttackGyro()
	for i = 0,.5,.05 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 642890855,SoundPitch = .81,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	local mousehit = Mouse.Hit
	local DISTANCE = (Holetwo.Position - mousehit.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,MAINRUINCOLOR,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,mousehit.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Color = CurrentColor
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	for i = 1,4 do
		coroutine.resume(coroutine.create(function()
			Lightning(Holetwo.Position,mousehit.p,15,3.5,CurrentColor,25,0,1,0,true,55)
		end))
	end
	coroutine.resume(coroutine.create(function()
		Lightning(Holetwo.Position,mousehit.p,15,3.5,CurrentColor,25,0,1,0,true,55)
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			for a = 0, 14 do
				EFFECT1(3,math.random(4,8),"Add",mousehit*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,GUN.NeonParts.Color,0)
			end
		end
		mdmg(mousehit.p,10)
	end))
	for i = 0,.5,.075 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(60)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	walkspeed = 50
	attack = false
end

function attackone2()
	attack = true
	walkspeed = 16
	AttackGyro()
	for i = 0,.5,.05 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 136523485,SoundPitch = 1,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	local mousehit = Mouse.Hit
	local DISTANCE = (Holetwo.Position - mousehit.p).Magnitude
	for i = 1,4 do
		coroutine.resume(coroutine.create(function()
			Lightning(Holetwo.Position,mousehit.p,.5,.5,CurrentColor,5,0,.3,0,true,55)
		end))
	end
	coroutine.resume(coroutine.create(function()
		Lightning(Holetwo.Position,mousehit.p,.5,.5,CurrentColor,5,0,.3,0,true,55)
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		mdmg(mousehit.p,10)
	end))
	for i = 0,.5,.075 do
		swait()
		if HipVal ~= 0 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(60)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	walkspeed = 50
	attack = false
end

function attacktwo()
	attack = true
	walkspeed = 0
	AttackGyro()
   local gBullet = CreatePart(3,Effects,"Neon",0,0,CurrentColor,"AbsoluteNoob",Vector3.new())
   MakeForm(gBullet,"Ball")
   gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
	CreateSound(2785493,gBullet,10,.8)
	for i = 0,1.25,.025 do
		swait()
		Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(.5,.5,.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).p,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
		gBullet.Size = gBullet.Size * 1.085
    	gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-30)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine/12)),math.rad(0),math.rad(30)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + .1 * math.cos(sine/12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(sine/12)),math.rad(0 - 6 * math.cos(sine/12)),math.rad(-30 - 6 * math.cos(sine/12))) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(-30)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine / 12)),math.rad(0),math.rad(30)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-62.5),math.rad(0 - 5 * math.cos(sine / 12)),math.rad(30)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5 + 0.1 * math.cos(sine / 12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12)),math.rad(-30 - 6 * math.cos(sine / 12))) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1 - 0.075 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1 - 0.075 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	local bullets = {}
	for i = 1,math.random(27,41) do
		swait()
		local Bullet = CreatePart(3,Effects,"Neon",0,0,CurrentColor,"Shit.",Vector3.new(.6,.6,.6))
    	MakeForm(Bullet,"Ball")
		Bullet.CFrame = gBullet.CFrame
		Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = .4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		table.insert(bullets,Bullet)
	end
	local oofing = false
	for b = 1,#bullets do
		swait()
		local part,pos = rayCast(LeftArm.CFrame*CFrame.new(0,-1.5,0).p,((Mouse.Hit.p+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - LeftArm.CFrame*CFrame.new(0,-1.5,0).p),500,Character)
		coroutine.resume(coroutine.create(function()
		FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
		Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(.6,.6,.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		swait(math.random(55,65))
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		for i = 0,10 do
		swait()
		bullets[b].Transparency = bullets[b].Transparency + .1
		end
		oofing = not oofing
		if oofing then
			mdmg(bullets[b].Position,10)
		end
		local EEEBRUHEEE = CreateSound(168513088,bullets[b],3.5,1.1,false)
		bullets[b].Transparency = 1
		EEEBRUHEEE.Ended:Connect(function()
if stopeverything then wait(math.huge) end
			bullets[b]:Destroy()
		end)
		end))
	end
	for i = 0,10 do
		swait()
		gBullet.Transparency = gBullet.Transparency + .1
	end
	gBullet:Destroy()
	walkspeed = 50
	attack = false
end

function hedshoot()
	attack = true
	walkspeed = 16
	CreateSound(235097614,RootPart,6,1.5,false)
	for i = 0,.5,.05 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	for xd = 1,5 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = Torso.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = Torso.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 642890855,SoundPitch = .81,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	mdmg(RootPart.Position,14)
	for i = 1,4 do
		RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,-25)
		mdmg(RootPart.Position,14)
		coroutine.resume(coroutine.create(function()
			Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,MAINRUINCOLOR,math.random(30,45),.5,1.5,0,true,60) 
		end))	
		coroutine.resume(coroutine.create(function()
			Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,CurrentColor,math.random(30,45),.5,1.5,0,true,60)
		end))
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for xd = 1,5 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = Torso.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = Torso.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0,.5,.1 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
	end
	attack = false
	walkspeed = 50
end
local stillraining = false
function painlessrain()
	if stillraining then
		return
	else
		stillraining = true
	end
	attack = true
	walkspeed = 16
	coroutine.wrap(function()
		for i = 0,2 do
			swait(12)
			CreateSound(199145095,GUN.Joint,10,1)
		end
	end)()
	for i = 0,2,.1 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1 / 2)
		end	
		end
	for i = 0,1.5,.1 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),1 / 3)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1 / 2)
			end	
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 642890855,SoundPitch = .81,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,.5,.1 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,-.2,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
			end		
		end
	local skypos = Holetwo.CFrame * CFrame.new(-400,0,0)
	local DISTANCE = (Holetwo.Position - skypos.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,MAINRUINCOLOR,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	for i = 1,4 do
		coroutine.resume(coroutine.create(function()
			Lightning(Holetwo.Position,skypos.p,15,3.5,CurrentColor,25,0,1,0,true,55)
		end))
	end
	Lightning(Holetwo.Position,skypos.p,15,3.5,CurrentColor,25,0,1,0,true,55)
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0,.5,.1 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
		end	
	attack = false
	walkspeed = 50
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 1,5 do
		local Sky = RootPart.CFrame*CFrame.new(0,500,0)
		local MoPos = Mouse.Hit.p
		local DISTANCE = (Sky.p - MoPos).Magnitude
		for i = 1,4 do
			coroutine.resume(coroutine.create(function()
				Lightning(Sky.p,MoPos,15,3.5,CurrentColor,25,0,1,0,true,55)
			end))
		end
		Lightning(Sky.p,MoPos,15,3.5,CurrentColor,25,0,1,0,true,55)
		local killbeam = CreatePart(3,Effects,"Neon",0,0,MAINRUINCOLOR,"Kill Beam",Vector3.new(1,DISTANCE,1))
		killbeam.CFrame = CFrame.new(Sky.p,MoPos) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
		MakeForm(killbeam,"Cyl")
		coroutine.resume(coroutine.create(function()
			for i = 1,25 do
				swait()
				killbeam.Transparency = i/25
			end
			killbeam:Destroy()
		end))
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			--Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			--Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			for a = 0, 14 do
				EFFECT1(3,math.random(4,8),"Add",CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,GUN.NeonParts.Color,0)
			end
		end
		mdmg(MoPos,12)
	end
	stillraining = false
end
function SingularityBeam()
	attack = true
	cannecksnap = false
	walkspeed = 0
	AttackGyro()
	for i = 0,.5,.05 do
		swait()
		if HipVal ~= 0 then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		else
			RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),1 / 3)
			Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1 / 3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-5),math.rad(75),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-65),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
		end	
		end
	local HoleDist = (Hole.Position - Holetwo.Position).Magnitude
	local chargebeam = CreatePart2(3,Effects,"Neon",0,0,MAINRUINCOLOR,"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
	MakeForm(chargebeam,"Cyl")
	chargebeam.CFrame = CFrame.new(Hole.Position,Holetwo.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	local chargeweld = weldBetween(GUN.Joint,chargebeam)
	local chargeball = CreatePart2(3,Effects,"Neon",0,0,MAINRUINCOLOR,"Charge Ball",Vector3.new(.5,.5,.5),false)
	chargeball.Shape = "Ball"
	chargeball.CFrame = Holetwo.CFrame
	weldBetween(Holetwo,chargeball)
	CreateSound(342793847,Hole,10,1,false)
	local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
	bigball:Play()
	bigball.Completed:Wait()
	chargebeam:Destroy()
	local KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude
	coroutine.resume(coroutine.create(function()
		repeat if stopeverything then wait(math.huge) end KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude Swait() until not attack
	end))
	local killbeam = CreatePart2(3,Effects,"Neon",0,0,MAINRUINCOLOR,"Kill Beam",Vector3.new(2.5,KillDist,2.5))
	MakeForm(killbeam,"Cyl")
	killbeam.Touched:Connect(function(victim)
if stopeverything then wait(math.huge) end
		mdmg(victim.Position,5)
	end)
	coroutine.resume(coroutine.create(function()
		while not stopeverything and killbeam:IsDescendantOf(game) do
			mdmg(Mouse.Hit.p,5)
			Swait(6)
		end
	end))
	coroutine.resume(coroutine.create(function()
		local isdoingathing = false
		while not stopeverything and killbeam:IsDescendantOf(game) do
			isdoingathing = not isdoingathing
			if lplr.Name == USERNAME then
				RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,.1)
			end
			killbeam.Size = Vector3.new(2.5,KillDist,2.5)
			killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.p) * CFrame.new(0,0,-KillDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
			if isdoingathing then
				coroutine.resume(coroutine.create(function()
					Lightning(Holetwo.Position,Mouse.Hit.p,15,3,CurrentColor,10,0,1,0,true,55)
				end))
				for a = 0, 14 do
					EFFECT1(3,math.random(4,8),"Add",Mouse.Hit*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,GUN.NeonParts.Color,0)
				end
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
			end
			Swait()
		end
	end))
	CreateSound(138677306,Holetwo,10,1,false)
	CreateSound(415700134,Holetwo,10,1,false)
	Swait(150)
	CreateSound(3264923,Holetwo,10,1,false)
	Swait(30)
	chargeball:Destroy()
	killbeam:Destroy()
	walkspeed = 50
	attack = false
	cannecksnap = true
end
Mouse.Button1Down:Connect(function()
if stopeverything then wait(math.huge) end
	if not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus" and taunt.Value ~= "Banisher" and taunt.Value ~= "Banisher2") then
		attackone()
	end
	if not attack and (taunt.Value == "Banisher" or taunt.Value == "Banisher2") then
		attackone2()
	end
end)
local FLYING = false
function sFLY()
	if not ISFLYING then
		FLYING = false
	else
		local CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local SPEED = 0			
		local function FLY()
			FLYING = true
			BG = Instance.new('BodyGyro',RootPart)
			BV = Instance.new('BodyVelocity',RootPart)
			BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
			BG.P = 1e4
			BG.CFrame = RootPart.CFrame
			BV.Velocity = Vector3.new()
			BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
			coroutine.resume(coroutine.create(function()
				repeat if stopeverything then wait(math.huge) end
					game:GetService("RunService").RenderStepped:Wait()
					if not alreadyfixing then
						if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
							SPEED = 50
						elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
							SPEED = 0
						end
						if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R,(CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * .2,0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
							lCONTROL = {F = CONTROL.F,B = CONTROL.B,L = CONTROL.L,R = CONTROL.R}
						elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R,(lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * .2,0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
						else
							BV.Velocity = Vector3.new()
						end
						BG.CFrame = workspace.CurrentCamera.CoordinateFrame
					end
				until not FLYING
				CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				SPEED = 0
				if not alreadyfixing then
					for i,v in pairs(RootPart:GetChildren()) do
						if v:IsA("BodyMover") then
							v:Destroy()
						end
					end
					RootPart.CFrame = CFrame.new(RootPart.Position)
				end
			end))
		end
		local IYMouse = Player:GetMouse()
		IYMouse.KeyDown:connect(function(KEY)
if stopeverything then wait(math.huge) end
			if KEY:lower() == 'w' then
				CONTROL.F = Humanoid.WalkSpeed*0.02
			elseif KEY:lower() == 's' then
				CONTROL.B = - Humanoid.WalkSpeed*0.02
			elseif KEY:lower() == 'a' then
				CONTROL.L = - Humanoid.WalkSpeed*0.02
			elseif KEY:lower() == 'd' then 
				CONTROL.R = Humanoid.WalkSpeed*0.02
	        elseif KEY:lower() == 'e' then
				CONTROL.Q = Humanoid.WalkSpeed*0.02
	        elseif KEY:lower() == 'q' then
				CONTROL.E = -Humanoid.WalkSpeed*0.02
			end
		end)
		IYMouse.KeyUp:connect(function(KEY)
if stopeverything then wait(math.huge) end
			if KEY:lower() == 'w' then
				CONTROL.F = 0
			elseif KEY:lower() == 's' then
				CONTROL.B = 0
			elseif KEY:lower() == 'a' then
				CONTROL.L = 0
			elseif KEY:lower() == 'd' then
	            CONTROL.R = 0
	        elseif KEY:lower() == 'e' then
	            CONTROL.Q = 0
	        elseif KEY:lower() == 'q' then
	            CONTROL.E = 0
			end
		end)
		FLY()
	end
end
function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			rng.Transparency = rng.Transparency + .01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed
				scaler2b = scaler2b - .01*value/bonuspeed
				scaler2c = scaler2c - .01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed
				scaler2b = scaler2b - .01/value*bonuspeed
				scaler2c = scaler2c - .01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + .01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2b*bonuspeed,scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Brick"
	rngm.Scale = Vector3.new(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			speeder = speeder - .01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + .01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = VT(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = Vector3.new(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			speeder = speeder - .01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + .01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,0)
		end
		rng:Destroy()
	end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + .01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - .01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10,0,scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end
function skid()
	CreateSound(4138167041,Head,10,math.random(0.96,1.055),false)
	chatfunc("Skids suck my nuts Y9728392",true)
end


function EFFECT1(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part",Effects)
	rng.Anchored = true
	rng.Color = GUN.NeonParts.Color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng)
	rngm.MeshType = "Brick"
	rngm.Scale = Vector3.new(x1,y1,z1)
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - .01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - .01/value*bonuspeed
			end
			rng.Color = GUN.NeonParts.Color
			speeder = speeder - .01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + .01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end
function OpenSH()
	if Shield.Value == false then
		Shield.Value = true
	elseif Shield.Value == true then
		Shield.Value = false
	end	
end

function TPEffect(pos)
	for xd = 1,5 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = pos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.15,0,.15),Transparency = 0,Transparency2 = 1,CFrame = pos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = MAINRUINCOLOR,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0, 14 do
		EFFECT1(3,math.random(4,8),"Add",pos*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3,3,3,0.03,GUN.NeonParts.Color,0)
	end
end
function Warp()
	TPEffect(Torso.CFrame)
	local ORIGIN = RootPart.Position
	local POS = RootPart.Position
	RootPart.CFrame = CF(Mouse.Hit.p+VT(0,3,0),VT(ORIGIN.X,Mouse.Hit.p.Y,ORIGIN.Z))
	CreateSound(1177785010, Torso, 10, 1, false)
	TPEffect(Torso.CFrame)
end
--[[function Switch()
	CreateSound(147722227, Torso, 4, 1.3, false)
	for m = 1,5 do
		Effect({Time = 10, EffectType = "Wave", Size = VT(500,0.11,500)*1, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = Torso.CFrame*CFrame.Angles(math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-15,15), RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	Effect({Time = 10, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
end]]
function balfolderclearlol()
	BallFolder:ClearAllChildren()
end
function spawnball()
	local Ball = Instance.new("Part")
	local Light = nil
	Ball.Shape = "Ball"
	Ball.Size = Vector3.new(ballsize.Value,ballsize.Value,ballsize.Value)
	Ball.Material = ballmaterial.Value
	Ball.Anchored = false
	Ball.Color = GUN.NeonParts.Color
	Ball.Position = Mouse.Hit.p
	Ball.Parent = BallFolder
	Ball.Name = randomstring()
	if Ball.Material == "ForceField" or Ball.Material == "Neon" then
		local Light = Instance.new("PointLight")
		Light.Brightness = 1
		Light.Color = GUN.NeonParts.Color
		Light.Range = 40*Ball.Size.Y
		Light.Shadows = true
		Light.Parent = Ball
		Light.Name = randomstring()
	end
	coroutine.resume(coroutine.create(function()
		while true do
			Swait()
			Ball.Shape = "Ball"
			Ball.Anchored = false
			Ball.Color = GUN.NeonParts.Color
			Ball.Parent = BallFolder
			if Ball.Material == "ForceField" or Ball.Material == "Neon" then
				Light.Brightness = 1
				Light.Color = GUN.NeonParts.Color
				Light.Range = 40*Ball.Size.Y
				Light.Shadows = true
				Light.Parent = Ball
			end
		end
	end))
end
local alreadydoneit = false
Mouse.KeyDown:Connect(function(k)
	if stopeverything then wait(math.huge) end
	k = k:lower()
	if k == "z" and not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus" and taunt.Value ~= "Banisher" and taunt.Value ~= "Banisher2") then	
		hedshoot()
	elseif k == "x" and not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus" and taunt.Value ~= "Banisher" and taunt.Value ~= "Banisher2") then
		SingularityBeam()
	elseif k == "c" and not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus" and taunt.Value ~= "Banisher" and taunt.Value ~= "Banisher2") then
		painlessrain()
	elseif k == "v" and not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus" and taunt.Value ~= "Banisher" and taunt.Value ~= "Banisher2") then
		attacktwo()
	elseif k == "b" and not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus" and taunt.Value ~= "Banisher" and taunt.Value ~= "Banisher2") then
		Ka_Boom()
	elseif k == "g" then
	
	
	elseif k == "h" and not attack then
		skid()
	elseif k == "r" and not attack then
		Warp()
	elseif k == "n" and not attack then
		OpenSH()
	elseif k == "l" and not attack then
		balfolderclearlol()
	elseif k == "j" and not attack then
		spawnball()
	elseif k == "m" and not attack and (taunt.Value ~= "Fave" and taunt.Value ~= "Krump" and taunt.Value ~= "OOOOO" and taunt.Value ~= "Sus") then
		--Switch()
if songid.Value ~= "rbxassetid://679355361" and songid.Value ~= "rbxassetid://481104377" and songid.Value ~= "rbxassetid://5170646860" and songid.Value ~= "rbxassetid://1931001768" and songid.Value ~= "rbxassetid://1338971957" and songid.Value ~= "rbxassetid://6174456295" and songid.Value ~= "rbxassetid://4185475912" and songid.Value ~= "rbxassetid://8469622715" and songid.Value ~= "rbxassetid://4557673096" and songid.Value ~= "rbxassetid://2920078671" and songid.Value ~= "rbxassetid://6678443282" and songid.Value ~= "rbxassetid://361511879" and songid.Value ~= "rbxassetid://1439600000" and songid.Value ~= "rbxassetid://844654533" and songid.Value ~= "rbxassetid://7171244184" and songid.Value ~= "rbxassetid://6291841343" and songid.Value ~= "rbxassetid://5797602893" and songid.Value ~= "rbxassetid://4550031738" and songid.Value ~= "rbxassetid://1280010741" and songid.Value ~= "rbxassetid://5644788747" and songid.Value ~= "rbxassetid://6294514849" and songid.Value ~= "rbxassetid://8153102099" then
			TauntRemote:Fire("None",679355361)
		elseif songid.Value == "rbxassetid://679355361" then
			TauntRemote:Fire("None2",4550031738)
		elseif songid.Value == "rbxassetid://4550031738" then
			TauntRemote:Fire("idk",7171244184)
		elseif songid.Value == "rbxassetid://7171244184" then
			TauntRemote:Fire("N4N",4185475912)
		elseif songid.Value == "rbxassetid://4185475912" then
			TauntRemote:Fire("Insanity",8469622715)
		elseif songid.Value == "rbxassetid://8469622715" then
			TauntRemote:Fire("Err0r",4557673096)
		elseif songid.Value == "rbxassetid://4557673096" then
			TauntRemote:Fire("Err0r2",361511879)
		elseif songid.Value == "rbxassetid://361511879" then
			TauntRemote:Fire("FAST BOIII",2920078671)
		elseif songid.Value == "rbxassetid://2920078671" then
			TauntRemote:Fire("Glitch",6678443282)
		elseif songid.Value == "rbxassetid://6678443282" then
			TauntRemote:Fire("Pazolite",1338971957)
		elseif songid.Value == "rbxassetid://1338971957" then
			TauntRemote:Fire("aEa",1931001768) --Exist
		elseif songid.Value == "rbxassetid://1931001768" then
			TauntRemote:Fire("N0X",5170646860) --Exist
		elseif songid.Value == "rbxassetid://5170646860" then
			TauntRemote:Fire("lcv1",6291841343) --Exist
		elseif songid.Value == "rbxassetid://6291841343" then
			TauntRemote:Fire("mlc",5644788747) --Exist
		elseif songid.Value == "rbxassetid://5644788747" then
			TauntRemote:Fire("error?",481104377) --Exist
		elseif songid.Value == "rbxassetid://481104377" then
			TauntRemote:Fire("idkw",6294514849)
		elseif songid.Value == "rbxassetid://6294514849" then
			chatfunc("h3lp m3Ee3",true)
			TauntRemote:Fire("unholy",1439600000) --Exist
		elseif songid.Value == "rbxassetid://1439600000" then
			chatfunc("I've Lost My Color",true)
			TauntRemote:Fire("uncolored",844654533) --Exist
		elseif songid.Value == "rbxassetid://844654533" then
			TauntRemote:Fire("X⁔X",5797602893) --Exist
		elseif songid.Value == "rbxassetid://5797602893" then
			TauntRemote:Fire("Banisher",1280010741)
		elseif songid.Value == "rbxassetid://1280010741" then
			TauntRemote:Fire("Banisher2",8153102099)
		elseif songid.Value == "rbxassetid://8153102099" then
			TauntRemote:Fire("|",6831440691)
		end
	elseif k == "y" then
		if taunt.Value ~= "Fave" then
			TauntRemote:Fire("Fave",290182215)
		else
			TauntRemote:Fire("None",6174456295)
		end
	elseif k == "t" then
		if taunt.Value ~= "Krump" then
			TauntRemote:Fire("Krump",1511734302)
		else
			TauntRemote:Fire("None",6174456295)
		end
	elseif k == "u" then
		if taunt.Value ~= "OOOOO" then
			TauntRemote:Fire("OOOOO",6835233891)
		else
			TauntRemote:Fire("None",6174456295)
		end
	elseif k == "p" then
		if taunt.Value ~= "Sus" then
			TauntRemote:Fire("Sus",806947472) -- i love this song
		else
			TauntRemote:Fire("None",6174456295)
		end
	elseif k == "f" then
		ISFLYING = not ISFLYING
		if lplr.Name == USERNAME then
			sFLY()
		end
	elseif k == "k" then
		TauntRemote:Fire("KickMode")
	end
end)

local ActualVelocity = Vector3.new()


coroutine.wrap(function()
	while not stopeverything do
		swait()
		if doe < 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()
antivoid = Instance.new("Part")
antivoid.Name = randomstring()
antivoid.Size = Vector3.new(400,10,400)
antivoid.Anchored = true
antivoid.Transparency = 1
antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
antivoid.Parent = workspace
coroutine.resume(coroutine.create(function()
	while not stopeverything do
		swait()
		if not alreadyfixing then
			if antivoid:IsDescendantOf(workspace) then
				antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
			else
				pcall(function()
					antivoid:Destroy()
				end)
				antivoid = Instance.new("Part")
				antivoid.Name = randomstring()
				antivoid.Size = Vector3.new(400,10,400)
				antivoid.Anchored = true
				antivoid.Transparency = 1
				antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
				antivoid.Parent = workspace
			end
		end
	end
end))
if lplr.Name == USERNAME then
	game:GetService("UserInputService").InputBegan:Connect(function()
if stopeverything then wait(math.huge) end
		if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) and not alreadyfixing and game:GetService("UserInputService"):GetFocusedTextBox() == nil then 
			repeat if stopeverything then wait(math.huge) end 
				Humanoid.Jump = true 
				game:GetService("RunService").RenderStepped:Wait() 
				Humanoid.Jump = false 
				game:GetService("RunService").RenderStepped:Wait() 
			until not game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space)
		end
	end)
end

function fly()

function weld(p0,p1,c0,c1,par)
	local w = Instance.new("Weld",p0 or par)
	w.Part0 = p0
	w.Part1 = p1
	w.C0 = c0 or CFrame.new()
	w.C1 = c1 or CFrame.new()
	return w
end
local motors = {}
function motor(p0,p1,c0,c1,des,vel,par)
	local w = Instance.new("Motor6D",p0 or par)
	w.Part0 = p0
	w.Part1 = p1
	w.C0 = c0 or CFrame.new()
	w.C1 = c1 or CFrame.new()
	w.MaxVelocity = tonumber(vel) or .05
	w.DesiredAngle = tonumber(des) or 0
	return w
end
function lerp(a,b,c)
	return a+(b-a)*c
end
function clerp(c1,c2,alBRUH)
	local al = .05
	local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
	local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
	for i,v in pairs(com1) do
		com1[i] = lerp(v,com2[i],al)
	end
	return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end
function ccomplerp(c1,c2,alBRUH)
	local al = .05
	local com1 = {c1:components()}
	local com2 = {c2:components()}
	for i,v in pairs(com1) do
		com1[i] = lerp(v,com2[i],al)
	end
	return CFrame.new(unpack(com1))
end
function tickwave(time,length,offset)
	return .2*math.sin(sine/20)
end
function invcol(c)
	c = c.Color
	return BrickColor.new(MAINRUINCOLOR)
end
local oc = oc or function(...) return ... end
local mod = Instance.new("Folder",Character)
mod.Name = "Wings"
mod.ChildAdded:Connect(function(v)
if stopeverything then wait(math.huge) end
	if v.Name == "Part" and not v:FindFirstChild("WingTrail") then
		swait()
		local top = Instance.new("Attachment")
		top.Name = "Top"
		top.Position = Vector3.new(0,v.Size.Y/2,0)
		top.Parent = v
		local bottom = Instance.new("Attachment")
		bottom.Name = "Bottom"
		bottom.Position = Vector3.new(0,-v.Size.Y/2,0)
		bottom.Parent = v
		local vtrail = Instance.new("Trail")
		vtrail.Name = "WingTrail"
		vtrail.Attachment0 = top
		vtrail.Attachment1 = bottom
		vtrail.Lifetime = .5
		vtrail.MinLength = 0
		vtrail.LightEmission = .5
		vtrail.LightInfluence = 5
		vtrail.Texture = ""
		vtrail.Color = ColorSequence.new(CurrentColor)
		vtrail.Transparency = NumberSequence.new(0,1)
		vtrail.Parent = v
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				vtrail.Color = ColorSequence.new(CurrentColor)
			end
		end))
	end
end)
local char = Character
local tor = Torso
local hum = Humanoid
local special = {
}
local topcolor = invcol(Character.Torso.BrickColor)
local feacolor = topcolor
local ptrans = 0
local pref = 0
local fire = false
local fmcol = Color3.new()
local fscol = Color3.new()
local part = Instance.new("Part")
part.FormFactor = "Custom"
part.Size = Vector3.new(.2,.2,.2)
part.TopSurface,part.BottomSurface = 0,0
part.CanCollide = false
part.BrickColor = topcolor
part.Transparency = 1
part.Reflectance = pref
part.Material = Enum.Material.Neon
local ef = Instance.new("Fire",fire and part or nil)
ef.Heat = 0
ef.Size = .15
ef.Color = fmcol or Color3.new()
ef.SecondaryColor = fscol or Color3.new()
part:BreakJoints()
function newpart()
	local clone = part:Clone()
	clone.Parent = mod
	clone:BreakJoints()
	return clone
end
local feath = newpart()
feath.BrickColor = feacolor
feath.Transparency = 0
Instance.new("SpecialMesh",feath).MeshType = "Brick"
function newfeather()
	local clone = feath:Clone()
	clone.Transparency = 0
	clone.Parent = mod
	clone:BreakJoints()
	return clone
end
local r1 = newpart()
r1.Size = Vector3.new(.3,1.5,.3)*1.2
local rm1 = motor(tor,r1,CFrame.new(.35,.6,.4) * CFrame.Angles(0,0,math.rad(-60)) * CFrame.Angles(math.rad(30),math.rad(-25),0),CFrame.new(0,-.8,0),.1)
local r2 = newpart()
r2.Size = Vector3.new(.4,1.5,.4)*1.2
local rm2 = motor(r1,r2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(-30),math.rad(15),0),CFrame.new(0,-.9,0),.1)
local r3 = newpart()
r3.Size = Vector3.new(.3,2,.3)*1.2
local rm3 = motor(r2,r3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-1.1,0),.1)
local r4 = newpart()
r4.Size = Vector3.new(.25,1.2,.25)*1.2
local rm4 = motor(r3,r4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(-3),0,0),CFrame.new(0,-.6,0),.1)
local feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,3,.3)
weld(r4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,2.3,.3)
weld(r4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.35,2.2,.25)
weld(r4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))
local rf3 = {}
for i = 0,7 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2,.35)
	table.insert(rf3,motor(r3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rf2 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2-i*.08,.3)
	table.insert(rf2,motor(r2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rf1 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.37,1.65-i*.06,.25)
	table.insert(rf1,motor(r1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local l1 = newpart()
l1.Size = Vector3.new(.3,1.5,.3)*1.2
local lm1 = motor(tor,l1,CFrame.new(-.35,.6,.4) * CFrame.Angles(0,0,math.rad(60)) * CFrame.Angles(math.rad(30),math.rad(25),0) * CFrame.Angles(0,-math.pi,0),CFrame.new(0,-.8,0) ,.1)
local l2 = newpart()
l2.Size = Vector3.new(.4,1.5,.4)*1.2
local lm2 = motor(l1,l2,CFrame.new(0,.75,0) * CFrame.Angles(0,0,math.rad(50)) * CFrame.Angles(math.rad(30),math.rad(-15),0),CFrame.new(0,-.9,0),.1)
local l3 = newpart()
l3.Size = Vector3.new(.3,2,.3)*1.2
local lm3 = motor(l2,l3,CFrame.new(.1,.9,0) * CFrame.Angles(0,0,math.rad(-140)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-1.1,0),.1)
local l4 = newpart()
l4.Size = Vector3.new(.25,1.2,.25)*1.2
local lm4 = motor(l3,l4,CFrame.new(0,1.1,0) * CFrame.Angles(0,0,math.rad(-10)) * CFrame.Angles(math.rad(3),0,0),CFrame.new(0,-.6,0),.1)
local feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,3,.3)
weld(l4,feather,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.4,2.3,.3)
weld(l4,feather,CFrame.new(.1,-.1,0) * CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
feather = newfeather()
feather.Mesh.Scale = Vector3.new(1,1,1)
feather.Size = Vector3.new(.35,2.2,.25)
weld(l4,feather,CFrame.new(.1,-.3,0) * CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))
local lf3 = {}
for i = 0,7 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2,.35)
	table.insert(lf3,motor(l3,feather,CFrame.new(.05,1-i*.285,0) * CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local lf2 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.45,2.2-i*.08,.3)
	table.insert(lf2,motor(l2,feather,CFrame.new(.05,.75-i*.26,0) * CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local lf1 = {}
for i = 0,6 do
	feather = newfeather()
	feather.Mesh.Scale = Vector3.new(1,1,1)
	feather.Size = Vector3.new(.37,1.65-i*.06,.25)
	table.insert(lf1,motor(l1,feather,CFrame.new(.05,.63-i*.21,0) * CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-feather.Size.Y/2,0)))
end
local rwing = {rm1,rm2,rm3,rm4}
local lwing = {lm1,lm2,lm3,lm4}
local oc0 = {}
for i,v in pairs(rwing) do
	oc0[v] = v.C0
end
for i,v in pairs(lwing) do
	oc0[v] = v.C0
end
function gotResized()
	if lastsize then
		if tor.Size == lastsize then return end
		local scaleVec = tor.Size/lastsize
		for i,v in pairs(oc0) do
			oc0[i] = v-v.p+scaleVec*v.p
		end
		lastsize = tor.Size
	end
	lastsize = tor.Size
end
tor:GetPropertyChangedSignal("Size"):Connect(function()
if stopeverything then wait(math.huge) end
	gotResized()
end)
gotResized()
local idle = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local outlow = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local outhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local veryhigh = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local flap1 = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
local divebomb = {-.3,.3,1.1,-.2; .3,.05,.1,.05; .2,-.6,0,0}
function setwings(tab,time)
	time = time or 10
	for i = 1,4 do
		rwing[i].DesiredAngle = tab[i]
		lwing[i].DesiredAngle = tab[i]
		rwing[i].MaxVelocity = math.abs(tab[i]-rwing[i].CurrentAngle)/time
		lwing[i].MaxVelocity = math.abs(tab[i]-lwing[i].CurrentAngle)/time
		local rcf = oc0[rwing[i]] * (tab[12+i] or CFrame.new())
		local lcf = oc0[lwing[i]] * (tab[12+i] or CFrame.new())
	end
	for i,v in pairs(rf1) do
		v.DesiredAngle = tab[9]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(lf1) do
		v.DesiredAngle = tab[9]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(rf2) do
		v.DesiredAngle = tab[10]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(lf2) do
		v.DesiredAngle = tab[10]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(rf3) do
		v.DesiredAngle = tab[11]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
	for i,v in pairs(lf3) do
		v.DesiredAngle = tab[11]
		v.MaxVelocity = math.abs(v.DesiredAngle-v.CurrentAngle)/time
	end
end
setwings(outhigh,1)
flying = false
moving = false
for i,v in pairs(tor:GetChildren()) do
	if v.ClassName:lower():match("body") then
		v:Destroy()
	end
end
local ctor = tor:Clone()
ctor:ClearAllChildren()
ctor.Name = "cTorso"
ctor.Transparency = 1
ctor.CanCollide = false
ctor.FormFactor = "Custom"
ctor.Size = Vector3.new(.2,.2,.2)
ctor.Parent = mod
weld(tor,ctor)
local bg = Instance.new("BodyGyro",ctor)
bg.maxTorque = Vector3.new()
bg.P = 15000
bg.D = 1000
local bv = Instance.new("BodyVelocity",ctor)
bv.maxForce = Vector3.new()
bv.P = 15000
vel = Vector3.new()
cf = CFrame.new()
flspd = 0
keysdown = {}
keypressed = {}
ktime = {}
descendtimer = 0
jumptime = tick()
hum.Jumping:connect(function()
if stopeverything then wait(math.huge) end
	jumptime = tick()
end)
cam = workspace.CurrentCamera
function mid(a,b,c)
	return math.max(a,math.min(b,c or -a))
end
function bn(a)
	return a and 1 or 0
end
function gm(tar)
	local m = 0
	for i,v in pairs(tar:GetChildren()) do
		if v:IsA("BasePart") then
			m = m + v:GetMass()
		end
		m = m + gm(v)
	end
	return m
end
reqrotx = 0
local grav = 196.2
local con
while not stopeverything and not alreadyfixing do
local obvel = tor.CFrame:vectorToObjectSpace(tor.Velocity)
local sspd,uspd,fspd = obvel.X,obvel.Y,obvel.Z
flying = true
if flying then
	local lfldir = fldir
	fldir = cam.CoordinateFrame:vectorToWorldSpace(Vector3.new(bn(keysdown.d)-bn(keysdown.a),0,bn(keysdown.s)-bn(keysdown.w))).unit
	local lmoving = moving
	moving = fldir.Magnitude > .1
	if lmoving and not moving then
		idledir = lfldir*Vector3.new(1,0,1)
		descendtimer = tick()
	end
	local dbomb = fldir.Y < -.6 or (moving and keysdown["1"])
	if moving and keysdown["0"] and lmoving then
		fldir = (Vector3.new(lfldir.X,math.min(fldir.Y,lfldir.Y+.01)-.1,lfldir.Z)+(fldir*Vector3.new(1,0,1))*.05).unit
	end
	local down = tor.CFrame:vectorToWorldSpace(Vector3.new(0,-1,0))
local descending = (not moving and keysdown["q"] and not keysdown[" "])
cf = ccomplerp(cf,CFrame.new(tor.Position,tor.Position+(not moving and idledir or fldir)),keysdown["0"] and .02 or .07)
local gdown = not dbomb and cf.lookVector.Y < -.2 and tor.Velocity.unit.Y < .05
local rotvel = CFrame.new(Vector3.new(),tor.Velocity):toObjectSpace(CFrame.new(Vector3.new(),fldir)).lookVector
bg.cframe = cf * CFrame.Angles(not moving and -.1 or -math.pi/2+.2,moving and mid(-2.5,rotvel.X/1.5) + reqrotx or 0,0)
reqrotx = reqrotx - reqrotx/10
local ani = tickwave(1.5,1)
vel = moving and cf.lookVector*flspd or Vector3.new()
flspd = math.min(120,lerp(flspd,moving and (fldir.Y<0 and flspd+(-fldir.Y)*grav/60 or math.max(50,flspd-fldir.Y*grav/300)) or 60,.4))
setwings(moving and (gdown and outlow or dbomb and divebomb) or (descending and veryhigh or flap1),15)
for i=1,4 do
rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-.5+bn(i==3)*.4+bn(i==4)*.5,.1+bn(i==2)*.5-bn(i==3)*1.1,bn(i==3)*.1) or descending and CFrame.Angles(.3,0,0) or CFrame.Angles((i*.1+1.5)*ani,ani*-.5,1*ani)),descending and .8 or .2)
lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * (gdown and CFrame.new() or dbomb and CFrame.Angles(-(-.5+bn(i==3)*.4+bn(i==4)*.5),-(.1+bn(i==2)*.5-bn(i==3)*1.1),bn(i==3)*.1) or descending and CFrame.Angles(-.3,0,0) or CFrame.Angles(-(i*.1+1.5)*ani,ani*.5,1*ani)),descending and .8 or .2)
end
local hit,ray = workspace:FindPartOnRayWithIgnoreList(Ray.new(tor.Position,Vector3.new(0,-3.5+math.min(0,bv.velocity.y)/30,0)),{Character})
else
bg.maxTorque = Vector3.new()
bv.maxForce = Vector3.new()
local ani = tickwave(walking and .8 or 4.5,1)
setwings(idle,10)
local x,y,z = fspd/160,uspd/700,sspd/900
for i=1,4 do
rwing[i].C0 = clerp(rwing[i].C0,oc0[rwing[i]] * CFrame.Angles(ani*.1 + -mid(-.1,x),0 + -mid(-.1,y) + bn(i==2)*.6,ani*.02 + -mid(-.1,z)),.2)
lwing[i].C0 = clerp(lwing[i].C0,oc0[lwing[i]] * CFrame.Angles(ani*-.05 + mid(-.1,x),0 + mid(-.1,y) + -bn(i==2)*.6,ani*.02 + mid(-.1,z)),.2)
end
if keypressed[" "] and not flying and (tick()-jumptime > .05 and (tick()-jumptime < 3 or hum.Jump)) then
vel = Vector3.new(0,50,0)
bv.velocity = vel
idledir = cam.CoordinateFrame.lookVector*Vector3.new(1,0,1)
cf = tor.CFrame * CFrame.Angles(-.01,0,0)
bg.cframe = cf
flystart = tick()
flying = true
end
end
keypressed = {}
swait()
end
end
coroutine.resume(coroutine.create(function()
fly()
end))
game:GetService("RunService").RenderStepped:Connect(function()
if stopeverything then wait(math.huge) end
	if not soundfixing then
		eeeblock.CFrame = Torso.CFrame
	end
	CurrentColor = GUN.NeonParts.Color
	shieldblock.CFrame = Torso.CFrame
	shieldblock.Size = Vector3.new(25+1*math.sin(sine/25),25+1*math.sin(sine/25),25+1*math.sin(sine/25))
	shieldblock.Color = CurrentColor
end)




RootPart.Anchored = false

while not stopeverything do
	if not alreadyfixing then
		if lplr.Name ~= USERNAME then
			antivoid.CanCollide = false
		end
	
		if not soundfixing then
			eeeblock.CFrame = Torso.CFrame
		
			if eee.Playing ~= true then
				eee.Playing = true
			end
			if eee.Looped ~= true then
				eee.Looped = true
			end
			if eee.EmitterSize ~= 50 then
				eee.EmitterSize = 50
			end
			if eee.MaxDistance ~= 100000 then
				eee.MaxDistance = 100000
			end
			if eee.PlayOnRemove ~= false then
				eee.PlayOnRemove = false
			end
		end
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	Humanoid.HipHeight = 3
		Humanoid.PlatformStand = ISFLYING
		Humanoid.UseJumpPower = true
		Humanoid.JumpPower = 50
		Humanoid.WalkSpeed = walkspeed
	
		for i,v in pairs(Character:GetDescendants()) do
			if v:IsA("BasePart") then
				if not v:IsDescendantOf(Effects) and v ~= RootPart then
					v.Anchored = false
				elseif v == RootPart and lplr.Name == USERNAME then
					v.Anchored = false
				elseif v == RootPart and lplr.Name ~= USERNAME then
					v.Anchored = true
				end
			end
		end
	
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v.Anchored == false and v.Position.Y < (workspace.FallenPartsDestroyHeight + 50) then
				local flot = Instance.new("BodyPosition")
				local spen = Instance.new("BodyGyro")
				local hu = math.huge
				flot.MaxForce = Vector3.new(hu,hu,hu)
				spen.MaxTorque = Vector3.new(hu,hu,hu)
				local spown = nil
				for o,b in pairs(workspace:GetDescendants()) do
					if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
						spown = b
					end
				end
				if spown then
					RootPart.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+6+Humanoid.HipHeight,spown.Position.Z)
				else
					local base = workspace:FindFirstChild("Base")
					if not base then
						base = workspace:FindFirstChild("Baseplate")
					end
					if base then
						RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+6+Humanoid.HipHeight,math.clamp(RootPart.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
					else
						RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,-100,100),100,math.clamp(RootPart.Position.Z,-100,100))
					end
				end
				flot.Position = RootPart.Position
				flot.Parent = RootPart
				spen.CFrame = RootPart.CFrame
				spen.Parent = RootPart
				game:GetService("Debris"):AddItem(flot,1)
				game:GetService("Debris"):AddItem(spen,1)
			end
		end
		Torsovelocity = (ActualVelocity).Magnitude
		if lplr.Name == USERNAME then
			Torsovelocity = (RootPart.Velocity).Magnitude
		end 
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		local sidevec = math.clamp((root.Velocity*root.CFrame.rightVector).X+(root.Velocity*root.CFrame.rightVector).Z,-hum.WalkSpeed,hum.WalkSpeed)
		local forwardvec =  math.clamp((root.Velocity*root.CFrame.lookVector).X+(root.Velocity*root.CFrame.lookVector).Z,-hum.WalkSpeed,hum.WalkSpeed)
		local sidevelocity = sidevec/hum.WalkSpeed
		local forwardvelocity = forwardvec/hum.WalkSpeed
		sine = sine + change
		walksine = walksine + walkc
		sine2 = sine2 + c2
		LOOPx = LOOPx + 5
		local sensitivity = 25
		if taunt.Value == "FAST BOIII" or taunt.Value == "OOOOO" or taunt.Value == "N4N" or taunt.Value == "N0X" or taunt.Value == "error?" or taunt.Value == "Sus" or taunt.Value == "unholy" or taunt.Value == "uncolored" or taunt.Value == "X⁔X" or taunt.Value == "idk" or taunt.Value == "lcv1" or taunt.Value == "Banisher" or taunt.Value == "Banisher2" or taunt.Value == "mlc" or taunt.Value == "idkw" or taunt.Value == "|" then
			for i,v in pairs(Character.Wings:GetChildren()) do
				if v.Name == "Part" then
					v.Transparency = 1
					pcall(function()
						v.WingTrail.Enabled = false
					end)
				end
			end
		else
			for i,v in pairs(Character.Wings:GetChildren()) do
				if v.Name == "Part" then
					if v:FindFirstChildOfClass("SpecialMesh") then
						v.Transparency = 0
					end
					pcall(function()
						v.WingTrail.Enabled = true
					end)
				end
			end
		end
		local hit,pos = rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		if taunt.Value == "None" or taunt.Value == "None2" then -- non
			change = 1
			--eeepitch = 1
			--eevol = 5
			sensitivity = 25
			if HipValLock == false then
				HipVal = 3
			end
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120+5*math.cos(sine/12)),math.rad(0),math.rad(0)),1/2)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/12))*CFrame.Angles(math.rad(-25-5*math.cos(sine/12)),0,0),.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30-1*math.cos(sine/12)),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/12)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/12))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 15 * math.cos(sine/12)),math.rad(80),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(13 + 15 * math.cos(sine/12)),math.rad(-80),math.rad(0)),0.7/3)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/12))*CFrame.Angles(math.rad(40-1*math.cos(sine/12)),0,0),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 9 * math.cos(sine/12)),math.rad(80),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-9 + 9 * math.cos(sine/12)),math.rad(-80),math.rad(0)),0.7/3)
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 50
		elseif taunt.Value == "idk" then
			if HipValLock == false then
				HipVal = 3
			end
			--eeepitch = 1
			change = 1
			sensitivity = 25
			--eevol = 5
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if attack == false then
				if Torsovelocity < sensitivity/3.125 then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/30)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20-5*math.cos(sine/30)),0,0),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.cos(sine/30))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.cos(sine/30))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.cos(sine/30))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity/3.125 then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/30)) * CFrame.Angles(math.rad(28.947),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-8),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(-10-10*math.cos(sine/30))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-30),math.rad(80),math.rad(10+10*math.cos(sine/30))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(-80),math.rad(-10-10*math.cos(sine/30))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 40
		elseif taunt.Value == "lcv1" then
			change = 1
			if HipValLock == false then
				HipVal = 0
			end
			Humanoid.HipHeight = 0
		
		
		if Torsovelocity < sensitivity then
				Anim = "Idle"
				if attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-15 - 3 * math.cos(sine / 12)),math.rad(5),math.rad(0)),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5 + 0.1 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(-53.75+1.75 * math.cos(sine / 12)),math.rad(0),math.rad(5)) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + 0.1 * math.cos(sine / 12),-0) * CFrame.Angles(math.rad(15 - 1.5 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12)),math.rad(0 - 6 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(15),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1.1 - 0.05 * math.cos(sine / 12),0) * CFrame.Angles(math.rad(10),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
				elseif Torsovelocity >= sensitivity then
				Anim = "Walk"
				if attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20),math.rad(0 + 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-20 - 3 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(5 + 2.5 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine / 12)),math.rad(0 - 10 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1 ,-1,0) * CFrame.Angles(math.rad(0),math.rad(85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-93.75+7.25*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
				end
			end
			GUN.Base.Transparency = 0
			GUN.GunAdditions.Transparency = 0
			GUN.NeonParts.Transparency = 0
			Humanoid.WalkSpeed = 10
		elseif taunt.Value == "mlc" then
			if HipValLock == false then
				HipVal = 3
			end
			--eeepitch = 1
			change = 1
			sensitivity = 25
			--eevol = 5
				RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
	
		
			if Torsovelocity < sensitivity then
				Anim = "Idle"
				if attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.sin(sine / 32)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-15 - 3 * math.cos(sine / 32)),math.rad(0),math.rad(0)),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5 + 0.1 * math.cos(sine / 32),0) * CFrame.Angles(math.rad(-53.75+1.75 * math.cos(sine / 32)),math.rad(0),math.rad(5)) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5 + 0.1 * math.cos(sine / 32),-0) * CFrame.Angles(math.rad(15 - 1.5 * math.cos(sine / 32)),math.rad(0 - 6 * math.cos(sine / 32)),math.rad(0 - 6 * math.cos(sine / 32))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1.1 - 0.05 * math.sin(sine / 32),0) * CFrame.Angles(math.rad(15),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(-4),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1.1 - 0.05 * math.sin(sine / 32),0) * CFrame.Angles(math.rad(10),math.rad(-70),math.rad(0)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3+.9*math.sin(sine/32)),math.rad(0),math.rad(0)),1 / 2)
				end
				elseif Torsovelocity >= sensitivity then
			
				if attack == false then
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.sin(sine / 12)) * CFrame.Angles(math.rad(15),math.rad(0 + 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(150),math.rad(0 - 2.5 * math.cos(sine / 12)),math.rad(5 + 2.5 * math.cos(sine / 12))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(5 - 45 * math.cos(sine / 12)),math.rad(0 - 10 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1 ,-1,0) * CFrame.Angles(math.rad(0),math.rad(85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
				end
			end
			GUN.Base.Transparency = 0
			GUN.GunAdditions.Transparency = 0
			GUN.NeonParts.Transparency = 0
			Humanoid.WalkSpeed = 10
		elseif taunt.Value == "N4N" then
			if HipValLock == false then
				HipVal = 3
			end
			--eeepitch = 1
			change = 1
			sensitivity = 25
			--eevol = 5
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,math.cos(sine/25),0-math.sin(sine/25))*CFrame.Angles(math.rad(5*math.sin(sine/25)),0,0),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(5*math.cos(sine/25)),0,0),.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(sine/25)))* RIGHTSHOULDERC0,.25)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-15+5*math.sin(sine/25)))* LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.1*math.sin(sine/25),-.01)*CFrame.Angles(0,math.rad(80),0),.25)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.5-.25*math.sin(sine/25),-.51)*CFrame.Angles(math.rad(-10),math.rad(-80),0),.25)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,math.cos(sine/25),0-math.sin(sine/25))*CFrame.Angles(math.rad(5*math.sin(sine/25)),0,math.rad(70)),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(0,0,math.rad(-70))*CFrame.Angles(math.rad(5*math.cos(sine/25)),0,0),.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))* RIGHTSHOULDERC0,.25)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-20+5*math.sin(sine/25)))* LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.1*math.sin(sine/25),-.01)*CFrame.Angles(0,math.rad(80),0),.25)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.5-.25*math.sin(sine/25),-.51)*CFrame.Angles(math.rad(-10),math.rad(-80),0),.25)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 50
		elseif taunt.Value == "Banisher2" then -- MrMaddox32's Anim
			if HipValLock == false then
				HipVal = 4
			end
			--eeepitch = 1
			change = 2 / Animation_Speed
			sensitivity = 25
			--eevol = 5
			WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0)*ANGLES(math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0)*ANGLES(math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/5, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = GUN2.Hole.CFrame*CF(0,0,0)*ANGLES(math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999)),math.rad(MRANDOM(-9999,9999))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * SIN(sine / 26)) * ANGLES(RAD(-25 - 2.5*COS(sine/26)), RAD(0), RAD(0)), 1 / 3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 - 1 * COS(sine / 26)), RAD(0), RAD(0)), 1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, .8) * ANGLES(RAD(-20), RAD(44), RAD(0))*ANGLES(0,0,RAD(-10)) * RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-12 + 4.10 * COS(sine / 26))) * LEFTSHOULDERC0, 1 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine / 12), -0.5) * ANGLES(RAD(-5 - 2.5 * COS(sine / 26)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 12), -0.01) * ANGLES(RAD(5 - 2.5 * SIN(sine / 26)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)	
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)), 1 / 3)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * SIN(sine / 26)) * ANGLES(RAD(50 - 2.5*SIN(sine/26)), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(sine / 47))), 1 / 3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-50 - 2.5 * SIN(sine / 26)), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y)), 1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.3, 0) * ANGLES(RAD(-15), RAD(0), RAD(12 - 4.10 * SIN(sine / 26))) * RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0) * ANGLES(RAD(-15), RAD(0), RAD(-12 + 4.10 * SIN(sine / 26))) * LEFTSHOULDERC0, 1 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.4 - 0.02 * SIN(sine / 26), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(sine / 26)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 26), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(sine / 26)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)	
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)), 1 / 3)
				end
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
			end
			Humanoid.WalkSpeed = 200
		elseif taunt.Value == "N0X" then
			--eeepitch = 1
			--eevol = 5
			change = 1
			sensitivity = 10
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				if HipValLock == false then
					HipVal = 0
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,.05*math.cos(sine/12))*CFrame.Angles(math.rad(15),0,0),1 / 3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(-15-3*math.cos(sine/12)),math.rad(5-5*math.sin(sine/12)),0),1 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(sine/12),0)*CFrame.Angles(math.rad(-53.75+1.75*math.cos(sine/12)),0,math.rad(5))* RIGHTSHOULDERC0,1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.1*math.sin(sine/12),0)*CFrame.Angles(math.rad(15),0,math.rad(-5+5*math.cos(sine/12)))* LEFTSHOULDERC0,1 / 3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.06*math.cos(sine/12),-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1-.06*math.cos(sine/12),-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(0)),1 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,.125*math.sin(sine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(-10*math.cos(sine/12)),math.rad(-5*math.cos(sine/12))),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(10*math.cos(sine/12)),math.rad(5*math.cos(sine/12))),.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(sine/12)),math.rad(-10+5*math.sin(sine/12)),math.rad(10))* RIGHTSHOULDERC0,.25)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-30*math.sin(sine/12)),math.rad(5*math.cos(sine/12)),0)* LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.9-.2*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(sine/12)),math.rad(90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(sine/12),-.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(sine/12)),math.rad(-90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
			end
			Humanoid.WalkSpeed = 16
		elseif taunt.Value == "aEa" then
			--eeepitch = 1
			local ADD = Humanoid.WalkSpeed*2
			change = 2 / Animation_Speed
			sensitivity = 25
			if HipValLock == false then
				HipVal = 3
			end
			--eevol = 5
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+0.5*COS(sine / 15)) * ANGLES(RAD(0), RAD(0), RAD(0)), 5.15 / 9)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 - 0.1 * COS(sine / 5) + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine / 12)), RAD(10 * COS(sine / 12)), RAD(0)), 5.15 / 9)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(sine / 12), 0) * ANGLES(RAD(180 - 3.5 * SIN(sine / 12)), RAD(0 - 8.5 * SIN(sine / 12)), RAD(20 + 8.5 * SIN(sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(sine / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/60)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/60)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+0.5*COS(sine / 15))*ANGLES(RAD(25+2.5*COS(sine / 12)),RAD(0-RootPart.RotVelocity.y),RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(sine / 47))), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 - 0.1 * COS(sine / 5) + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine / 12)), RAD(10 * COS(sine / 12)), RAD(0)), 5.15 / 9)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(sine / 12), 0) * ANGLES(RAD(180 - 3.5 * SIN(sine / 12)), RAD(0 - 8.5 * SIN(sine / 12)), RAD(20 + 8.5 * SIN(sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(sine / 7), -0.01) * ANGLES(RAD(-20-2.5*math.cos(sine/60)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-35-2.5*math.cos(sine/60)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120),math.rad(0),math.rad(0)),1/2)
				end
			end
			Humanoid.WalkSpeed = 100
			GUN.Base.Transparency = 0
			GUN.GunAdditions.Transparency = 0
			GUN.NeonParts.Transparency = 0
		elseif taunt.Value == "Insanity" then
			if HipValLock == false then
				HipVal = 3
			end
			--eeepitch = 1
			change = 1
			sensitivity = 25
			--eevol = 5
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if attack == false then
				if Torsovelocity < sensitivity/3.125 then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(sine/100)),math.rad(0)),1)
					if math.random(1,40) == 1 then
						Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
					end
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(170-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity/3.125 then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = walkspeed/3.125
		elseif taunt.Value == "Banisher" then -- Pastel Shooter, Good Script.
			if HipValLock == false then
				HipVal = 0
			end
			--eeepitch = 1
			change = 2 / Animation_Speed
			sensitivity = 10
			--eevol = 5
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if attack == false then
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				if Torsovelocity < sensitivity/3.125 then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(sine / 20))), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+ 0.35 * SIN(sine / 12), 0) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(sine / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(sine / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(sine / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(sine / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity/3.125 then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,.125*math.sin(sine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(-10*math.cos(sine/12)),math.rad(-5*math.cos(sine/12))),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(10*math.cos(sine/12)),math.rad(5*math.cos(sine/12))),.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(-40-10*math.cos(sine/12)),math.rad(-10+5*math.sin(sine/12)),math.rad(10))* RIGHTSHOULDERC0,.25)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-30*math.sin(sine/12)),math.rad(5*math.cos(sine/12)),0)* LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.9-.2*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(sine/12)),math.rad(90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(sine/12),-.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(sine/12)),math.rad(-90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
			end
			Humanoid.WalkSpeed = 16
		elseif taunt.Value == "idkw" then -- ok....
			if HipValLock == false then
				HipVal = 0
			end
			--eeepitch = 1
			change = 2 / Animation_Speed
			sensitivity = 10
			--eevol = 5
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if attack == false then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity/3.125 then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + .1 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(sine / 20))), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.35 * SIN(sine / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(10 - 5 * COS(sine / 12))) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.95, 0.5, 0.3) * ANGLES(RAD(-20), RAD(0), RAD(35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - .1 * COS(sine / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - .1 * COS(sine / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity/3.125 then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(sine / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(sine / 47))), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
				else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 16
		elseif taunt.Value == "unholy" then
			if cannecksnap == true then
			local snap = math.random(1,6)
			local snap2 = math.random(1,2)
			if snap == 1 then
				Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0)*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1/Animation_Speed)
			end
			if snap2 == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end
			end
			change = 2 / Animation_Speed
			--eeepitch = 1
			--eevol = 5
			sensitivity = 25
			if HipValLock == false then
				HipVal = 3
			end
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * SIN(sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(sine/24)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(sine / 12*5)), RAD(0), RAD(math.random(-5,5))), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine / 12), -0.5) * ANGLES(RAD(-70 - 2.5 * SIN(sine / 32)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 12), -0.01) * ANGLES(RAD(-70 - 2.5 * SIN(sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * SIN(sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(sine/24)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(math.random(-5,5))), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(10), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine / 12), -0.5) * ANGLES(RAD(-70 - 2.5 * SIN(sine / 32)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 12), -0.01) * ANGLES(RAD(-70 - 2.5 * SIN(sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 30
		elseif taunt.Value == "uncolored" then
			change = 2 / Animation_Speed
			--eeepitch = .75
			--eevol = 5
			sensitivity = 25
			if HipValLock == false then
				HipVal = 2
			end
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					snap = math.random(1,6)
					if snap == 1 then
						Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1/Animation_Speed)
					end
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.5*COS(sine / 32))*ANGLES(RAD(-25 + 2*Cos(sine/42)),RAD(0),RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2.5+1*COS(sine / 12)), RAD(MRANDOM(-5,5)), RAD(0)), 1 / Animation_Speed) 
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 5.5 * COS(sine / 20))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15 + 5.5 * COS(sine / 20))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(sine/32)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(sine/46)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(sine / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(sine / 47))), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 120
		elseif taunt.Value == "error?" then
			change = 2 / Animation_Speed
			--eeepitch = 1
			--eevol = 5
			if HipValLock == false then
				HipVal = 1
			end
			sensitivity = 25
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if math.random(1,3) == 1 then
					WACKYEFFECT({TIME = MRANDOM(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(sine2/4),3 + 2 * COS(sine2/4),3 + 2 * COS(sine2/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-20,20),2,MRANDOM(-20,20))), MoveToPos = Torso.Position+VT(0,MRANDOM(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({TIME = MRANDOM(0,22), EffectType = "Sphere", Size = VT(2 + 2 * COS(sine2/4),5 + 2 * COS(sine2/4),2 + 2 * COS(sine2/4)), Size2 = VT(-3,-6,-4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				end
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					--WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+eee.PlaybackLoudness/25,0.55,7+eee.PlaybackLoudness/25), Size2 = VT(7+eee.PlaybackLoudness/25,0.55,7+eee.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(Hue/360,1,math.clamp(eee.PlaybackLoudness/950,0,1)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.25*COS(sine2 / 12))*ANGLES(RAD(1+2.5*COS(sine2 / 12)),RAD(0),RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(1-2.5*COS(sine2 / 12)), RAD(0), RAD(0)), 1 / Animation_Speed) 
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.05*COS(sine2 / 12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(sine2/12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.05*COS(sine2  / 12), -0.5) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(sine2/12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					--WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+eee.PlaybackLoudness/25,0.55,7+eee.PlaybackLoudness/25), Size2 = VT(7+eee.PlaybackLoudness/25,0.55,7+eee.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(Hue/360,1,math.clamp(eee.PlaybackLoudness/950,0,1)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine2/63)+.92*Sin(sine2/95), 0, 0 + 1 * SIN(sine2 / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(sine2 / 47))), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine2 / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(sine2 / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(sine2 / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(sine2 / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(sine2 / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(sine2 / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(sine2 / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
					-----------------
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(sine2 / 28)) * ANGLES(RAD(25+2.5*COS(sine2/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(RAD(-5+3.4*COS(sine2/28)),RAD(3*COS(sine2/28)),RAD(0)),1/Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5, 0.5, 0)*ANGLES(RAD(-90-5*COS(sine2/28)),RAD(0),RAD(0))* RIGHTSHOULDERC0,1/Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.05*COS(sine2 / 28), -0.01) * ANGLES(RAD(-4), RAD(80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(sine2/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.05*COS(sine2  / 28), -0.5) * ANGLES(RAD(-8), RAD(-80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(sine2/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			Humanoid.WalkSpeed = 70
		elseif taunt.Value == "Err0r" then
			if HipValLock == false then
			HipVal = 3
			end
			--eeepitch = 1
			change = 1
			--eevol = 5
			sensitivity = 25
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					local headsnap = math.random(1,60);
					local headsnapping=false;
					if headsnap == 1 then
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
					end
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 0 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(20), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-10-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					local headsnap = math.random(1,60);
					local headsnapping=false;
					if headsnap == 1 then
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
					end
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 0 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(25-math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(sine/25)), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-30-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			walkspeed = 50
		elseif taunt.Value == "Glitch" then
			if HipValLock == false then
			HipVal = 3
			end
			--eeepitch = 1
			--eevol = 5
			change = 1
			sensitivity = 25
			WACKYEFFECT({Time = 1, EffectType = "Block", Size =VT(1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300), Size2 = VT(1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+9*math.sin(sine/55),0+2*math.sin(sine/75),0+9*math.cos(sine/55))*CFrame.Angles(math.rad(-sine*1),math.rad(-sine*2),math.rad(-sine*3)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300), Size2 = VT(1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300,1+eee.PlaybackLoudness/300), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0-9*math.sin(sine/55),0-2*math.sin(sine/75),0-9*math.cos(sine/55))*CFrame.Angles(math.rad(-sine*1),math.rad(-sine*2),math.rad(-sine*3)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(135+5*math.sin(sine/9)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(0+30*math.cos(sine/9)),math.rad(0),math.rad(-10+10*math.cos(sine/9))) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(20-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(125+5*math.sin(sine/9)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(-70+1*math.cos(sine/9)),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = GUN.NeonParts.Color
					swait()
					if not alreadyfixing then
						wingpart.Color = MAINRUINCOLOR
					end
				end))
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			walkspeed = 50
		elseif taunt.Value == "X⁔X" then
			if HipValLock == false then
			HipVal = 2
			end
			--eeepitch = .8
			--eevol = 5
			change = 2 / Animation_Speed
			sensitivity = 25
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(sine / 15)), RAD(10 * SIN(sine/32)), RAD(-10 + 5.5 * SIN(sine /15))), 3 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 5.5 * SIN(sine/12)), RAD(5 * SIN(sine /12)), RAD(22 + 4.4 * SIN(sine /12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0- 5.5 * SIN(sine /12)), RAD(5 * SIN(sine /12)), RAD(-22 + 4.4 * SIN(sine/12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 1 * COS(sine / 39)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.8 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80+10* SIN(sine / 78)), RAD(0)) * ANGLES(RAD(-3+1* SIN(sine / 58)), RAD(0), RAD(2.5+8 * SIN(sine / 43))), 0.8 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-80-10* SIN(sine / 81)), RAD(0)) * ANGLES(RAD(-3+1* SIN(sine / 63)), RAD(0), RAD(0+15 * SIN(sine / 49))), 0.8 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.5 * COS(sine / 24)) * ANGLES(RAD(24), RAD(-5 * SIN(sine / 24)), RAD(0)), 0.4 / Animation_Speed*3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-24), RAD(5 * SIN(sine / 24)), RAD(MRANDOM(-5.5,5.5))), 0.2)			
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.15 * COS(sine / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(14 + 6.5* SIN(sine / 24)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.15 * COS(sine / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(-14 - 6.5 * SIN(sine / 24))) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(sine / 24), 0) * ANGLES(RAD(-25), RAD(78), RAD(0)) * ANGLES(RAD(-5 * SIN(sine / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.3 - 0.1 * COS(sine / 24), -0.5) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(-5 * SIN(sine / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			walkspeed = 100
		elseif taunt.Value == "|" then -- ah yes, anims made by MrMaddox32
			if HipValLock == false then
				HipVal = 0
			end
			--eeepitch = .8
			--eevol = 5
			change = 2/Animation_Speed
			sensitivity = 10
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if RootPart.Velocity.y > 1 and hit == nil then 
					Anim = "Jump"
					if attack == false then
						RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
						Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(0)),1 / 3)
						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(25 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(-25 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
						RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.4,-0.6) * CFrame.Angles(math.rad(1),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
						LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
						GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
					end
				elseif RootPart.Velocity.y < -1 and hit == nil then 
					Anim = "Fall"
					if attack == false then
						RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
						Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),1 / 3)
						RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(45 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(35 - 4 * math.cos(sine / 6)),math.rad(0),math.rad(-45 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
						RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.3,-0.7) * CFrame.Angles(math.rad(-25 + 5 * math.sin(sine / 12)),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
						LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-0.8,-0.3) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
						GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1 / 2)
					end
				elseif Torsovelocity < sensitivity then
					Anim = "Idle"
					if attack == false then
						if math.random(1,50)==1 then
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * LEFTSHOULDERC0,0.7/3)
						end
						if math.random(1,50)==1 then
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0+math.random(-5,5),0+math.random(-5,5),0+math.random(-5,5)) * ANGLES(RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999))), 0.2)			
						end
						if math.random(1,50)==1 then
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * RIGHTSHOULDERC0,0.7/3)
						end
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.1*COS(sine / 12))*ANGLES(RAD(0),RAD(0),RAD(0)), 0.8 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(sine / 15)), RAD(10 * SIN(sine/32)), RAD(-10 + 5.5 * SIN(sine /15))), 0.8 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 5.5 * SIN(sine/12)), RAD(5 * SIN(sine /12)), RAD(22 + 4.4 * SIN(sine /12))) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0- 5.5 * SIN(sine /12)), RAD(5 * SIN(sine /12)), RAD(-22 + 4.4 * SIN(sine/12))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.1*COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(80-5*math.sin(sine/12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.1*COS(sine  / 12), -0.01) * ANGLES(RAD(0), RAD(-80 + 5*math.sin(sine/12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
					end
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					if attack == false then
						if math.random(1,50)==1 then
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * LEFTSHOULDERC0,0.7/3)
						end
						if math.random(1,50)==1 then
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0+math.random(-5,5),0+math.random(-5,5),0+math.random(-5,5)) * ANGLES(RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999)), RAD(math.random(-99999,9999))), 0.2)			
						end
						if math.random(1,50)==1 then
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5+math.random(-5,5),0.5+math.random(-5,5),0+math.random(-5,5)) * CFrame.Angles(math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999)),math.rad(math.random(-99999,9999))) * RIGHTSHOULDERC0,0.7/3)
						end
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2* SIN(sine / 6)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0-25* SIN(sine / 12)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+25* SIN(sine / 12)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.1* COS(sine / 6)) * ANGLES(RAD(5-1*math.cos(sine/12)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0-0.07*SIN(sine/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-5), RAD(-5 + 45 * SIN(sine / 12))), 0.8 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0+0.07*SIN(sine/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(5 + 45 * SIN(sine / 12))), 0.8 / Animation_Speed)
						GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
					end
				end
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			walkspeed = 16
		elseif taunt.Value == "Err0r2" then
			if HipValLock == false then
				HipVal = 3
			end
			--eeepitch = 1
			change = 1
			--eevol = 5
			sensitivity = 25
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			if attack == false then
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 + .5 * math.sin(sine/15)) * CFrame.Angles(math.rad(0),math.rad(-10*math.cos(sine/30)),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(-15*math.cos(sine/30)),math.rad(0)),1/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135+-15*math.cos(sine/30)),math.rad(0),math.rad(25+15*math.cos(sine/30))) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(5),math.rad(5),math.rad(-10+15*math.cos(sine/30))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(10+10*math.sin(sine/15))),1/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-10-10*math.sin(sine/15))),1/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 + .5 * math.sin(sine/15)) * CFrame.Angles(math.rad(40),math.rad(-5*math.cos(sine/30)),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = GUN.NeonParts.Color
					swait()
					if not alreadyfixing then
						wingpart.Color = MAINRUINCOLOR
					end
				end))
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
			walkspeed = 50
		elseif taunt.Value == "Pazolite" then
			if HipValLock == false then
				HipVal = 3
			end
			--eeepitch = 1
			change = 1
			--eevol = 5
			sensitivity = 25
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			if not attack then
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1,.75,.1) * CFrame.Angles(math.rad(-165),math.rad(0),math.rad(40)) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-12.5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(12.5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				elseif Torsovelocity >= sensitivity then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,-.1) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
				local partnum = math.random(1,48)
				coroutine.resume(coroutine.create(function()
					local wingpart = Character.Wings:GetChildren()[partnum]
					wingpart.Color = GUN.NeonParts.Color
					swait()
					if not alreadyfixing then
						wingpart.Color = MAINRUINCOLOR
					end
				end))
			end
			walkspeed = 50
		elseif taunt.Value == "FAST BOIII" then
			change = 1
			if HipValLock == false then
				HipVal = 0
			end
			--eeepitch = 1
			--eevol = 5
			sensitivity = 25
			if not Character:FindFirstChild("WalkingWheel") and Anim == "Idle" and not attack then
				local ww = Instance.new("Model")
				ww.Name = "WalkingWheel"
				for i = 1,36 do
					local wwpart = Instance.new("Part")
					wwpart.Size = Vector3.new(2,.2,.56)
					wwpart.CFrame = Torso.CFrame * CFrame.Angles(math.rad(85+(10*i)),0,0) * CFrame.new(0,3.1,0)
					weldBetween(RootPart,wwpart)
					wwpart.Material = "Neon"
					if i <= 18 then
						wwpart.CanCollide = false
					end
					wwpart.Color = Color3.new()
					wwpart.Name = randomstring()
					wwpart.Parent = ww
				end
				ww.Parent = Character
				coroutine.resume(coroutine.create(function()
					repeat if stopeverything then wait(math.huge) end 
						for i,v in pairs(ww:GetChildren()) do 
							v.Color = GUN.NeonParts.Color 
						end 
						swait() 
					until attack or Anim ~= "Idle" or taunt.Value ~= "FAST BOIII"
					alreadyfixing = true
					ww:Destroy()
					alreadyfixing = false
				end))
			end
			local vAlUe = 100
			RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
			RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
			LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
			Humanoid.WalkSpeed = walkspeed*6
			if not attack then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if Torsovelocity < sensitivity then
					Anim = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,.2) * CFrame.Angles(math.rad(-sine*6),math.rad(0),math.rad(0)),.25)
					Neck.C0 = Clerp(Neck.C0,NECKC0,.25)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.25)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.25)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(90),math.rad(0)),.25)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(-90),math.rad(0)),.25)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
				elseif Torsovelocity >= sensitivity then
					Anim = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.25/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.25/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.6,.5) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.75/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.6,.5) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.75/3)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(180+-sine*vAlUe),math.rad(90),math.rad(0)),1)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(-sine*vAlUe),math.rad(-90),math.rad(0)),1)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
					GUN.Base.Transparency = 0
					GUN.GunAdditions.Transparency = 0
					GUN.NeonParts.Transparency = 0
				end
			else
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
			end
		else
			if not attack then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				if HipValLock == false then
					HipVal = 0
				end
				if taunt.Value == "Fave" then
					change = 1
					--eeepitch = 1
					sensitivity = 25
					if HipValLock == false then
						HipVal = 0
					end
					RootJoint.C0 = Clerp(RootJoint.C0,rc0,1)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(),1)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * rscp,1)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.3,.7,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-135)) * lscp,1)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0),1)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.9,-1.9,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-25)),1)
					RightHip.C1 = Clerp(RightHip.C1,CFrame.new(),1)
					LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(),1)
					RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
					LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				elseif taunt.Value == "Krump" then
					change = 1
					--eeepitch = 1
					if HipValLock == false then
						HipVal = 0
					end
					RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0+1*math.sin(sine/3),0+1*math.cos(sine/3),-.75) * CFrame.Angles(math.rad(0),math.rad(-10),math.rad(0)),1)
					Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(),1)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)) * rscp,1)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)) * lscp,1)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1.5,-1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(70)),1)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-1.25,-.25) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),1)
					RightHip.C1 = Clerp(RightHip.C1,CFrame.new(),1)
					LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(),1)
					RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
					LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				elseif taunt.Value == "Sus" then
					VT=Vector3.new

					--Anim Fixer
					RootJoint.C1 = Clerp(RootJoint.C1,ROOTC0,.2/3)
					Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
					RightHip.C1 = Clerp(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
					LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
					RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
					LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
					--End
					
					change = 1
					--eeepitch = 1
					if HipValLock == false then
						HipVal = 0
					end
					CF=CFrame.new
Animation_Speed=3
SIN=math.sin
ANGLES=CFrame.Angles
angles=CFrame.Angles
RAD=math.rad
COS=math.cos
MRANDOM=math.random
Cos=math.cos
Sin=math.sin
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(-0.25 * COS(LOOPx / 50), 0, -0.5 - 0.5 * COS(LOOPx / 25)) * ANGLES(RAD(0), RAD(0), RAD(45 * SIN(LOOPx / 50))) * ANGLES(RAD(45 + 22.5 * COS(LOOPx / 25)), RAD(0), RAD(0)), 2 / 3)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-45 - 22.5 * COS(LOOPx / 25)), RAD(0), RAD(-45 * SIN(LOOPx / 50))), 2 / 3)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * ANGLES(RAD(175+65 * SIN(LOOPx / 25)), RAD(0), RAD(-45 * SIN(LOOPx / 12.5))) * CF(0,-0.5,0) * RIGHTSHOULDERC0, 1 / 3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * ANGLES(RAD(175+65 * SIN(LOOPx / 25)), RAD(0), RAD(45 * SIN(LOOPx / 12.5))) * CF(0,-0.5,0) * LEFTSHOULDERC0, 1 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5 + 0.5 * COS(LOOPx / 25), -0.5 - 0.5 * COS(LOOPx / 25)) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / 3)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5 + 0.5 * COS(LOOPx / 25), -0.5 - 0.5 * COS(LOOPx / 25)) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / 3)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				elseif taunt.Value == "OOOOO" then
					if HipValLock == false then
						HipVal = 0
					end
					change = 1
					--eeepitch = 1
					sensitivity = 25
					if not eee:FindFirstChildOfClass("DistortionSoundEffect") then
						local dse = Instance.new("DistortionSoundEffect")
						dse.Priority = 2147483647
						dse.Level = .99
						dse.Name = randomstring()
						dse.Parent = eee
						coroutine.resume(coroutine.create(function()
							repeat swait() until not dse:IsDescendantOf(game) or taunt.Value ~= "OOOOO"
							if not soundfixing then
								soundfixing = true
								dse:Destroy()
								soundfixing = false
							end
						end))
					end
					RootJoint.C0 = Clerp(RootJoint.C0,rc0*CFrame.new(math.random(-1,1)/2,math.random(-1,1)/2,math.random(-1,1)/2)*CFrame.Angles(math.rad(math.random(-45,45)),math.rad(math.random(-45,45)),0),1)
					Neck.C0 = Clerp(Neck.C0,nc0,1)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(2,0,0) * rscp * CFrame.Angles(math.rad(-90),0,0),1)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-2,0,0) * lscp * CFrame.Angles(math.rad(-90),0,0),1)
					RightHip.C0 = Clerp(RightHip.C0,CFrame.new(.5,-2,0),1)
					LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-.5,-2,0),1)
					RightHip.C1 = Clerp(RightHip.C1,CFrame.new(),1)
					LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(),1)
					RightShoulder.C1 = Clerp(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
					LeftShoulder.C1 = Clerp(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
				end
			end
		end
	end
	if shieldblock == nil and Shield.Value == true then
		shieldfixer()
	end
	if taunt.Value ~= "Banisher" or taunt.Value ~= "Banisher2" then
		Hole = GUN.Hole
		Holetwo = GUN.Hole2
	else
		Hole = GUN2.Hole
		Holetwo = GUN2.Hole
	end
	shieldblock.Transparency = 0
	shieldblock.Name = "Garcello "..randomstring()
	shieldblock.Shape = "Ball"
	shieldblock.Locked = true
	shieldblock.Massless = false
	shieldblock.CanTouch = true
	shieldblock.CanCollide = false
	shieldblock.Archivable = true
	shieldblock.Material = "ForceField"
	shieldblock.Reflectance = 0
	shieldblock.Anchored = true
	shieldblock.CastShadow = false
	shieldblock:ClearAllChildren()
	eeeblock.Transparency = "inf"
	if Shield.Value == true then
		shieldblock.Parent = workspace
		mdmg(shieldblock.Position,10+0.05*math.sin(sine/25))
	end
	if Shield.Value == false then
		shieldblock.Parent = nil
	end	
	if not BallFolder then
		BallFolder = Instance.new("Folder")
		BallFolder.Parent = workspace.Terrain
		BallFolder.Name = randomstring()
	end
	Hue = Hue + 1
	if (Hue>360) then Hue = 0 end

	swait()
	end
print("Load successful")
end)
Section:NewButton("FE Halo", "ButtonInfo", function()
    print("Clicked")
wait(0.9)
script = game:GetObjects("rbxassetid://5812973403")[1].Masterchief
script.Parent = game:GetService("PolicyService")
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))() --mw reanimate 36

wait(.1)

	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

--made by helkern	
wait(1/60)	
player = game:GetService("Players").LocalPlayer
mouse = player:GetMouse()
character = player.Character
playergui = player.PlayerGui
targetnnn = nil
humanoid = character.Humanoid
rootpart = character.HumanoidRootPart
head = character.Head
torso = character.Torso
rightarm = character["Right Arm"]
leftarm = character["Left Arm"]
rightleg = character["Right Leg"]
leftleg = character["Left Leg"]
grenadenn = false
rootjoint = rootpart.RootJoint
neck = torso.Neck
rightshoulder = torso["Right Shoulder"]
leftshoulder = torso["Left Shoulder"]
righthip = torso["Right Hip"]
lefthip = torso["Left Hip"]
tripnnn = nil

song = Instance.new("Sound",torso)

cf = CFrame.new
d = cf(0,0,0)
vt = Vector3.new
random = math.random
cos = math.cos
sin = math.sin
rad = math.rad
angles = CFrame.Angles

tweenservice = game:GetService("TweenService")
debris = game:GetService("Debris")

sine = 0
mousehold,keyhold = false,false
rooted = false
attack = false
rootc0 = cf(0, 0, 0) * angles(rad(-90), rad(0), rad(180))
neckc0 = cf(0, 1, 0) * angles(rad(-90), rad(0), rad(180))
change = 1
effects = Instance.new("Folder",workspace)
effects.Name = "effects lol"
if humanoid.Animator then humanoid.Animator:Destroy() end
anim = "idle"

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Swait(n)
	if n == 0 or n == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, n do
			ArtificialHB.Event:wait()
		end
	end
end

function part(parent, mat, transp, color, size, anchored, shape)
	local p = Instance.new("Part")
	p.Transparency = transp
	p.CanCollide = false
	p.Locked = true
	if not type(anchored) == "boolean" then
	p.Anchored = true	
	end
	p.Anchored = anchored
	p.Color = color
	p.Size = size
	p.Position = rootpart.Position
	p.Material = mat
	p.Parent = parent
	if shape then
	if shape == "ball" then
	local m = Instance.new("SpecialMesh",p)
	m.MeshType = "Sphere"	
	end	
	end
	return p
end

function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
end

function weld(parent, part0, part1, c0, c1)
	local w = Instance.new("Weld")
	w.Part0 = part0
	w.Part1 = part1
	w.C0 = c0
	w.C1 = c1
	w.Parent = parent
	return w
end

function sound(id, parent, vol, pitch)
		local so = Instance.new("Sound")
		so.EmitterSize = 5*vol
		so.Parent = parent
		so.Volume = vol
		so.Pitch = pitch
		so.SoundId = "rbxassetid://"..id
		so:Play()
	return so
end

function Tween(obj,prop,easing,easingdir,timer)
local easin = Enum.EasingStyle[easing]
local easindir = Enum.EasingDirection[easingdir]
local tweeninf = TweenInfo.new(
	timer/1,	
	easin,
	easindir,
	0,
	false,
	0
)
local props = prop
local tweenanim = tweenservice:Create(obj,tweeninf,props)
tweenanim:Play()
end

function raycast(pos, dir, range, ignore)
	return workspace:FindPartOnRay(Ray.new(pos, dir.unit * range), ignore)
end

function castray(start, endp, dist, ignore)
	local dir = cf(start,endp).lookVector
	return raycast(start, dir, dist, ignore)
end

function Effect(tblee)
	coroutine.resume(coroutine.create(function()
		local origpos = (tblee.cf or nil)
		local moveto = (tblee.moveto or nil)
		local color = (tblee.clr or Color3.new(0,0,0))
		local color2 = (tblee.clr2 or nil)
		local defaultsize = (tblee.size or vt(2,2,2))
		local material = (tblee.mat or "Neon")
		local locker = (tblee.lock or false)
		local rotateX = (tblee.radX or 0)
		local rotateY = (tblee.radY or 0)
		local rotateZ = (tblee.radZ or 0)
		local secondsize = (tblee.size2 or vt(4,4,4))
		local acttime = (tblee.waits or 100)
		local transpar = (tblee.tran or 0)
		local transpar2 = (tblee.tran2 or 1)
		local typeofmesh = (tblee.mtype or "S")
		local movingspeed = nil
		local mesh = nil
		if typeof(origpos) == "Vector3"then origpos=cf(origpos) end 
		if typeof(moveto) == "CFrame"then moveto=moveto.p end 
		if typeof(color) == "BrickColor"then color=color.Color end 
		if typeof(color2) == "BrickColor"then color2=color2.Color end
		if origpos then
		local p=Instance.new("Part",effects)p.Anchored=true p.CanCollide=false p.Color=color p.CFrame=origpos p.Material=material p.Size=Vector3.new(1,1,1)p.CanCollide=false p.Transparency=transpar p.CastShadow=false p.Locked=true
		if typeofmesh == "Box" or typeofmesh == "B" or typeofmesh == "1" then
			mesh=Instance.new("BlockMesh",p)mesh.Scale=defaultsize
		elseif typeofmesh == "Sphere" or typeofmesh == "S" or typeofmesh == "2" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="Sphere"mesh.Scale=defaultsize
		elseif typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="Cylinder"mesh.Scale=defaultsize
		elseif typeofmesh == "Slash" or typeofmesh == "SL" or typeofmesh == "4" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="FileMesh"mesh.MeshId="rbxassetid://662585058"mesh.Scale = vt(defaultsize.X/10,0,defaultsize.X/10)
		elseif typeofmesh == "Wave" or typeofmesh == "W" or typeofmesh == "5" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="FileMesh"mesh.MeshId="rbxassetid://20329976"mesh.Scale = vt(0,0,-defaultsize.X/8)
		end
		if locker == true then
			p.Position = origpos.p
			if typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then 
				p.CFrame = cf(p.Position,moveto)*cf(0,0,-(p.Size.Z/1.5))*angles(0,rad(90),0)
			else
				p.CFrame = cf(p.Position,moveto)*cf(0,0,-(p.Size.Z/1.5))
			end
		else
			if typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then 
				p.CFrame = origpos*CFrame.Angles(0,math.rad(90),0)
			else
				p.CFrame = origpos
			end
		end
		if color2 then
		Tween(p,{Color = color2},"Linear","In",acttime/60)
		end	
		if mesh then
			if  moveto then
				movingspeed=(origpos.p - moveto).Magnitude/acttime
			end
			local endsize=(defaultsize - secondsize)
			local endtranpar=transpar-transpar2
			for i = 1, acttime+1 do Swait()
				mesh.Scale=mesh.Scale-endsize/acttime
				p.Transparency = p.Transparency - endtranpar/acttime
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(rotateX),math.rad(rotateY),math.rad(rotateZ))
				if moveto ~= nil then
					local a = p.Orientation
					if typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then 
						p.CFrame = CFrame.new(p.Position,moveto)*CFrame.new(0,0,-movingspeed)*CFrame.Angles(0,math.rad(90),0)
					else
						p.CFrame = CFrame.new(p.Position,moveto)*CFrame.new(0,0,-movingspeed)
					end
					p.Orientation = a
				end
			end
			p:Destroy()
		end
		elseif origpos == nil then
		warn("Origpos is nil!")
		end
	end))
end

function attcf(p)
	return p.Parent.CFrame*cf(p.Position)
end

function unanchor(what)
	if typeof(what) == "Instance" then
	for _,v in pairs(what:GetDescendants()) do
		if v:IsA("BasePart") then
			v.Anchored = false
		end
	end
	else
	warn("not an instance")
	end
end

function randomangle()
	return angles(rad(random(1,360)),rad(random(1,360)),rad(random(1,360)))
end

function randompos(num,typ)
	if typ == "vt" or not typ then
		return vt(random(-num,num),random(-num,num),random(-num,num))
	elseif typ == "cf" then
		return cf(random(-num,num),random(-num,num),random(-num,num))
	end
end

function deathfunction(model)
	--model:BreakJoints()
	targetnnn = model
	for _, c in pairs(model:GetChildren()) do
		if c:IsA("BasePart") and c.Name ~= "HumanoidRootPart" then
			if c.Name == "Head" then
				
				elseif c.Name ~= "HumanoidRootPart" then
					
			end
		end
	end
	--debris:AddItem(model,6)
end

function applydamage(humanoid,damage)
	damage = damage
	if humanoid.Health < 2000 then
		if humanoid.Health - damage > 0 then
			targetnnn = humanoid.Parent
			--humanoid.Health = humanoid.Health - damage
		else
			deathfunction(humanoid.Parent)
		end
	else
		deathfunction(humanoid.Parent)
	end
end

function aoe(pos,range,min,max,fling,instakill,knock)
	for index, ch in pairs(workspace:GetDescendants()) do
		if ch.ClassName == "Model" and ch ~= character and ch ~= character.Model then
			local hum = ch:FindFirstChildOfClass("Humanoid")
			if hum  and hum.Parent then
				local torso = ch:FindFirstChild("Torso") or ch:FindFirstChild("UpperTorso")
				if torso then
					if (torso.Position - pos).Magnitude <= range then
						if instakill == true then
							print(ch)
							targetnnn = ch
							--deathfunction(ch)
						else
							print(ch)
							targetnnn = ch
							--local dmag = random(min,max)
							--applydamage(hum,dmag)
						end
						if fling > 0 then
							for _, c in pairs(ch:GetChildren()) do
								if c:IsA("BasePart") then
									--local bv = Instance.new("BodyVelocity") 
									--bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									--bv.velocity = cf(pos,torso.Position).lookVector*fling bv.Parent = c debris:AddItem(bv,.05)
								end
							end
						end
						if knock and knock == true then
							if ch:FindFirstChild("HumanoidRootPart") then
								--ch.HumanoidRootPart.CFrame = ch.HumanoidRootPart.CFrame*randomangle()
							end
						else	
						end
					end
				end
			end
		end
	end
end

function agyro()
	local g = Instance.new("BodyGyro",rootpart)
	g.D = 25
	g.P = 20000
	g.MaxTorque = vt(0,4000000,0)
	g.CFrame = cf(rootpart.Position,mouse.Hit.p)
	coroutine.wrap(function()
		repeat
			Swait()
			g.CFrame = cf(rootpart.Position,mouse.Hit.p)
		until not attack
		g:Destroy()
	end)()
end



songid = 0
speed = 16
riflequipped = true

for _,v in next, humanoid:GetPlayingAnimationTracks() do
	 v:Stop();
end
character.Animate.Parent = nil

local la = Instance.new("Weld")
local ra = Instance.new("Weld")
rightshoulder.Parent = nil
leftshoulder.Parent = nil
ra.Name = "ra"
ra.Part0 = torso 
ra.C0 = cf(1.5, 0.5, 0)
ra.C1 = cf(0, 0.5, 0)
ra.Part1 = rightarm
ra.Parent = torso  

la.Name = "la"
la.Part0 = torso 
la.C0 = cf(-1.5, 0.5, 0)
la.C1 = cf(0, 0.5, 0) 
la.Part1 = leftarm
la.Parent = torso

local lh = weld(leftleg,torso,leftleg,cf(-.5,-1,0),d)
lh.C1 = cf(0,1,0)
local rh = weld(rightleg,torso,rightleg,cf(.5,-1,0),d)
rh.C1 = cf(0,1,0)

--player:ClearCharacterAppearance()
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

mc = script.chief

for _, v in pairs(mc:GetDescendants()) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end


for _,v in pairs(mc:GetChildren()) do
	weld(v,v,character[v.Name],d,d)
end
unanchor(mc)
mc.Parent = character
rifle = script.rifle

for _, v in pairs(rifle:GetDescendants()) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end
Grenade = gp(gp(cnnnnn.Model, "CaramelBear", "Accessory"), "Handle", "BasePart")
Grenade.Mesh:Destroy()

local Grenade = gp(gp(gp(cnnnnn, "CaramelBear", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
Grenade.Parent = character.Torso

local attnnn = gp(gp(gp(cnnnnn, "CR-L 16 Grenadier [Back]", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment") -- rifle
attnnn.Parent = rifle.Handle
attnnn.Rotation = Vector3.new(-0, -90, 0)
attnnn.Position = Vector3.new(0, 0.3, 0)
shirt = script.s
shirt.Parent = character
pants = script.p
pants.Parent = character
head.Transparency = 1
eqpweld = weld(rifle,rifle.eqp,rightarm,d,d)
uneqpweld = weld(rifle,rifle.uneqp,torso,d,d)
uneqpweld.Parent = nil
unanchor(rifle)
rifle.Parent = character
riflejoint = rifle.joint2.Weld
shg = script.shotgun
for _, v in pairs(shg:GetDescendants()) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end

local attnnn2 = gp(gp(gp(cnnnnn, "Type-12Accessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment") -- shutgun
attnnn2.Parent = shg.shotgun
attnnn2.Rotation = Vector3.new(-90, 0, 180)
attnnn2.Position = Vector3.new()
seqw = weld(shg,shg.eqp,rightarm,d,d)
seqw.Parent = nil
suneq = weld(shg,shg.uneqp,torso,d,d)
unanchor(shg)
shg.Parent = character
weap = "rifle"
shotgunjoint = shg.joint2.Weld
changin = false
gren = script.gren
gren.Parent = nil

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if attack == true and changin == false and grenadenn == false and tripnnn == false then

			if weap == "rifle" then
				GlobalFunctions.fling(mouse.Hit.p, 0.001)
			end
			
			if weap == "shotgun" then
				GlobalFunctions.fling(mouse.Hit.p,1.05)
			end
			
			
		elseif targetnnn then
			
				print("Fling")
				GlobalFunctions.fling(targetnnn, 0.5)
				wait(0.1)
				targetnnn = nil
			
		end
	end
end)

function switch()
	if not attack and weap == "rifle" then
			changin = true
		for _,v in pairs(rifle:GetChildren()) do
			if v:IsA("BasePart") and v.Name ~= "Hole" and v.Name ~= "uneqp" and v.Name ~= "eqp" then
				Tween(v,{Transparency = 1},"Linear","In",.5)
			end
		end
		Tween(shg.shotgun,{Transparency = 1},"Linear","In",.5)
		delay(.5,function()
		eqpweld.Parent = nil
		uneqpweld.Parent = rifle
		attnnn.Parent = rifle.Handle
		seqw.Parent = shg
		attnnn2.Parent = shg.shotgun
		suneq.Parent = nil
		for _,v in pairs(rifle:GetChildren()) do
			if v:IsA("BasePart") and v.Name ~= "Hole" and v.Name ~= "uneqp" and v.Name ~= "eqp" then
				Tween(v,{Transparency = 1},"Linear","In",.5)
			end
		end	
		Tween(shg.shotgun,{Transparency = 1},"Linear","In",.5)
		weap = "shotgun"
		changin = false
		end)
	elseif not attack and weap == "shotgun" then
		for _,v in pairs(rifle:GetChildren()) do
			if v:IsA("BasePart") and v.Name ~= "Hole" and v.Name ~= "uneqp" and v.Name ~= "eqp" then
				Tween(v,{Transparency = 1},"Linear","In",.5)
			end
		end
		Tween(shg.shotgun,{Transparency = 1},"Linear","In",.5)
		delay(.5,function()
		eqpweld.Parent = rifle
		attnnn.Parent = rifle.Handle
		uneqpweld.Parent = nil
		seqw.Parent = nil
		suneq.Parent = shg
		attnnn2.Parent = shg.shotgun
		for _,v in pairs(rifle:GetChildren()) do
			if v:IsA("BasePart") and v.Name ~= "Hole" and v.Name ~= "uneqp" and v.Name ~= "eqp" then
				Tween(v,{Transparency = 1},"Linear","In",.5)
			end
		end	
		Tween(shg.shotgun,{Transparency = 1},"Linear","In",.5)
				weap = "rifle"
				changin = false
		end)
	end
end




function cs()
	if songid == 0 then
		songid = 1
	elseif song == 1 then
		songid = 2
	end
end

function shoot()
	attack = true
	  	local Time,Easing,Direction = .35,'Quad','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(riflejoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
	repeat
		rootpart.Anchored = true
		swait(.02)
		sound(1044434118,rifle.Hole,3,random(8,12)/10)
		  	local Time,Easing,Direction = .075,'Linear','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0+.15)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4-.15)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7-.15)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8+.3)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7+.3)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(riflejoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
local h,p = castray(rifle.Hole.Position,mouse.Hit.p, 500,character)
local di = (p - rifle.Hole.Position).Magnitude
Effect({cf=cf(rifle.Hole.Position,p)*cf(0,0,-di/2),moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=10,size=Vector3.new(.05,.05,di),size2=Vector3.new(.1,.1,di),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
Effect({cf=rifle.Hole.Position,moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=15,size=Vector3.new(.1,.1,.1),size2=Vector3.new(.3,.3,.3),radX=random(-8,8),radY=random(-8,8),radZ=random(-8,8),mat="Neon",lock=false,tran=0,tran2=1})
if h then
	if h.Parent:FindFirstChildOfClass("Humanoid") then
		applydamage(h.Parent:FindFirstChildOfClass("Humanoid"),random(30,35))
		local bl = part(h.Parent,"Granite",0,BrickColor.new("Crimson").Color,vt(.2,.2,.2),false,"ball")
		bl.Position = p
		weldBetween(bl,h)
		Tween(bl,{Transparency = 1},"Linear","In",1)
		debris:AddItem(bl,1.01)
		sound(1565725028,bl,6,random(9,12)/10)
	end
end
	  	local Time,Easing,Direction = .075,'Linear','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(riflejoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
	until mousehold == false
	rootpart.Anchored = false
	attack = false
end

function shoot2()
	attack = true
	  	local Time,Easing,Direction = .35,'Quad','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
		rootpart.Anchored = true
		sound(2001619675,shg.Hole,3,random(8,12)/10)
		  	local Time,Easing,Direction = .2,'Back','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(5.9),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.7,-0.3)*angles(rad(-24.2),rad(7.5),rad(-12.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.7,-0.6)*angles(rad(-13.1),rad(-9.5),rad(1.3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.1,0.1,-0.3)*angles(rad(125.8),rad(8.4),rad(39))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.2,0.6,-0.1)*angles(rad(101.5),rad(11.1),rad(-23.4))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(7.7),rad(0),rad(-20.3))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
for i = 1,6 do
local h,p = castray(shg.Hole.Position,mouse.Hit*randompos(1,"cf").p, 500,character)
local di = (p - shg.Hole.Position).Magnitude
local ab
if not h then ab = randompos(12) else ab = vt(0,0,0) end
Effect({cf=cf(shg.Hole.Position,p+ab)*cf(0,0,-di/2),moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=10,size=Vector3.new(.05,.05,di),size2=Vector3.new(.1,.1,di),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
Effect({cf=shg.Hole.Position,moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=15,size=Vector3.new(.1,.1,.1),size2=Vector3.new(.3,.3,.3),radX=random(-8,8),radY=random(-8,8),radZ=random(-8,8),mat="Neon",lock=false,tran=0,tran2=1})
if h then
	if h.Parent:FindFirstChildOfClass("Humanoid") then
		applydamage(h.Parent:FindFirstChildOfClass("Humanoid"),random(20,25))
		local bl = part(h.Parent,"Granite",0,BrickColor.new("Crimson").Color,vt(.2,.2,.2),false,"ball")
		bl.Position = p
		weldBetween(bl,h)
		Tween(bl,{Transparency = 1},"Linear","In",1)
		debris:AddItem(bl,1.01)
		sound(1565725028,bl,6,random(9,12)/10)
	end
end
end
  swait(Time)
	  	local Time,Easing,Direction = .15,'Linear','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
  	local Time,Easing,Direction = .2,'Quad','InOut'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,-0.1)*angles(rad(6.6),rad(32.4),rad(-1.5))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.7,-0.3)*angles(rad(-24.2),rad(7.5),rad(-12.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.7,-0.6)*angles(rad(-13.1),rad(-9.5),rad(1.3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.6,0.7,-0.3)*angles(rad(127),rad(-1),rad(-22.6))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(0.9,0.5,-0.9)*angles(rad(105.8),rad(0.4),rad(-53.5))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0.1,0,0)*angles(rad(0.1),rad(0),rad(5.7))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(0.3,-0.1,0)*angles(rad(23),rad(42),rad(-18.1))},Easing,Direction,Time)
  swait(Time)
sound(3299747822,shg.Hole,4,1)
  	local Time,Easing,Direction = .2,'Back','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(6.2),rad(26.8),rad(-0.7))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.7,-0.3)*angles(rad(-24.2),rad(7.5),rad(-12.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.7,-0.6)*angles(rad(-13.1),rad(-9.5),rad(1.3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.6,0.3,-0.5)*angles(rad(127),rad(-1),rad(19.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(0.9,0.5,-0.9)*angles(rad(105.8),rad(0.4),rad(-53.5))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0.1,0,0)*angles(rad(0.4),rad(0),rad(11.4))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(0.3,-0.1,0)*angles(rad(23),rad(42),rad(-18.1))},Easing,Direction,Time)
  swait(Time)
	rootpart.Anchored = false
	attack = false
end

function grenade()
	
	grenadenn = true
	attack = true
	  	local Time,Easing,Direction = .45,'Quad','InOut'
  Tween(rootjoint,{C0 = cf(0,0,0)*angles(rad(0),rad(52.9),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-1,-0.1)*angles(rad(1.4),rad(5.6),rad(-2.4))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.5,-1,-0.2)*angles(rad(-0.9),rad(-9.7),rad(3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.4,0.5,0)*angles(rad(14.2),rad(14.4),rad(1.2))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.6,0.5,0)*angles(rad(117.8),rad(25.4),rad(26.7))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-52.9))},Easing,Direction,Time)
  swait(Time)
  	local Time,Easing,Direction = .3,'Quad','InOut'
  Tween(rootjoint,{C0 = cf(0,0,0)*angles(rad(0),rad(43),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-1,-0.1)*angles(rad(1.4),rad(5.6),rad(-2.4))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.5,-1,-0.2)*angles(rad(-0.9),rad(-9.7),rad(3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.4,0.7,0.1)*angles(rad(-162.6),rad(-15),rad(-10.9))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.2,0.8,0.5)*angles(rad(-103.3),rad(0.5),rad(-36.2))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-43))},Easing,Direction,Time)
local gren2 = gren:Clone()
gren2.Anchored = false
gren2.Parent = effects
gren2.CFrame = leftarm.CFrame
Grenade.Parent = gren2
local grenw = weld(gren2,gren2,leftarm,d*angles(rad(90),0,0)*cf(0,1,0),d)
  swait(Time)
  	local Time,Easing,Direction = .3,'Quint','Out'
  Tween(rootjoint,{C0 = cf(0,0,0)*angles(rad(-9.2),rad(-18.5),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.9,-0.4)*angles(rad(11.4),rad(15.8),rad(-5.5))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.4,-1,-0.2)*angles(rad(7.4),rad(-9.8),rad(0))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.4,0.5,-1.2)*angles(rad(37.1),rad(8.9),rad(61.6))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.2,0.8,0.5)*angles(rad(-103.3),rad(0.5),rad(-36.2))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(-0,0,-0)*angles(rad(-7.9),rad(0),rad(18.4))},Easing,Direction,Time)
local proj = gren:Clone()
sound(4847394559,leftarm,4,1)
proj.Anchored = false
proj.Parent = effects
proj.Position = gren2.Position
Grenade.Parent = proj
proj.CFrame = cf(proj.Position,mouse.Hit.p)*cf(0,0,-4)
gren2:Destroy()
proj.Velocity = proj.CFrame.lookVector*125
proj.CanCollide = true
delay(1,function()

aoe(proj.Position,20,0,0,200,true)
local s = sound(2814354338,proj,2,1)
s.PlayOnRemove = true
Effect({cf=proj.Position,moveto=nil,clr=Color3.fromRGB(255,150,0),clr2=Color3.fromRGB(255,100,0),mtype="S",waits=60/1.5,size=Vector3.new(1,1,1),size2=Vector3.new(40,40,40),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
Effect({cf=proj.Position,moveto=nil,clr=Color3.fromRGB(255,100,0),clr2=Color3.fromRGB(255,150,0),mtype="S",waits=60/1.5,size=Vector3.new(1,1,1),size2=Vector3.new(30,30,30),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
for i = 1,3 do
Effect({cf=proj.CFrame*randomangle(),moveto=nil,clr=Color3.new(1,1,1),clr2=Color3.new(1,1,1),mtype="Wave",waits=75/1.5,size=Vector3.new(1,.1,3),size2=Vector3.new(45,.2,45),radX=0,radY=random(-4,4),radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
end
Grenade.Parent = character.Torso
proj:Destroy()	
end)
  swait(Time)
	
	grenadenn = false
	attack = false
	
	
end

run = false

function trip()
	tripnnn = true
	attack = true
	Swait()
	local Time,Easing,Direction = .3,'Quart','Out'
  Tween(rootjoint,{C0 = cf(0,-0.3,0.1)*angles(rad(-12.9),rad(73.3),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.8,-0.1)*angles(rad(3.8),rad(6.1),rad(3.9))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.5,-0.8,-0.4)*angles(rad(-12),rad(8.2),rad(57.6))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.5,0.5,0.1)*angles(rad(7.5),rad(17.6),rad(-21.2))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(0.9,0.5,-0.9)*angles(rad(93.5),rad(7.9),rad(-58.5))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-73.3))},Easing,Direction,Time)
	rootpart.Velocity = rootpart.CFrame.lookVector*235
	aoe(rightleg.Position,3,10,17,0,false,true)
  swait(Time)
	aoe(rightleg.Position,7,10,17,0,false,true)
	tripnnn = false
	attack = false
end

mouse.Button1Down:Connect(function()
	mousehold = true
	if attack == false and weap == "rifle" and not changin then
		shoot()
	elseif not attack and weap == "shotgun" and not changin then
		shoot2()
	end
end)

mouse.Button1Up:Connect(function()
	mousehold = false
end)

mouse.KeyDown:Connect(function(k)
	keyhold = true
	if k == "z" and attack == false and grenadenn == false then
		grenade()
	end
	
	if k == "x" and attack == false then
		trip()
	end
	if k == "c" and attack == false then
		
	end
	
	if k == "v" and attack == false then
		
	end
	
	if k == "b" and attack == false then
		
	end
	
	if k == "2" and run == false then run = true elseif k == "2" and run == true then run = false end
	
	if k == "q" and not attack and not changin then
		switch()
	end
	
	if k == "m" and attack == false then cs() end
end)

mouse.KeyUp:Connect(function(k)
	keyhold = false
end)

while true do
	Swait()
	sine = sine + change
	local torsoverticalvel = rootpart.Velocity.Y
	local torsovel = (rootpart.Velocity * vt(1, 0, 1)).Magnitude
	local hitfloor,hitpos,normal = raycast(rootpart.Position,(cf(rootpart.Position, rootpart.Position+vt(0,-1,0))).lookVector,4+humanoid.HipHeight,character)
	local speedval = 10/(humanoid.WalkSpeed/16)
	local Walking = humanoid.MoveDirection.magnitude>0
	local FwdDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.lookVector or vt())
	local RigDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.rightVector or vt())
	local Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide
	if torsoverticalvel > 1 and not hitfloor then
		anim = "jump"
		if attack == false then
		local Alpha = .2
  		rootjoint.C0 = rootjoint.C0:lerp(cf(0,0,0)*angles(rad(15.2),rad(0),rad(0))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1.1,0)*angles(rad(-21),rad(0),rad(0)),Alpha)
 		rh.C0 = rh.C0:lerp(cf(0.5,-0.4,-1)*angles(rad(-18.6),rad(0),rad(0)),Alpha)
  		la.C0 = la.C0:lerp(cf(-1.5,0.5,0.2)*angles(rad(-9.7),rad(8.3),rad(-8.1)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.5,0.5,0.2)*angles(rad(-9.7),rad(-8.3),rad(8.1)),Alpha)
  		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(-9.6),rad(0),rad(0)),Alpha)
		end
	elseif torsoverticalvel < -1 and not hitfloor then
		anim = "fall"
		local Alpha = .2
		if attack == false then
 		rootjoint.C0 = rootjoint.C0:lerp(cf(0,0,-0)*angles(rad(-16.1),rad(0),rad(0))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1,-0.3)*angles(rad(-12.5),rad(0),rad(0)),Alpha)
  		rh.C0 = rh.C0:lerp(cf(0.5,-0.2,-1.1)*angles(rad(-16),rad(0),rad(0)),Alpha)
		la.C0 = la.C0:lerp(cf(-1.6,0.1+.085*sin(sine/35),-0.4)*angles(rad(72.3),rad(1.5),rad(-18.9)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.3,0.4+.085*sin(sine/35),-0.9)*angles(rad(71.8),rad(14.3),rad(-66.2)),Alpha)
  		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(-5),rad(0),rad(0)),Alpha)
		end
	elseif torsovel < 1 and hitfloor then
		anim = "idle"
		local Alpha = .1
		if attack == false then
 		rootjoint.C0 = rootjoint.C0:lerp(cf(0,0+.07*cos(sine/27),0)*angles(rad(0),rad(45.5+1*cos(sine/(27*2))),rad(0))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1-.07*cos(sine/27),-0.1)*angles(rad(1.4),rad(5.6-1*cos(sine/(27*2))),rad(-2.4)),Alpha)
 		rh.C0 = rh.C0:lerp(cf(0.5,-1-.07*cos(sine/27),-0.2)*angles(rad(-0.9),rad(-9.7-1*cos(sine/(27*2))),rad(3)),Alpha)
  		la.C0 = la.C0:lerp(cf(-1.3,0.1+.085*sin(sine/27),-0.4)*angles(rad(75.1),rad(28.8),rad(-25.2)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.1,0.3+.085*sin(sine/27),-0.8)*angles(rad(95.2),rad(17.7),rad(-57.2)),Alpha)
 		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(2.75*sin(sine/27)),rad(-3*cos(sine/(27*2))),rad(-45.5)),Alpha)
		end
	elseif torsovel > 1 and torsovel < 22 and hitfloor then
		anim = "walk"
		local Alpha = .1
		rootjoint.C0 = rootjoint.C0:lerp(cf(0,.14-.07*cos(sine/speedval*2),0)*angles(rad(-15*Vec.Z),rad(5*cos(sine/speedval)),rad(-12.5*Vec.X))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1+.18*sin(sine/speedval),-.1+.12*sin(sine/speedval)*Vec.Z)*angles(rad(-40*cos(sine/speedval)*Vec.Z),rad(2*cos(sine/speedval)),rad(-20*cos(sine/speedval)*Vec.X)),Alpha)
  		rh.C0 = rh.C0:lerp(cf(0.5,-1-.18*sin(sine/speedval),-.1-.12*sin(sine/speedval)*Vec.Z)*angles(rad(40*cos(sine/speedval)*Vec.Z),rad(-2*cos(sine/speedval)),rad(20*cos(sine/speedval)*Vec.X)),Alpha)
   		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(-2),rad(0),rad(-5*cos(sine/speedval)-26*Vec.X)),Alpha)
		la.C0 = la.C0:lerp(cf(-1.3,0.1,-0.4)*angles(rad(75.1),rad(28.8),rad(-25.2)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.1,0.3,-0.8)*angles(rad(95.2),rad(17.7),rad(-57.2)),Alpha)
	elseif torsovel >= 22 and hitfloor then
		anim = "run"
		runval = 6
		local Alpha = .1
		rootjoint.C0 = rootjoint.C0:lerp(cf(0,.2-.15*cos(sine/runval*2),0)*angles(rad(-15*Vec.Z),rad(5*sin(sine/runval)),rad(-12.5*Vec.X))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1+.45*sin(sine/runval),-.1+.2*sin(sine/runval)*Vec.Z)*angles(rad(-60*cos(sine/runval)*Vec.Z),rad(4*cos(sine/runval)),rad(-40*cos(sine/runval)*Vec.X)),Alpha)
  		rh.C0 = rh.C0:lerp(cf(0.5,-1-.45*sin(sine/runval),-.1-.2*sin(sine/runval)*Vec.Z)*angles(rad(60*cos(sine/runval)*Vec.Z),rad(-4*cos(sine/runval)),rad(40*cos(sine/runval)*Vec.X)),Alpha)
  		la.C0 = la.C0:lerp(cf(-1.3,0.1,-0.4)*angles(rad(75.1),rad(28.8),rad(-25.2)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.1,0.3,-0.8)*angles(rad(95.2),rad(17.7),rad(-57.2)),Alpha)
  		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-5*sin(sine/runval)-26*Vec.X)),Alpha)
	end
	if attack == false and weap == "rifle" then
		riflejoint.C0 = riflejoint.C0:lerp(cf(0,0,0)*angles(rad(0.3),rad(25.4),rad(-3.7)),.1)
		shotgunjoint.C0 = shotgunjoint.C0:lerp(d,.1)
	elseif not attack and weap == "shotgun" then
		riflejoint.C0 = riflejoint.C0:lerp(d,.1)
		shotgunjoint.C0 = shotgunjoint.C0:lerp(cf(0,0,0)*angles(rad(0.3),rad(25.4),rad(-3.7)),.1)
	end
	if run == false then
		speed = 16
	elseif run == true then
		speed = 35
	end
	song.SoundId,song.Looped,song.Pitch,song.Volume,song.Playing = "rbxassetid://"..songid,true,1,3,true
	humanoid.Health,humanoid.MaxHealth,humanoid.WalkSpeed = 9e9,9e9,speed
end
end)
Section:NewButton("FE Shotgun", "ButtonInfo", function()
--require(3747589551)()
game.Players:Chat("-gh 4504231783,5134896593")

wait(0.9)

GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
warn("converted by deia")
wait(1 / 60)
Effects = { }
local Player = game.Players.localPlayer
local Mouse = Player:GetMouse()
local Character = Player.Character
local Humanoid = Character.Humanoid
local Head = Character.Head
local RootPart = Character.HumanoidRootPart
local Torso = Character.Torso
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Camera = game.Workspace.CurrentCamera
local RootJoint = RootPart.RootJoint
local Equipped = false
local Attack = false
local IntroATT = false
local targetnnn = nil
local SecondaryBread = false
local Anim = 'Idle'
local Idle = 0
local Combo = 1
local TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local Velocity = RootPart.Velocity.y
local Sine = 0
local Change = 1
local maxammo = 6 -- max ammo
local AmmoCount = 6 --ammo in gun
local AmmoUsage = 1 --boolets used
local currentammo = AmmoCount
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
local relodee = false
local UIS = game:GetService("UserInputService")    
local stance = false
local maincol = "Rust"
local skillcolorscheme = BrickColor.new(maincol).Color
local maincol2 = "Grey"
local skillcolorscheme2 = BrickColor.new(maincol2).Color
local desirefont = "SourceSansLight"

local coZ = 6
local coX = 0
local coXZ = 5
local coXC = 8
local coXV = 10
local coC = 20
local coV = 25


local cooldownZ = 0
local cooldownX = 0
local cooldownXZ = 0
local cooldownXC = 0
local cooldownXV = 0
local cooldownC = 0
local cooldownV = 0



local scrn = Instance.new('ScreenGui', Player.PlayerGui)
function makeframe(par, trans, pos, size, color)
	local frame = Instance.new('Frame', par)
	frame.BackgroundTransparency = trans
	frame.BorderSizePixel = 0
	frame.Position = pos
	frame.Size = size
	frame.BackgroundColor3 = color
	return frame
end


frameskZ = makeframe(scrn, .8, UDim2.new(.8, 0, .85, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskX = makeframe(scrn, .8, UDim2.new(.8, 0, .74, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskXZ = makeframe(scrn, .8, UDim2.new(.8, 0, .85, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskXC = makeframe(scrn, .8, UDim2.new(.8, 0, .63, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskXV = makeframe(scrn, .8, UDim2.new(.8, 0, .52, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskC = makeframe(scrn, .8, UDim2.new(.8, 0, .63, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)
frameskV = makeframe(scrn, .8, UDim2.new(.8, 0, .52, 0), UDim2.new(.14, 0, .08, 0), skillcolorscheme)

barZ = makeframe(frameskZ, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barX = makeframe(frameskX, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barXZ = makeframe(frameskXZ, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barXC = makeframe(frameskXC, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barXV = makeframe(frameskXV, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barC = makeframe(frameskC, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
barV = makeframe(frameskV, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)
text1 =  Instance.new('TextLabel', frameskZ)
text1.BackgroundTransparency = 1
text1.Size = UDim2.new(1, 0, 1, 0)
text1.Position = UDim2.new(0, 0, 0, 0)
text1.TextColor3 = Color3.new(255, 255, 255)
text1.TextStrokeTransparency = 0
text1.FontSize = Enum.FontSize.Size18
text1.Font = desirefont
text1.BorderSizePixel = 0
text1.TextScaled = true
text2 =  Instance.new('TextLabel', frameskX)
text2.BackgroundTransparency = 1
text2.Size = UDim2.new(1, 0, 1, 0)
text2.Position = UDim2.new(0, 0, 0, 0)
text2.TextColor3 = Color3.new(255, 255, 255)
text2.TextStrokeTransparency = 0
text2.FontSize = Enum.FontSize.Size18
text2.Font = desirefont
text2.BorderSizePixel = 0
text2.TextScaled = true
text3 =  Instance.new('TextLabel', frameskC)
text3.BackgroundTransparency = 1
text3.Size = UDim2.new(1, 0, 1, 0)
text3.Position = UDim2.new(0, 0, 0, 0)
text3.TextColor3 = Color3.new(255, 255, 255)
text3.TextStrokeTransparency = 0
text3.FontSize = Enum.FontSize.Size18
text3.Font = desirefont
text3.BorderSizePixel = 0
text3.TextScaled = false
text4 =  Instance.new('TextLabel', frameskV)
text4.BackgroundTransparency = 1
text4.Size = UDim2.new(1, 0, 1, 0)
text4.Position = UDim2.new(0, 0, 0, 0)
text4.TextColor3 = Color3.new(255, 255, 255)
text4.TextStrokeTransparency = 0
text4.FontSize = Enum.FontSize.Size18
text4.Font = desirefont
text4.BorderSizePixel = 0
text4.TextScaled = true

text1.Text = "[Z]\n Reposition"
text2.Text = "[X]\n Battle Stance"
text3.Text = "[C]\n Mend"
text4.Text = "[V]\n Unload"

textXZ =  Instance.new('TextLabel', frameskXZ)
textXZ.BackgroundTransparency = 1
textXZ.Size = UDim2.new(1, 0, 1, 0)
textXZ.Position = UDim2.new(0, 0, 0, 0)
textXZ.TextColor3 = Color3.new(255, 255, 255)
textXZ.TextStrokeTransparency = 0
textXZ.FontSize = Enum.FontSize.Size18
textXZ.Font = desirefont
textXZ.BorderSizePixel = 0
textXZ.TextScaled = true
textXC =  Instance.new('TextLabel', frameskXC)
textXC.BackgroundTransparency = 1
textXC.Size = UDim2.new(1, 0, 1, 0)
textXC.Position = UDim2.new(0, 0, 0, 0)
textXC.TextColor3 = Color3.new(255, 255, 255)
textXC.TextStrokeTransparency = 0
textXC.FontSize = Enum.FontSize.Size18
textXC.Font = desirefont
textXC.BorderSizePixel = 0
textXC.TextScaled = true
textXV =  Instance.new('TextLabel', frameskXV)
textXV.BackgroundTransparency = 1
textXV.Size = UDim2.new(1, 0, 1, 0)
textXV.Position = UDim2.new(0, 0, 0, 0)
textXV.TextColor3 = Color3.new(255, 255, 255)
textXV.TextStrokeTransparency = 0
textXV.FontSize = Enum.FontSize.Size18
textXV.Font = desirefont
textXV.BorderSizePixel = 0
textXV.TextScaled = false

textXZ.Text = " "
textXC.Text = " "
textXV.Text = " "



frameskXZ.BackgroundTransparency = 1
frameskXC.BackgroundTransparency = 1
frameskXV.BackgroundTransparency = 1
barXZ.BackgroundTransparency = 1
barXC.BackgroundTransparency = 1
barXV.BackgroundTransparency = 1


reloadframe = makeframe(scrn, .8, UDim2.new(.8, 0, .4, 0), UDim2.new(.14, 0, .05, 0), skillcolorscheme)
reloadbar = makeframe(reloadframe, 0, UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0), skillcolorscheme2)

relodetext =  Instance.new('TextLabel', reloadframe)
relodetext.BackgroundTransparency = 1
relodetext.Size = UDim2.new(1, 0, 1, 0)
relodetext.Position = UDim2.new(0, 0, 0, 0)
relodetext.TextColor3 = Color3.new(255, 255, 255)
relodetext.TextStrokeTransparency = 0
relodetext.FontSize = Enum.FontSize.Size24
relodetext.Font = desirefont
relodetext.BorderSizePixel = 0
relodetext.TextScaled = false
relodetext.Text = currentammo..'/'..maxammo




Humanoid.WalkSpeed = 16
Humanoid.JumpPower = 60
Humanoid.Animator.Parent = nil
Character.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
	local w = Create('Motor'){
		Parent = part0,
		Part0 = part0,
		Part1 = part1,
		C0 = c0,
		C1 = c1,
	}
	return w
end



function clerp(a, b, t)
	return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
	RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
	Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
	RW.C0 = clerp(RW.C0, table[3], speed) 
	LW.C0 = clerp(LW.C0, table[4], speed) 
	RH.C0 = clerp(RH.C0, table[5], speed) 
	LH.C0 = clerp(LH.C0, table[6], speed) 
	if bool == true then
		if resetc1 == false then
			resetc1 = true
			RootJoint.C1 = RootJoint.C1
			Torso.Neck.C1 = Torso.Neck.C1
			RW.C1 = rarmc1
			LW.C1 = larmc1
			RH.C1 = rlegc1
			LH.C1 = llegc1
		end
	end
end

ArtificialHB = Create("BindableEvent"){
	Parent = script,
	Name = "Heartbeat",
}

script:WaitForChild("Heartbeat")

frame = 1 / 35
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

local m = Create("Model"){
	Parent = Character,
	Name = "WeaponModel"
}

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

CFuncs = {	
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			if Size == Vector3.new() then
				Part.Size = Vector3.new(0.2, 0.2, 0.2)
			else
				Part.Size = Size
			end
			return Part
		end;
	};

	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	Sound = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = "rbxassetid://" .. id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local Particle = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return Particle
		end;
	};

	CreateTemplate = {

	};
}

--Shotgun Model

Handle=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","Handle",Vector3.new(0.230977222, 0.505653977, 0.244424))
HandleWeld=CFuncs.Weld.Create(m,Character["Left Arm"],Handle,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.489551544, 0.226313591, 0.00205421448, -0.0140927732, -0.988225222, -0.15235588, -0.120409302, 0.152939469, -0.980872691, 0.992624283, 0.00452187657, -0.121146858))
fHandle=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","fHandle",Vector3.new(0.230977222, 0.505653977, 0.244424))
fHandleWeld=CFuncs.Weld.Create(m,Handle,fHandle,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.489551544, 0.226313591, 0.00205421448, -0.0140927732, -0.988225222, -0.15235588, -0.120409302, 0.152939469, -0.980872691, 0.992624283, 0.00452187657, -0.121146858))
Stockbox=CFuncs.Part.Create(m,Enum.Material.Plastic,0,1,"Medium stone grey","Stockbox",Vector3.new(1.35000181, 1.25999975, 1.21000016))
StockboxWeld=CFuncs.Weld.Create(m,fHandle,Stockbox,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.624462128, -0.121447086, -0.0863800049, 0.0217821598, 0.976389289, 0.214917779, -0.119256809, 0.215971515, -0.969089329, -0.992624402, -0.00452160835, 0.121145353))
Shellmaker=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","Shellmaker",Vector3.new(0.294364125, 0.10708534, 0.0960408598))
ShellmakerWeld=CFuncs.Weld.Create(m,fHandle,Shellmaker,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.01054192, -0.63139534, -0.123239517, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
bulletmaker=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,1,"Medium stone grey","bulletmaker",Vector3.new(0.0773126334, 0.0921989903, 0.084515892))
bulletmakerWeld=CFuncs.Weld.Create(m,fHandle,bulletmaker,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-3.09943199, -0.656896591, -0.0268611908, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0763523355, 0.74047333, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.020904541, -2.09744072, -0.430066109, 1.1920929e-07, -7.4505806e-07, 1.00000012, 1, -2.98023224e-08, -1.78813934e-07, 2.98023224e-08, 1, 7.59959221e-07))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 0.678870738))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.182476982, 0.119570628, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0352497101, 0.183197975, -0.0285701752, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.183437362, 0.465309709, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0454616547, -0.0627765656, -0.0285644531, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0753918514, 0.119570628, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.129617691, 0.184212685, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0753918514, 0.371197164, 0.172873527))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0450191498, 0.00573158264, -0.0285778046, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.486446053, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.084405899, -0.0508937836, -0.0285682678, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.119090639, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.16843605, 0.182041168, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.154145062, 0.159900382, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.22857666, -0.191133022, -0.0285720825, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0753918514, 0.112847812, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00222587585, -0.22913456, -0.0285568237, 0.965925932, -0.258819044, 7.74860382e-07, 0.258818984, 0.965925813, 1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.113808274, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0371608734, -0.228617668, -0.0285663605, 0.965925932, -0.258819044, 7.74860382e-07, 0.258818984, 0.965925813, 1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.113808274, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.105619431, -0.289684772, -0.0285644531, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.0540017299, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0854762271, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.12963295, -0.276510715, -0.0285644531, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.112847812, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.316268921, -0.173998833, -0.0285587311, 0.500002027, 0.866024256, 2.11596489e-06, -0.866024196, 0.500001967, 5.96046448e-08, -1.07288361e-06, -1.86264515e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.54772383, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.113808274, 0.144061252))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.298994064, -0.173471451, -0.0285644531, 0.500002027, 0.866024256, 2.11596489e-06, -0.866024196, 0.500001967, 5.96046448e-08, -1.07288361e-06, -1.86264515e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.239147544, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0950803086, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.208971024, -0.221178055, -0.0285568237, 0.866025448, 0.499999702, -2.38418579e-07, -0.499999732, 0.866025507, 8.7916851e-07, 6.2584877e-07, -6.55651093e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.146461785, 0.196876034, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.327466965, -0.178565979, -0.0285739899, 0.707106829, 0.70710665, -2.08616257e-07, -0.70710665, 0.707106888, 1.93715096e-07, 2.08616257e-07, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0622474775, 0.246817216, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.409929276, -0.000652313232, -0.0285587311, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.987445176, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.256908506, 0.250178576, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0943717957, -0.513149977, -0.0285682678, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.81730479, 0.0997623056, 0.0997624695))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.471679688, -0.463490486, -0.0529289246, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.504212916, 0.0997623056, 0.0997624695))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.374668121, -0.534323692, -0.0529251099, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0744314641, 0.272275418, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.242843628, -0.510847807, -0.0285606384, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0744314641, 1.11887383, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.454176903, -0.655622482, -0.0285568237, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.296285421, 0.194002435))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.280355453, 0.50044775, -0.0285720825, -0.965925932, -0.258818686, 0, 0.258818686, -0.965925872, 9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.200575769, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.283319652, 0.249225661, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.314329147, -0.559855938, -0.0285587311, 0.995653629, 0.0931321532, 2.32458115e-06, -0.0931321681, 0.995653749, 7.5250864e-07, -2.29477882e-06, -9.83476639e-07, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.133496568, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.349269867, -0.24421072, -0.0285644531, 0.866025448, 0.499999702, -2.38418579e-07, -0.499999732, 0.866025507, 8.7916851e-07, 6.2584877e-07, -6.55651093e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.192081362, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.293024063, -0.294204473, -0.0285720825, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.356941223, 0.0116996765, -0.0285701752, 0.707106829, 0.70710665, -2.08616257e-07, -0.70710665, 0.707106888, 1.93715096e-07, 2.08616257e-07, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.28327179, 0.268438339, -0.0285663605, 0.258818686, 0.965925872, 1.57952309e-06, -0.965925932, 0.258818716, -5.66244125e-07, -1.07288361e-06, -1.37090683e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.192222595, 0.423189163, -0.0285587311, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0979615301, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0651254654, 0.542451859, -0.0285663605, -0.500002563, 0.866023898, -1.69873238e-06, -0.866023898, -0.500002503, -5.36441803e-07, -1.37090683e-06, 1.1920929e-06, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.349715233, 0.488988876, -0.0285606384, -0.866025507, 0.499999702, 1.78813934e-07, -0.499999762, -0.866025507, -8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 0.62486881, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.468893051, 0.414321899, -0.0285682678, -0.965925932, 0.258819044, -7.74860382e-07, -0.258818984, -0.965925813, -1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 0.62486881, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.166150421, 0.172873542))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.564922333, 0.374081612, -0.0285587311, -0.999999881, 1.49011612e-08, 2.98023224e-08, 1.49011612e-08, -0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.717440903, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.446313858, 0.0350942612, -0.0285625458, 0.707106829, 0.70710665, -2.08616257e-07, -0.70710665, 0.707106888, 1.93715096e-07, 2.08616257e-07, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.393159211, 0.862414598, 0.327713668))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.391670227, -0.236137867, -0.0285568237, 0.965925932, 0.258818686, 0, -0.258818686, 0.965925872, -9.9465251e-07, -3.27825546e-07, 9.53674316e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.393159211, 0.862414598, 0.327713668))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.0622474775, 0.10526102, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.208478928, -0.470833778, -0.0285587311, 0.965925932, -0.258819044, 7.74860382e-07, 0.258818984, 0.965925813, 1.57952309e-06, -1.22189522e-06, -1.32620335e-06, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.393159211, 1, 0.327713668))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.853799939, 0.249225661, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.811216354, -0.600500107, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(1.86222541, 0.142131716, 0.142131925))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.88418007, -0.649424553, -0.0289115906, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.919107974, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.843883514, -0.728718758, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.11571791, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.919107974, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.843877792, -0.746054649, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.11571791, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.919107974, 0.0622474775, 0.152704939))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.843877792, -0.734283447, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.401151627, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.391284943, -0.759021759, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.223722026, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.433917999, -0.758702278, -0.0285682678, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.479598999, -0.758406639, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.519172668, -0.759467125, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.564876556, -0.759284019, -0.0285587311, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.74656105, -0.757936478, -0.0285720825, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.700839996, -0.758119583, -0.0285701752, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.615558624, -0.759425163, -0.0285568237, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.661268234, -0.759130478, -0.0285720825, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.790523529, -0.757699966, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.10312653, -0.756930351, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.05741501, -0.757115364, -0.0285663605, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.836206436, -0.757403374, -0.0285663605, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.875770569, -0.75846386, -0.0285644531, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.972162247, -0.758422852, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.01785469, -0.758123398, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.921495438, -0.758282661, -0.0285682678, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.23103142, -0.755340576, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.14575386, -0.756649017, -0.0285682678, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.26502037, -0.755158424, -0.0285644531, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.19145584, -0.756355286, -0.0285701752, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.300866187, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.29557228, -0.757285118, -0.0285549164, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.223722026, 0.3008641, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.608816147, 0.439056396, -0.133686066, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.608924866, 0.559501648, -0.141916275, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.609196663, 0.676843643, -0.133676529, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.695789337, 0.558382034, -0.141908646, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.163862169, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.612273216, 0.558391571, -0.141902924, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164241493, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.612018585, 0.438463211, -0.137260437, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.695731163, 0.438491821, -0.137289047, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164620817, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.611670494, 0.676483154, -0.133932114, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.695570946, 0.676485062, -0.133947372, -5.96046448e-08, 0.999999881, -1.49011612e-08, -1, -2.98023224e-08, 2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.427860439, 0.156066164, 0.156066418))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.02061081, -0.622268677, -0.0845718384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0773126855, 0.309250325, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.805314064, -1.1217041, -0.0285644531, 0.866025507, -0.499999702, -1.78813934e-07, 0.499999762, 0.866025507, 8.04662704e-07, -3.27825546e-07, -8.19563866e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.261230201, 0.185357824, 0.158467412))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.552032471, -1.27363014, -0.0285682678, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.983454704, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.876041412, -0.700925827, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.655727208, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.983454704, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.822029114, -0.663985252, -0.0285663605, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.655727208, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.983454704, 0.0622474775, 0.184398398))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.787355423, -0.642092705, -0.0285625458, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.655727208, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(0.228096232, 1.19426513, 0.0672286227))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.572554588, -1.87078285, -0.0285701752, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Earth blue","Part",Vector3.new(1.1721741, 0.0672284812, 0.0672286004))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.94434929, -0.457939148, -0.0285606384, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0960405394, 1.18610215, 0.119090654))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.60875988, -1.8666954, -0.0285606384, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0960405394, 0.837954462, 0.119090654))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.593738556, -1.92202759, -0.0285644531, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.217051655, 0.74047333, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.51939106, -2.09714317, 0.0765304565, 3.62284482e-07, -0.965925813, -0.258818895, 0.99999994, 3.27825546e-07, 8.94069672e-08, 0, -0.258818865, 0.965925932))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 0.948875785))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.217051655, 0.74047333, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.508298635, -2.09652901, -0.119865417, -1.25169754e-06, -0.965925932, 0.258818418, 1, -1.11758709e-06, 6.85453415e-07, -4.76837158e-07, 0.258818418, 0.965926051))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 0.948875785))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(1.51359856, 0.108333342, 0.108333521))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.70987511, -0.587060928, -0.0289077759, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.116297506, 0.126513839, 0.126514062))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.51787376, -0.492711067, -0.0289020538, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.281487226, 0.0818847269, 0.0818848684))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.59470558, -0.490480423, -0.0289134979, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.128214061, 0.210328475, 0.119090654))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.553534508, -2.6796627, -0.0285625458, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.133873656, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0289173126, -0.551986694, -2.5983963, -1.1920929e-07, 7.4505806e-07, -1.00000012, -5.96046448e-08, 1, 7.4505806e-07, 1, 7.4505806e-08, -1.49011612e-07))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.644316077, 0.644317031))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.133873656, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0289115906, -0.555045128, -2.70437813, -1.1920929e-07, 7.4505806e-07, -1.00000012, -5.96046448e-08, 1, 7.4505806e-07, 1, 7.4505806e-08, -1.49011612e-07))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.644316077, 0.644317031))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.133873656, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0289211273, -0.556861877, -2.75073242, -1.1920929e-07, 7.4505806e-07, -1.00000012, -5.96046448e-08, 1, 7.4505806e-07, 1, 7.4505806e-08, -1.49011612e-07))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.644316077, 0.644317031))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.325578123, 0.120581053, 0.120581254))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.89797592, -0.653188705, -0.0289173126, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0812890455, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.78231049, 0.759439468, 0.0285625458, -0.866025448, -0.499999702, 2.38418579e-07, -0.499999732, 0.866025507, 8.7916851e-07, -6.2584877e-07, 6.55651093e-07, -1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.61715281, 1, 0.482340217))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.0622474775, 0.0745662153, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.76589775, -0.741744041, 0.0285568237, -0.999999881, 1.49011612e-08, 2.98023224e-08, -1.49011612e-08, 0.999999881, 0, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.61715281, 1, 0.482340217))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Lily white","Part",Vector3.new(0.0622474775, 0.0622474775, 0.0622474775))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.76446533, -0.764004707, -0.028553009, 0.999999881, -1.49011612e-08, -2.98023224e-08, -1.49011612e-08, 0.999999881, 0, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.617152989, 0.408864677, 0.339435399))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(1.09150016, 0.159420162, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.903377533, -0.564111233, -0.0285682678, 0.999867797, 0.0162549913, 7.74860382e-07, -0.0162550062, 0.999867916, 8.7916851e-07, -7.15255737e-07, -8.94069672e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.799536645, 0.156538948, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.757575989, -0.625374794, -0.0285549164, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.15222393, 0.0696221218, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.413620949, -0.488759995, -0.0285682678, 0.0912402272, 0.995828867, 1.47521496e-06, -0.995828867, 0.0912402719, 5.66244125e-07, 3.27825546e-07, -1.5348196e-06, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.523900926, 0.0622474775, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.716959, -0.339764595, -0.0285701752, 0.995828986, -0.0912401676, -5.06639481e-07, 0.0912401378, 0.995828927, 7.15255737e-07, 3.27825546e-07, -7.89761543e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.523900926, 0.0622474775, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.607765198, -0.601490259, -0.0285663605, 0.908034444, 0.418895423, -5.66244125e-07, -0.418895513, 0.908034563, -2.60770321e-07, 3.57627869e-07, 4.61935997e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.873703957, 0.431451797, -0.0285663605, 0.639640331, -0.768674433, -4.61935997e-07, 0.768674374, 0.639640331, 5.66244125e-07, -1.78813934e-07, -7.30156898e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.909405231, 0.553689957, -0.0285549164, 0.639640331, -0.768674433, -4.61935997e-07, 0.768674374, 0.639640331, 5.66244125e-07, -1.78813934e-07, -7.30156898e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.927492619, 0.657333374, -0.0285587311, 0.639640331, -0.768674433, -4.61935997e-07, 0.768674374, 0.639640331, 5.66244125e-07, -1.78813934e-07, -7.30156898e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.294364095, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.11587906, -0.356192112, -0.028547287, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.495088696, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.322112083, -1.28462601, -0.0285587311, 0.345870823, 0.938282073, -7.4505806e-07, -0.938282132, 0.345870882, 1.07288361e-06, 1.25169754e-06, 3.27825546e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.257387787, 0.159420162, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.3693037, 0.223978043, -0.0285739899, 0.874038696, -0.485856384, 3.57627869e-07, 0.485856295, 0.874038756, 3.57627869e-07, -5.66244125e-07, -1.78813934e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.706377685, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.269904137, -1.45611191, -0.0285568237, -0.000838190317, 0.999999642, 7.74860382e-07, -0.999999642, -0.000838235021, 2.38418579e-07, 1.1920929e-07, -7.89761543e-07, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.871611476, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.107085116, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.4155426, 0.194704056, -0.028553009, 0.995828986, -0.0912401676, -5.06639481e-07, 0.0912401378, 0.995828927, 7.15255737e-07, 3.27825546e-07, -7.89761543e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.964184403, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.181996748, 0.0622474775, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.30640793, -0.446501732, -0.0285644531, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.964184403, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.196883038, 0.188232288, 0.0864367038))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.27062798, -0.612149715, -0.0285511017, 0.985511184, 0.169610262, -6.2584877e-07, -0.169610262, 0.985511243, 3.87430191e-07, 6.85453415e-07, -2.68220901e-07, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.116208896, 0.737585008, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.52254105, -0.293103695, -0.0285682678, 0.999867797, 0.0162549913, 7.74860382e-07, -0.0162550062, 0.999867916, 8.7916851e-07, -7.15255737e-07, -8.94069672e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.116208896, 0.400002003, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.57855415, -0.319172859, -0.0285606384, 0.997218013, -0.0745394826, 8.94069672e-07, 0.0745394677, 0.997218013, -1.1920929e-07, -9.83476639e-07, 1.49011612e-07, 1.00000024))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.112847485, 0.34814018, 0.175754741))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.5480423, -0.172746658, -0.0285549164, 0.997943401, 0.0641013086, -2.98023224e-08, -0.0641013458, 0.997943401, 8.49366188e-07, 0, -8.64267349e-07, 1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.696815491, -0.553442001, -0.102174759, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.696748734, -0.673355103, -0.0975265503, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Br. yellowish orange","Part",Vector3.new(0.0622474775, 0.118231699, 0.118231893))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.696596146, -0.435348511, -0.094203949, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
CFuncs.Mesh.Create("SpecialMesh",Part,Enum.MeshType.Cylinder,"",Vector3.new(0, 0, 0),Vector3.new(0.170620233, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.163862169, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.613293648, -0.553445816, -0.102149963, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164241493, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.613039017, -0.673345566, -0.0975208282, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.609944344, -0.552326202, -0.102172852, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.610219002, -0.434988022, -0.0939350128, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Black","Part",Vector3.new(0.148310468, 0.123276234, 0.12327645))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.609839439, -0.672796249, -0.0939388275, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Cocoa","Part",Vector3.new(0.164620817, 0.112265885, 0.112266079))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.612697601, -0.435344696, -0.0941925049, -5.96046448e-08, 0.999999881, -1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, 2.98023224e-08, 0, -1.00000012))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0622474775, 0.330372602, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.190822601, -0.254428864, -0.0285701752, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.648010492, 1, 1))
Part=CFuncs.Part.Create(m,Enum.Material.SmoothPlastic,0,0,"Burlap","Part",Vector3.new(0.0622474775, 0.216564372, 0.16326943))
PartWeld=CFuncs.Weld.Create(m,fHandle,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.217577934, -0.165513992, -0.0285587311, 5.96046448e-08, -0.999999881, 1.49011612e-08, 1, 2.98023224e-08, -2.98023224e-08, -2.98023224e-08, 0, 1.00000012))
CFuncs.Mesh.Create("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.648010492, 1, 1))

local lp = game:GetService("Players").LocalPlayer
local cnnn = lp.Character
local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end
local hatnnn = gp(gp(gp(cnnn, "Red Sci-Fi Scattergun", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
hatnnn.Parent = fHandle
hatnnn.Position = Vector3.new(1, 0.32, 0)
hatnnn.Rotation = Vector3.new(-180, -2.03555e-13, 120)



function RayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

FindNearestTorso = function(pos)
	local list = (game.Workspace:children())
	local torso = nil
	local dist = 1000
	local temp, human, temp2 = nil, nil, nil
	for x = 1, #list do
		temp2 = list[x]
		if temp2.className == "Model" and temp2.Name ~= Character.Name and temp2 ~= Character.Model then
			temp = temp2:findFirstChild("Torso")
			human = temp2:findFirstChild("Humanoid")
			if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
				local dohit = true
				if dohit == true then
					torso = temp
					dist = (temp.Position - pos).magnitude
				end
			end
		end
	end
	return torso, dist
end
spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do

		if Attack == true and IntroATT == false and AmmoCount > 0 and relodee == false and SecondaryBread == false and targetnnn == nil then

			if lp:GetMouse().Target ~= nil then
				local targetmouse = lp:GetMouse().Target.Parent:FindFirstChildOfClass("Humanoid")

				if targetmouse then

					GlobalFunctions.fling(lp:GetMouse().Target.Parent.Head.Position, 0.03)

				else 

					GlobalFunctions.fling(lp:GetMouse().Hit.p, 0.001)

				end


			end

		end
		if Attack == true and SecondaryBread == true and targetnnn then
			print("A")
			GlobalFunctions.fling(targetnnn, 0.3)
			wait(0.4)
			targetnnn = nil
		end
	end
end)


function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChild("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent ~= Character.Model and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
		targetnnn = hit.Parent
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			--h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 5)).p + Vector3.new(math.random(-5,5), math.random(3,5),0)), -Damage, 1, BrickColor.new("White").Color)
		else
			--h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 5)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, BrickColor.new("Really black").Color)
		end
		
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cf = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		if Delay > 0 then
			local debounce = Create("BoolValue"){
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true,
			}
			game:GetService("Debris"):AddItem(debounce, Delay)
		end

		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end

function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "SourceSansLight",
		TextColor3 = Color,
		TextScaled = true,
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end

function MagnitudeDamage(Part, Magnitude, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= Magnitude and c.Name ~= Player.Name then 
					Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, 0, "rbxassetid://" .. HitSound, HitPitch)
				end
			end
		end
	end
end

EffectModel = Create("Model"){
	Parent = Character,
	Name = "EffectModel",
}

Effects = {
	Block = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, Part)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 3 then
				table.insert(Effects, {
					prt,
					"Block3",
					delay,
					x3,
					y3,
					z3,
					msh,
					Part
				})
			elseif Type == 4 then
				table.insert(Effects, {
					prt,
					"Block2Fire",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		end
	};

	Sphere = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, parent)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			if parent == nil then
				prt.Parent = workspace
			else
				prt.Parent = parent
			end
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Blood = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Blood",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Blast = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Part)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "1323306", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Block4",
				delay,
				x3,
				y3,
				z3,
				msh,
				Part
			})
		end
	};

	Ring = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Cylinder = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Head = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Wave = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	};

	Break = {
		Create = function(brickcolor, cframe, x1, y1, z1)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			game:GetService("Debris"):AddItem(prt, 10)
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local num = math.random(10, 50) / 1000
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end
	};

	Elec = {
		Create = function(brickcolor, cff, x, y, z)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Part", Vector3.new(1, 1, 1))
			prt.Anchored = true
			prt.CFrame = cff * CFrame.new(math.random(-x * 100, x * 100) / 100, math.random(-y * 100, y * 100) / 100, math.random(-z * 100, z * 100) / 100)
			prt.CFrame = CFrame.new(prt.Position)
			game:GetService("Debris"):AddItem(prt, 10)
			xval = math.random() / 9
			yval = math.random() / 9
			zval = math.random() / 9
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
			eul1 = math.random(-50, 50)
			eul2 = math.random(-50, 50)
			eul3 = math.random(-50, 50)
			euld = CFrame.fromEulerAnglesXYZ(eul1, eul2, eul3)
			euld2 = CFrame.fromEulerAnglesXYZ(-eul1, -eul2, -eul3)
			table.insert(Effects, {
				prt,
				"Elec",
				.05,
				x,
				y,
				z,
				xval,
				yval,
				zval,
				msh,
				euld,
				euld2
			})
		end
	};

	Elec2 = {
		Create = function(brickcolor, cff, x, y, z)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Part", Vector3.new(1, 1, 1))
			prt.Anchored = true
			prt.CFrame = cff * CFrame.new(math.random(-x * 100, x * 100) / 100, math.random(-y * 100, y * 100) / 100, math.random(-z * 100, z * 100) / 100)
			prt.CFrame = CFrame.new(prt.Position)
			game:GetService("Debris"):AddItem(prt, 10)
			xval = math.random() / 7
			yval = math.random() / 7
			zval = math.random() / 7
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
			eul1 = math.random(-50, 50)
			eul2 = math.random(-50, 50)
			eul3 = math.random(-50, 50)
			euld = CFrame.fromEulerAnglesXYZ(eul1, eul2, eul3)
			euld2 = CFrame.fromEulerAnglesXYZ(-eul1, -eul2, -eul3)
			table.insert(Effects, {
				prt,
				"Elec",
				.1,
				x,
				y,
				z,
				xval,
				yval,
				zval,
				msh,
				euld,
				euld2
			})
		end
	};

	Clone = {
		Create = function() 
			for _, v in pairs(Torso.Parent:children()) do
				if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
					local c = CFuncs.Part.Create(EffectModel, "Neon", 0, .5, BrickColor.new("Bright blue"), "Effect", v.Size)
					c.Anchored = true
					c.CFrame = v.CFrame
					game:GetService("Debris"):AddItem(c, 5)
					local cmsh = nil
					if v.Name == "Head" then
						cmsh = CFuncs.Mesh.Create("SpecialMesh", c, "Head", "", Vector3.new(0, 0, 0), v.Mesh.Scale)
					else
						cmsh = CFuncs.Mesh.Create("BlockMesh", c, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
					end
					table.insert(Effects, {
						c,
						"Cylinder",
						0.05,
						0.1,
						0.1,
						0.1,
						cmsh
					})
				end
			end
		end
	};

	EffectTemplate = {

	};
}


Laser = function(brickcolor, reflect, cframe, x1, y1, z1, x3, y3, z3, delay)

	prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", reflect, 0, brickcolor, "Effect", Vector3.new(.1, 0.5, 0.1))
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 1)
	coroutine.resume(coroutine.create(function(Part, Mesh)

		for i = 0, 1, delay do
			swait()
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
		end
		Part.Parent = nil
	end
	), prt, msh)
end

wshoot = function(mouse, aoe , partt, SpreadAmount, multiply)

	local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
	local MainPos = partt.Position
	local MainPos2 = mouse.Hit.p + SpreadVectors
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	local speed = 1000
	local num = .5
	coroutine.resume(coroutine.create(function()

		repeat
			swait()
			local hit, pos = RayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
			local mag = (MainPos - pos).magnitude                                                            
			Laser(BrickColor.new("Gold"), 0, CFrame.new((MainPos + pos)/2, pos) * CFrame.Angles(1.57, 0, 0), 5, mag * (speed / (speed / 2)), .2, .2, 0, .2, 0.1)
			MainPos = MainPos + MouseLook.lookVector * speed
			num = num - 1
			MouseLook = MouseLook * CFrame.Angles(math.rad(-1), 0, 0)
			if hit ~= nil then
				if hit.Name == "Torso" or hit.Name == "Right Leg" or hit.Name == "Left Leg" or hit.Name == "Right Arm" or hit.Name == "Left Arm" then
					num = 0
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					local hitsound = math.random(1,3)
					if hitsound == 1 then
						CFuncs.Sound.Create("898398743", refpart, .5, 1)
					elseif hitsound == 2 then
						CFuncs.Sound.Create("898398730", refpart, .5, 1)	
					elseif hitsound == 3 then
						CFuncs.Sound.Create("898398706", refpart, .5, 1)
					end
					local smonk = Instance.new("ParticleEmitter",refpart)
					smonk.LightEmission = .1
					smonk.Size = NumberSequence.new(0.2)
					smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
					aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1)})
					bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
					smonk.Transparency = bbb
					smonk.Size = aaa
					smonk.ZOffset = 0
					smonk.Acceleration = Vector3.new(0, -5, 0)
					smonk.LockedToPart = false
					smonk.EmissionDirection = "Back"
					smonk.Lifetime = NumberRange.new(.1, .5)
					smonk.Rate = 50
					smonk.Rotation = NumberRange.new(-100, 100)
					smonk.RotSpeed = NumberRange.new(-100, 100)
					smonk.Speed = NumberRange.new(4)
					smonk.VelocitySpread = 50
					smonk.Enabled=true
					game:GetService("Debris"):AddItem(smonk, .3)
				elseif hit.Name == "Head" then
					num = 0
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					game:GetService("Debris"):AddItem(refpart, 2)
					local smonk = Instance.new("ParticleEmitter",refpart)
					smonk.LightEmission = .1
					smonk.Size = NumberSequence.new(0.2)
					smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
					aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1.5)})
					bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
					smonk.Transparency = bbb
					smonk.Size = aaa
					smonk.ZOffset = 0
					smonk.Acceleration = Vector3.new(0, -5, 0)
					smonk.LockedToPart = false
					smonk.EmissionDirection = "Back"
					smonk.Lifetime = NumberRange.new(.1, .5)
					smonk.Rate = 50
					smonk.Rotation = NumberRange.new(-100, 100)
					smonk.RotSpeed = NumberRange.new(-100, 100)
					smonk.Speed = NumberRange.new(4)
					smonk.VelocitySpread = 100
					smonk.Enabled=true
					game:GetService("Debris"):AddItem(smonk, .3)
				else
					num = 0
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					CFuncs.Sound.Create("342190504", prt, 1, 1)
					game:GetService("Debris"):AddItem(refpart, 0)		
				end
			end
			do
				if num <= 0 then
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 1, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					if hit ~= nil then
						--MagnitudeDamage(refpart, 5, 2, 2, .01, "Normal", " ", 1)			
					end
					game:GetService("Debris"):AddItem(refpart, 1)
				end
			end
		until num <= 0
	end
	))
end



shoot = function(mouse, aoe , partt, SpreadAmount, multiply)

	local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
	local MainPos = partt.Position
	local MainPos2 = mouse.Hit.p + SpreadVectors
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	local speed = 1000
	local num = .5
	coroutine.resume(coroutine.create(function()

		repeat
			swait()
			local hit, pos = RayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
			local mag = (MainPos - pos).magnitude                                                            
			Laser(BrickColor.new("Gold"), 0, CFrame.new((MainPos + pos)/2, pos) * CFrame.Angles(1.57, 0, 0), 5, mag * (speed / (speed / 2)), .2, .2, 0, .2, 0.1)
			MainPos = MainPos + MouseLook.lookVector * speed
			num = num - 1
			MouseLook = MouseLook * CFrame.Angles(math.rad(-1), 0, 0)
			if hit ~= nil then
				if hit.Name == "Torso" or hit.Name == "Right Leg" or hit.Name == "Left Leg" or hit.Name == "Right Arm" or hit.Name == "Left Arm" then
					num = 0
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					local hitsound = math.random(1,3)
					if hitsound == 1 then
						CFuncs.Sound.Create("898398743", refpart, .5, 1)
					elseif hitsound == 2 then
						CFuncs.Sound.Create("898398730", refpart, .5, 1)	
					elseif hitsound == 3 then
						CFuncs.Sound.Create("898398706", refpart, .5, 1)
					end
					local smonk = Instance.new("ParticleEmitter",refpart)
					smonk.LightEmission = .1
					smonk.Size = NumberSequence.new(0.2)
					smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
					aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1)})
					bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
					smonk.Transparency = bbb
					smonk.Size = aaa
					smonk.ZOffset = 0
					smonk.Acceleration = Vector3.new(0, -5, 0)
					smonk.LockedToPart = false
					smonk.EmissionDirection = "Back"
					smonk.Lifetime = NumberRange.new(.1, .5)
					smonk.Rate = 50
					smonk.Rotation = NumberRange.new(-100, 100)
					smonk.RotSpeed = NumberRange.new(-100, 100)
					smonk.Speed = NumberRange.new(4)
					smonk.VelocitySpread = 50
					smonk.Enabled=true
					game:GetService("Debris"):AddItem(smonk, .3)
				elseif hit.Name == "Head" then
					num = 0
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					game:GetService("Debris"):AddItem(refpart, 2)
					local smonk = Instance.new("ParticleEmitter",refpart)
					smonk.LightEmission = .1
					smonk.Size = NumberSequence.new(0.2)
					smonk.Texture = "http://www.roblox.com/asset/?ID=256293532"
					aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, .2),NumberSequenceKeypoint.new(1, 1.5)})
					bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, .3),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
					smonk.Transparency = bbb
					smonk.Size = aaa
					smonk.ZOffset = 0
					smonk.Acceleration = Vector3.new(0, -5, 0)
					smonk.LockedToPart = false
					smonk.EmissionDirection = "Back"
					smonk.Lifetime = NumberRange.new(.1, .5)
					smonk.Rate = 50
					smonk.Rotation = NumberRange.new(-100, 100)
					smonk.RotSpeed = NumberRange.new(-100, 100)
					smonk.Speed = NumberRange.new(4)
					smonk.VelocitySpread = 100
					smonk.Enabled=true
					game:GetService("Debris"):AddItem(smonk, .3)
				else
					num = 0
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					CFuncs.Sound.Create("342190504", prt, 1, 1)
					game:GetService("Debris"):AddItem(refpart, 0)		
				end
			end
			do
				if num <= 0 then
					local refpart = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 1, 1, "Really black", "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					if hit ~= nil then
						--MagnitudeDamage(refpart, 3, 2, 5, 0, "Normal", " ", 1)			
					end
					game:GetService("Debris"):AddItem(refpart, 1)
				end
			end
		until num <= 0
	end
	))
end





function fire()
	Attack = true	
	Humanoid.WalkSpeed = 8
	Humanoid.JumpPower = 0
	Humanoid.AutoRotate = false
	local bodygyro = Instance.new("BodyGyro",RootPart)
	bodygyro.MaxTorque = Vector3.new(50000,50000,50000)
	bodygyro.P = 8000
	CFuncs.Sound.Create("873073703", Handle, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
			CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end

	AmmoCount = AmmoCount - AmmoUsage
	for i = 0, 9, 1 do
		shoot(Mouse, 3 , bulletmaker, .15 + (Torso.Position - Mouse.Hit.p).magnitude/math.random(17,20) , 0)
	end
	Torso.Velocity=RootPart.CFrame.lookVector*-20
	Effects.Block.Create(BrickColor.new("Flame reddish orange"), bulletmaker.CFrame, .5, .5, .5, .5, .5, .5, .1, 1)
	CFuncs.Sound.Create("1132379030", Handle, 1, 1)
	bodygyro:Destroy()
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.588929892, -1.11013651e-06, -0.0153462738, 0.466293842, -0.234925136, 0.85287708, 0.171010062, 0.969846427, 0.17364794, -0.867954016, 0.0648796037, 0.492407978) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.160780251, 1.50000441, 0.0393266231, 0.488946259, -0.0697783977, -0.869518578, -0.125678584, 0.980760813, -0.149376884, 0.863213003, 0.182317138, 0.470769644) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.67061281, 0.704267323, -0.691583157, 0.423231184, -0.709484339, -0.563477933, -0.879032731, -0.472217411, -0.065669328, -0.219492719, 0.52310884, -0.823517084) * CFrame.new(-.2, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.0540117994, 0.73741293, -0.982708097, 0.0631480217, -0.978079677, 0.198425397, -0.319141895, -0.208172753, -0.924560905, 0.945600986, -0.00494170189, -0.325291872) * CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.378202379, -1.77786493, -0.298971295, 0.837791204, 0.33804059, -0.428759336, -0.235888705, 0.932314754, 0.274127543, 0.492404819, -0.128522187, 0.860825062) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.773099661, -1.83571112, -0.503498793, 0.964610457, 0.171010062, -0.200704694, -0.200705469, 0.969846427, -0.138258308, 0.171009183, 0.17364794, 0.969846606) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Humanoid.AutoRotate = true
	CFuncs.Sound.Create("131072992", Handle, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.51687121, 0.252128333, -0.305914342, -0.106392592, -0.288472205, -0.951559067, -0.959828019, 0.279683411, 0.0225289911, 0.259636283, 0.915729821, -0.306639969) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.342295825, 0.26239565, -1.10844982, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	local shell = CFuncs.Part.Create(EffectModel, "SmoothPlastic", .1, 0, "Bright red", "Effect", Vector3.new(.5,.8,.5))
	local shllmsh = CFuncs.Mesh.Create("CylinderMesh", shell, "", "", Vector3.new(0, 0, 0), Vector3.new(.3, .4, .3))
	shell.Anchored = false
	shell.Position = Shellmaker.Position
	shell.CanCollide = true
	shell.Velocity=RootPart.CFrame.rightVector*20
	game:GetService("Debris"):AddItem(shell, 3)
	local shellsound = math.random(1,2)
	if shellsound == 1 then
		CFuncs.Sound.Create("1132378823", shell, .5, 1)
	elseif shellsound  == 2 then
		CFuncs.Sound.Create("1132378791", shell, .5, 1)
	end
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.64014888, 0.224238992, -0.403565288, 0.0212229788, -0.603865683, -0.796803713, -0.989261985, 0.102589145, -0.104097351, 0.144604191, 0.790456831, -0.595203996) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.522896647, 0.315473199, -1.06896186, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	for i = 0, .2, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0), 
			CFrame.new(-0.00987245888, 1.54137087, -0.232474566, 0.983905733, 0.0593912564, -0.168529823, 0.000888057693, 0.941511214, 0.336980611, 0.17868638, -0.331706822, 0.926305413) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.05 * math.cos(Sine/25), 0, 0), 
			CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Attack = false
end


function dryfire()
	Attack = true	
	Humanoid.WalkSpeed = 8
	Humanoid.JumpPower = 0
	Humanoid.AutoRotate = false
	local bodygyro = Instance.new("BodyGyro",RootPart)
	bodygyro.MaxTorque = Vector3.new(50000,50000,50000)
	bodygyro.P = 8000
	CFuncs.Sound.Create("873073703", Handle, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
			CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end
	CFuncs.Sound.Create("132464034", Handle, 1, 1)
	for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
			CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
	end
	bodygyro:Destroy()
	Humanoid.AutoRotate = true
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Attack = false
end







function relode()
	relodee = true
	Attack = true
	
	Humanoid.WalkSpeed = 5
	CFuncs.Sound.Create("1132378728", Handle, .5, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0),  
			CFrame.new(-0.100350231, 1.4967103, -0.061891377, 0.64132297, 0.208182856, -0.738488197, -0.0762534291, 0.975015342, 0.208640277, 0.763472557, -0.0774935335, 0.641174316) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
			CFrame.new(1.07593381, -0.046435535, 0.399106979, -0.603867352, -0.0212483108, -0.796801686, 0.102590129, 0.989258587, -0.104129925, 0.790455341, -0.144624621, -0.595201015) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.52289784, 0.315474898, -1.0689652, 0.117606997, -0.938983917, -0.323230416, -0.303329468, 0.275966793, -0.912049174, 0.945600212, 0.205308646, -0.252365857) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(5), math.rad(90)), 0.3)
	end	
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0),  
			CFrame.new(-0.100350231, 1.4967103, -0.061891377, 0.64132297, 0.208182856, -0.738488197, -0.0762534291, 0.975015342, 0.208640277, 0.763472557, -0.0774935335, 0.641174316) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.28816545, 0.371927321, -0.785959482, 0.833941579, -0.0145216882, -0.551661849, -0.529568017, -0.302267253, -0.79258585, -0.155239552, 0.953112662, -0.25976342) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.522895455, 0.31547451, -1.06896842, -0.0472328961, -0.986910462, -0.154198274, -0.250799775, 0.161142588, -0.954532683, 0.966886103, -0.0064124465, -0.255128086) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(5), math.rad(90)), 0.3)
	end
	AmmoCount = AmmoCount + AmmoUsage
	print(AmmoCount)
	CFuncs.Sound.Create("1001714844", Handle, 1, 1)
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	
	Attack = false
	relodee = false
end


function hop()
	SecondaryBread = true
	Attack = true
	CFuncs.Sound.Create("158149887", Torso, 1, 1)
	Humanoid.Jump = true
	Humanoid.JumpPower = 60
	for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(-0, -1.01481628, -8.04662704e-07, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0, 1.45637476, -0.213752031, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.80887365, 0.563777864, 0.393151999, 0.642787039, -0.766044915, -1.2109125e-06, 0.754407167, 0.633021533, 0.173648313, -0.133021653, -0.111619815, 0.984807789) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-1.67181289, 0.594474256, -0.03263852, 0.499999285, 0.866025865, 1.98491279e-07, -0.750001073, 0.433012605, -0.499998599, -0.43301177, 0.249998808, 0.866026282) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.5, -1.80666828, -0.689023316, 1, 0, 0, 0, 0.984807849, 0.173648134, 0, -0.173648164, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.5, -1.42673647, -0.144118369, 1, 0, 0, 0, 0.766044736, 0.642787457, 0, -0.642787457, 0.766044736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Torso.Velocity=RootPart.CFrame.lookVector*100
	for i = 0, .9, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.708232701, 0.127894983, 0.246774122, 0.76604414, -0.111618884, 0.633022666, 0, 0.984807849, 0.173648044, -0.642788053, -0.13302207, 0.754406214) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.0324593484, 1.43977821, -0.119624585, 0.995960355, -0.0868238062, -0.0229113102, 0.0894833133, 0.938373625, 0.333838284, -0.00748568773, -0.334539831, 0.942351937) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.69410944, 0.329396009, -0.667013586, 0.977326989, -0.133022755, 0.164733544, 0.196574897, 0.280932605, -0.939380229, 0.0786799788, 0.95046401, 0.30071193) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-1.50714529, 0.0157378055, -0.431941032, 0.884520769, 0.235685706, -0.402585804, -0.362369925, 0.890611291, -0.274772465, 0.29378742, 0.388926923, 0.873169541) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.618915975, -1.85825384, -0.515439391, 0.98480773, 0.173648864, -1.81794167e-06, -0.17101045, 0.969846725, 0.173646331, 0.0301553011, -0.171007901, 0.984808087) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.523646474, -1.39458823, -0.171092927, 0.939692676, 0.342020273, 3.57627869e-07, -0.262003183, 0.719847083, 0.642786682, 0.219845772, -0.604022026, 0.766045213) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Torso.Velocity=RootPart.CFrame.upVector*0
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Attack = false	
	SecondaryBread = false
end



function pump()
	relodee = true
	Attack = true
	
	Humanoid.WalkSpeed = 8
	CFuncs.Sound.Create("131072992", Handle, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.51687121, 0.252128333, -0.305914342, -0.106392592, -0.288472205, -0.951559067, -0.959828019, 0.279683411, 0.0225289911, 0.259636283, 0.915729821, -0.306639969) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.342295825, 0.26239565, -1.10844982, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-5), math.rad(90)), 0.3)
	end
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.588927984, -1.34110451e-07, -0.0153470635, 0.500004232, -0.15038535, 0.852876961, 0, 0.98480773, 0.173648342, -0.86603415, -0.0868248865, 0.492408037) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.0697273612, 1.49668336, 0.0200494975, 0.503342092, 0.208182395, -0.838634133, -0.0388649404, 0.975015461, 0.218711212, 0.863212883, -0.0774930716, 0.49885726) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.64014888, 0.224238992, -0.403565288, 0.0212229788, -0.603865683, -0.796803713, -0.989261985, 0.102589145, -0.104097351, 0.144604191, 0.790456831, -0.595203996) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.522896647, 0.315473199, -1.06896186, 0.117607087, -0.938983917, -0.323230654, -0.30332914, 0.275967002, -0.912049174, 0.945600331, 0.205308735, -0.2523655) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.54057467, -1.946859, -0.234844446, 0.866025031, 0, -0.500000834, -0.0868243054, 0.98480773, -0.15038377, 0.49240464, 0.173648342, 0.85286808) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.44258678, -1.94206941, -0.503499508, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-5), math.rad(90)), 0.3)
	end	
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Attack = false
	relodee = false
end


function patchedup()
	Attack = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	for i = 0, .5, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.0266105551, -0.00228797412, -0.00301300199, 0.984924495, 0.00856173038, 0.172772706, -0.0739319623, 0.923793733, 0.375685036, -0.156389832, -0.382794857, 0.91050005) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.0833636597, 1.5589056, -0.0514357612, 0.983785033, 0.098459132, -0.149909437, -0.0804414302, 0.989283204, 0.121852726, 0.160300359, -0.107818037, 0.98116219) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.75938904, 0.357653558, -0.556756616, 0.863215625, -0.470763803, -0.182319537, -0.20867531, -0.00388178229, -0.977977395, 0.459688604, 0.882250845, -0.101587564) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-1.14530098, -0.0176402628, -0.497072637, 0.927982748, -0.326782674, -0.179056004, 0.238273218, 0.889843524, -0.389107317, 0.286485285, 0.318420619, 0.903622985) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.600150764, -1.42493248, -0.842450619, 0.983785033, 0.0984595343, -0.149909154, -0.0804414302, 0.989282846, 0.121855408, 0.160300359, -0.10782069, 0.981161833) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.608668685, -1.83582413, -0.778081357, 0.983785033, 0.0412500128, -0.174543589, -0.0804414302, 0.971299112, -0.22384648, 0.160300359, 0.234257326, 0.958867729) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end

	local heals2 = Instance.new("ParticleEmitter",LeftArm)
	heals2.Size = NumberSequence.new(.5,0)
	heals2.Texture = "rbxassetid://242856226"
	heals2.ZOffset = 0
	heals2.Acceleration = Vector3.new(0, -5, 0)
	heals2.Lifetime = NumberRange.new(1)
	heals2.Rate = 5
	heals2.Rotation = NumberRange.new(0, 0)
	heals2.RotSpeed = NumberRange.new(0, 0)
	heals2.Speed = NumberRange.new(2)
	heals2.VelocitySpread = 10
	heals2.Enabled=true
	heals2.EmissionDirection = "Front"
	local particol1 = Color3.new(0,1,0)
	local particol2 = Color3.new(1,1,1)
	heals2.Color = ColorSequence.new(particol1,particol2)
	game:GetService("Debris"):AddItem(heals2, 3.5)
	CFuncs.Sound.Create("1489909826", LeftArm, 1, .9)
	for i = 0, 4, 1 do
		for i = 0, .5, 0.1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0), 
				CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
				CFrame.new(0.587695718, 0.719740391, -0.886763453, -0.226821065, 0.740158081, -0.633023083, -0.919379234, -0.377204776, -0.111617722, -0.321394086, 0.556670964, 0.766043901) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
		end
		for i = 0, .5, 0.1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0 + 0.005 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
				CFrame.new(0.579867244, 0.441816211, -1.01476061, 0.218706101, 0.498854131, -0.838637173, -0.975016475, 0.0774877518, -0.208179355, -0.0388670191, 0.863215089, 0.503337979) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
		end
		for i = 0, .5, 0.1 do
			swait()
			PlayAnimationFromTable({         
				CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0 + 0.005 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
				CFrame.new(0.684166193, 0.417331696, -0.85110873, 0.302008986, 0.453297824, -0.838636816, -0.946748018, 0.245620534, -0.208179712, 0.111619003, 0.856849909, 0.503338397) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
		end
		for i = 0, .5, 0.1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(-0, -1.04790533, -1.78813934e-07, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849) * CFrame.new(0, 0 + 0.005 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0, 1.53909004, -0.194619089, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0 - 0.08 * math.cos(Sine/25), 0), 
				CFrame.new(0.889964521, 0.489984095, -0.478169471, 0.218706101, 0.498854131, -0.838637173, -0.975016475, 0.0774877518, -0.208179355, -0.0388670191, 0.863215089, 0.503337979) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.178292572, 0.354673386, -1.05802333, 0.173647001, -0.984807968, 0, 0, 0, -1, 0.984807968, 0.173647001, 0) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -1.50897241, 0.416451782, 1, 0, 0, 0, 0.173647985, 0.984807849, 0, -0.984807849, 0.173647985) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.5, -1.0367974, -0.558902025, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
		end
	end
	Attack = false
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	for i = 0, 9, 1 do
		if Humanoid.Health < 100 then 
			Humanoid.Health = Humanoid.Health + 2
			ShowDamage((Head.CFrame * CFrame.new(0, 0, (Torso.Size.Z / 4)).p + Vector3.new(0, 2, 0)), "+2", 1, BrickColor.new("Lime green").Color)			
			CFuncs.Sound.Create("588737722", Torso, .5, 1)
			wait(1)
		end
	end
end


function fireatwill()
	Attack = true	
	Humanoid.WalkSpeed = 8
	Humanoid.AutoRotate = false
	local bodygyro = Instance.new("BodyGyro",RootPart)
	bodygyro.MaxTorque = Vector3.new(50000,50000,50000)
	bodygyro.P = 8000	

	for i = 0, 6, 1 do
		if AmmoCount <= 0 then 
			break
		end	
		Torso.Velocity=RootPart.CFrame.lookVector*-5
		for i = 0, .5, 0.1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0.757158816, 0.024620086, -0.316807836, 0.00376787782, -0.197771132, 0.98024106, -0.0522153527, 0.978872001, 0.197695583, -0.998628855, -0.0519285128, -0.00663840771) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),  
				CFrame.new(0.0513084419, 1.52798402, -0.0491129272, 0.503341198, 0.0593924709, -0.862044334, -0.0388650261, 0.998181403, 0.0460789353, 0.86321336, 0.0103099495, 0.504734159) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(1.62060225, 0.561005533, -0.67263329, 0.184799463, -0.818805337, -0.543513656, -0.980174243, -0.113341682, -0.162518218, 0.0714680403, 0.56277138, -0.823517323) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.181243077, 0.716829836, -0.982703269, 0.117607087, -0.980847061, -0.15526706, -0.30332914, 0.113398649, -0.946114302, 0.945600331, 0.158366859, -0.284183025) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.628674686, -1.98509169, -0.25950858, 1.00000024, 0, 0, -7.4505806e-09, 0.98480773, -0.173648342, -2.98023224e-08, 0.173648342, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.442586422, -1.94206905, -0.503501356, 0.984808087, 0, -0.173647165, -0.0301535428, 0.98480773, -0.171010256, 0.171009004, 0.173648342, 0.969846487) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
			bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
		end			
		Effects.Block.Create(BrickColor.new("Flame reddish orange"), bulletmaker.CFrame, .5, .5, .5, .5, .5, .5, .1, 1)
		CFuncs.Sound.Create("1132379030", Handle, 1, 1)
		AmmoCount = AmmoCount - AmmoUsage
		for i = 0, 9, 1 do
			wshoot(Mouse, 3 , bulletmaker, .15 + (Torso.Position - Mouse.Hit.p).magnitude/15 , 0)
		end
		for i = 0, .5, 0.1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0.588929892, -1.11013651e-06, -0.0153462738, 0.466293842, -0.234925136, 0.85287708, 0.171010062, 0.969846427, 0.17364794, -0.867954016, 0.0648796037, 0.492407978) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.160780251, 1.50000441, 0.0393266231, 0.488946259, -0.0697783977, -0.869518578, -0.125678584, 0.980760813, -0.149376884, 0.863213003, 0.182317138, 0.470769644) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(1.67061281, 0.704267323, -0.691583157, 0.423231184, -0.709484339, -0.563477933, -0.879032731, -0.472217411, -0.065669328, -0.219492719, 0.52310884, -0.823517084) * CFrame.new(-.2, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.0540117994, 0.73741293, -0.982708097, 0.0631480217, -0.978079677, 0.198425397, -0.319141895, -0.208172753, -0.924560905, 0.945600986, -0.00494170189, -0.325291872) * CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.378202379, -1.77786493, -0.298971295, 0.837791204, 0.33804059, -0.428759336, -0.235888705, 0.932314754, 0.274127543, 0.492404819, -0.128522187, 0.860825062) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.773099661, -1.83571112, -0.503498793, 0.964610457, 0.171010062, -0.200704694, -0.200705469, 0.969846427, -0.138258308, 0.171009183, 0.17364794, 0.969846606) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
			bodygyro.CFrame = CFrame.new(RootPart.Position, Vector3.new(Mouse.Hit.p.X, RootPart.Position.Y, Mouse.Hit.p.Z))
		end
	end
	bodygyro:Destroy()
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Humanoid.AutoRotate = true
	Attack = false

end	

function stanceintro()
	IntroATT = true
	Attack = true
	Humanoid.WalkSpeed = 0
	swait()
	PlayAnimationFromTable({
		CFrame.new(0.401558101, -0.0234151632, 0.119796708, 0.764670074, 0.00020499996, 0.644422114, 0.024826102, 0.999248326, -0.02977648, -0.643943787, 0.0387676619, 0.764090121) * CFrame.new(0,0 + .05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		CFrame.new(0.0190042555, 1.53773534, -0.193438619, 0.64132297, 0.076782994, -0.763419509, 0.0574810207, 0.987376094, 0.147595912, 0.765114963, -0.138538778, 0.628813386) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.05 * math.cos(Sine/25), 0, 0), 
		CFrame.new(1.56287539, 0.196361139, -0.218576014, -0.0478557944, -0.26976496, -0.961736321, -0.464462936, 0.858424187, -0.217674509, 0.884298742, 0.436273903, -0.166376382) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
		CFrame.new(-0.354559392, 0.216858774, -0.992860973, -0.0544251502, -0.876319766, -0.478645861, -0.108326986, 0.481708944, -0.86961019, 0.992624402, 0.00452160835, -0.121146157) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
		CFrame.new(0.540573061, -1.95806193, 0.106789596, 0.93969214, 0, -0.342021883, 0, 1, 0, 0.342021853, 0, 0.93969208) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
		CFrame.new(-0.461303771, -1.99999595, -0.0524673536, 1.00000012, 0, 0, 0, 1, 0, 0, 0, 1.00000012) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
	}, .3, false)
	fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Attack = false
	IntroATT = false
end


function quickkick()
	SecondaryBread = true
	Attack = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 20
	Humanoid.Jump = true
	for i = 0, .3, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0, 0, -0, 1, 0, -0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0, 1.50351071, 0.0460739173, 1, 0, -0, 0, 1.00000012, 0, -0, 0, 1.00000012) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.50000381, 0.0324970335, 0.425725073, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-1.5, -0.159844279, 0.285122991, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.5, -1.15181708, -0.124861211, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.5, -1.8810792, 0.500639379, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	CFuncs.Sound.Create("200632136", Handle, 1, 1)
	local con = RightLeg.Touched:connect(function(hit)
		Damage(RightLeg, hit, 8, 12, 5, "Normal", RootPart, 0.2, "743521272", 1)end)
	Torso.Velocity=RootPart.CFrame.lookVector*50
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0, 0, -0, 1, 0, -0, 0, 0.939692736, -0.342019886, 0, 0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0, 1.56996083, -0.261622638, 1, 0, 0, 0, 0.939692736, 0.342019916, -0, -0.342019886, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.50000381, 0.27931872, 0.728133559, 1, 0, 0, 0, 0.499999821, 0.866025627, -0, -0.866025567, 0.499999821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-1.5, 0.34596175, 0.570588231, 1, 0, 0, 0, 0.499999821, 0.866025627, -0, -0.866025567, 0.499999821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.5, -1.39599705, -1.111431, 1, 0, -0, 0, 0.642786562, -0.766045451, -0, 0.766045451, 0.642786503) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.5, -1.70923471, 0.977958977, 1, 0, 0, 0, 0.499999821, 0.866025627, -0, -0.866025567, 0.499999821) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Torso.Velocity=RootPart.CFrame.lookVector*0
	con:Disconnect()
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	Attack = false
	SecondaryBread = false
end

function hedbap()
	SecondaryBread = true
	Attack = true
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(-0, -0.115550078, 0.250714004, 1, 0, -0, 0, 0.939692736, -0.342019886, 0, 0.342019916, 0.939692736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0, 1.51567197, 0.00248532044, 1, 0, -0, 0, 1, 2.98023224e-08, -0, 2.98023224e-08, 1) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.5, -1.48346758, 0.057243526, 1, 0, 0, 0, 0.766044796, 0.642787218, -0, -0.642787218, 0.766044855) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.499999523, -1.82032359, 0.395741045, 0.984807849, 0, 0.173647985, -0.0593910702, 0.939692736, 0.33682391, -0.163175747, -0.342019886, 0.925416768) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Torso.Velocity=RootPart.CFrame.lookVector*40
	CFuncs.Sound.Create("200632136", Handle, 1, 1)
	local con = Head.Touched:connect(function(hit)
		
		--print(hit)
		Damage(RightLeg, hit, 15, 18, 3, "Knockdown", RootPart, 0.2, "1296132303", 1) 
		--Humanoid.Health = Humanoid.Health - 5 
	end)
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0, 0.0488227382, -0.156543747, 1, 0, 0, 0, 0.76604414, 0.642788053, 0, -0.642788053, 0.76604414) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0, 1.52236009, -0.201607227, 1, 0, 0, 0, 0.939692438, 0.34202075, 0, -0.34202075, 0.939692438) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 - 0.1 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 - 0.1 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.5, -2.03161407, -0.00965765119, 1, 0, 0, 0, 0.98480773, 0.173648447, 0, -0.173648447, 0.98480773) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.5, -1.83802676, -0.920656502, 1, 0, 0, 0, 0.939692438, -0.342020959, 0, 0.342020929, 0.939692438) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	Attack = false
	con:Disconnect()
	SecondaryBread = false
end


function stockcrash()
	SecondaryBread = true
	Attack = true
	Humanoid.WalkSpeed = 5
	Humanoid.JumpPower = 0
	CFuncs.Sound.Create("1073355392", Stockbox, 1, 1)
	for i = 0, 1.5, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.0377655476, -0, -0.109542102, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-4.17232513e-07, 1.49999011, -3.93390656e-06, 0.856849194, 0.197328225, -0.476309896, -0.163177073, 0.980159342, 0.112521209, 0.489063263, -0.0186908543, 0.87204814) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.75000632, 0.42197898, -0.563352466, 0.766044974, -0.64278698, -0, 0, 0, -1, 0.64278698, 0.766044974, 0) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.420839459, 0.476516426, -1.11699474, 0.418066114, -0.903488457, -0.09449514, -0.139175028, 0.0390909165, -0.989495933, 0.897692144, 0.42682609, -0.109400436) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.637096405, -1.86514843, -0.291526765, 1, 0, 0, 0, 0.984807849, 0.173648059, 0, -0.173648059, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.48112309, -1.99999511, 0.0593808591, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(3, .5, 1) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(-100)), 0.3)
	end
	CFuncs.Sound.Create("1073356365", Stockbox, 1, 1)
	local con = Stockbox.Touched:connect(function(hit)
		Damage(Stockbox, hit, 18, 23, 5, "Knockdown", RootPart, 1, "146163534", 1) end)
	for i = 0, .2, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.441541791, 2.43237423e-07, 0.00331187248, 0.336825132, -0.0593909472, 0.939692259, 0.173648059, 0.984807849, -3.82394944e-07, -0.92541635, 0.163175866, 0.342021108) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.104509205, 1.59855092, -0.215072125, 0.890994191, 0.0636333674, -0.449533641, 0.0275982097, 0.980707407, 0.193524063, 0.453175396, -0.184835091, 0.872048259) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(1.75627017, 0.431958854, -0.449601173, 0.754407525, -0.653558016, -0.0610871017, -0.13302204, -0.0610866398, -0.989228785, 0.642786741, 0.754407406, -0.133021802) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.367935598, 0.648825228, -1.07648134, 0.387547314, -0.915556669, -0.107533015, -0.209657595, 0.0260535926, -0.977427781, 0.897691965, 0.401344508, -0.181856394) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.358966112, -1.63310397, -0.651200593, 0.984807909, 0.17100957, 0.0301558673, -0.173648059, 0.969846368, 0.171010047, -2.23517418e-06, -0.173648521, 0.98480773) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.654243588, -1.85264969, 0.148285508, 0.754406095, -0.0533300862, 0.654238164, -0.133022279, 0.963592768, 0.231935903, -0.642788172, -0.262002051, 0.71984601) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
	end
	for i = 0, 1, 0.1 do
		swait()
		PlayAnimationFromTable({
			CFrame.new(0.278367251, 9.0772329e-07, 0.0731263831, 0.633022964, -0.111618958, 0.766043842, 0.173647985, 0.984807849, 5.96214491e-08, -0.754405856, 0.133021936, 0.64278841) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.104512498, 1.59855139, -0.215077341, 0.727161527, 0.0636337325, 0.683510542, -0.172414482, 0.980707347, 0.0921231061, -0.664461732, -0.184835523, 0.724103987) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.400077015, 0.238431826, -1.01036751, 0.518464565, 0.840397179, 0.157882661, -0.035381794, 0.205562487, -0.978004277, -0.854366899, 0.50147438, 0.13631162) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-1.62448943, 0.329740167, -0.818884015, 0.598198533, 0.795001924, 0.100649826, -0.176135838, 0.25297159, -0.95130527, -0.781751156, 0.551341355, 0.29135555) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(0.302916914, -1.95092583, 0.295360684, 0.98480773, 0.171009585, 0.0301554501, -0.173648, 0.969846547, 0.1710096, -1.81794167e-06, -0.173648, 0.984807909) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			CFrame.new(-0.801789224, -1.60096383, -0.361114919, 0.974819183, 0.117734738, 0.189383537, -0.166570976, 0.949086845, 0.267373323, -0.148262233, -0.292186439, 0.944799304) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
		}, .3, false)
		fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(1, 1, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(-50)), 0.3)
	end
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 60
	con:Disconnect()
	Attack = false
	SecondaryBread = false
end






Mouse.KeyDown:connect(function(Key)
	Key = Key:lower()
	while Attack == false and UIS:IsKeyDown(Enum.KeyCode.R) and AmmoCount >= 0 and AmmoCount <= maxammo - 1 do
		relode()
		if Attack == false and AmmoCount == maxammo then
			pump() 
		end			
	end
end)


Mouse.KeyDown:connect(function(Key)
	Key = Key:lower()
	while Attack == false and UIS:IsKeyDown(Enum.KeyCode.X) and cooldownX >=coX do
		stanceintro()
		textXZ.Text = "[X+Z]\n Quick Kick"
		text2.Text = "[X]\n HOLD"
		textXC.Text = "[X+C]\n Headbutt"
		textXV.Text = "[X+V]\n Stock Swing"

		text1.Text = " "
		text3.Text = " "
		text4.Text = " "
		frameskXZ.BackgroundTransparency = .5
		frameskXC.BackgroundTransparency = .5
		frameskXV.BackgroundTransparency = .5
		barXZ.BackgroundTransparency = 0
		barXC.BackgroundTransparency = 0
		barXV.BackgroundTransparency = 0

		frameskZ.BackgroundTransparency = 1
		frameskC.BackgroundTransparency = 1
		frameskV.BackgroundTransparency = 1
		barZ.BackgroundTransparency = 1
		barC.BackgroundTransparency = 1
		barV.BackgroundTransparency = 1


		if UIS:IsKeyDown(Enum.KeyCode.X) and UIS:IsKeyDown(Enum.KeyCode.Z) and cooldownXZ >=coXZ then
			quickkick()
			cooldownXZ = 0
		elseif UIS:IsKeyDown(Enum.KeyCode.X) and UIS:IsKeyDown(Enum.KeyCode.C) and cooldownXC >=coXC then
			hedbap()
			cooldownXC = 0
		elseif UIS:IsKeyDown(Enum.KeyCode.X) and UIS:IsKeyDown(Enum.KeyCode.V) and cooldownXV >=coXV then
			stockcrash()
			cooldownXV = 0
		end
	end
end)



Mouse.KeyDown:connect(function(Key)
	if Attack == false and Key == 'z' and cooldownZ >=coZ then
		cooldownZ = 0		
		hop()
	elseif Attack == false and Key == 'c' and cooldownC >=coC and Humanoid.Health < 100 then
		cooldownC = 0
		patchedup()
	elseif Attack == false and Key == 'v' and cooldownV >=coV then
		cooldownV = 0
		fireatwill()

	end
end)


Mouse.Button1Down:connect(function()
	if Attack == false and AmmoCount > 0 then
		fire()
	elseif Attack == false and AmmoCount == 0 then
		dryfire()
	end
end)


function updateskills1()
	if cooldownZ <= coZ then
		cooldownZ = cooldownZ + 1 / 35
	end
	if cooldownX <= coX then
		cooldownX = cooldownX + 1 / 35
	end
	if cooldownXZ <= coXZ then
		cooldownXZ = cooldownXZ + 1 / 35
	end
	if cooldownXC <= coXC then
		cooldownXC = cooldownXC + 1 / 35
	end
	if cooldownXV <= coXV then
		cooldownXV = cooldownXV + 1 / 35
	end
	if cooldownC <= coC then
		cooldownC = cooldownC + 1 / 35
	end
	if cooldownV <= coV then
		cooldownV = cooldownV + 1 / 35
	end
end


while true do
	swait()
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA("Part") then
			v.Material = "SmoothPlastic"
		elseif v:IsA("Accessory") then
			v:WaitForChild("Handle").Material = "SmoothPlastic"
		end
	end
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA'Model' then
			for _, c in pairs(v:GetChildren()) do
				if c:IsA'Part' then
					c.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
				end
			end
		end
	end
	updateskills1()
	barZ:TweenSize(UDim2.new(1 * (cooldownZ / coZ), 0, 1, 0), 'Out', 'Quad', .5)
	barX:TweenSize(UDim2.new(1 * (cooldownX / coX), 0, 1, 0), 'Out', 'Quad', .5)
	barXZ:TweenSize(UDim2.new(1 * (cooldownXZ / coXZ), 0, 1, 0), 'Out', 'Quad', .5)
	barXC:TweenSize(UDim2.new(1 * (cooldownXC / coXC), 0, 1, 0), 'Out', 'Quad', .5)
	barXV:TweenSize(UDim2.new(1 * (cooldownXV / coXV), 0, 1, 0), 'Out', 'Quad', .5)
	barC:TweenSize(UDim2.new(1 * (cooldownC / coC), 0, 1, 0), 'Out', 'Quad', .5)
	barV:TweenSize(UDim2.new(1 * (cooldownV / coV), 0, 1, 0), 'Out', 'Quad', .5)

	if AmmoCount ~= 0 then
		relodetext.Text = '[ '..AmmoCount..' / '..maxammo..' ]'
	elseif AmmoCount == 0 then 
		relodetext.Text = '[ Hold R to Reload. ]'
	end


	if UIS:IsKeyDown(Enum.KeyCode.X) == false then
		text1.Text = "[Z]\n Reposition"
		text2.Text = "[X]\n Battle Stance"
		text3.Text = "[C]\n Mend"
		text4.Text = "[V]\n Unload"
		textXZ.Text = " "
		textXC.Text = " "
		textXV.Text = " "
		frameskZ.BackgroundTransparency = .5
		frameskC.BackgroundTransparency = .5
		frameskV.BackgroundTransparency = .5
		barZ.BackgroundTransparency = 0
		barC.BackgroundTransparency = 0
		barV.BackgroundTransparency = 0

		frameskXZ.BackgroundTransparency = 1
		frameskXC.BackgroundTransparency = 1
		frameskXV.BackgroundTransparency = 1
		barXZ.BackgroundTransparency = 1
		barXC.BackgroundTransparency = 1
		barXV.BackgroundTransparency = 1
	end
	TorsoVelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
	Velocity = RootPart.Velocity.y
	Sine = Sine + Change
	local hit, pos = RayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
	if RootPart.Velocity.y > 1 and hit == nil then 
		Anim = "Jump"
		if Attack == false then
			Change = 1
			PlayAnimationFromTable({
				CFrame.new(-0, -1.01481628, -8.04662704e-07, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0, 1.45637476, -0.213752031, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(1.80887365, 0.563777864, 0.393151999, 0.642787039, -0.766044915, -1.2109125e-06, 0.754407167, 0.633021533, 0.173648313, -0.133021653, -0.111619815, 0.984807789) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-1.67181289, 0.594474256, -0.03263852, 0.499999285, 0.866025865, 1.98491279e-07, -0.750001073, 0.433012605, -0.499998599, -0.43301177, 0.249998808, 0.866026282) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -1.80666828, -0.689023316, 1, 0, 0, 0, 0.984807849, 0.173648134, 0, -0.173648164, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.5, -1.42673647, -0.144118369, 1, 0, 0, 0, 0.766044736, 0.642787457, 0, -0.642787457, 0.766044736) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
			fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end	
	elseif RootPart.Velocity.y < -1 and hit == nil then 
		Anim = "Fall"
		if Attack == false then
			Change = 1
			PlayAnimationFromTable({
				CFrame.new(-0, -1.01481628, -8.04662704e-07, 1, 0, 0, 0, 0.866025686, 0.499999642, -0, -0.499999642, 0.866025686) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0, 1.45637476, -0.213752031, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(1.53209591, 0.16416876, 0.0263971146, 0.98480773, -0.173648164, -1.55591565e-07, 0.171010092, 0.969846427, 0.173648164, -0.0301535316, -0.171010077, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-1.64498818, 0.287739754, -0.209731221, 0.86602509, 0.500000656, 7.92254752e-07, -0.433013529, 0.750000894, -0.499998152, -0.25, 0.433010578, 0.86602664) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -1.26449406, -1.10387921, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.5, -1.24956489, -0.292783707, 1, 0, 0, 0, 0.642787695, 0.766044557, 0, -0.766044557, 0.642787695) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
			fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end		
	elseif TorsoVelocity < 1 and hit ~= nil then
		Anim = "Idle"
		if Attack == false then
			Change = 1
			PlayAnimationFromTable({
				CFrame.new(0.038382329, -2.14204192e-08, -0.0314837135, 0.984807849, 0.0301536452, 0.171009868, 0, 0.98480773, -0.173648119, -0.173647985, 0.171010017, 0.969846368) * CFrame.new(0, 0 + 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0 + 0.005 * math.cos(Sine/25), 0), 
				CFrame.new(-0.00987245888, 1.54137087, -0.232474566, 0.983905733, 0.0593912564, -0.168529823, 0.000888057693, 0.941511214, 0.336980611, 0.17868638, -0.331706822, 0.926305413) * CFrame.new(0, 0, 0) * CFrame.Angles(0 - 0.05 * math.cos(Sine/25), 0, 0), 
				CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0 + 0.02 * math.cos(Sine/25), 0 + 0.01 * math.cos(Sine/25)) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.628665984, -2.00964737, 0.120245621, 1.00000012, 0, 0, 1.86264515e-09, 0.98480773, 0.173648119, 0, -0.173648119, 0.984807849) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.44258371, -1.99715459, 0.19109571, 0.939692676, 0, 0.342020601, -0.0593912229, 0.98480773, 0.163175851, -0.336824536, -0.173648119, 0.925416529) * CFrame.new(0, 0 - 0.05 * math.cos(Sine/25), 0) * CFrame.Angles(0, 0, 0), 
			}, .3, false)
			fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end
	elseif TorsoVelocity > 2 and hit ~= nil then
		Anim = "Walk"
		if Attack == false then
			PlayAnimationFromTable({
				CFrame.new(-0, -0, 0, 1, 0, 0, 0, 0.996187985, 0.0871556774, 0, -0.0871556699, 0.996194661) * CFrame.new(0, 0 + .05 * math.cos(Sine/25), 0) * CFrame.Angles(-.2 + 0.05 * math.cos(Sine/25), 0 + 0.05 * math.cos(Sine/5), 0),
				CFrame.new(0, 1.49999499, 1.11760201e-08, 1, 0, 0, 0, 0.999998331, -7.45067918e-09, 0, 7.45069251e-09, 1) * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sine/30)) * CFrame.Angles(0 + 0.05 * math.cos(Sine/15), 0, 0),
				CFrame.new(1.00599754, 0.00645497441, -0.987730443, 0.387630165, 0.322637081, -0.863509297, -0.802340508, 0.579304218, -0.143723249, 0.453864068, 0.748539925, 0.483420581) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(-0.927108586, 0.209949538, -0.179899275, 0.68265909, -0.539921403, -0.492403984, -0.24406442, 0.4666816, -0.850082874, 0.688773632, 0.700495183, 0.18680881) * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), 
				CFrame.new(0.5, -2.00000334, 2.67028881e-005, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024) * CFrame.new(0, .21 - .1 * math.cos((Sine) / 2), -.1 + 1 * math.cos((Sine) / 4)) * CFrame.Angles(math.rad(1 - 50 * math.cos((Sine) / 4)), math.rad(0), math.rad(0 - .5 * math.cos((Sine) / 5))),
				CFrame.new(-0.5, -2.00000334, 2.67028881e-005, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024) * CFrame.new(0, .21 - .1 * math.cos((Sine) / 2), .1 - 1 * math.cos((Sine) / 4)) * CFrame.Angles(math.rad(-1 + 50 * math.cos((Sine) / 4)), math.rad(0), math.rad(0 + .5 * math.cos((Sine) / 5))),
			}, .3, false)
			fHandleWeld.C0 = clerp(fHandleWeld.C0, CFrame.new(-.4, .2, 0) * CFrame.Angles(math.rad(90), math.rad(-10), math.rad(90)), 0.3)
		end
	end
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Ice" then
							if Thing[6] <= Thing[5] then
								Thing[6] = Thing[6] + .05
								Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, .4, 0)
							else
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							end
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[8].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block4" then
							Thing[1].CFrame = Thing[8].CFrame * CFrame.new(0, -Thing[7].Scale.Y, 0) * CFrame.fromEulerAnglesXYZ(3.14, 0, 0)
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2Fire" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							if Thing[1].Transparency >= .3 then
								Thing[1].BrickColor = BrickColor.new("Bright red")
							else
								Thing[1].BrickColor = BrickColor.new("Bright yellow")
							end
						elseif Thing[2] == "Cylinder" then
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, -.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							Mesh = Thing[10]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[1].CFrame = Thing[1].CFrame * Thing[11] * CFrame.new(0, 0, .2)
							Thing[1].Rotation = Vector3.new(0, 0, 0)
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end	
end
print("Loaded")
end)
Section:NewButton("FE Cop", "ButtonInfo", function()
    print("Clicked")
--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
_G.Sounds = true;

local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
    local unit = realPartVelocity.Unit
    if (unit.Y > 0.9) or (unit.Y < -0.9) then
        return realPartVelocity * (25.1 / realPartVelocity.Y)
    end
    realPartVelocity *= Vector3_101
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        realPartVelocity = unit * Vector3_101 * 100
    end
    return realPartVelocity + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local noclipAllParts = true --set it to true if you want noclip
local flingpart = "HumanoidRootPart" --the part that will be used to fling (ctrl + F "fling function")
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end




local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local noclipmodel = (noclipAllParts and c) or model
local noclipcon = nil
local function uncollide()
	if noclipmodel then
		for i, v in pairs(noclipmodel:GetDescendants()) do
		    if v:IsA("BasePart") then
			    v.CanCollide = false
		    end
		end
	else
		noclipcon:Disconnect()
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck = nil
	local conTorso = nil
	local contorso1 = nil
	local aligns = {}
	local function enableAligns()
	    conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
	    if table.find({"Part0", "Part1", "Parent"}, prop) then
	        enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

--[[
    fling function
    usage: fling(target, duration, velocity)
    target can be set to: basePart, CFrame, Vector3, character model or humanoid
    duration (fling time) can be set to a number or a string containing the number (in seconds) will be set to 0.5 if not provided,
    velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)
]]

local flingpart0 = gp(model, flingpart, "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0.Destroying:Connect(function()
        flingpart0 = nil
        fling = function() end
    end)
    flingpart0.Archivable = true
    flingpart1.Destroying:Connect(function()
        flingpart1 = nil
        fling = function() end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0.Destroying:Connect(function()
            att0 = nil
            fling = function() end
        end)
        att1.Destroying:Connect(function()
            att1 = nil
            fling = function() end
        end)
        local lastfling = nil
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    local parent = target.Parent
                    if not (parent and parent:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                return
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.Size = v3(0.01, 0.01, 0.01)
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Destroying:Connect(function()
                flingpart = nil
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = false
                end
            end
            local con = nil
            con = heartbeat:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rotVelocity
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            local steppedRotVel = v3(
                ((rotVelocity.X > 0) and -1) or 1,
                ((rotVelocity.Y > 0) and -1) or 1,
                ((rotVelocity.Z > 0) and -1) or 1
            )
            local con = nil
            con = stepped:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = steppedRotVel
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = true
                end
            end
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end

wait(6)

-----------------------------------
--WATCH OUT HERE COMES THE COPPAS--
----------------------------------------------------------------
--By CKbackup (Sugarie Saffron)                               --
--YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw--
--Discord: Sugarie Saffron#4705                               --
----------------------------------------------------------------

print([[
--Script Cop--
By CKbackup (Sugarie Saffron)                               
YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw
Discord: Sugarie Saffron#4705  


Credits Convert:
Discord : Deia#1057
YT: https://www.youtube.com/channel/UCx1SYXyvNILH3ZPmOYes9Yg
:)
--------------------------------
As I've been demoted from my SB
Mod rank in VSB, I don't see the
need to hold this back any longer.

Also, if the anims look weird or
the weapon looks out of place,
it's because it's actually modeled
off a scaled rig with a package.
It looks better with the Boy
package.
--------------------------------
(Keys)
M - Mute/Play Music

Click - Baton Swing
(Hold) Q - Run
Z - Pistol
X - Arrest

P - Move Jail(s)
]])

wait(1/60)
Effects = { }

local attackm = nil
local Player = game:service'Players'.localPlayer
local chara = Player.Character
local Humanoid = chara:FindFirstChildOfClass("Humanoid")
local Mouse = Player:GetMouse()
local LeftArm = chara["Left Arm"]
local RightArm = chara["Right Arm"]
local LeftLeg = chara["Left Leg"]
local RightLeg = chara["Right Leg"]
local Head = chara.Head
local Torso = chara.Torso
local RootPart = chara.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local attack = false
local Anim = 'Idle'
local attacktype = 1
local delays = false
local play = true
local targetted = nil
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local doe = 0

FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()

local Create = FELOADLIBRARY.Create
Humanoid.WalkSpeed = 16



Humanoid.Animator.Parent = nil
chara.Animate.Parent = nil

local pos = Vector3.new(0,0,-50)

local newMotor = function(part0, part1, c0, c1)
	local w = Create('Motor'){
		Parent = part0,
		Part0 = part0,
		Part1 = part1,
		C0 = c0,
		C1 = c1,
	}
	return w
end

function clerp(a, b, t)
	return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)


local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
	RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
	Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
	RW.C0 = clerp(RW.C0, table[3], speed) 
	LW.C0 = clerp(LW.C0, table[4], speed) 
	RH.C0 = clerp(RH.C0, table[5], speed) 
	LH.C0 = clerp(LH.C0, table[6], speed) 
	if bool == true then
		if resetc1 == false then
			resetc1 = true
			RootJoint.C1 = RootJoint.C1
			Torso.Neck.C1 = Torso.Neck.C1
			RW.C1 = rarmc1
			LW.C1 = larmc1
			RH.C1 = rlegc1
			LH.C1 = llegc1
		end
	end
end


ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.03333333333333
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
  tf = tf + s
  if tf >= frame then
    if allowframeloss then
      script.Heartbeat:Fire()
      lastframe = tick()
    else
      for i = 1, math.floor(tf / frame) do
        script.Heartbeat:Fire()
      end
      lastframe = tick()
    end
    if tossremainder then
      tf = 0
    else
      tf = tf - frame * math.floor(tf / frame)
    end
  end
end)
function swait(num)
  if num == 0 or num == nil then
    ArtificialHB.Event:wait()
  else
    for i = 0, num do
      ArtificialHB.Event:wait()
    end
  end
end

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
	

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}


function so(id,par,pit,vol)
    if _G.Sounds == true then
  local sou = Instance.new("Sound", par or workspace)
  if par == chara then
    sou.Parent = chara.Torso
  end
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "rbxassetid://" .. id
  sou.PlayOnRemove = true
  sou:Destroy()
end
end
if _G.Sounds == true then
local mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://345868687"
mus.Looped = true
mus.Volume = 1
mus:Play()
end
New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local PoliceHat = New("Part",chara,"PoliceHat",{BrickColor = BrickColor.new("Really black"),FormFactor = Enum.FormFactor.Plate,Size = Vector3.new(2, 0.400000006, 1),CFrame = CFrame.new(18.3999939, 1.20000005, -23.1000061, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Weld,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
local Mesh = New("SpecialMesh",PoliceHat,"Mesh",{Scale = Vector3.new(1.10000002, 1.20000005, 1.10000002),MeshId = "rbxassetid://1028788",TextureId = "rbxassetid://152240477",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",PoliceHat,"Weld",{Part0 = PoliceHat,Part1 = Head,C1 = CFrame.new(0, 0.700000048, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),})
for i, v in pairs(chara:children()) do
if v:IsA("Shirt") or v:IsA("Pants") or v:IsA("BodyColors") then
v:Destroy()
elseif v.Name == "FakeHeadM" then
v.Ahoge.Mesh.Scale = Vector3.new()
elseif v.Name == "Chest" then
for a, b in pairs(v:children()) do
if b.Name ~= "Tail" then
b.Transparency = 1
end
end
end
end
local sh = Instance.new("Shirt",chara)
local pn = Instance.new("Pants",chara)
sh.ShirtTemplate = "rbxassetid://133284214"
pn.PantsTemplate = "rbxassetid://15224239"


bdefc0 = CFrame.new(.8,-1,0)*CFrame.Angles(math.rad(30),0,0)
gdefc0 = CFrame.new(-.8,-1,0)*CFrame.Angles(math.rad(130),0,0)

local baton = Instance.new("Part",chara)
baton.Name = "Baton"
baton.Size = Vector3.new(.2,.2,3.2)
baton.BrickColor = BrickColor.new("Really black")
baton.CanCollide = false
CFuncs.Mesh.Create("SpecialMesh", baton, "FileMesh", "rbxassetid://11820238", Vector3.new(), Vector3.new(1.5,1.5,1.5))

local bweld = Instance.new("Weld",baton)
bweld.Part0 = Torso
bweld.Part1 = baton
bweld.C0 = bdefc0

local att1 = Instance.new("Attachment",baton)
att1.Position = Vector3.new(-baton.Size.X/2,baton.Size.Y/2,baton.Size.Z/2)
local att2 = Instance.new("Attachment",baton)
att2.Position = Vector3.new(-baton.Size.X/2,-baton.Size.Y/2,-baton.Size.Z/2)
local tr1 = Instance.new("Trail",baton)
tr1.Color = ColorSequence.new(Color3.new(1,1,1))
tr1.Transparency = NumberSequence.new(0,1)
tr1.Lifetime = .5
tr1.Enabled = false
tr1.LightEmission = 1
tr1.Attachment0 = att1
tr1.Attachment1 = att2
local att3 = Instance.new("Attachment",RightLeg)
att3.Position = Vector3.new(0,1,0)
local att4 = Instance.new("Attachment",RightLeg)
att4.Position = Vector3.new(0,-1,0)
local tr2 = Instance.new("Trail",RightLeg)
tr2.Color = ColorSequence.new(Color3.new(1,1,1))
tr2.Transparency = NumberSequence.new(0,1)
tr2.Lifetime = .5
tr2.Enabled = false
tr2.LightEmission = 1
tr2.Attachment0 = att3
tr2.Attachment1 = att4

local gun = Instance.new("Part",chara)
gun.Name = "Gun"
gun.Size = Vector3.new(.2,.2,.2)
gun.BrickColor = BrickColor.new("Really black")
gun.CanCollide = false
CFuncs.Mesh.Create("SpecialMesh", gun, "FileMesh", "rbxassetid://72012879", Vector3.new(), Vector3.new(2,2,2))

local gweld = Instance.new("Weld",gun)
gweld.Part0 = Torso
gweld.Part1 = gun
gweld.C0 = gdefc0

local lp = game:GetService("Players").LocalPlayer

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end


local hat = gp(cplayer, "Meshes/1911RightAccessory", "Accessory")
local handle = gp(hat, "Handle", "BasePart")
local att = gp(handle, "att1_Handle", "Attachment")
att.Parent = gun
--att.Rotation = v3(-90, -60, 270)
att.Rotation = v3(0, 0, 180)



local hat2 = gp(cplayer, "Nightstick", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
--handle2.SpecialMesh:Destroy()
local att = gp(handle2, "att1_Handle", "Attachment")
att.Parent = baton
--att.Position = v3(0, 0, 0)
att.Rotation = v3(-40, 0, 0)

baton.Transparency = 1
gun.Transparency = 1
spawn(function()
while game:GetService("RunService").Heartbeat:Wait() do
if attack == false then
fling(game:GetService("Players").LocalPlayer.Character["Model"].HumanoidRootPart.Position, 0.1)

elseif attack == true then
if attackm == "baton" then
fling(baton.Position, 0.1)
elseif attackm == "gun" then
if Player:GetMouse().Target ~= nil then
fling(Player:GetMouse().Hit.p, 0.1)

end
end
end
end
end)
 


function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function mdmg(Part, Magnitude, HitType)
	for _, c in pairs(workspace:GetDescendants()) do
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum ~= nil and c ~= cplayer and c ~= cplayer.Model then
			local head = c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= Magnitude and c.Name ~= Player.Name and c:FindFirstChild("MagDmgd")==nil and c ~= cplayer and c ~= cplayer.Model  then 
				if c.Name ~= chara and c ~= cplayer and c ~= cplayer.Model then
				if c.Name ~= "CKbackup" or c.Name ~= "Nebula_Zorua" or c.Name ~= "Salvo_Starly" then
			local val = Instance.new("BoolValue",c)
			val.Name = "MagDmgd"
			local asd = Instance.new("ParticleEmitter",head)
			asd.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
			asd.LightEmission = .1
			asd.Size = NumberSequence.new(0.2)
			asd.Texture = "rbxassetid://771221224"
			aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 1)})
			bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
			asd.Transparency = bbb
			asd.Size = aaa
			asd.ZOffset = .9
			asd.Acceleration = Vector3.new(0, -5, 0)
			asd.LockedToPart = false
			asd.EmissionDirection = "Back"
			asd.Lifetime = NumberRange.new(1, 2)
			asd.Rate = 1000
			asd.Rotation = NumberRange.new(-100, 100)
			asd.RotSpeed = NumberRange.new(-100, 100)
			asd.Speed = NumberRange.new(6)
			asd.VelocitySpread = 10000
			asd.Enabled = false
			asd:Emit(20)
			game:service'Debris':AddItem(asd,3)
					--Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, .1, "rbxassetid://" .. HitSound, HitPitch)
				if HitType == "Blunt" then				
				so(386946017,head,.95,3)
				game:service'Debris':AddItem(val,1)
				elseif HitType == "Shot" then
				so(144884872,head,.9,3)
				game:service'Debris':AddItem(val,.05)	
				end
                if _G.Sounds == true then
				local soaa = Instance.new("Sound",c.Head)
				soaa.Volume = .5
				local cho = math.random(1,5)
				if cho == 1 then
				soaa.SoundId = "rbxassetid://111896685"
				elseif cho == 2 then
				soaa.SoundId = "rbxassetid://535528169"
				elseif cho == 3 then
				soaa.SoundId = "rbxassetid://1080363252"
				elseif cho == 4 then
				soaa.SoundId = "rbxassetid://147758746"
				elseif cho == 5 then
				soaa.SoundId = "rbxassetid://626777433"
				soaa.Volume = .2
				soaa.TimePosition = 1
				end
				game:service'Debris':AddItem(soaa,6)
				soaa:Play()
            end
					--for i,v in pairs(c:children()) do
					--if v:IsA("LocalScript") or v:IsA("Tool") then
					--v:Destroy()
					--end
					--end
					--hum.PlatformStand = true
					--head.Velocity = RootPart.CFrame.lookVector*50
					--head.RotVelocity = Vector3.new(10,0,0)
					chatfunc("Let that be a warning!")
					coroutine.wrap(function()
					swait(5)
					 end)()
				       else
					end
				end
			end
		end
	end
	end
end

--[[FindNearestTorso = function(pos)
	local list = (game.workspace:GetDescendants())
	local torso = nil
	local dist = 1000
	local temp, human, temp2 = nil, nil, nil
	for x = 1, #list do
		temp2 = list[x]
		if temp2.className == "Model" and temp2.Name ~= chara.Name then
			temp = temp2:findFirstChild("Torso")
			human = temp2:FindFirstChildOfClass("Humanoid")
			if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
				local dohit = true
				if dohit == true then
					torso = temp
					dist = (temp.Position - pos).magnitude
				end
			end
		end
	end
	return torso, dist
end]]


function FindNearestTorso(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetDescendants()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= chara then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end


--Chat Function--
function chatfunc(text)
coroutine.wrap(function()
if chara:FindFirstChild("TalkingBillBoard")~= nil then
chara:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",chara)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = chara.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = "Fantasy"
tecks2.FontSize = "Size24"
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,1,1)
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
for i = 1,string.len(text),1 do
tecks2.Text = string.sub(text,1,i)
swait()
end
swait(30)
for i = 1, 5 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.05,0)
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.2
tecks2.TextTransparency = tecks2.TextTransparency + .2
end
naeeym2:Destroy()
end)()
end



EffectModel = Create("Model"){
	Parent = chara,
	Name = "Effects",
}


Effects = {
	Block = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		end;
	};

		Cylinder = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())		
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end;
	};
	Head = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Head", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end;
	};
	
	Sphere = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end;
	};
	
	Elect = {
		Create = function(cff, x, y, z)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, BrickColor.new("Lime green"), "Part", Vector3.new(1, 1, 1))
			prt.Anchored = true
			prt.CFrame = cff * CFrame.new(math.random(-x, x), math.random(-y, y), math.random(-z, z))
			prt.CFrame = CFrame.new(prt.Position)
			game:GetService("Debris"):AddItem(prt, 2)
			local xval = math.random() / 2
			local yval = math.random() / 2
			local zval = math.random() / 2
			local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(xval, yval, zval))
			table.insert(Effects, {
				prt,
				"Elec",
				0.1,
				x,
				y,
				z,
				xval,
				yval,
				zval
			})
		end;

	};
	
	Ring = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end;
	};


	Wave = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end;
	};

	Break = {
		Create = function(brickcolor, cframe, x1, y1, z1)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local num = math.random(10, 50) / 1000
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end;
	};
	
	Fire = {
		Create = function(brickcolor, cframe, x1, y1, z1, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Fire",
				delay,
				1,
				1,
				1,
				msh
			})
		end;
	};
	
	FireWave = {
		Create = function(brickcolor, cframe, x1, y1, z1)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 1, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local d = Create("Decal"){
				Parent = prt,
				Texture = "rbxassetid://26356434",
				Face = "Top",
			}
			local d = Create("Decal"){
				Parent = prt,
				Texture = "rbxassetid://26356434",
				Face = "Bottom",
			}
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"FireWave",
				1,
				30,
				math.random(400, 600) / 100,
				msh
			})
		end;
	};
	
	Lightning = {
		Create = function(p0, p1, tym, ofs, col, th, tra, last)
			local magz = (p0 - p1).magnitude
			local curpos = p0
			local trz = {
				-ofs,
				ofs
			}
			for i = 1, tym do
				local li = CFuncs.Part.Create(EffectModel, "Neon", 0, tra or 0.4, col, "Ref", Vector3.new(th, th, magz / tym))
				local ofz = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
				local trolpos = CFrame.new(curpos, p1) * CFrame.new(0, 0, magz / tym).p + ofz
				li.Material = "Neon"
				if tym == i then
					local magz2 = (curpos - p1).magnitude
					li.Size = Vector3.new(th, th, magz2)
					li.CFrame = CFrame.new(curpos, p1) * CFrame.new(0, 0, -magz2 / 2)
					table.insert(Effects, {
						li,
						"Disappear",
						last
					})
				else
					do
						do
							li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / tym / 2)
							curpos = li.CFrame * CFrame.new(0, 0, magz / tym / 2).p
							game.Debris:AddItem(li, 10)
							table.insert(Effects, {
								li,
								"Disappear",
								last
							})
						end
					end
				end
			end
		end
	};

	EffectTemplate = {

	};
}


function smek()
attack = true
bweld.Part0 = RightArm
bweld.C0 = CFrame.new(-.2,-2,.4)*CFrame.Angles(math.rad(90),0,math.rad(180))
Humanoid.WalkSpeed = 40
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.499998987, 0, -0.866025984, 0, 1, 0, 0.866025984, 0, 0.499998987),
CFrame.new(0, 1.49999714, 0, 0.499998987, 0, 0.866025984, 0, 1, 0, -0.866025984, 0, 0.499998987),
CFrame.new(1.6195364, 0.256343663, -3.60019794e-06, 0.939692736, -0.342020124, -8.94069672e-08, 0.342020154, 0.939692676, -4.35416268e-07, 2.08616257e-07, 3.87430191e-07, 1),
CFrame.new(-1.65980804, 0.323206544, 5.72385352e-06, 0.866025329, 0.500000238, -2.98023224e-07, -0.500000179, 0.866025388, -1.34623383e-06, -4.47034836e-07, 1.29640102e-06, 1.00000012),
CFrame.new(0.500001073, -2.00000095, -1.57952309e-06, 0.939692616, 0, -0.342020184, 0, 1, 0, 0.342020184, 0, 0.939692616),
CFrame.new(-0.499998212, -2.00000095, 1.49011612e-06, 0.766043544, 0, 0.642788708, 0, 1, 0, -0.642788708, 0, 0.766043544),
}, .3, false)
end
Humanoid.WalkSpeed = 2
tr1.Enabled = true
so(536642316,baton,1,1)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(-0.0116844922, 0, -0.381816059, 0.342019022, 0, 0.939693093, 0, 1, 0, -0.939693093, 0, 0.342018992),
CFrame.new(-0.0728889629, 1.49999714, 0.038963601, 0.342019022, 0, -0.939693093, 0, 1, 0, 0.939693093, 0, 0.342018992),
CFrame.new(1.06065702, 1.09677029, -0.161810428, 0.400286436, 0.242276207, 0.88378346, 0.734158754, -0.661962748, -0.151050553, 0.548435688, 0.709300876, -0.442843854),
CFrame.new(-1.59605861, 0.10887894, 1.11486224e-06, 0.984807909, 0.173648059, -2.23517418e-06, -0.173648059, 0.984807849, 3.82394944e-07, 2.29477882e-06, 1.86264515e-08, 1),
CFrame.new(0.685087919, -1.96527183, 0.0673596561, 0.92541647, -0.163175598, -0.342020869, 0.173647985, 0.984807849, 2.90093368e-07, 0.336824894, -0.0593915246, 0.939692438),
CFrame.new(-0.499999702, -2.00000095, 8.68737698e-06, 0.766045451, 0, 0.642786503, 0, 1, 0, -0.642786503, 0, 0.766045511),
}, .3, false)
mdmg(baton,3,"Blunt")
end
swait(5)
bweld.Part0 = Torso
bweld.C0 = bdefc0
Humanoid.WalkSpeed = 16
tr1.Enabled = false
attack = false
end

function asmek()
attack = true
--local par
--coroutine.wrap(function()
--repeat swait() par = rayCast(RootPart.Position,Vector3.new(0,-1,0),3,chara) until par~=nil or Torso.Velocity.Y == 0
--tr2.Enabled = false
--attack = false
--end)()
--for i=0,1,.2 do
--swait()
--PlayAnimationFromTable({		
--CFrame.new(0, -0.0460019112, -0.0689063296, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
--CFrame.new(0, 1.52556431, -0.222140759, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
--CFrame.new(1.59158015, 0.575856388, 6.13234874e-07, 0.642787039, -0.766044974, -4.38231467e-07, 0.766045034, 0.642787039, 1.78813934e-07, 1.63912773e-07, -4.39584255e-07, 1.00000012),
--CFrame.new(-1.59158027, 0.575856209, 6.13234988e-07, 0.642787039, 0.766044974, 4.38231467e-07, -0.766045034, 0.642787039, 1.78813934e-07, -1.63912773e-07, -4.39584255e-07, 1.00000012),
--CFrame.new(0.499998927, -1.99999928, 3.81469772e-06, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
--CFrame.new(-0.5, -1.41182017, 0.232474089, 1, 0, 0, 0, 0.642786622, 0.766045392, 0, -0.766045392, 0.642786622),
--}, .3, false)
--end
tr2.Enabled = true
so(536642316,RightLeg,1,1)
for i=0,1.5,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.11843279, 0.00109164417, 1, 0, 0, 0, 0.76604414, -0.642788053, 0, 0.642788053, 0.76604414)*CFrame.Angles(math.rad(-360*i),0,0),
CFrame.new(0, 1.36002374, -0.491580963, 1, 0, 0, 0, 0.642787457, 0.766044736, 0, -0.766044736, 0.642787457),
CFrame.new(1.59157825, 0.575854659, 4.30346518e-06, 0.64278698, -0.766045034, -1.0103544e-07, 0.766045094, 0.64278698, -5.36441803e-07, 5.06639481e-07, 2.98023224e-07, 1.00000012),
CFrame.new(-1.59158015, 0.575855613, 2.39611677e-06, 0.64278698, 0.766045034, 1.0103544e-07, -0.766045094, 0.64278698, -5.36441803e-07, -5.06639481e-07, 2.98023224e-07, 1.00000012),
CFrame.new(0.399999022, -1.92074621, -0.716740668, 1, 0, 0, 0, 0.766044736, -0.642787457, 0, 0.642787457, 0.766044736),
CFrame.new(-0.5, -1.41181993, 0.232477784, 1, 0, 0, 0, 0.642787457, 0.766044736, 0, -0.766044736, 0.642787457),
}, .3, false)
if i >= .4 then
mdmg(RightLeg,3.5,"Blunt")
end
end
tr2.Enabled = false
attack = false
end

local shots = 7
zhold = true
function shoot()
attackm = "gun"
attack = true
so(169799883,gun,1,1)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.0524868444, 0, -0.0110093001, 0.64278698, 0, 0.766044974, 0, 1, 0, -0.766044974, 0, 0.64278698),
CFrame.new(-0.0421711877, 1.49999738, -0.0331315249, 0.852868021, -0.0612752885, -0.518518507, 0.17364794, 0.969846606, 0.171008661, 0.492404759, -0.235887513, 0.837791562),
CFrame.new(0.611007333, -0.00932076573, -0.639356554, 0.653100669, 0.696805716, -0.296515375, -0.748181939, 0.533255994, -0.394793421, -0.116975725, 0.479687244, 0.869607329),
CFrame.new(-1.29161143, -0.030067116, -0.0939707607, 0.98480773, -0.163176328, 0.0593894422, 0.173647985, 0.925416648, -0.336824149, 1.78813934e-06, 0.342019945, 0.939692736),
CFrame.new(0.499998003, -2.00000095, 3.84449959e-06, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(-0.499998897, -2.00000095, 1.59442425e-06, 0.98480767, 0, 0.173648536, 0, 1, 0, -0.173648536, 0, 0.98480767),
}, .3, false)
end
Humanoid.WalkSpeed = 2
local ref = Instance.new("Part",chara)
ref.Size = Vector3.new(0,0,0)
ref.Anchored = true
ref.CanCollide = false
ref.Transparency = 1
gweld.Part0 = RightArm
gweld.C0 = CFrame.new(.1,-1.5,-.2)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(-40))
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301527902, -0.171009317, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984806046, 1.48289788, -0.00301507115, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(0.9734447, 0.943128467, -1.04116416, 0.76604414, 0.642788053, 0, 0.219846308, -0.262002349, -0.939692736, -0.604023278, 0.719846129, -0.342019886),
CFrame.new(-0.516993761, 0.475136518, -0.924885869, 0, -0.499998987, 0.866025984, 0.939692736, -0.29619813, -0.171009615, 0.342019886, 0.813798308, 0.469845414),
CFrame.new(0.5, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000238, -1.99999905, 5.96046164e-08, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
swait(5)
repeat
so(470245800,gun,1,1)
ref.CFrame = Mouse.Hit
mdmg(ref,3,"Shot")
local hitpt = Instance.new("Part",EffectModel)
hitpt.Size = Vector3.new(0,0,.3)
local bf = Instance.new("BodyVelocity",hitpt)
bf.P = 10000
bf.MaxForce = Vector3.new(bf.P,bf.P,bf.P)
game:service'Debris':AddItem(bf,.1)
hitpt.CFrame = gun.CFrame * CFrame.new(0,-.5,.5) * CFrame.Angles(math.rad(90),0,0)
bf.Velocity = Vector3.new(0,5,0) + RootPart.CFrame.rightVector*10
local hitm = Instance.new("SpecialMesh",hitpt)
hitm.MeshId = "http://www.roblox.com/asset/?id=94295100"
hitm.TextureId = "http://www.roblox.com/asset/?id=94287792"
hitm.Scale = Vector3.new(3,3,3.5)
coroutine.wrap(function()
swait(120)
for i = 0,1.1 do
swait()
hitpt.Transparency = i
end
hitpt:Destroy()
end)()
Effects.Block.Create(BrickColor.new("Bright yellow"), gun.CFrame*CFrame.new(0,.6,.3), 0,0,0,1,1,1, 0.05)
shots = shots - 1
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301530343, -0.171007201, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984815434, 1.48289728, -0.00301322341, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(0.973445654, 1.13885617, -0.660623372, 0.766044199, 0.642787933, 5.27496837e-08, 0.413175672, -0.492403269, -0.766045034, -0.492404401, 0.586824477, -0.64278698),
CFrame.new(-0.516991675, 0.65931946, -0.711421967, 0, -0.499999166, 0.866025925, 0.766044796, -0.556670487, -0.321393073, 0.642787218, 0.663414717, 0.383021772),
CFrame.new(0.499999523, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000954, -1.99999809, -1.84774399e-06, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301527902, -0.171009317, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984806046, 1.48289788, -0.00301507115, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(0.9734447, 0.943128467, -1.04116416, 0.76604414, 0.642788053, 0, 0.219846308, -0.262002349, -0.939692736, -0.604023278, 0.719846129, -0.342019886),
CFrame.new(-0.516993761, 0.475136518, -0.924885869, 0, -0.499998987, 0.866025984, 0.939692736, -0.29619813, -0.171009615, 0.342019886, 0.813798308, 0.469845414),
CFrame.new(0.5, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000238, -1.99999905, 5.96046164e-08, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
if shots == 0 then
so(147323220,gun,1,1)
for i=0,1.3,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301530343, -0.171007201, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984815434, 1.48289728, -0.00301322341, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(0.973445654, 1.13885617, -0.660623372, 0.766044199, 0.642787933, 5.27496837e-08, 0.413175672, -0.492403269, -0.766045034, -0.492404401, 0.586824477, -0.64278698),
CFrame.new(-1.29161143, -0.030067116, -0.0939707607, 0.98480773, -0.163176328, 0.0593894422, 0.173647985, 0.925416648, -0.336824149, 1.78813934e-06, 0.342019945, 0.939692736),
CFrame.new(0.499999523, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000954, -1.99999809, -1.84774399e-06, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
local MagPartt = New("Part",chara,"MagPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.200000033, 0.399999976, 1),CFrame = CFrame.new(-9.29999638, 0.700002313, -0.200002074, 1, 0, 0, 0, 0, 1, 0, -1, 0),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
MagPartt.CFrame = gun.CFrame * CFrame.new(0,-.5,-.5) * CFrame.Angles(0,0,0)
coroutine.wrap(function()
swait(5)
MagPartt.CanCollide = true
swait(120)
for i = 0,1.1 do
swait()
MagPartt.Transparency = i
end
MagPartt:Destroy()
end)()
swait(10)
local MagPart = New("Part",chara,"MagPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(.2,.4,1),CFrame = CFrame.new(-9.29999638, 0.700002313, -0.200002074, 1, 0, 0, 0, 0, 1, 0, -1, 0),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
local Weld = New("ManualWeld",MagPart,"Weld",{Part0 = MagPart,Part1 = chara["Left Arm"],C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 1, 0)*CFrame.Angles(math.rad(90),math.rad(90),math.rad(0)),C1 = CFrame.new(0.200001717, -1.20000005, -0.200000286, 1, 0, 0, 0, 0, 1, 0, -1, 0),})
for i=0,1.4,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301530343, -0.171007201, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984815434, 1.48289728, -0.00301322341, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(0.973445654, 1.13885617, -0.660623372, 0.766044199, 0.642787933, 5.27496837e-08, 0.413175672, -0.492403269, -0.766045034, -0.492404401, 0.586824477, -0.64278698),
CFrame.new(-0.516991675, 0.65931946, -0.711421967, 0, -0.499999166, 0.866025925, 0.766044796, -0.556670487, -0.321393073, 0.642787218, 0.663414717, 0.383021772),
CFrame.new(0.499999523, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000954, -1.99999809, -1.84774399e-06, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
MagPart:Destroy()
swait(5)
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301530343, -0.171007201, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984815434, 1.48289728, -0.00301322341, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(1.16020393, 0.666379213, -0.905047119, 0.76604414, 0.604023218, 0.219846413, 0.219846308, 0.0751920938, -0.972632408, -0.604023278, 0.793411791, -0.0751917362),
CFrame.new(-0.629211903, 0.930547178, -0.87133497, 0.262002915, -0.642787874, -0.71984607, -0.958213985, -0.262002975, -0.114805877, -0.114805937, 0.71984601, -0.684573948),
CFrame.new(0.499999523, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000954, -1.99999809, -1.84774399e-06, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
so(506273075,gun,1,1)
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301530343, -0.171007201, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984815434, 1.48289728, -0.00301322341, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(1.16020393, 0.666379213, -0.905047119, 0.76604414, 0.604023218, 0.219846413, 0.219846308, 0.0751920938, -0.972632408, -0.604023278, 0.793411791, -0.0751917362),
CFrame.new(-0.629361629, 0.793605626, -0.495871037, 0.262002915, -0.642787874, -0.71984607, -0.958213985, -0.262002975, -0.114805877, -0.114805937, 0.71984601, -0.684573948),
CFrame.new(0.499999523, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000954, -1.99999809, -1.84774399e-06, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301530343, -0.171007201, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984815434, 1.48289728, -0.00301322341, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(1.16020393, 0.666379213, -0.905047119, 0.76604414, 0.604023218, 0.219846413, 0.219846308, 0.0751920938, -0.972632408, -0.604023278, 0.793411791, -0.0751917362),
CFrame.new(-0.629211903, 0.930547178, -0.87133497, 0.262002915, -0.642787874, -0.71984607, -0.958213985, -0.262002975, -0.114805877, -0.114805937, 0.71984601, -0.684573948),
CFrame.new(0.499999523, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000954, -1.99999809, -1.84774399e-06, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
shots = 7
swait(10)
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.0301527902, -0.171009317, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0.0984806046, 1.48289788, -0.00301507115, 0.984807849, 0.173648134, -3.13053391e-07, -0.171010122, 0.969846427, -0.173647895, -0.0301533248, 0.171009824, 0.984807849),
CFrame.new(0.9734447, 0.943128467, -1.04116416, 0.76604414, 0.642788053, 0, 0.219846308, -0.262002349, -0.939692736, -0.604023278, 0.719846129, -0.342019886),
CFrame.new(-0.516993761, 0.475136518, -0.924885869, 0, -0.499998987, 0.866025984, 0.939692736, -0.29619813, -0.171009615, 0.342019886, 0.813798308, 0.469845414),
CFrame.new(0.5, -1.72638702, -0.751741886, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(-0.500000238, -1.99999905, 5.96046164e-08, 1, 0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1),
}, .3, false)
end
end
until zhold == false
swait(5)
ref:Destroy()
so(211134014,gun,1,1)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.0524868444, 0, -0.0110093001, 0.64278698, 0, 0.766044974, 0, 1, 0, -0.766044974, 0, 0.64278698),
CFrame.new(-0.0421711877, 1.49999738, -0.0331315249, 0.852868021, -0.0612752885, -0.518518507, 0.17364794, 0.969846606, 0.171008661, 0.492404759, -0.235887513, 0.837791562),
CFrame.new(0.611007333, -0.00932076573, -0.639356554, 0.653100669, 0.696805716, -0.296515375, -0.748181939, 0.533255994, -0.394793421, -0.116975725, 0.479687244, 0.869607329),
CFrame.new(-1.29161143, -0.030067116, -0.0939707607, 0.98480773, -0.163176328, 0.0593894422, 0.173647985, 0.925416648, -0.336824149, 1.78813934e-06, 0.342019945, 0.939692736),
CFrame.new(0.499998003, -2.00000095, 3.84449959e-06, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(-0.499998897, -2.00000095, 1.59442425e-06, 0.98480767, 0, 0.173648536, 0, 1, 0, -0.173648536, 0, 0.98480767),
}, .3, false)
end
gweld.Part0 = Torso
gweld.C0 = gdefc0
Humanoid.WalkSpeed = 16
attack = false
end

local Jails = Instance.new("Model",chara)
Jails.Name = "Jails"
function arrest()
attack = true
if Mouse.Target~= nil then
local dude = Mouse.Target.Parent
local ply = game:service'Players':GetPlayerFromCharacter(dude)
if dude:FindFirstChildOfClass("Humanoid") then
Humanoid.WalkSpeed = 0
for i,v in pairs(dude:children()) do
if v:IsA("LocalScript") or v:IsA("Tool") then
v:Destroy()
end
end
local haed = dude:FindFirstChild("Head")
local JailCell = New("Model",Jails,"JailCell",{})
local SpawnPart = New("Part",JailCell,"SpawnPart",{Material = Enum.Material.SmoothPlastic,Transparency = 1,Transparency = 1,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-76.1000137, 3.00000596, -1.99999905, 1, 0, 0, 0, 0, 1, 0, -1, 0),Anchored = true,CanCollide = false,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
local removescriptspart = New("Part",JailCell,"removescriptspart",{Transparency = 1,Transparency = 1,Size = Vector3.new(16, 9, 13),CFrame = CFrame.new(-69.5999985, 5.5000062, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,CanCollide = false,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(6, 9, 1),CFrame = CFrame.new(-75.0999985, 5.5000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(19, 1, 16),CFrame = CFrame.new(-69.5999985, 0.50000602, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 4, 1),CFrame = CFrame.new(-68.5999985, 6.0000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(1, 9, 16),CFrame = CFrame.new(-78.5999985, 5.5000062, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-77.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 4, 1),CFrame = CFrame.new(-69.5999985, 6.0000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999946, 0.600000024, 1.60000014),CFrame = CFrame.new(-62.3000031, 2.70000601, 0.600000381, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Dark stone grey"),Material = Enum.Material.Metal,Size = Vector3.new(0.400000006, 0.200000003, 0.800000012),CFrame = CFrame.new(-61.5, 3.10000563, 1.39999962, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.388235, 0.372549, 0.384314),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(35, 1, 6),CFrame = CFrame.new(-69.5999985, 0.50000602, 12, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 2.50000572, 4.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Dark stone grey"),Material = Enum.Material.Metal,Size = Vector3.new(0.400000006, 0.400000006, 0.400000036),CFrame = CFrame.new(-61.2999992, 3.40000558, 1.39999962, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.388235, 0.372549, 0.384314),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 5.5000062, 1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 16),CFrame = CFrame.new(-85.0999985, 0.50000602, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999946, 0.600000024, 1.60000014),CFrame = CFrame.new(-65.8999939, 2.10000563, -4.79999924, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(2, 0.200000003, 2.00000024),CFrame = CFrame.new(-62.1000023, 2.30000591, 1.39999962, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.19999993, 0.600000024, 0.400000036),CFrame = CFrame.new(-65.1000061, 2.10000563, -4.19999886, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(2, 0.600000143, 0.400000155),CFrame = CFrame.new(-61.3000031, 2.70000529, 1.39999962, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999946, 0.600000024, 1.60000014),CFrame = CFrame.new(-62.3000031, 2.70000505, 2.19999886, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Bright blue"),Material = Enum.Material.Granite,Size = Vector3.new(1.19999981, 0.400000036, 1.20000005),CFrame = CFrame.new(-62.1000023, 2.60000587, 1.39999962, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0509804, 0.411765, 0.67451),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Lily white"),Material = Enum.Material.Glass,Reflectance = 1,Size = Vector3.new(2, 2.80000019, 0.200000003),CFrame = CFrame.new(-61.1999969, 5.20000648, 1.40000057, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.929412, 0.917647, 0.917647),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Metal,Size = Vector3.new(0.599999964, 0.200000033, 0.200000003),CFrame = CFrame.new(-64.5999985, 3.70000505, -5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.39999998, 1.20000005, 1.39999998),CFrame = CFrame.new(-61.8000031, 1.6000061, 1.39999962, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.19999993, 0.600000024, 0.400000036),CFrame = CFrame.new(-62.9000015, 2.70000601, 1.3999958, 0, 0, -1, 0, 1, 0, 1, 0, 0),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-71.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(2, 0.200000003, 2.00000024),CFrame = CFrame.new(-65.0999985, 1.70000601, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.39999998, 0.600000024, 1.39999998),CFrame = CFrame.new(-65.0999985, 1.30000627, -5.29999924, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 4, 1),CFrame = CFrame.new(-67.5999985, 6.0000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-74.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 4, 1),CFrame = CFrame.new(-71.5999985, 6.0000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(19, 1, 16),CFrame = CFrame.new(-69.5999985, 10.5000114, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Bright blue"),Material = Enum.Material.Granite,Size = Vector3.new(1.19999981, 0.400000036, 1.20000005),CFrame = CFrame.new(-65.0999985, 2.00000572, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0509804, 0.411765, 0.67451),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-72.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-76.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-75.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(3.99999976, 0.400000095, 6),CFrame = CFrame.new(-76.1000137, 2.6000061, -1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(2, 2.40000033, 0.400000155),CFrame = CFrame.new(-65.0999985, 3.00000525, -5.79999924, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999946, 0.600000024, 1.60000014),CFrame = CFrame.new(-64.3000031, 2.10000491, -4.79999924, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 3),CFrame = CFrame.new(-81.0999985, 0.50000602, -5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-70.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-73.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Dark stone grey"),Material = Enum.Material.Metal,Size = Vector3.new(3.99999976, 0.400000036, 8),CFrame = CFrame.new(-76.1000137, 2.20000601, -2, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.388235, 0.372549, 0.384314),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(1, 9, 16),CFrame = CFrame.new(-60.5999985, 5.5000062, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(-77.5999985, 1.50000584, -5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 4, 1),CFrame = CFrame.new(-70.5999985, 6.0000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(3.99999976, 0.400000095, 2),CFrame = CFrame.new(-76.1000137, 2.6000061, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 4.50000572, 2.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 3.50000572, 3.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 1.50000584, 5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 7.5000062, -0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 6.5000062, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 9.50000572, -2.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 3, 1),CFrame = CFrame.new(-81.0999985, 2.5000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 3),CFrame = CFrame.new(-81.0999985, 0.50000602, 7.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(1, 3, 21),CFrame = CFrame.new(-86.5999985, 2.50000596, 3.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 8.50000572, -1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(6, 9, 1),CFrame = CFrame.new(-64.0999985, 5.5000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(5, 3, 1),CFrame = CFrame.new(-69.5999985, 2.50000572, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(5, 2, 1),CFrame = CFrame.new(-69.5999985, 9.00000572, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-81.0999985, 10.5000114, -3.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-62.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(-74.5999985, 1.50000584, -5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(-74.5999985, 1.50000584, 1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(-77.5999985, 1.50000584, 1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-69.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-66.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-67.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-65.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-68.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-64.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-63.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(1, 9, 1),CFrame = CFrame.new(-61.5999985, 5.5000062, 8.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.5, 1, 0.5),})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 6.5000062, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 2.50000572, 4.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 10.5000114, -3.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 4.50000572, 2.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 3.50000572, 3.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 8.50000572, -1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 9.50000572, -2.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 16),CFrame = CFrame.new(-54.0999985, 0.50000602, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 3),CFrame = CFrame.new(-58.0999985, 0.50000602, -5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 5.5000062, 1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 3),CFrame = CFrame.new(-58.0999985, 0.50000602, 7.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 7.5000062, -0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 1, 1),CFrame = CFrame.new(-58.0999985, 1.50000584, 5.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(1, 3, 21),CFrame = CFrame.new(-52.5999985, 2.50000596, 3.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(4, 3, 1),CFrame = CFrame.new(-58.0999985, 2.5000062, -6.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
Part = New("Part",JailCell,"Part",{Material = Enum.Material.Concrete,Size = Vector3.new(35, 3, 1),CFrame = CFrame.new(-69.5999985, 2.50000596, 14.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),Anchored = true,Locked = true,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
JailCell:MoveTo(pos)
removescriptspart.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= chara then
for i,v in pairs(hit.Parent:children()) do
if v:IsA("LocalScript") or v:IsA("Tool") then
v:Destroy()
end
end
end
end)
    for _, v in pairs(chara:children()) do
      if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
        do
          local p = v:clone()
          p.Name = "trail"
          p.Parent = workspace
          p.Transparency = 0.5
          p.Anchored = true
          p.BrickColor = BrickColor.White()
          p.Material = "Neon"
          p:BreakJoints()
          p.CanCollide = false
		  if v == chara.Head then
		  for a, b in pairs(p:children()) do
		  if b:IsA("Sound") then
		  b:Destroy()
		  end
		  end
		  end
          coroutine.resume(coroutine.create(function()
            for i = 1, 50 do
              swait()
              p.Transparency = i / 50
            end
            p:Destroy()
          end))
        end
      end
      if v.className == "Accessory" then
      end
end
so(1055279036,Torso,1,3)
if haed~=nil then
haed.Anchored = true
Head.CFrame = haed.CFrame*CFrame.new(0,0,-4)*CFrame.Angles(0,math.rad(180),0)
end
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.174721688, 0, -0.147934705, 0.866025388, 0, 0.500000238, 0, 1, 0, -0.500000238, 0, 0.866025388),
CFrame.new(3.35276127e-06, 1.44895828, -0.0894558877, 0.939692616, 3.12924385e-07, -0.342020482, 0.0593909845, 0.98480773, 0.163176119, 0.336824477, -0.173648328, 0.925416529),
CFrame.new(1.5, 0.499998093, -0.40000084, 0.939692676, -0.342020601, 0, 0, 0, -1, 0.342020601, 0.939692676, 0),
CFrame.new(-1.52924228, 0.286380947, -3.51718177e-06, 0.939692855, 0.342019916, 2.08616257e-07, -0.342019856, 0.939692736, -1.5155652e-07, -2.08616257e-07, 8.94069672e-08, 1.00000024),
CFrame.new(0.499998987, -2.00000095, -1.14738941e-06, 0.939692676, 0, -0.342020601, 0, 1, 0, 0.342020601, 0, 0.939692676),
CFrame.new(-0.499998212, -2.00000095, 1.90734909e-06, 1.00000024, 0, 0, 0, 1, 0, 0, 0, 1.00000024),
}, .3, false)
end
chatfunc("You are under arrest! Now face your sentence!")
swait(50)
if _G.Sounds == true then
				local soaa = Instance.new("Sound",haed)
				soaa.Volume = 1
				local cho = math.random(1,5)
				if cho == 1 then
				soaa.SoundId = "rbxassetid://111896685"
				elseif cho == 2 then
				soaa.SoundId = "rbxassetid://535528169"
				elseif cho == 3 then
				soaa.SoundId = "rbxassetid://1080363252"
				elseif cho == 4 then
				soaa.SoundId = "rbxassetid://147758746"
				elseif cho == 5 then
				soaa.SoundId = "rbxassetid://626777433"
				soaa.Volume = .3
				soaa.TimePosition = 1
				end
				game:service'Debris':AddItem(soaa,6)
				soaa:Play()
            end
if haed~=nil then
haed.Anchored = false
end
Humanoid.WalkSpeed = 16
local jc = JailCell
if ply~=nil then
local p = ply
coroutine.wrap(function()
while true do
swait()
if p~=nil and p.Character ~= nil and p.Character:FindFirstChild("Head") and jc ~= nil then
if (p.Character:FindFirstChild("Head").Position - removescriptspart.Position).magnitude >= 10 then
p.Character:FindFirstChild("Head").CFrame = SpawnPart.CFrame*CFrame.new(0,2,0)
end
elseif p==nil then
jc:Destroy()
break
elseif jc==nil then
break
end
end
end)()
coroutine.wrap(function()
while true do
swait()
if p~=nil and p.Character ~= nil then
for i,v in pairs(p.Character:children()) do
if v:IsA("LocalScript") or v:IsA("Tool") then
if v:IsA("LocalScript") then
v.Disabled = true
end
v:Destroy()
end
end
end
end
end)()
p.CharacterAdded:connect(function()
if p~=nil and p.Character ~= nil and p.Character:FindFirstChild("Head") and jc~=nil then
p.Character:FindFirstChild("Head").CFrame = SpawnPart.CFrame*CFrame.new(0,2,0)
end
end)
elseif ply == nil then
coroutine.wrap(function()
local ch = dude
while true do
swait()
if ch ~= nil and ch:FindFirstChild("Head") and jc~=nil and jc:FindFirstChild("SpawnPart")~=nil then
if (ch:FindFirstChild("Head").Position - removescriptspart.Position).magnitude >= 10 then
ch:FindFirstChild("Head").CFrame = SpawnPart.CFrame*CFrame.new(0,2,0)
end
elseif ch.Parent==nil then
jc:Destroy()
break
elseif jc.Parent==nil then
break
end
end
end)()
end
end
end
attack = false
end


qhold = false
justsprinted = false
function sprint()
attack = true
--print("supurinto?")
--justsprinted = true
--coroutine.wrap(function()
--swait(10)
--justsprinted = false
--end)()
repeat
swait()
PlayAnimationFromTable({		
CFrame.new(-2.4138464e-07, 0.123327732, -0.188363045, 1, -4.38293796e-07, 1.20420327e-06, 0, 0.939692736, 0.342019886, -1.28148622e-06, -0.342019916, 0.939692736) * CFrame.new(0, 0- .08 * math.cos((sine/2.5)), 0),
CFrame.new(0, 1.41422474, 0.0894482136, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(1.54809988, 0.041232653, 1.35168499e-08, 0.996376455, -0.0850530341, -3.41060513e-13, 0.0850530341, 0.996376455, 4.47034836e-07, 2.78823862e-08, 3.26637689e-07, 1.00000024) * CFrame.new(0, 0, -.6 * math.cos((sine) / 2.5)) * CFrame.Angles(math.rad(0 + 60 * math.cos((sine) / 2.5)), 0, 0), 
CFrame.new(-1.53598976, 0.0413191095, -1.86092848e-06, 0.995650649, 0.0931596532, -2.61508148e-07, -0.0931649953, 0.995651186, -1.00695124e-05, -7.49969331e-07, 1.08217946e-05, 1.00000024) * CFrame.new(0, 0, .6 * math.cos((sine) / 2.5)) * CFrame.Angles(math.rad(0 - 60 * math.cos((sine) / 2.5)), 0, 0), 
CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ 1 * math.cos((sine) / 2.5)) * CFrame.Angles(math.rad(0 - 60 * math.cos((sine) / 2.5)), 0, 0), 
CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- 1 * math.cos((sine) / 2.5)) * CFrame.Angles(math.rad(0 + 60 * math.cos((sine) / 2.5)), 0, 0), 
}, .3, false)
Humanoid.WalkSpeed = 40
until qhold == false or Torso.Velocity == Vector3.new(0,0,0)
--print'sutoppu'
Humanoid.WalkSpeed = 16
attack = false
end


function movejails()
pos = Mouse.Hit.p
for i,v in pairs(Jails:children()) do
swait(5)
v:MoveTo(pos)
end
end

Mouse.Button1Down:connect(function()
	if attack == false then
attackm = "baton"
	if Anim == "Jump" or Anim == "Fall" then
	asmek()
	else
	smek()
	end
	end
end)

local sprintt = 0


Mouse.KeyDown:connect(function(k)
	k = k:lower()
	if k=='m' then
	if mus.IsPlaying == true then
	mus:Stop()
	elseif mus.IsPaused == true then
	mus:Play()
	end
	end
	if attack == false then
	if k == 'q' then
	qhold = true
	sprint()
	elseif k == 'x' then
	arrest()
	elseif k == 'z' then
	zhold = true
	shoot()
	elseif k == 'p' then
	movejails()
	end
	end
end)


Mouse.KeyUp:connect(function(k)
	k = k:lower()
	if k == 'q' then
	qhold = false
	elseif k == 'z' then
	zhold = false
	end
end)


coroutine.wrap(function()
while 1 do
swait()
if doe <= 360 then
	doe = doe + 2
else
	doe = 0
end
end
end)()
while true do
	swait()
	for i, v in pairs(chara:GetChildren()) do
		if v:IsA("Part") then
			v.Material = "SmoothPlastic"
		elseif v:IsA("Accessory") then
			v:WaitForChild("Handle").Material = "SmoothPlastic"
		end
	end
while true do
swait()
	if sprintt >= 1 then
	sprintt = sprintt - 1
	end
	
	if Head:FindFirstChild("mus")==nil then
        if _G.Sounds == true then
	mus = Instance.new("Sound",Head)
	mus.Name = "mus"
	mus.SoundId = "rbxassetid://345868687"
	mus.Looped = true
	mus.Volume = 1
	mus:Play()
        end
	end
	Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
	velocity = RootPart.Velocity.y
	sine = sine + change
	local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
		if RootPart.Velocity.y > 1 and hit == nil then 
			Anim = "Jump"
			if attack == false then
		PlayAnimationFromTable({
CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
		}, .3, false)
					end
		elseif RootPart.Velocity.y < -1 and hit == nil then 
			Anim = "Fall"
			if attack == false then
		PlayAnimationFromTable({
CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
		}, .3, false)
					end
		elseif Torsovelocity < 1 and hit ~= nil then
			Anim = "Idle"
			if attack == false then
				change = 1
		PlayAnimationFromTable({
CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
CFrame.new(0, 1.49999809, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(0.89930898, -0.180769742, 0.30436784, 0.766043901, 0.642788172, 8.56792951e-07, -0.556670964, 0.663412929, 0.500000715, 0.321393967, -0.383022994, 0.866024971),
CFrame.new(-0.899309754, -0.180769712, 0.304367989, 0.766043901, -0.642788172, -8.56792951e-07, 0.556670964, 0.663412929, 0.500000715, -0.321393967, -0.383022994, 0.866024971),
CFrame.new(0.5, -1.99999893, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
CFrame.new(-0.5, -1.99999893, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
		}, .3, false)
			end
		elseif Torsovelocity > 2 and hit ~= nil then
			Anim = "Walk"
			if attack == false then
		PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 1, -2.21689355e-12, -5.11591203e-13, -2.21689355e-12, 1, 7.74860496e-07, -5.11591203e-13, 7.74860496e-07, 1.00000048) * CFrame.new(0, 0- .08 * math.cos((sine) / 3.5), 0) * CFrame.Angles(0, 0, 0), 
CFrame.new(-2.09923631e-14, 1.48262846, -0.0984891504, 1, -1.42108547e-14, 0, 0, 0.984807491, 0.173649743, 0, -0.173649758, 0.984807491),
CFrame.new(0.89930898, -0.180769742, 0.30436784, 0.766043901, 0.642788172, 8.56792951e-07, -0.556670964, 0.663412929, 0.500000715, 0.321393967, -0.383022994, 0.866024971),
CFrame.new(-0.899309754, -0.180769712, 0.304367989, 0.766043901, -0.642788172, -8.56792951e-07, 0.556670964, 0.663412929, 0.500000715, -0.321393967, -0.383022994, 0.866024971),
CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos((sine) / 5)), 0, 0), 
CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos((sine) / 5)), 0, 0), 
		}, .3, false)
			end
		end
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if Thing[2] == "Shoot" then
						local Look = Thing[1]
						local move = 30
						if Thing[8] == 3 then
							move = 10
						end
						local hit, pos = rayCast(Thing[4], Thing[1], move, m)
						if Thing[10] ~= nil then
							da = pos
							cf2 = CFrame.new(Thing[4], Thing[10].Position)
							cfa = CFrame.new(Thing[4], pos)
							tehCF = cfa:lerp(cf2, 0.2)
							Thing[1] = tehCF.lookVector
						end
						local mag = (Thing[4] - pos).magnitude
						Effects["Head"].Create(Torso.BrickColor, CFrame.new((Thing[4] + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0), 1, mag * 5, 1, 0.5, 0, 0.5, 0.2)
						if Thing[8] == 2 then
							Effects["Ring"].Create(Torso.BrickColor, CFrame.new((Thing[4] + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0) * CFrame.fromEulerAnglesXYZ(1.57, 0, 0), 1, 1, 0.1, 0.5, 0.5, 0.1, 0.1, 1)
						end
						Thing[4] = Thing[4] + Look * move
						Thing[3] = Thing[3] - 1
						if 2 < Thing[5] then
							Thing[5] = Thing[5] - 0.3
							Thing[6] = Thing[6] - 0.3
						end
						if hit ~= nil then
							Thing[3] = 0
							if Thing[8] == 1 or Thing[8] == 3 then
								Damage(hit, hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, "", 1)
							else
								if Thing[8] == 2 then
									Damage(hit, hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, "", 1)
									if (hit.Parent:FindFirstChildOfClass("Humanoid")) ~= nil or (hit.Parent.Parent:FindFirstChildOfClass("Humanoid")) ~= nil then
										ref = CFuncs.Part.Create(workspace, "Neon", 0, 1, BrickColor.new("Really red"), "Reference", Vector3.new())
										ref.Anchored = true
										ref.CFrame = CFrame.new(pos)
                                        if _G.Sounds == true then
										CFuncs["Sound"].Create("161006093", ref, 1, 1.2)
                                        end
										game:GetService("Debris"):AddItem(ref, 0.2)
										Effects["Block"].Create(Torso.BrickColor, CFrame.new(ref.Position) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 10, 10, 10, 0.1, 2)
										Effects["Ring"].Create(BrickColor.new("Bright yellow"), CFrame.new(ref.Position) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 0.1, 4, 4, 0.1, 0.1)
										MagnitudeDamage(ref, 15, Thing[5] / 1.5, Thing[6] / 1.5, 0, "Normal", "", 1)
									end
								end
							end
							ref = CFuncs.Part.Create(workspace, "Neon", 0, 1, BrickColor.new("Really red"), "Reference", Vector3.new())
							ref.Anchored = true
							ref.CFrame = CFrame.new(pos)
							Effects["Sphere"].Create(Torso.BrickColor, CFrame.new(pos), 5, 5, 5, 1, 1, 1, 0.07)
							game:GetService("Debris"):AddItem(ref, 1)
						end
						if Thing[3] <= 0 then
							table.remove(Effects, e)
						end
					end
					do
						do
							if Thing[2] == "FireWave" then
								if Thing[3] <= Thing[4] then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(0, 1, 0)
									Thing[3] = Thing[3] + 1
									Thing[6].Scale = Thing[6].Scale + Vector3.new(Thing[5], 0, Thing[5])
								else
									Part.Parent = nil
									table.remove(Effects, e)
								end
							end
							if Thing[2] ~= "Shoot" and Thing[2] ~= "Wave" and Thing[2] ~= "FireWave" then
								if Thing[1].Transparency <= 1 then
									if Thing[2] == "Block1" then
										Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
										Mesh = Thing[7]
										Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
										Thing[1].Transparency = Thing[1].Transparency + Thing[3]
									else
										if Thing[2] == "Block2" then
											Thing[1].CFrame = Thing[1].CFrame
											Mesh = Thing[7]
											Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
											Thing[1].Transparency = Thing[1].Transparency + Thing[3]
										else
											if Thing[2] == "Fire" then
												Thing[1].CFrame = CFrame.new(Thing[1].Position) + Vector3.new(0, 0.2, 0)
												Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
												Thing[1].Transparency = Thing[1].Transparency + Thing[3]
											else
												if Thing[2] == "Cylinder" then
													Mesh = Thing[7]
													Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
													Thing[1].Transparency = Thing[1].Transparency + Thing[3]
												else
													if Thing[2] == "Blood" then
														Mesh = Thing[7]
														Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 0.5, 0)
														Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
														Thing[1].Transparency = Thing[1].Transparency + Thing[3]
													else
														if Thing[2] == "Elec" then
															Mesh = Thing[10]
															Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
															Thing[1].Transparency = Thing[1].Transparency + Thing[3]
														else
															if Thing[2] == "Disappear" then
																Thing[1].Transparency = Thing[1].Transparency + Thing[3]
															else
																if Thing[2] == "Shatter" then
														Thing[1].Transparency = Thing[1].Transparency + Thing[3]
														Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
														Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
														Thing[6] = Thing[6] + Thing[5]
																end
															end
														end
													end
												end
											end
										end
									end
								else
									Part.Parent = nil
									table.remove(Effects, e)
								end
							end
						end
					end
				end
			end
		end
	end
end
end
print("Loaded")
end)
Section:NewButton("FE Glove and Sword", "you get a glove and sword", function()
--5197851188
game.Players:Chat("-gh 9239416688")
wait(0.8)
GlobalFunctions = {}
GlobalFunctions = {}
local Global = (getgenv and getgenv()) or _G
if not Global.FlingPart then Global.FlingPart = "HumanoidRootPart" end
if not Global.Noclip then Global.Noclip = true end
if not Global.HatCollide then Global.HatCollide = false end
--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity)
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        local unit = realPartVelocity.Unit
        if (unit.Y > 0.25) or (unit.Y < -0.75) then
            return realPartVelocity * (25.1 / realPartVelocity.Y)
        end
        realPartVelocity = unit * 125
    end
    return (realPartVelocity * Vector3_101) + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local healthHide = true --moves your head under map every 3 seconds so players dont see your health bar
local noclipAllParts = Global.Noclip --set it to true if you want noclip
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = Global.HatCollide --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
method = 3
if Global.HatCollide == true then
method = 0
else
method = 3
end
print(method)
--local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs

local alignmode = 4 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false
--4 - CFrame (if u dont have the isnetworkowner function it will use alignmode 2)
local flingpart = Global.FlingPart --name of the part or the hat used for flinging
--the fling function
--usage: fling(target, duration, velocity)
--target can be set to: basePart, CFrame, Vector3, character model or humanoid (flings at mouse.Hit if argument not provided))
--duration (fling time in seconds) can be set to: a number or a string convertable to the number (0.5s if not provided),
--velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
    return
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
        c = nil
    end
end)

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

if type(getNetlessVelocity) ~= "function" then
    getNetlessVelocity = nil
end

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad
local ino = fenv.isnetworkowner or fenv.is_network_owner or fenv.isnetowner or fenv.is_net_owner

if (alignmode == 4) and (not ino) then
    alignmode = 2
end

local physp = PhysicalProperties.new(0.01, 0, 1, 0, 0)
local function align(Part0, Part1)
    
    local att0 = Instance.new("Attachment")
    att0.Orientation = v3_0
    att0.Position = v3_0
    att0.Name = "att0_" .. Part0.Name
    local att1 = Instance.new("Attachment")
    att1.Orientation = v3_0
    att1.Position = v3_0
    att1.Name = "att1_" .. Part1.Name
    
    if alignmode == 4 then
    
        local con = nil
        local rot, angles = math.rad(0.05), CFrame.Angles
        con1 = heartbeat:Connect(function()
            if Part0 and Part1 and att1 then
                if ino(Part0) then
                    Part0.CFrame = Part1.CFrame * att1.CFrame * angles(0, 0, rot)
                    rot = -rot
                end
            else
                con:Disconnect()
            end
        end)
    
    else
        
        Part0.CustomPhysicalProperties = physp
        if (alignmode == 1) or (alignmode == 2) then
            local ape = Instance.new("AlignPosition", att0)
            ape.ApplyAtCenterOfMass = false
            ape.MaxForce = inf
            ape.MaxVelocity = inf
            ape.ReactionForceEnabled = false
            ape.Responsiveness = 200
            ape.Attachment1 = att1
            ape.Attachment0 = att0
            ape.Name = "AlignPositionRtrue"
            ape.RigidityEnabled = true
        end
        
        if (alignmode == 2) or (alignmode == 3) then
            local apd = Instance.new("AlignPosition", att0)
            apd.ApplyAtCenterOfMass = false
            apd.MaxForce = inf
            apd.MaxVelocity = inf
            apd.ReactionForceEnabled = false
            apd.Responsiveness = 200
            apd.Attachment1 = att1
            apd.Attachment0 = att0
            apd.Name = "AlignPositionRfalse"
            apd.RigidityEnabled = false
        end
        
        local ao = Instance.new("AlignOrientation", att0)
        ao.MaxAngularVelocity = inf
        ao.MaxTorque = inf
        ao.PrimaryAxisOnly = false
        ao.ReactionTorqueEnabled = false
        ao.Responsiveness = 200
        ao.Attachment1 = att1
        ao.Attachment0 = att0
        ao.RigidityEnabled = false
    
    end

    if getNetlessVelocity then
        local vel = Part0.Velocity
        local con0, con1 = nil, nil
        if alignmode == 4 then
            con0 = stepped:Connect(function(_, delta)
                if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                Part0.RotVelocity = Part1.RotVelocity
            end)
            con1 = heartbeat:Connect(function()
                if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                Part0.Velocity = getNetlessVelocity(Part1.Velocity)
            end)
        else
            con0 = renderstepped:Connect(function()
                if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                Part0.Velocity = vel
            end)
            con1 = heartbeat:Connect(function()
                if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                vel = Part0.Velocity
                Part0.Velocity = getNetlessVelocity(Part1.Velocity)
            end)
        end
    end
    
    att0:GetPropertyChangedSignal("Parent"):Connect(function()
        Part0 = att0.Parent
        if not Part0:IsA("BasePart") then
            att0 = nil
            Part0 = nil
        end
    end)
    att0.Parent = Part0
    
    att1:GetPropertyChangedSignal("Parent"):Connect(function()
        Part1 = att1.Parent
        if not Part1:IsA("BasePart") then
            att1 = nil
            Part1 = nil
        end
    end)
    att1.Parent = Part1
end

local function respawnrequest()
    local ccfr = ws.CurrentCamera.CFrame
    local c = lp.Character
    lp.Character = nil
    lp.Character = c
    local con = nil
    con = ws.CurrentCamera.Changed:Connect(function(prop)
        if (prop ~= "Parent") and (prop ~= "CFrame") then
            return
        end
        ws.CurrentCamera.CFrame = ccfr
        con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

if shp and (simradius == "shp") then
    spawn(function()
        while c and heartbeat:Wait() do
            shp(lp, "SimulationRadius", inf)
        end
    end)
elseif ssr and (simradius == "ssr") then
    spawn(function()
        while c and heartbeat:Wait() do
            ssr(inf)
        end
    end)
end

antiragdoll = antiragdoll and function(v)
    if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
        v.Parent = nil
    end
end

if antiragdoll then
    for i, v in pairs(c:GetDescendants()) do
        antiragdoll(v)
    end
    c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
    respawnrequest()
end

if method == 0 then
    wait(loadtime)
    if not c then
        return
    end
end

if discharscripts then
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("LocalScript") then
            v.Disabled = true
        end
    end
elseif newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate and (not animate.Disabled) then
        animate.Disabled = true
    else
        newanimate = false
    end
end

if addtools then
    for i, v in pairs(addtools:GetChildren()) do
        if v:IsA("Tool") then
            v.Parent = c
        end
    end
end

pcall(function()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
workspace.FallenPartsDestroyHeight = 0/0
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
    if v.ClassName == "Script" then
        table.insert(OLDscripts, v)
    end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
    if v:IsA("BasePart") then
        local newName = tostring(i)
        local exists = true
        while exists do
            exists = false
            for i, v in pairs(OLDscripts) do
                if v.Name == newName then
                    exists = true
                end
            end
            if exists then
                newName = newName .. "_"    
            end
        end
        table.insert(scriptNames, newName)
        Instance.new("Script", v).Name = newName
    end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
    for i, v in pairs(hum:GetPlayingAnimationTracks()) do
        v:Stop()
    end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    anything:Destroy()
end

local model = Instance.new("Model", c)
model:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (model and model.Parent) then
        model = nil
    end
end)

for i, v in pairs(c:GetChildren()) do
    if v ~= model then
        if addtools and v:IsA("Tool") then
            for i1, v1 in pairs(v:GetDescendants()) do
                if v1 and v1.Parent and v1:IsA("BasePart") then
                    local bv = Instance.new("BodyVelocity", v1)
                    bv.Velocity = v3_0
                    bv.MaxForce = v3(1000, 1000, 1000)
                    bv.P = 1250
                    bv.Name = "bv_" .. v.Name
                end
            end
        end
        v.Parent = model
    end
end

if breakjoints then
    model:BreakJoints()
else
    if head and torso then
        for i, v in pairs(model:GetDescendants()) do
            if v:IsA("JointInstance") then
                local save = false
                if (v.Part0 == torso) and (v.Part1 == head) then
                    save = true
                end
                if (v.Part0 == head) and (v.Part1 == torso) then
                    save = true
                end
                if save then
                    if hedafterneck then
                        hedafterneck = v
                    end
                else
                    v:Destroy()
                end
            end
        end
    end
    if method == 3 then
        task.delay(loadtime, pcall, model.BreakJoints, model)
    end
end

for i, v in pairs(cl:GetChildren()) do
    v.Parent = c
end
cl:Destroy()

local uncollide, noclipcon = nil, nil
if noclipAllParts then
    uncollide = function()
        if c then
            for i, v in pairs(c:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end
        else
            noclipcon:Disconnect()
        end
    end
else
    uncollide = function()
        if model then
            for i, v in pairs(model:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end
        else
            noclipcon:Disconnect()
        end
    end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
    if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
        local Part0 = scr.Parent
        if Part0:IsA("BasePart") then
            for i1, scr1 in pairs(c:GetDescendants()) do
                if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                    local Part1 = scr1.Parent
                    if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                        align(Part0, Part1)
                        scr:Destroy()
                        scr1:Destroy()
                        break
                    end
                end
            end
        end
    end
end

for i, v in pairs(c:GetDescendants()) do
    if v and v.Parent and (not v:IsDescendantOf(model)) then
        if v:IsA("Decal") then
            v.Transparency = 1
        elseif v:IsA("BasePart") then
            v.Transparency = 1
            v.Anchored = false
        elseif v:IsA("ForceField") then
            v.Visible = false
        elseif v:IsA("Sound") then
            v.Playing = false
        elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
            v.Enabled = false
        end
    end
end

if newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate then
        animate.Disabled = false
    end
end

if addtools then
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("Tool") then
            v.Parent = addtools
        end
    end
end

local hum0, hum1 = model:FindFirstChildOfClass("Humanoid"), c:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum0 and hum0.Parent) then
            hum0 = nil
        end
    end)
end
if hum1 then
    hum1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum1 and hum1.Parent) then
            hum1 = nil
        end
    end)

    ws.CurrentCamera.CameraSubject = hum1
    local camSubCon = nil
    local function camSubFunc()
        camSubCon:Disconnect()
        if c and hum1 then
            ws.CurrentCamera.CameraSubject = hum1
        end
    end
    camSubCon = renderstepped:Connect(camSubFunc)
    if hum0 then
        hum0:GetPropertyChangedSignal("Jump"):Connect(function()
            if hum1 then
                hum1.Jump = hum0.Jump
            end
        end)
    else
        respawnrequest()
    end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
    rb:Destroy()
    sg:SetCore("ResetButtonCallback", true)
    if destroyhum then
        if c then c:BreakJoints() end
        return
    end
    if model and hum0 and (hum0.Health > 0) then
        model:BreakJoints()
        hum0.Health = 0
    end
    if antirespawn then
        respawnrequest()
    end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
    while wait() and c do
        if hum0 and hum1 then
            hum1.Jump = hum0.Jump
        end
    end
    sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
    if part then
        local cfr = part.CFrame
        local R6parts = { 
            head = {
                Name = "Head",
                Size = v3(2, 1, 1),
                R15 = {
                    Head = 0
                }
            },
            torso = {
                Name = "Torso",
                Size = v3(2, 2, 1),
                R15 = {
                    UpperTorso = 0.2,
                    LowerTorso = -0.8
                }
            },
            root = {
                Name = "HumanoidRootPart",
                Size = v3(2, 2, 1),
                R15 = {
                    HumanoidRootPart = 0
                }
            },
            leftArm = {
                Name = "Left Arm",
                Size = v3(1, 2, 1),
                R15 = {
                    LeftHand = -0.849,
                    LeftLowerArm = -0.174,
                    LeftUpperArm = 0.415
                }
            },
            rightArm = {
                Name = "Right Arm",
                Size = v3(1, 2, 1),
                R15 = {
                    RightHand = -0.849,
                    RightLowerArm = -0.174,
                    RightUpperArm = 0.415
                }
            },
            leftLeg = {
                Name = "Left Leg",
                Size = v3(1, 2, 1),
                R15 = {
                    LeftFoot = -0.85,
                    LeftLowerLeg = -0.29,
                    LeftUpperLeg = 0.49
                }
            },
            rightLeg = {
                Name = "Right Leg",
                Size = v3(1, 2, 1),
                R15 = {
                    RightFoot = -0.85,
                    RightLowerLeg = -0.29,
                    RightUpperLeg = 0.49
                }
            }
        }
        for i, v in pairs(c:GetChildren()) do
            if v:IsA("BasePart") then
                for i1, v1 in pairs(v:GetChildren()) do
                    if v1:IsA("Motor6D") then
                        v1.Part0 = nil
                    end
                end
            end
        end
        part.Archivable = true
        for i, v in pairs(R6parts) do
            local part = part:Clone()
            part:ClearAllChildren()
            part.Name = v.Name
            part.Size = v.Size
            part.CFrame = cfr
            part.Anchored = false
            part.Transparency = 1
            part.CanCollide = false
            for i1, v1 in pairs(v.R15) do
                local R15part = gp(c, i1, "BasePart")
                local att = gp(R15part, "att1_" .. i1, "Attachment")
                if R15part then
                    local weld = Instance.new("Weld", R15part)
                    weld.Name = "Weld_" .. i1
                    weld.Part0 = part
                    weld.Part1 = R15part
                    weld.C0 = cf(0, v1, 0)
                    weld.C1 = cf(0, 0, 0)
                    R15part.Massless = true
                    R15part.Name = "R15_" .. i1
                    R15part.Parent = part
                    if att then
                        att.Parent = part
                        att.Position = v3(0, v1, 0)
                    end
                end
            end
            part.Parent = c
            R6parts[i] = part
        end
        local R6joints = {
            neck = {
                Parent = R6parts.torso,
                Name = "Neck",
                Part0 = R6parts.torso,
                Part1 = R6parts.head,
                C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            rootJoint = {
                Parent = R6parts.root,
                Name = "RootJoint" ,
                Part0 = R6parts.root,
                Part1 = R6parts.torso,
                C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            rightShoulder = {
                Parent = R6parts.torso,
                Name = "Right Shoulder",
                Part0 = R6parts.torso,
                Part1 = R6parts.rightArm,
                C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            leftShoulder = {
                Parent = R6parts.torso,
                Name = "Left Shoulder",
                Part0 = R6parts.torso,
                Part1 = R6parts.leftArm,
                C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            rightHip = {
                Parent = R6parts.torso,
                Name = "Right Hip",
                Part0 = R6parts.torso,
                Part1 = R6parts.rightLeg,
                C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            leftHip = {
                Parent = R6parts.torso,
                Name = "Left Hip" ,
                Part0 = R6parts.torso,
                Part1 = R6parts.leftLeg,
                C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            }
        }
        for i, v in pairs(R6joints) do
            local joint = Instance.new("Motor6D")
            for prop, val in pairs(v) do
                joint[prop] = val
            end
            R6joints[i] = joint
        end
        if hum1 then
            hum1.RigType = Enum.HumanoidRigType.R6
            hum1.HipHeight = 0
        end
    end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
    local conNeck = nil
    local conTorso = nil
    local contorso1 = nil
    local aligns = {}
    local function enableAligns()
        conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
        for i, v in pairs(aligns) do
            v.Enabled = true
        end
    end
    conNeck = hedafterneck.Changed:Connect(function(prop)
        if table.find({"Part0", "Part1", "Parent"}, prop) then
            enableAligns()
        end
    end)
    conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    for i, v in pairs(head:GetDescendants()) do
        if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
            i = tostring(i)
            aligns[i] = v
            v:GetPropertyChangedSignal("Parent"):Connect(function()
                aligns[i] = nil
            end)
            v.Enabled = false
        end
    end
end

local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")
GlobalFunctions.fling = function() end
if flingpart0 and flingpart1 then
    flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart0 and flingpart0.Parent) then
            flingpart0 = nil
            GlobalFunctions.fling = function() end
        end
    end)
    flingpart0.Archivable = true
    flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart1 and flingpart1.Parent) then
            flingpart1 = nil
            GlobalFunctions.fling = function() end
        end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att0 and att0.Parent) then
                att0 = nil
                GlobalFunctions.fling = function() end
            end
        end)
        att1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att1 and att1.Parent) then
                att1 = nil
                GlobalFunctions.fling = function() end
            end
        end)
        local lastfling = nil
        local mouse = lp:GetMouse()
        GlobalFunctions.fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    target = target.Parent
                    if not (target and target:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                target = mouse.Hit
                if target then
                    target = target.Position
                else
                    return
                end
            end
            if target.Y < ws.FallenPartsDestroyHeight + 5 then
                target = v3(target.X, ws.FallenPartsDestroyHeight + 5, target.Z)
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Position = target
            flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (flingpart and flingpart.Parent) then
                    flingpart = nil
                end
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            local con = nil
            local rotchg = v3(0, rotVelocity.Unit.Y * -1000, 0)
            con = heartbeat:Connect(function(delta)
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart.Orientation += rotchg * delta
                    flingpart0.RotVelocity = rotVelocity
                else
                    con:Disconnect()
                end
            end)
            if alignmode ~= 4 then
                local con = nil
                con = renderstepped:Connect(function()
                    if flingpart0 and target then
                        flingpart0.RotVelocity = v3_0
                    else
                        con:Disconnect()
                    end
                end)
            end
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end

--[[NIGHTOWLACE_WEAPONRY]]--
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
wait(1 / 60)
Effects = { }
local Player = game.Players.localPlayer
local Character = Player.Character
local Humanoid = Character.Humanoid
Humanoid.WalkSpeed = 25
local mouse = Player:GetMouse()
local m = Instance.new('Model', Character)
m.Name = "WeaponModel"
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local cam = game.Workspace.CurrentCamera
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local equipped = false
local attack = false
local Anim = 'Idle'
local idle = 0
local attacktype = 1
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local grabbed = false
local cn = CFrame.new
local mr = math.rad
local angles = CFrame.Angles
local ud = UDim2.new
local c3 = Color3.new

local NeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)

function clerp(a, b, t)
	return a:lerp(b, t)
end

--[[Credits to SazErenos for his Artificial Heartbeat]]--

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 30
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
local Mode = "Normal"
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

--[[ Credits to Fenrier for Outline-Remover, Part, Mesh, Weld, Raycase and Sound Creation functions ]]--

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
	
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
	
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld"){
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1,
	}
	return Weld
end

function CreateBillBoardGui(Img, Pos, Siz) --returns a basic billboard gui object for further manipulation
	local billpar = Create("Part"){
		Transparency = 1,
		Size = Vector3.new(1, 1, 1),
		Anchored = true,
		CanCollide = false,
		CFrame = CFrame.new(Pos),
		Name = "BillboardGuiPart",
	}
	local bill = Create("BillboardGui"){
		Parent = billpar,
		Adornee = billpar,
		Size = UDim2.new(1, 0, 1, 0),
		SizeOffset = Vector2.new(Siz, Siz),
	}
	local d = Create("ImageLabel"){
		Parent = bill,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Image = Img,
	}
	return billpar
end

function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function CreateSound(id, par, vol, pit) 
	coroutine.resume(coroutine.create(function()
		local S = Create("Sound"){
			Volume = vol,
			Pitch = pit or 1,
			SoundId = id,
			Parent = par or workspace,
		}
		swait() 
		S:play() 
		game:GetService("Debris"):AddItem(S, 6)
	end))
end

local function GetNearest(obj, distance)
	local last, lastx = distance + 1
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA'Model' and v ~= Character and v:findFirstChild('Humanoid') and v:findFirstChild('Torso') and v:findFirstChild('Humanoid').Health > 0 then
			local t = v.Torso
			local dist = (t.Position - obj.Position).magnitude
			if dist <= distance then
				if dist < last then
					last = dist
					lastx = v
				end
			end
		end
	end
	return lastx
end
local Target = nil
--[[ Credits to Kert109 (Ninja_Deer) for the Damage function. Fenrier for the Magnitude Damage ]]--

function Damage(hit, damage, cooldown, Color1, Color2, HSound, HPitch)
	for i, v in pairs(hit:GetChildren()) do 
		if v:IsA("Humanoid") and hit.Name ~= Character.Name and hit ~= Character and hit ~= Character.Model then
			local find = v:FindFirstChild("DebounceHit")
			if not find then
				if v.Parent:findFirstChild("Head") then
					Target = hit
					local BillG = Create("BillboardGui"){
						Parent = v.Parent.Head,
						Size = UDim2.new(1, 0, 1, 0),
						Adornee = v.Parent.Head,
						StudsOffset = Vector3.new(math.random(-3, 3), math.random(3, 5), math.random(-3, 3)),
					}
					local TL = Create("TextLabel"){
						Parent = BillG,
						Size = UDim2.new(3, 3, 3, 3),
						BackgroundTransparency = 1,
						Text = tostring(damage).."-",
						TextColor3 = Color1.Color,
						TextStrokeColor3 = Color2.Color,
						TextStrokeTransparency = 1,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						FontSize = Enum.FontSize.Size18,
						Font = "ArialBold",
					}
					coroutine.resume(coroutine.create(function()
						swait(1)
						for i = 0, 1, .1 do
							swait(.1)
							BillG.StudsOffset = BillG.StudsOffset + Vector3.new(0, .1, 0)
						end
						BillG:Destroy()
					end))
				end
                
				--v.Health = v.Health - damage
				local bool = Create("BoolValue"){
					Parent = v,
					Name = "DebounceHit",
				}
				if HSound ~= nil and HPitch ~= nil then
					CreateSound(HSound, hit, 1, HPitch) 
				end
				game:GetService("Debris"):AddItem(bool, cooldown)

				--Target = nil
			end


		end
	end
end

function MagnitudeDamage(Part, magni, mindam, maxdam, Color1, Color2, HSound, HPitch)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= magni and c.Name ~= Player.Name and c ~= Character and c ~= Character.Model then 
					Damage(head.Parent, math.random(mindam, maxdam), 0, Color1, Color2, HSound, HPitch)
				end
			end
		end
	end
end

Handle = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "Handle", Vector3.new(3.20000005, 0.320000023, 0.200000003))
HandleWeld = CreateWeld(m, Character["Torso"], Handle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-3.57640076, -0.105987549, -0.672006607, 0.866025388, 0.500000119, -8.94076351e-008, -0.500000119, 0.866025388, 1.49014454e-007, 1.51936518e-007, -8.43464605e-008, 1))
CreateMesh("BlockMesh", Handle, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.800000072))
FakeHandle = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "FakeHandle", Vector3.new(1.92000008, 0.320000023, 0.200000003))
FakeHandleWeld = CreateWeld(m, Handle, FakeHandle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012, 0, 0, 0, 1))
BladeHitbox = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "BladeHitbox", Vector3.new(6.87999964, 1.28000009, 0.320000023))
BladeHitboxWeld = CreateWeld(m, FakeHandle, BladeHitbox, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(5.83992767, 7.62939453e-006, 0.00178432465, 1.00000012, 0, 1.78815313e-007, 0, -1.00000012, 2.0861782e-007, 1.78815299e-007, -2.0861782e-007, -1))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "BladePrt", Vector3.new(6.71999979, 0.640000045, 0.200000003))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-5.75999451, 0.320018768, -9.53674316e-007, -1.00000012, 0, -6.70215812e-008, 0, -1.00000012, 3.87433118e-007, -6.70215812e-008, 3.87433118e-007, 1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.0104, 0.0104, 0.00800000038))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "BladePrt", Vector3.new(4.96000051, 0.320000023, 0.480000019))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-5.35999298, 0.176017761, -9.53674316e-007, -1.00000012, 0, -8.74827464e-008, 0, -1.00000012, 4.61938924e-007, -8.74827464e-008, 4.61938953e-007, 1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.00879999995, 0.00560000027, 0.0160000008))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "BladePrt", Vector3.new(6.71999979, 0.320000023, 0.200000003))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-5.75999451, 0.159992218, 9.53674316e-007, -1, 1.49011612e-007, -9.26303798e-008, 1.49011612e-007, 1, -4.17235356e-007, 9.26303159e-008, -4.17235412e-007, -1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.00960000046, 0.00520000001, 0.00960000046))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "BladePrt", Vector3.new(6.71999979, 0.320000023, 0.200000003))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-5.75999451, 0.160015106, 0, -1.00000012, 0, -8.7701622e-008, 0, -1.00000012, 3.87433118e-007, -8.7701622e-008, 3.87433118e-007, 1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.00960000046, 0.00520000001, 0.00960000046))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "BladePrt", Vector3.new(4.32000065, 0.200000003, 0.480000019))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-4.5599823, 0.0879821777, 0, -1.00000012, 0, -8.89660754e-008, 0, 1.00000012, -5.36444873e-007, 8.89660896e-008, -5.36444816e-007, -1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.0064000003, 0.00320000015, 0.0200000014))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "BladePrt", Vector3.new(4.96000004, 0.320000023, 0.480000019))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-5.36000061, 0.167987823, 9.53674316e-007, -1, 1.49011612e-007, -9.26303798e-008, 1.49011612e-007, 1, -4.17235356e-007, 9.26303159e-008, -4.17235412e-007, -1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.00879999995, 0.00560000027, 0.0160000008))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "BladePrt", Vector3.new(6.71999979, 0.640000045, 0.200000003))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-5.76000214, 0.319988251, -9.53674316e-007, -1.00000012, 2.68220901e-007, -1.42108547e-014, 2.68220901e-007, 1.00000012, -2.9802888e-007, -6.59472477e-014, -2.9802888e-007, -1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.0104, 0.0104, 0.00800000038))
BladePrt = CreatePart(m, Enum.Material.SmoothPlastic, 0, 1, "Really black", "BladePrt", Vector3.new(4.32000065, 0.200000003, 0.480000019))
BladePrtWeld = CreateWeld(m, FakeHandle, BladePrt, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-4.5599823, 0.112014771, -9.53674316e-007, -1.00000012, 0, -8.74827464e-008, 0, -1.00000012, 4.61938924e-007, -8.74827464e-008, 4.61938953e-007, 1))
CreateMesh("SpecialMesh", BladePrt, Enum.MeshType.FileMesh, "rbxassetid://433431848", Vector3.new(0, 0, 0), Vector3.new(0.0064000003, 0.00320000015, 0.0200000014))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.200000003, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-1.59932709, 0.159358978, 1.23977661e-005, 1.00000012, 0, 0, 0, -1.00000012, 0, 0, 0, -1))
CreateMesh("SpecialMesh", Part, Enum.MeshType.Sphere, "", Vector3.new(0, 0, 0), Vector3.new(0.800000072, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.59998322, 0.0799942017, -9.53674316e-007, -1, 1.49011612e-007, -9.10118445e-007, 1.49011612e-007, 1, -5.66248389e-007, 9.10118445e-007, -5.66248559e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-1.59931946, -0.160633087, 1.23977661e-005, 1.00000012, 0, 0, 0, -1.00000012, 0, 0, 0, -1))
CreateMesh("SpecialMesh", Part, Enum.MeshType.Sphere, "", Vector3.new(0, 0, 0), Vector3.new(0.800000072, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(3.20000005, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.62939453e-006, 0.079990387, 0, 1.00000012, 0, 0, 0, 1.00000012, 0, 0, 0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 0.960000038, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.83992767, 1.14440918e-005, 0.00178432465, 1.00000012, 0, 1.78815313e-007, 0, -1.00000012, 2.0861782e-007, 1.78815299e-007, -2.0861782e-007, -1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.800000072, 1, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.320000023, 3.20000005, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.160007477, 7.62939453e-006, 0, 0, -1.00000012, 0, -1.00000012, 0, 1.42108547e-014, -1.42108547e-014, 7.10542736e-015, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(3.20000005, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, -0.0800018311, 0, 1.00000012, 0, 0, 0, 1.00000012, 0, 0, 0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.320007324, 1.6799469, -1.90734863e-006, -5.66244125e-007, -1, 5.23353265e-007, 1, -5.66244125e-007, 7.59964848e-007, -7.59964678e-007, 5.23353719e-007, 1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.320000023, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.59998322, -0.0799980164, -9.53674316e-007, -1, 1.49011612e-007, -9.10118445e-007, 1.49011612e-007, 1, -5.66248389e-007, 9.10118445e-007, -5.66248559e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.319988251, 1.67993927, -1.90734863e-006, -5.66244125e-007, -1, 5.23353265e-007, 1, -5.66244125e-007, 7.59964848e-007, -7.59964678e-007, 5.23353719e-007, 1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 3.20000005, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.159992218, 1.52587891e-005, 0, 0, -1.00000012, 0, -1.00000012, 0, 1.42108547e-014, -1.42108547e-014, 7.10542736e-015, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.800000072))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.320000023, 0.320000023, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.480003357, -2.07992554, 0.00178527832, 3.87430191e-007, -1, 8.24703648e-007, -1, -3.87430191e-007, -7.15261194e-007, 7.15261535e-007, -8.2470342e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.480003357, -1.8399353, 0.00178527832, 3.87430191e-007, -1, 8.24703648e-007, -1, -3.87430191e-007, -7.15261194e-007, 7.15261535e-007, -8.2470342e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.320000023, 0.320000023, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.479980469, -2.07992554, 0.00178527832, 3.87430191e-007, -1, 8.24703648e-007, -1, -3.87430191e-007, -7.15261194e-007, 7.15261535e-007, -8.2470342e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.320000023, 0.960000038, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.07992554, 1.52587891e-005, 0.00178432465, 1.00000012, 0, 1.78815313e-007, 0, -1.00000012, 2.0861782e-007, 1.78815299e-007, -2.0861782e-007, -1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.480003357, -2.3199234, 0.00178527832, 3.87430191e-007, -1, 8.24703648e-007, -1, -3.87430191e-007, -7.15261194e-007, 7.15261535e-007, -8.2470342e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 0.960000038, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.31991577, 1.14440918e-005, 0.00178432465, 1.00000012, 0, 1.78815313e-007, 0, -1.00000012, 2.0861782e-007, 1.78815299e-007, -2.0861782e-007, -1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.800000072, 1, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.479984283, -1.8399353, 0.00178527832, 3.87430191e-007, -1, 8.24703648e-007, -1, -3.87430191e-007, -7.15261194e-007, 7.15261535e-007, -8.2470342e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.320000023, 0.200000003, 0.320000023))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.479980469, -2.3199234, 0.00178527832, 3.87430191e-007, -1, 8.24703648e-007, -1, -3.87430191e-007, -7.15261194e-007, 7.15261535e-007, -8.2470342e-007, -1))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 0.640000045, 0.200000003))
PartWeld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.67993164, 7.62939453e-006, 0, 1.00000012, 0, 1.78815313e-007, 0, -1.00000012, 2.0861782e-007, 1.78815299e-007, -2.0861782e-007, -1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.800000072, 1, 0.800000072))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.351999998, 0.200000003, 0.200000003))
WedgeWeld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00178337097, 1.41417694, 1.52728844, -8.94076351e-008, 1.49014454e-007, 1, 0.707107067, -0.70710665, 1.68589878e-007, 0.70710665, 0.707107067, -4.21484252e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.351999998, 0.200000003, 0.200000003))
WedgeWeld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00178337097, -1.52731323, -1.41415596, -8.94076351e-008, 1.49014454e-007, 1, -0.707106829, 0.707106829, -1.68589878e-007, -0.707106829, -0.707106829, 4.2148379e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(0.336000025, 0.200000003, 0.200000003))
WedgeWeld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00178337097, -2.15991974, 0.0800132751, -8.94076351e-008, 1.49014454e-007, 1, -1.00000012, 0, -8.94076351e-008, 0, -1.00000012, 1.49014454e-007))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(0.336000025, 0.200000003, 0.200000003))
WedgeWeld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00178337097, -0.0800132751, -1.99993896, -8.94076351e-008, 1.49014454e-007, 1, 0, 1.00000012, -1.49014454e-007, -1.00000012, 0, -8.94076351e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(0.336000025, 0.200000003, 0.200000003))
WedgeWeld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00178337097, -0.079990387, 2.15991974, -8.94076351e-008, 1.49014454e-007, 1, -1.49011612e-007, -1, 1.49014426e-007, 1, -1.49011612e-007, 8.94076493e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(0.336000025, 0.200000003, 0.200000003))
WedgeWeld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00178337097, 1.99992371, 0.0799865723, -8.94076351e-008, 1.49014454e-007, 1, 1, -1.49011612e-007, 8.94076493e-008, 1.49011612e-007, 1, -1.49014426e-007))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 0.800000072, 0.800000072))
CreateMesh("BlockMesh", FakeHandle, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.800000072))
HandleL = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "HandleL", Vector3.new(1, 2, 1.01999998))
HandleLWeld = CreateWeld(m, Character["Left Arm"], HandleL, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00849914551, 0.00999999046, 6.77108765e-005, 1, 0, 0, 0, 1, 0, 0, 0, 1))
EffectPrt1 = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0.30000001192093, "Really black", "EffectPrt1", Vector3.new(0.600000024, 0.600000024, 0.400000036))
EffectPrt1Weld = CreateWeld(m, HandleL, EffectPrt1, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.00999355316, -0.499996185, -0.509780884, 0, 0, 1, 0, 1, 0, -1, 0, 0))
CreateMesh("SpecialMesh", EffectPrt1, Enum.MeshType.Sphere, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
EffectPrt2 = CreatePart(m, Enum.Material.SmoothPlastic, 0.30000001192093, 0, "Mid gray", "EffectPrt2", Vector3.new(0.600000024, 0.600000024, 0.400000036))
EffectPrt2Weld = CreateWeld(m, HandleL, EffectPrt2, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0100440979, 0.499996185, 0.509773254, 4.06801701e-005, 8.90720813e-008, 1, 2.13165718e-014, -1, 8.90720813e-008, 1, -3.60215091e-012, -4.06801701e-005))
CreateMesh("SpecialMesh", EffectPrt2, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=18430887", Vector3.new(0, 0, 0), Vector3.new(0.379999906, 0.399999678, 2.21999955))
HitboxL = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "HitboxL", Vector3.new(1.20000005, 1.39999998, 1.01999998))
HitboxLWeld = CreateWeld(m, HandleL, HitboxL, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0999908447, 0.699999809, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.75, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, HandleL, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.12071991, 0.312129974, -0.409996033, 0.965925872, 0.258819103, 0, -0.258819103, 0.965925872, 0, 0, 0, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 0.200000003, 1.01999998))
PartWeld = CreateWeld(m, HandleL, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.354278564, 0.31212616, 0, 0.965925872, 0.258819103, 0, -0.258819103, 0.965925872, 0, 0, 0, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.600000024, 0.200000003, 1.01999998))
PartWeld = CreateWeld(m, HandleL, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.200004578, 0.899998903, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.75, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, HandleL, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.12071991, 0.312129974, 0.410003662, 0.965925872, 0.258819103, 0, -0.258819103, 0.965925872, 0, 0, 0, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 1.20000005, 1.00999999))
PartWeld = CreateWeld(m, HandleL, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.409751892, -0.412899256, 0.00154209137, -1, -5.71118512e-008, 0, -5.71118512e-008, 1, 1.6609139e-008, -9.48578645e-016, 1.6609139e-008, -1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0.19999998807907, "Really black", "Part", Vector3.new(0.400000036, 0.400000036, 0.400000006))
PartWeld = CreateWeld(m, HandleL, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0105276108, -0.491856098, -0.509765625, 0, 0, 1, 0, 1, 0, -1, 0, 0))
CreateMesh("SpecialMesh", Part, Enum.MeshType.Sphere, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
ThunderHoleL = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "ThunderHoleL", Vector3.new(0.200000003, 1.05000007, 0.200000003))
ThunderHoleLWeld = CreateWeld(m, HandleL, ThunderHoleL, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.699999809, -0.000227928162, 0.228645325, 0, -1, 0, 0, 0, -1, 1, -0, 0))
CreateMesh("CylinderMesh", ThunderHoleL, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.800000012, 0.200000003))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.21999836, 0.600001812, 0.62865448, 0, 0, -1, 0, 1, 0, 1, 0, 0))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.600000024, 0.200000003))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.232361794, 0.0286483765, 1.10000181, -5.96046448e-008, 1.07931243e-007, 1, 1, 5.49689858e-008, 5.96046412e-008, -5.49689787e-008, 1, -1.07931243e-007))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.400000006, 0.200000003))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.21999836, -0.528648376, 1.10000181, 0, 0, -1, -1, -5.96046377e-008, 0, -5.96046377e-008, 1, 0))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.600000024, 0.200000003))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.21999836, 0.0286483765, 1.10000181, -5.96046448e-008, 1.07931243e-007, 1, 1, 5.49689858e-008, 5.96046412e-008, -5.49689787e-008, 1, -1.07931243e-007))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(1.01999998, 1.80999994, 0.619999945))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, -0.104995966, -0.199783325, 0, 0, 1, 0, 1, 0, -1, 0, 0))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(1.03999996, 1.00999999, 1.01999998))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, 0.494999886, -0.018661499, 0, 0, 1, 0, 1, 0, -1, 0, 0))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.800000012, 0.200000003))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.232361794, 0.600001812, 0.62865448, 0, 0, -1, 0, 1, 0, 1, 0, 0))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.400000006, 0.200000003))
WedgeWeld = CreateWeld(m, HandleL, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.232361794, -0.528648376, 1.10000181, 0, 0, -1, -1, -5.96046377e-008, 0, -5.96046377e-008, 1, 0))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
HandleR = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "HandleR", Vector3.new(1, 2, 1.01999998))
HandleRWeld = CreateWeld(m, Character["Right Arm"], HandleR, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00468444824, 0.0100209713, -0.00353145599, -1, -5.71118512e-008, 0, -5.71118512e-008, 1, 1.6609139e-008, -9.48578645e-016, 1.6609139e-008, -1))
Barrel1 = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "Barrel1", Vector3.new(0.600000024, 1.20000005, 0.400000036))
Barrel1Weld = CreateWeld(m, HandleR, Barrel1, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.299865723, 0.599565029, 0.718658447, -1.49011612e-007, -6.73397207e-015, -1, 0, 1, -7.10542736e-015, 1, 0, -1.49011612e-007))
CreateMesh("SpecialMesh", Barrel1, Enum.MeshType.FileMesh, "rbxassetid://433397018", Vector3.new(0, 0, 0), Vector3.new(0.00999999978, 0.00999999978, 0.00999999978))
Barrel2 = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "Barrel2", Vector3.new(0.600000024, 1.20000005, 0.400000036))
Barrel2Weld = CreateWeld(m, HandleR, Barrel2, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.300126076, 0.599565029, 0.718658447, -1.49011612e-007, -6.73397207e-015, -1, 0, 1, -7.10542736e-015, 1, 0, -1.49011612e-007))
CreateMesh("SpecialMesh", Barrel2, Enum.MeshType.FileMesh, "rbxassetid://433397018", Vector3.new(0, 0, 0), Vector3.new(0.00999999978, 0.00999999978, 0.00999999978))
Choke1 = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "Choke1", Vector3.new(0.600000024, 0.400000006, 0.400000036))
Choke1Weld = CreateWeld(m, HandleR, Choke1, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.297118187, 1.39956522, 0.718673706, -1.49011612e-007, -6.73397207e-015, -1, 0, 1, -7.10542736e-015, 1, 0, -1.49011612e-007))
CreateMesh("SpecialMesh", Choke1, Enum.MeshType.FileMesh, "rbxassetid://433397231", Vector3.new(0, 0, 0), Vector3.new(0.00999999978, 0.00999999978, 0.00999999978))
Choke2 = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "Choke2", Vector3.new(0.600000024, 0.400000006, 0.400000036))
Choke2Weld = CreateWeld(m, HandleR, Choke2, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.303283691, 1.3995651, 0.718673706, -1.49011612e-007, -6.73397207e-015, -1, 0, 1, -7.10542736e-015, 1, 0, -1.49011612e-007))
CreateMesh("SpecialMesh", Choke2, Enum.MeshType.FileMesh, "rbxassetid://433397231", Vector3.new(0, 0, 0), Vector3.new(0.00999999978, 0.00999999978, 0.00999999978))
HitboxR = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 1, "Mid gray", "HitboxR", Vector3.new(1.20000005, 0.99999994, 1.01999998))
HitboxRWeld = CreateWeld(m, HandleR, HitboxR, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.100006104, 0.700003862, 0, 1, 0, 0, 0, 1, 5.41750795e-023, 0, 5.41750795e-023, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.75, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.120735168, 0.312120438, 0.40998745, 0.965925872, 0.258819222, -5.53058896e-008, -0.258819222, 0.965925872, 3.094436e-008, 6.14303701e-008, -1.55757274e-008, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.400000006, 0.819999993, 1.01999998))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.718658447, -0.4104321, -1.43051147e-005, 1, 0, 0, 0, 1, 5.41750795e-023, 0, 5.41750795e-023, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.600000024, 0.200000003, 1.01999998))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.199996948, 0.900001049, 0, 1, 0, 0, 0, 1, 5.41750795e-023, 0, 5.41750795e-023, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.409999996, 2.01999998, 1.01999998))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.313659668, -0.00999617577, 0, 1, 0, 0, 0, 1, 5.41750795e-023, 0, 5.41750795e-023, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.75, 0.200000003, 0.200000003))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.120735168, 0.312120438, -0.410010338, 0.965925872, 0.258819222, -5.53058896e-008, -0.258819222, 0.965925872, 3.094436e-008, 6.14303701e-008, -1.55757274e-008, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.409999967, 0.200000003, 1.01999998))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.0863342285, -0.919991493, -3.05175781e-005, 1, 0, 0, 0, 1, 5.41750795e-023, 0, 5.41750795e-023, 1))
Part = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Part", Vector3.new(0.200000003, 0.200000003, 1.01999998))
PartWeld = CreateWeld(m, HandleR, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.354248047, 0.312124252, -1.43051147e-005, 0.965925872, 0.258819222, -5.53058896e-008, -0.258819222, 0.965925872, 3.094436e-008, 6.14303701e-008, -1.55757274e-008, 1))
ThunderHoleR = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "ThunderHoleR", Vector3.new(0.200000003, 1.05000007, 0.200000003))
ThunderHoleRWeld = CreateWeld(m, HandleR, ThunderHoleR, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.700005054, -0.000213623047, 0.228675842, -1.0658141e-014, -1, -1.0658141e-014, 9.48578222e-016, 1.0658141e-014, -1, 1, -1.0658141e-014, 9.48578116e-016))
CreateMesh("CylinderMesh", ThunderHoleR, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.800000012, 0.200000003))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.232376099, 0.600004911, 0.628646851, 9.48580657e-016, -3.19744231e-014, -1, 0, 1, -3.19744231e-014, 1, 0, 9.48580551e-016))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.600000024, 0.200000003))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.219985962, 0.0286712646, 1.10000277, -3.12924385e-007, 1.07931264e-007, 1, 1, 5.49689787e-008, 3.12924385e-007, -5.49689467e-008, 1, -1.07931285e-007))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.400000006, 0.200000003))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.232376099, -0.528656006, 1.100003, 9.48580657e-016, -3.19744231e-014, -1, -1, -5.9604659e-008, -9.48578539e-016, -5.9604659e-008, 1, -3.19744231e-014))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(1.01999998, 0.200000003, 0.400000006))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.43051147e-005, -0.920844555, 0.718658447, 9.48580657e-016, -3.19744231e-014, -1, 0, 1, -3.19744231e-014, 1, 0, 9.48580551e-016))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(1.03999996, 1.00999999, 1.01999998))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, 0.495002031, -0.0186691284, -9.48580657e-016, 3.19744231e-014, 1, 0, 1, -3.19744231e-014, -1, 0, -9.48580551e-016))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.600000024, 0.200000003))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.232390404, 0.0286712646, 1.100003, -3.12924385e-007, 1.07931264e-007, 1, 1, 5.49689787e-008, 3.12924385e-007, -5.49689467e-008, 1, -1.07931285e-007))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.400000006, 0.200000003))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.219985962, -0.528671265, 1.100003, 9.48580657e-016, -3.19744231e-014, -1, -1, -5.9604659e-008, -9.48578539e-016, -5.9604659e-008, 1, -3.19744231e-014))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(1.01999998, 0.200000003, 0.400000006))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-1.43051147e-005, -0.100847006, 0.718658447, 2.45555211e-015, -5.96046306e-008, 1, -1.42108547e-014, -1, -5.96046306e-008, 1, -1.42108547e-014, -2.45555296e-015))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.800000012, 0.200000003))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.220002174, 0.600004911, 0.628662109, 9.48580657e-016, -3.19744231e-014, -1, 0, 1, -3.19744231e-014, 1, 0, 9.48580551e-016))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(m, Enum.Material.SmoothPlastic, 0.20000000298023, 0, "Mid gray", "Wedge", Vector3.new(1.00999999, 0.410000026, 0.410000026))
WedgeWeld = CreateWeld(m, HandleR, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.00409030914, 0.623651981, 0.0869140625, 7.5121838e-016, 3.45568019e-009, -1, -5.9604659e-008, -1, -3.45568019e-009, -1, 5.9604659e-008, -5.45243684e-016))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))

--[[ Credits to Fenrier for the Effect Functions. ]]--

function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.new(x1, y1, z1)
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end
for i,v in pairs(Character.WeaponModel:GetDescendants()) do
if v:IsA("BasePart") then
v.Transparency = 1
end
end
local lp = game:GetService("Players").LocalPlayer

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end



local hat = gp(cplayer, "SciFiDemonicSword", "Accessory")
local handle = gp(hat, "Handle", "BasePart")
local att = gp(handle, "att1_Handle", "Attachment")
att.Parent = BladePrt
att.Position = v3(-1.8, 2.2, 0)
att.Rotation = v3(0, 180, 180)

spawn(function()
    while game:GetService("RunService").Heartbeat:Wait() do
    if attack == true then
    if Mode == "Sword" then
    GlobalFunctions.fling(BladePrt.Position, 0.01)
    end
    if Mode == "Normal" and Target ~= nil then
    GlobalFunctions.fling(Target, 0.2)
    wait(0.3)
    Target = nil
    end
    end
    end
    end)

--[[ Attack Functions ]]--



RSH = Torso["Right Shoulder"] 
LSH = Torso["Left Shoulder"]
RH = Torso["Right Hip"] 
LH = Torso["Left Hip"]
Animate = Character.Animate
Animator = Humanoid.Animator

function Equip()
	attack = true
	equipped = true
	RSH.Parent = nil 
	LSH.Parent = nil
	Animator.Parent = nil
	Animate.Disabled = true
	change = 3
	RW = Create("Weld"){
		Name = "Right Shoulder",
		Part0 = Torso ,
		C0 = CFrame.new(1.5, 0.5, 0),
		C1 = CFrame.new(0, 0.5, 0), 
		Part1 = RightArm ,
		Parent = Torso ,
	}
	LW = Create("Weld"){
		Name = "Left Shoulder",
		Part0 = Torso ,
		C0 = CFrame.new(-1.5, 0.5, 0),
		C1 = CFrame.new(0, 0.5, 0) ,
		Part1 = LeftArm ,
		Parent = Torso ,
	}
	CreateSound("http://roblox.com/asset/?id=346134880", Torso, 1, 1)
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(5), math.rad(0), math.rad(0)), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.3, -.5) * angles(math.rad(0), math.rad(170), math.rad(90)), .25)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.3, -.7) * angles(math.rad(0), math.rad(-170), math.rad(-110)), .25)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(5)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(-5)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	CreateSound("http://roblox.com/asset/?id=346134880", Torso, 1, .9)
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(5), math.rad(0), math.rad(0)), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.3, -.5) * angles(math.rad(0), math.rad(170), math.rad(95)), .34)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, -.7) * angles(math.rad(0), math.rad(-170), math.rad(-120)), .34)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(5)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(-5)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(5), math.rad(0), math.rad(0)), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.3, -.7) * angles(math.rad(0), math.rad(170), math.rad(110)), .25)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.3, -.5) * angles(math.rad(0), math.rad(-170), math.rad(-90)), .25)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(5)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(-5)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(5), math.rad(0), math.rad(0)), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.3, -.7) * angles(math.rad(0), math.rad(170), math.rad(120)), .34)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.3, -.7) * angles(math.rad(0), math.rad(-180), math.rad(-95)), .34)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(5)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(-5)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	attack = false
end

function Unequip()
	attack = true
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(0), math.rad(0), math.rad(0)), .2)
	end
	equipped = false
	RW.Parent = nil 
	LW.Parent = nil 
	RSH.Parent = Torso
	LSH.Parent = Torso
	Torso.Neck.C0 = NeckCF
	RootJoint.C0 = RootCF
	Animator.Parent = Humanoid
	Animate.Disabled = false
	RW.C0 = CFrame.new(1.5, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0)
	RW.C1 = CFrame.new(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0)
	LW.C0 = CFrame.new(-1.5, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0)
	LW.C1 = CFrame.new(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0)
	attack = false
end

function attackone()
	attack = true
	local Con1 = HitboxL.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 0, 1, 0.13 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.3) * angles(math.rad(0), math.rad(0), math.rad(70)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-70)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0, -.3) * angles(math.rad(180), math.rad(-20), math.rad(10)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.4, -.7) * angles(math.rad(0), math.rad(-150), math.rad(-90)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -.8, 0) * RHCF * angles(math.rad(-4), math.rad(-40), math.rad(0)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-4), math.rad(-40), math.rad(30)), .3)
	end
	CreateSound("http://www.roblox.com/asset/?id=200632136", HitboxL, 1, 1)
	for i = 0, 1, 0.12 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.3) * angles(math.rad(20), math.rad(0), math.rad(-80)), .54)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-10), math.rad(-10), math.rad(80)), .54)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, .3) * angles(math.rad(50), math.rad(20), math.rad(0)), .54)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.7, -.3) * angles(math.rad(0), math.rad(-20), math.rad(-110)), .54)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-4), math.rad(40), math.rad(-10)), .54)
		LH.C0 = clerp(LH.C0, cn(-1, -.7, 0) * LHCF * angles(math.rad(-4), math.rad(40), math.rad(-20)), .54)
	end
	Con1:disconnect()
	attack = false
end

function attacktwo()
	attack = true
	local Con1 = HitboxR.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 0, 1, 0.13 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.4) * angles(math.rad(0), math.rad(0), math.rad(-80)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(80)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(-90), math.rad(0)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.4) * angles(math.rad(120), math.rad(0), math.rad(10)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(-40)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -.7, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
	end
	CreateSound("http://www.roblox.com/asset/?id=200632136", HitboxR, 1, 1.1)
	for i = 0, 1, 0.12 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0) * angles(math.rad(0), math.rad(0), math.rad(80)), .55)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-80)), .55)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, -.3) * angles(math.rad(180), math.rad(-20), math.rad(10)), .55)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(10)), .55)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .55)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .55)
	end
	Con1:disconnect()
	attack = false
end

function attackthree()
	attack = true
	local Con1 = HitboxL.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	local Con2 = HitboxR.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 0, 1, 0.13 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-20), math.rad(0), math.rad(0)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(90), math.rad(50), math.rad(0)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.5) * angles(math.rad(90), math.rad(-50), math.rad(0)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(-20)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(20)), .3)
	end
	CreateSound("http://www.roblox.com/asset/?id=200632136", Torso, 1, .8)
	Torso.Velocity = RootPart.CFrame.lookVector * 120
	for i = 0, 1, 0.13 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(20), math.rad(0), math.rad(0)), .55)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-10), math.rad(0), math.rad(0)), .55)
		RW.C0 = clerp(RW.C0, CFrame.new(.8, 0.5, -.8) * angles(math.rad(120), math.rad(60), math.rad(0)), .55)
		LW.C0 = clerp(LW.C0, CFrame.new(-.8, 0.5, -.8) * angles(math.rad(120), math.rad(-60), math.rad(0)), .55)
		RH.C0 = clerp(RH.C0, cn(1, -.6, -.2) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(-20)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -.8, -.3) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(10)), .3)
	end
	Con1:disconnect()
	Con2:disconnect()
	attack = false
end

function attackfour()
	attack = true
	Torso.Velocity = Vector3.new(0, 100, 0)
	Humanoid.Jump = true
	CreateSound("http://roblox.com/asset/?id=199145327", Torso, 1, .8)
	for i = 0, 1, 0.12 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(6 * i, math.rad(0), math.rad(0)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.5) * angles(math.rad(90), math.rad(0), math.rad(-40)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.5, -.5) * angles(math.rad(90), math.rad(0), math.rad(40)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -.2, -.5) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-20)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -.1, -.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(20)), .3)
	end
	for i = 0, 1, 0.12 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(10 * i), math.rad(0), math.rad(0)), .5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .5)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(60)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-60)), .5)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(40)), .5)
		LH.C0 = clerp(LH.C0, cn(-1, 0, -.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(20)), .5)
	end
	local hitfloor = nil
	while hitfloor == nil do
		swait()
		hitfloor, posfloor = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 3, Character)
	end
	MagnitudeDamage(RootPart, 0, 0, 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 6, Character)
	if hit ~= nil then
		local Color = hit.BrickColor
		local refpart = CreatePart(workspace, "SmoothPlastic", 0, 1, "Really black", "Effect", Vector3.new())
		refpart.Anchored = true
		refpart.CFrame = CFrame.new(pos)
		game:GetService("Debris"):AddItem(refpart, 1)
		CreateSound("http://www.roblox.com/asset/?id=199145477", refpart, .8, 1)
		for i = 1, 5 do
			local Color = hit.BrickColor
			local Materials = hit.Material
			local groundpart = CreatePart(workspace, "SmoothPlastic", 0, 0, Color, "Ground", Vector3.new(math.random(50, 100) / 100, math.random(50, 100) / 100, math.random(50, 100) / 100))
			groundpart.Anchored = false
			groundpart.Material = Materials
			groundpart.CanCollide = true
			groundpart.Friction = 0.1
			groundpart.Velocity = Vector3.new(math.random(-50, 50), math.random(25, 50), math.random(-50, 50))
			groundpart.CFrame = CFrame.new(pos) * CFrame.new(math.random(-250, 250) / 100, 0.5, math.random(-250, 250) / 100) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			game:GetService("Debris"):AddItem(groundpart, 10)
		end
		for i = 1, 6 do
			local Color = hit.BrickColor
			local Materials = hit.Material
			local actualgroundpart = CreatePart(workspace, "SmoothPlastic", 0, 0, Color, "Ground", Vector3.new(math.random(100, 200) / 100, math.random(100, 200) / 100, math.random(100, 200) / 100))
			actualgroundpart.Anchored = true
			actualgroundpart.Material = Materials
			actualgroundpart.CanCollide = true
			actualgroundpart.Friction = 1
			actualgroundpart.CFrame = CFrame.new(pos) * CFrame.new(math.random(-500, 500) / 100, 0, math.random(-500, 500) / 100) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			game:GetService("Debris"):AddItem(actualgroundpart, 10)
		end 
		WaveEffect(hit.BrickColor, refpart.CFrame, .2, .2, .2, .5, .5, .5, .04)
		SphereEffect(hit.BrickColor, refpart.CFrame, .2, .2, .2, 3, 3, 3, .04)
		RingEffect(hit.BrickColor, refpart.CFrame * CFrame.Angles(math.random(5, 6), math.random(2, 7), math.random(3, 6)), .2, .2, .2, 1, 1, 1, .05)
	end
	attack = false
end

function ShootCannon(asd)
	local MainPos = asd.Position
	local MainPos2 = mouse.Hit.p
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	num = 100
	coroutine.resume(coroutine.create(function() 
		repeat
			swait()
			local hit, pos = rayCast(MainPos, MouseLook.lookVector, 10, RootPart.Parent)
			local mag = (MainPos - pos).magnitude 
			CylinderEffect(BrickColor.new("New Yeller"), CFrame.new((MainPos + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0), 3, mag * 5, 100, .1, 0, 1.5, 0.1)
			MainPos = MainPos + (MouseLook.lookVector * 10)
			num = num - 1
			if hit ~= nil then
				num = 0
				local ref = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new("New Yeller"), "Reference", Vector3.new())
				ref.Anchored = true
				ref.CFrame = CFrame.new(pos)
				BlockEffect(BrickColor.new("New Yeller"), CFrame.new(pos), 20, 20, 20, 5, 5, 5, 0.1)
                MagnitudeDamage(ref, 0, 0, 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
				game:GetService("Debris"):AddItem(ref, 1)
			end
		until num <= 0
	end))
end

gun = false

shoot = false

gunidle = false

local Loaded = false

function GunStance()
	attack = true
	gun = true
	change = 3
	Barrel1.Transparency = 1
	Barrel2.Transparency = 1
	Choke1.Transparency = 1
	Choke2.Transparency = 1
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-90)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), .3)
		HandleWeld.C0 = clerp(HandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	local offset = nil
	gunidle = true
	while gun == true do
		swait()
		local gunpos = Vector3.new(mouse.Hit.p.x, Head.Position.Y, mouse.Hit.p.z)
		offset = (Torso.Position.y - mouse.Hit.p.y) / 60
		local mag = (Torso.Position - mouse.Hit.p).magnitude / 80
		offset = offset / mag 
		RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, offset), .5)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	if shoot == true then
		gunidle = false
		CreateSound("rbxassetid://131632972", Torso, 1, 1.2)
		CreateSound("rbxassetid://131632972", Torso, 1, 1)
		CreateSound("rbxassetid://131632972", Torso, 1, .7)
		ShootCannon(Choke1)
		ShootCannon(Choke2)
		for i = 0, 1, 0.15 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), .3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-90)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.7, 0) * angles(math.rad(0), math.rad(0), math.rad(150)), .5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), .3)
			HandleWeld.C0 = clerp(HandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			if Torsovelocity < 1 then
				RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .2)
				LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .2)
			elseif Torsovelocity > 2 then
				RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 10) / 2, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 10) / 2, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			end
		end
		Loaded = false
	end
	RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), 1)
	Barrel1.Transparency = 1
	Barrel2.Transparency = 1
	Choke1.Transparency = 1
	Choke2.Transparency = 1
	gun = false
	gunidle = false
	shoot = false
	attack = false
end

function Disappear()
	for _, i in pairs(m:children()) do
		if i.Name == "BladePrt" then
			coroutine.resume(coroutine.create(function(Part) 
				for i = 0, 1, 0.1 do
					swait()
					Part.Transparency = i
				end
				Part.Transparency = 1
			end), i)
		end
	end
end


function Reappear()
	for _, i in pairs(m:children()) do
		if i.Name == "BladePrt" then
			coroutine.resume(coroutine.create(function(Part) 
				for i = 0, 1, 0.1 do
					swait()
					Part.Transparency = i
				end
				Part.Transparency = 1
			end), i)
		end
	end
end

function BladeEquip()
	attack = true
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.3, 0) * angles(math.rad(210), math.rad(0), math.rad(30)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-20)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
	end
	CreateSound("http://roblox.com/asset/?id=199145327", FakeHandle, .6, 1)
	HandleWeld:remove()
	HandleWeld = CreateWeld(m, Character["Right Arm"], Handle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.032043457, 0.996201754, -0.111961365, 8.94076351e-008, 1.1920929e-007, 1, -1.49014454e-007, 1, -1.19209275e-007, -1, -1.4901444e-007, 8.94076564e-008))
	for i = 0, 1, 0.1 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.5, 0) * angles(math.rad(80), math.rad(0), math.rad(70)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-20)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(90), math.rad(0), -6 * i), .3)
	end
	Reappear()
	Mode = "Sword"
	attack = false
end

function UnequipBlade()
	attack = true
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.3, 0) * angles(math.rad(210), math.rad(0), math.rad(30)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-20)), .3)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .3)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(40), math.rad(-60)), .3)
	end
	Disappear()
	HandleWeld:remove()
	HandleWeld = CreateWeld(m, Character["Torso"], Handle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-3.57640076, -0.105987549, -0.672006607, 0.866025388, 0.500000119, -8.94076351e-008, -0.500000119, 0.866025388, 1.49014454e-007, 1.51936518e-007, -8.43464605e-008, 1))
	Mode = "Normal"
	attack = false
end

function BladeAttackOne()
	attack = true
	local Con1 = BladeHitbox.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(60)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-60)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.3, -.5) * angles(math.rad(0), math.rad(150), math.rad(120)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.5, -.7) * angles(math.rad(0), math.rad(70), math.rad(90)), .3)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(-10), math.rad(30)), .3)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(-30), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(-30), math.rad(0)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	CreateSound("http://roblox.com/asset/?id=356430004", BladeHitbox, 1, .8)
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1) * angles(math.rad(10), math.rad(0), math.rad(-60)), .4)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5), math.rad(-5), math.rad(60)), .4)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.3, 0) * angles(math.rad(0), math.rad(70), math.rad(80)), .4)
		LW.C0 = clerp(LW.C0, CFrame.new(-.4, 0.5, -1) * angles(math.rad(0), math.rad(20), math.rad(70)), .4)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(80)), .4)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(30), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -.9, 0) * LHCF * angles(math.rad(-5), math.rad(30), math.rad(-10)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(30), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(30), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	Con1:disconnect()
	attack = false
end

function BladeAttackTwo()
	attack = true
	local Con1 = BladeHitbox.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)), .3)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(60)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.7) * angles(math.rad(0), math.rad(-70), math.rad(-90)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, -.5) * angles(math.rad(0), math.rad(-150), math.rad(-120)), .3)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(-10), math.rad(30)), .3)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(30), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(30), math.rad(0)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(-0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(30), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	CreateSound("http://roblox.com/asset/?id=356430004", BladeHitbox, 1, 1)
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1) * angles(math.rad(10), math.rad(0), math.rad(60)), .4)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5), math.rad(5), math.rad(-60)), .4)
		RW.C0 = clerp(RW.C0, CFrame.new(.4, 0.5, -1) * angles(math.rad(0), math.rad(-20), math.rad(-70)), .4)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.1, 0) * angles(math.rad(0), math.rad(-70), math.rad(-80)), .4)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(30), math.rad(80)), .4)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(-30), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -.9, 0) * LHCF * angles(math.rad(-5), math.rad(-30), math.rad(-10)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	Con1:disconnect()
	attack = false
end

function BladeAttackThree()
	attack = true
	local Con1 = BladeHitbox.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 0, 1, 0.15 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-10), math.rad(0), math.rad(0)), .34)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .34)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 1, -.5) * angles(math.rad(120), math.rad(0), math.rad(-40)), .34)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 1, -.5) * angles(math.rad(120), math.rad(0), math.rad(40)), .34)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(40), math.rad(0), math.rad(0)), .4)
		if Torsovelocity < 1 then
		    RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(-10)), .34)
		    LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(10)), .34)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	CreateSound("http://roblox.com/asset/?id=356430004", BladeHitbox, 1, .7)
	for i = 0, 1, 0.13 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.3) * angles(math.rad(0), math.rad(0), math.rad(0)), .5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .5)
		RW.C0 = clerp(RW.C0, CFrame.new(1, .3, -.3) * angles(math.rad(10), math.rad(0), math.rad(-40)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, .3, -.3) * angles(math.rad(10), math.rad(0), math.rad(40)), .5)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(40), math.rad(0), math.rad(30)), .5)
		if Torsovelocity < 1 then
		    RH.C0 = clerp(RH.C0, cn(1, -.8, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(-10)), .34)
		    LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(10)), .34)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -.8, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(0), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	Con1:disconnect()
	attack = false
end

function BladeAttackFour()
	attack = true
	local Con1 = BladeHitbox.Touched:connect(function(hit)
		Damage(hit.Parent, math.random(0, 0), 0, BrickColor.new("Really black"), BrickColor.new("Mid gray"), "rbxassetid://199149186" ,1)
	end)
	for i = 1,2 do
	for i = 0, 1, 0.3 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(60)), .5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-60)), .5)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.3, -.5) * angles(math.rad(0), math.rad(150), math.rad(120)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.5, -.7) * angles(math.rad(0), math.rad(70), math.rad(90)), .5)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(-10), math.rad(30)), .5)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(-30), math.rad(0)), .5)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(-30), math.rad(0)), .5)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .5)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .5)
		end
	end
	CreateSound("http://roblox.com/asset/?id=356430004", BladeHitbox, 1, 1)
	for i = 0, 1, 0.3 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1) * angles(math.rad(10), math.rad(0), math.rad(-60)), .4)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5), math.rad(-5), math.rad(60)), .4)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.3, 0) * angles(math.rad(0), math.rad(70), math.rad(80)), .4)
		LW.C0 = clerp(LW.C0, CFrame.new(-.4, 0.5, -1) * angles(math.rad(0), math.rad(20), math.rad(70)), .4)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(80)), .4)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(30), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -.9, 0) * LHCF * angles(math.rad(-5), math.rad(30), math.rad(-10)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(30), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(30), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	for i = 0, 1, 0.3 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)), .5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(60)), .5)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.7) * angles(math.rad(0), math.rad(-70), math.rad(-110)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, -.5) * angles(math.rad(0), math.rad(-150), math.rad(-120)), .5)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(-10), math.rad(30)), .5)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(30), math.rad(0)), .5)
			LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(30), math.rad(0)), .5)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(-0), math.rad(0) - math.sin(sine / 10)), .5)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(30), math.rad(0) - math.sin(sine / 10)), .5)
		end
	end
	CreateSound("http://roblox.com/asset/?id=356430004", BladeHitbox, 1, .8)
	for i = 0, 1, 0.3 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1) * angles(math.rad(10), math.rad(0), math.rad(60)), .4)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5), math.rad(5), math.rad(-60)), .4)
		RW.C0 = clerp(RW.C0, CFrame.new(.4, 0.5, -1) * angles(math.rad(0), math.rad(-20), math.rad(-70)), .4)
		LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.1, 0) * angles(math.rad(0), math.rad(-70), math.rad(-80)), .4)
		FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(30), math.rad(80)), .4)
		if Torsovelocity < 1 then
			RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(-30), math.rad(0)), .2)
			LH.C0 = clerp(LH.C0, cn(-1, -.9, 0) * LHCF * angles(math.rad(-5), math.rad(-30), math.rad(-10)), .2)
		elseif Torsovelocity > 2 then
			RH.C0 = clerp(RH.C0, cn(1, -1, -.05 + math.sin(sine / 10) / 2) * RHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .3)
			LH.C0 = clerp(LH.C0, cn(-1, -1, -.05 - math.sin(sine / 10) / 2) * LHCF * angles(math.rad(-1), math.rad(-30), math.rad(0) - math.sin(sine / 10)), .3)
		end
	end
	end
	Con1:disconnect()
	attack = false
end

--[[Attacks]]--

mouse.Button1Down:connect(function()
	if attack == false and attacktype == 1 and equipped == true and Mode == "Normal" then
		attacktype = 2
		attackone()
	elseif attack == false and attacktype == 2 and equipped == true and Mode == "Normal" then
		attacktype = 3
		attacktwo()
	elseif attack == false and attacktype == 3 and equipped == true and Mode == "Normal" then
		attacktype = 4
		attackthree()
	elseif attack == false and attacktype == 4 and equipped == true and Mode == "Normal" then
		attacktype = 1
		attackfour()
	end
	if attack == false and attacktype == 1 and equipped == true and Mode == "Sword" then
		attacktype = 2
		BladeAttackOne()
	elseif attack == false and attacktype == 2 and equipped == true and Mode == "Sword" then
		attacktype = 3
		BladeAttackTwo()
	elseif attack == false and attacktype == 3 and equipped == true and Mode == "Sword" then
		attacktype = 4
		BladeAttackThree()
	elseif attack == false and attacktype == 4 and equipped == true and Mode == "Sword" then
		attacktype = 1
		BladeAttackFour()
	end
	if gun == true and shoot == false and equipped == true then
		shoot = true
		gun = false
	end
end)

mouse.KeyDown:connect(function(k)
	k = k:lower()
	if attack == false and equipped == false and k == 'f' and Mode == "Normal" then
		Equip()
	elseif attack == false and equipped == true and k == 'f' and Mode == "Normal" then
		Unequip()
	elseif attack == false and equipped == true and Mode == "Normal" and k == 'g' then
		BladeEquip()
	elseif attack == false and equipped == true and Mode == "Sword" and k == 'g' then
		UnequipBlade()
	elseif k == 'e' and gun == false and shoot == false and Mode == "Normal" and attack == false and equipped == true then
		GunStance()
	elseif k == 'e' and shoot == false and equipped == true and Mode == "Normal" then
		if gun == true then
			gun = false
		end
	end
end)

--[[ Credits to Fenrier for the Movement Detection and Effects table. ]]--

while true do
	swait()
	for i, v in pairs(Character:GetChildren()) do
		if v:IsA("Part") then
			v.Material = "SmoothPlastic"
		elseif v:IsA("Hat") then
			v:WaitForChild("Handle").Material = "SmoothPlastic"
		end
	end
	if gun == true then
		local aim = CFrame.new(RootPart.Position, mouse.Hit.p)
		local direction = aim.lookVector
		local headingA = math.atan2(direction.x, direction.z)
		headingA = math.deg(headingA)
		Humanoid.AutoRotate = false
		RootPart.CFrame = CFrame.new(RootPart.Position) * angles(math.rad(0), math.rad(headingA - 180), math.rad(0))		
	else
		Humanoid.AutoRotate = true			
	end
	Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
	velocity = RootPart.Velocity.y
	sine = sine + change
	local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
	if equipped == true then
		if RootPart.Velocity.y > 1 and hit == nil then 
			Anim = "Jump"
			if attack == false then
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-10), math.rad(0), math.rad(0)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(30)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-30)), .3)
				RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(-20)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(20)), .3)
				FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			end
		elseif RootPart.Velocity.y < -1 and hit == nil then 
			Anim = "Fall"
			if attack == false then
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(30), math.rad(0), math.rad(0)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(50)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-50)), .3)
				RH.C0 = clerp(RH.C0, cn(1, -.8, 0) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(20)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(-20)), .3)
				FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			end
		elseif Torsovelocity < 1 and hit ~= nil then
			Anim = "Idle"
			if attack == false and Mode == "Normal" then
				change = 1
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1 + .1 * math.sin(sine / 27)) * angles(math.rad(0), math.rad(0), math.rad(30)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5 + 3 * math.cos(sine / 23)), math.rad(-2 - 3 * math.cos(sine / 23)), math.rad(-30)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.6 + .07 * math.cos(sine / 23), -.2) * angles(math.rad(110 + 2 * math.cos(sine / 24)), math.rad(35 + 3 * math.cos(sine / 23)), math.rad(-30)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.6 + .07 * math.cos(sine / 23), -.5) * angles(math.rad(120 + 2 * math.cos(sine / 24)), math.rad(-40 + 3 * math.cos(sine / 23)), math.rad(40)), .3)
				RH.C0 = clerp(RH.C0, cn(1, -.9 - .1 * math.sin(sine / 27), 0) * RHCF * angles(math.rad(-4 + 1 * math.cos(sine / 23)), math.rad(-30), math.rad(0)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -.9 - .1 * math.sin(sine / 27), 0) * LHCF * angles(math.rad(-4 + 1 * math.cos(sine / 23)), math.rad(-30), math.rad(0)), .3)
				FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			elseif attack == false and Mode == "Sword" then
				change = 1
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1 + .1 * math.sin(sine / 27)) * angles(math.rad(0), math.rad(0), math.rad(-60)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5 + 3 * math.cos(sine / 23)), math.rad(-2 + 3 * math.cos(sine / 23)), math.rad(60)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, 0) * angles(math.rad(150 + 3 * math.cos(sine / 23)), math.rad(0), math.rad(10)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, 0) * angles(math.rad(10 + 2 * math.cos(sine / 23)), math.rad(0), math.rad(-20 - 5 * math.cos(sine / 23))), 0.3)
				RH.C0 = clerp(RH.C0, cn(1, -.9 - .1 * math.sin(sine / 27), 0) * RHCF * angles(math.rad(-4 + 1 * math.cos(sine / 23)), math.rad(20), math.rad(0)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -.9 - .1 * math.sin(sine / 27), 0) * LHCF * angles(math.rad(-4 + 1 * math.cos(sine / 23)), math.rad(20), math.rad(0)), .3)
				FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)), .3)
			end
		elseif Torsovelocity > 2 and hit ~= nil then
			Anim = "Walk"
			if attack == false and Mode == "Normal" then
				change = 3
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.2) * angles(math.rad(30), math.rad(0), math.rad(5 * math.cos(sine / 10) / 2)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-20), math.rad(0), math.rad(-5 * math.cos(sine / 10) / 2)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6 + .07 * math.cos(sine / 23), -.2) * angles(math.rad(110), math.rad(40), math.rad(-40)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6 + .07 * math.cos(sine / 23), -.2) * angles(math.rad(110), math.rad(-40), math.rad(40)), .3)
				RH.C0 = clerp(RH.C0, cn(1, -.8 - 0.3 * math.cos(sine / 8) / 2, -.05 + math.sin(sine / 8) / 2) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(10) - math.sin(sine / 8)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 8) / 2, -.05 - math.sin(sine / 8) / 2) * LHCF * angles(math.rad(-4), math.rad(0), math.rad(-10) - math.sin(sine / 8)), .3)
				FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			elseif attack == false and Mode == "Sword" then
				change = 3
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.1 + .1 * math.sin(sine / 27)) * angles(math.rad(15), math.rad(0), math.rad(-60 + 10 * math.cos(sine / 13))), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5), math.rad(-5), math.rad(60 - 10 * math.cos(sine / 13))), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.5, -.5) * angles(math.rad(150 + 3 * math.cos(sine / 23)), math.rad(0), math.rad(-20)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-.3, 0.7, -1) * angles(math.rad(150 + 2 * math.cos(sine / 23)), math.rad(0), math.rad(40)), 0.3)
				RH.C0 = clerp(RH.C0, cn(1, -1 - 0.3 * math.cos(sine / 8) / 2, -.05 + math.sin(sine / 8) / 2) * RHCF * angles(math.rad(-4), math.rad(40), math.rad(10) - math.sin(sine / 8)), .3)
				LH.C0 = clerp(LH.C0, cn(-1, -.8 + 0.3 * math.cos(sine / 8) / 2, -.05 - math.sin(sine / 8) / 2) * LHCF * angles(math.rad(-4), math.rad(40), math.rad(-10) - math.sin(sine / 8)), .3)
				FakeHandleWeld.C0 = clerp(FakeHandleWeld.C0, CFrame.new(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)), .3)
			end
		end
	end
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame
							Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, .5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
print("Loaded")
end)
Section:NewButton("FE Zenith Rifle", "gives you a cool rifle", function()
--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
    local unit = realPartVelocity.Unit
    if (unit.Y > 0.9) or (unit.Y < -0.9) then
        return realPartVelocity * (25.1 / realPartVelocity.Y)
    end
    realPartVelocity *= Vector3_101
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        realPartVelocity = unit * Vector3_101 * 100
    end
    return realPartVelocity + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local noclipAllParts = true --set it to true if you want noclip
local flingpart = "HumanoidRootPart" --the part that will be used to fling (ctrl + F "fling function")
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local noclipmodel = (noclipAllParts and c) or model
local noclipcon = nil
local function uncollide()
	if noclipmodel then
		for i, v in pairs(noclipmodel:GetDescendants()) do
		    if v:IsA("BasePart") then
			    v.CanCollide = false
		    end
		end
	else
		noclipcon:Disconnect()
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck = nil
	local conTorso = nil
	local contorso1 = nil
	local aligns = {}
	local function enableAligns()
	    conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
	    if table.find({"Part0", "Part1", "Parent"}, prop) then
	        enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

--[[
    fling function
    usage: fling(target, duration, velocity)
    target can be set to: basePart, CFrame, Vector3, character model or humanoid
    duration (fling time) can be set to a number or a string containing the number (in seconds) will be set to 0.5 if not provided,
    velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)
]]

local flingpart0 = gp(model, flingpart, "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0.Destroying:Connect(function()
        flingpart0 = nil
        fling = function() end
    end)
    flingpart0.Archivable = true
    flingpart1.Destroying:Connect(function()
        flingpart1 = nil
        fling = function() end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0.Destroying:Connect(function()
            att0 = nil
            fling = function() end
        end)
        att1.Destroying:Connect(function()
            att1 = nil
            fling = function() end
        end)
        local lastfling = nil
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    local parent = target.Parent
                    if not (parent and parent:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                return
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.Size = v3(0.01, 0.01, 0.01)
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Destroying:Connect(function()
                flingpart = nil
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = false
                end
            end
            local con = nil
            con = heartbeat:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rotVelocity
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            local steppedRotVel = v3(
                ((rotVelocity.X > 0) and -1) or 1,
                ((rotVelocity.Y > 0) and -1) or 1,
                ((rotVelocity.Z > 0) and -1) or 1
            )
            local con = nil
            con = stepped:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = steppedRotVel
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = true
                end
            end
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end

wait(7)


-------------------------------------------------------------------------
--------------------------
--Zenith Battle Rifle-70--
----------------------------------------------------------------
--By CKbackup (Sugarie Saffron)                               --
--YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw--
--Discord: Sugarie Saffron#4705                               --
----------------------------------------------------------------
FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()

print([[
--------------------------------
By CKbackup (Sugarie Saffron)                               
YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw
Discord: Sugarie Saffron#4705    
--------------------------------
The Zenith Battle Rifle 70 (ZBR-70)
The ZBR-70 was a rifle designed by
Engineer Alexander Zenith in 1970, for a
cheap yet reliable option to be used
as a standard issue rifle.
It fires 5.56 calibre rounds and
is still used today in several armies
and police forces.
--------------------------------
(Keys)
Click (Hold) - Fire
R - Reload
Q/E - Quick Strafe
Z - Dive
X - Knife Stab
F - Heal
H - Flashlight

Reloading while there's still ammo will
add an extra bullet.
Rifle only has an effective range of
200 studs.
Healing will add a health point for 200
frames before wearing out, and has a
cooldown of 30 seconds.
]])


wait(1/60)
Effects = { }
local Player = game:service'Players'.LocalPlayer
local plr = game:service'Players'.LocalPlayer

local Mouse = Player:GetMouse()
local chara = Player.Character
local Humanoid = chara:FindFirstChildOfClass("Humanoid")
local LeftArm = chara["Left Arm"]
local RightArm = chara["Right Arm"]
local LeftLeg = chara["Left Leg"]
local RightLeg = chara["Right Leg"]
local Head = chara.Head
local Torso = chara.Torso
local Camera = workspace.CurrentCamera
local RootPart = chara.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local attack = false
local Anim = 'Idle'
local attacktype = 1
local delays = false
local play = true
local targetted = nil
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local doe = 0
local Create = FELOADLIBRARY.Create
local debby = game:GetService("Debris")
Humanoid.WalkSpeed = 16

local shots = 30

local healing = false

Humanoid.Animator.Parent = nil
chara.Animate.Parent = nil



local newMotor = function(part0, part1, c0, c1)
local w = Create('Motor'){
Parent = part0,
Part0 = part0,
Part1 = part1,
C0 = c0,
C1 = c1,
}
return w
end

function clerp(a, b, t)
return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
if bool == true then
if resetc1 == false then
resetc1 = true
RootJoint.C1 = RootJoint.C1
Torso.Neck.C1 = Torso.Neck.C1
RW.C1 = rarmc1
LW.C1 = larmc1
RH.C1 = rlegc1
LH.C1 = llegc1
end
end
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.03333333333333
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
script.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
script.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)
function swait(num)
if num == 0 or num == nil then
ArtificialHB.Event:wait()
else
for i = 0, num do
ArtificialHB.Event:wait()
end
end
end

function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function so(id,par,pit,vol)
local sou = Instance.new("Sound", par or workspace)
if par == chara then
sou.Parent = chara.Torso
end
sou.Volume = vol
sou.Pitch = pit or 1
sou.SoundId = "rbxassetid://" .. id
sou.PlayOnRemove = true
sou:Destroy()
end

--This is just for builds--
New = function(Object, Parent, Name, Data)
local Object = Instance.new(Object)
for Index, Value in pairs(Data or {}) do
Object[Index] = Value
end
Object.Parent = Parent
Object.Name = Name
return Object
end

Rifle = New("Model",chara,"Rifle",{})
Handaru = New("Part",Rifle,"Handaru",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299999684, 0.899999976, 0.200000003),CFrame = CFrame.new(4.86797953, 9.56716633, -139.033096, 5.38420863e-10, 1.44063961e-09, 1, 0.939692974, -0.342020035, 4.30411262e-12, 0.342022955, 0.93970108, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Handaru,"Mesh",{Scale = Vector3.new(0.699999988, 0.800000012, 0.899999976),})
Weld = New("ManualWeld",Handaru,"Weld",{Part0 = Handaru,Part1 = RightArm,C0 = CFrame.new(0, 0, 0, 0, 0.939692974, 0.342020005, 0, -0.342020005, 0.939692974, 1, 0, 0),C1 = CFrame.new(-0.17155385, -1.13280964, 0.0381164551, -1, -0.000112917653, 0.000207058736, -0.000112889931, 1, 0.000133873371, -0.000207074263, 0.000133850204, -1.00000167),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.300000191, 0.200000003),CFrame = CFrame.new(4.86804056, 9.70005512, -138.636124, 1.32227007e-11, 1.53790924e-09, 1, 1.00000036, 0, 4.30411262e-12, 0, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(0.260647774, 0.327582359, 6.10351563e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299999744, 0.200000003, 0.200000003),CFrame = CFrame.new(4.86801004, 6.5500145, -138.486115, 1.32227007e-11, 1.53790924e-09, 1, 1.00000036, 0, 4.30411262e-12, 0, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.64811707, 1.54591751, 3.05175781e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.19999969, 0.300000012, 0.200000003),CFrame = CFrame.new(4.86801004, 9.10005951, -138.636124, 1.32227007e-11, 1.53790924e-09, 1, 1.00000036, 0, 4.30411262e-12, 0, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.303163528, 0.532794952, 3.05175781e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.0999999195, 0.200000003),CFrame = CFrame.new(4.86804056, 6.35001183, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(-2.8360548, 1.6143322, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 8.10003662, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.19156933, 1.01578903, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 8.10003662, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.19156933, 1.01578903, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 8.10003662, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-1.17448044, 1.06274033, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 8.10003662, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-1.20866871, 0.968809128, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.200000003, 0.5, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999678, 0.400000006, 0.200000003),CFrame = CFrame.new(4.86801004, 8.84343719, -138.889923, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 1, 0.899999976),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.631113052, 0.382074356, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 6.90001345, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-2.33632183, 1.37924004, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 7.5000248, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.75539589, 1.22100544, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 7.5000248, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.75539589, 1.22100544, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 7.45002079, -138.536102, -1.32226452e-11, 1.53790924e-09, -1, -1.00000036, 2.98023224e-08, -4.30411262e-12, 2.98023224e-08, 1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.81948566, 1.19112206, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(0.199999765, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 6.50001335, -138.336105, -1.32226452e-11, 1.53790924e-09, -1, -1.00000036, 2.98023224e-08, -4.30411262e-12, 2.98023224e-08, 1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.400000006, 0.600000024, 0.0500000007),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-2.64379501, 1.70398521, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999975, 0.100000001, 0.100000001),CFrame = CFrame.new(4.86801004, 8.05001831, -138.636108, 1, -1.53790924e-09, 1.32226452e-11, 4.30411262e-12, -2.98023224e-08, 1.00000036, 2.29920261e-09, -1.00000894, -2.98023224e-08),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1.00000668, 0, -1.00000668, 0, 0),C1 = CFrame.new(-1.28987503, 0.891940117, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999559, 0.200000018, 0.200000003),CFrame = CFrame.new(4.86801004, 8.30002022, -138.586105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.03784847, 0.853420258, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.100000001, 0.600000024, 0.699999988),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 9.1500349, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.153590202, 0.797625542, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 7.5000248, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-1.738307, 1.26795673, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 7.20001698, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.0373106, 1.32361412, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.25003147, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.999316216, 1.10544491, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 6.90001297, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-2.31922245, 1.42622185, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 6.90001297, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.31922245, 1.42622185, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.200000003, 0.5, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Bolt1 = New("Part",Rifle,"Bolt1",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.499999553, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 8.85004425, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Bolt1,"Mesh",{Scale = Vector3.new(1, 0.400000006, 1.04999995),})
Weld = New("ManualWeld",Bolt1,"Weld",{Part0 = Bolt1,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.486792564, 0.759271622, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 7.20001793, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-2.02022171, 1.37056446, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 7.20001698, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-2.0373106, 1.32361412, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.35003948, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.905339241, 1.07124043, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 7.5000248, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-1.77249527, 1.17402458, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 6.90001297, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-2.30213356, 1.47317219, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 7.45002079, -138.436096, -1.32226452e-11, -1.53790924e-09, 1, -1.00000036, -2.98023224e-08, 4.30411262e-12, 2.98023224e-08, -1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.78528309, 1.28509235, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 7.20001793, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-2.05440998, 1.27663231, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
BoltP2 = New("Part",Rifle,"BoltP2",{Material = Enum.Material.SmoothPlastic,Transparency = 1,Transparency = 1,Size = Vector3.new(0.0999995545, 0.200000003, 0.100000001),CFrame = CFrame.new(4.71800089, 9.05003452, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",BoltP2,"Mesh",{Offset = Vector3.new(-0.0399999991, 0, 0),Scale = Vector3.new(0.200000003, 0.200000003, 1.20000005),})
Weld = New("ManualWeld",BoltP2,"Weld",{Part0 = BoltP2,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.298863411, 0.690872192, -0.149978638, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 9.05004311, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.247550964, 0.831825256, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 7.45002079, -138.436096, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.78528309, 1.28509235, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.330000043, 0.100000001, 0.200000018),CFrame = CFrame.new(4.86801004, 10.4435368, -138.676941, 1.44968448e-09, 5.13570408e-10, 1, 0.342020035, -0.939692914, 4.30411262e-12, 0.93970108, 0.342023075, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.34202221, 0.939699054, 0, 0.939699054, 0.342022151, 0, 0, 0, -1),C1 = CFrame.new(0.945329666, 0.0349359512, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999964, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 10.475091, -138.861252, -5.13568965e-10, 1.44968504e-09, 1, 0.939693391, 0.342019081, 4.30411262e-12, -0.342022091, 0.939701438, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.939699411, -0.342021286, 0, -0.342021257, 0.939699411, 0, 0, 0, -1),C1 = CFrame.new(0.911945343, -0.149044991, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.95003605, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.341526985, 0.866029739, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.75003719, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.529464722, 0.934432983, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.200000003),CFrame = CFrame.new(4.86804056, 9.70004368, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Sphere,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(0.311944008, 0.468552589, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.09999979, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.75003815, -138.436096, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.563667297, 0.840460777, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.0999999866, 0.200000003),CFrame = CFrame.new(4.86797953, 9.75094795, -139.391876, 5.38420808e-10, 1.44063961e-09, 1, 0.939692974, -0.342020005, 4.30411262e-12, 0.342022926, 0.93970108, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 1, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),C1 = CFrame.new(0.049990654, -0.399991989, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.399999917, 0.200000003),CFrame = CFrame.new(4.86804056, 9.50004482, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(0.124007225, 0.536956787, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.630000234, 0.100000001, 0.200000018),CFrame = CFrame.new(4.86801004, 11.1861582, -138.831116, 1.53790924e-09, -1.32226452e-11, 1, 2.98023224e-08, -1.00000036, 4.30411262e-12, 1.00000894, 2.98023224e-08, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, 1.00000668, 0, 0, 0, 0, -1),C1 = CFrame.new(1.59043694, -0.36392498, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.100000001, 0.600000024, 0.699999988),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.65003014, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.623440742, 0.968637466, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999975, 0.100000016, 0.400000006),CFrame = CFrame.new(4.86801004, 8.30003548, -138.736115, 1, -1.53790924e-09, 1.32226452e-11, 4.30411262e-12, -2.98023224e-08, 1.00000036, 2.29920261e-09, -1.00000894, -2.98023224e-08),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1.00000668, 0, -1.00000668, 0, 0),C1 = CFrame.new(-1.08913803, 0.712458611, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 7.80001593, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.47349644, 1.11840248, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.199999765, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 6.50001335, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.5, 0.5, 0.100000001),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.64379501, 1.70398521, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.45003128, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.811378479, 1.03704071, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999975, 0.300000012, 0.300000012),CFrame = CFrame.new(4.86801004, 9.23582172, -138.853729, 1, -5.13568965e-10, 1.44968504e-09, 4.30411262e-12, 0.939693391, 0.342019081, 2.29920261e-09, -0.342022091, 0.939701438),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(0.300000012, 0.200000003, 0.600000024),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 0, -1, -0.939699411, -0.342021286, 0, -0.342021257, 0.939699411, 0),C1 = CFrame.new(-0.250016212, 0.281872749, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 7.80001593, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-1.45640755, 1.16535378, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 7.80001593, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.47349644, 1.11840248, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.199999988, 0.200000003),CFrame = CFrame.new(4.86797953, 9.63987923, -139.379089, 1.44063961e-09, 1, 5.38420808e-10, -0.342020005, 4.30411262e-12, 0.939692974, 0.93970108, 2.29920261e-09, 0.342022926),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.800000012, 1),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0.34202221, 0.939698994, 0, 0, 0, -1, -0.939698994, 0.34202221, 0),C1 = CFrame.new(-0.0500078201, -0.349992752, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.55003834, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.717402458, 1.00283623, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999678, 0.200000003, 0.200000003),CFrame = CFrame.new(4.86801004, 9.20003986, -138.986115, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.200000003, 0.899999976),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.328917503, 0.169712067, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 7.45002079, -138.536102, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.81948566, 1.19112206, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299999684, 0.800000012, 0.200000003),CFrame = CFrame.new(4.86797953, 9.55004978, -138.986099, 5.38420808e-10, 1.44063961e-09, 1, 0.939692974, -0.342020005, 4.30411262e-12, 0.342022926, 0.93970108, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 1, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),C1 = CFrame.new(-1.14440918e-05, 0.0500144958, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.85004425, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.435488701, 0.9002285, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999964, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 10.4500523, -138.536102, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(0.999621391, 0.165052414, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.0999999195, 0.200000003),CFrame = CFrame.new(4.86804056, 6.35001183, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 1.04999995, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(-2.8360548, 1.6143322, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 7.80001593, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-1.49059582, 1.07142258, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Mag = New("Model",Rifle,"Mag",{})
MagPart = New("Part",Mag,"MagPart",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999678, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.80870724, -139.086884, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",MagPart,"Mesh",{Scale = Vector3.new(0.899999976, 1, 0.699999988),})
Weld = New("ManualWeld",MagPart,"Weld",{Part0 = MagPart,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.731114388, 0.208864212, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.95642948, -139.11293, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(0.150000572, 1.43051147e-06, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.85794735, -139.095566, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(0.0499992371, 1.43051147e-06, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.75946617, -139.078201, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.0500011444, 1.43051147e-06, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.66098499, -139.060837, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.150001526, 9.53674316e-07, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.499999553, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 8.85004425, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.949999988, 0.349999994, 1.02499998),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.486792564, 0.759271622, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
MuzzleFlash = New("Part",Rifle,"MuzzleFlash",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.100000001, 0.100000001, 0.100000001),CFrame = CFrame.new(4.86804056, 6.25002193, -138.486115, 1.53790924e-09, 1.32227007e-11, -1, 0, 1.00000036, -4.30411262e-12, 1.00000894, 0, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Weld = New("ManualWeld",MuzzleFlash,"Weld",{Part0 = MuzzleFlash,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(-2.93001747, 1.64852142, 6.10351563e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
BoltP1 = New("Part",Rifle,"BoltP1",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999995545, 0.200000003, 0.100000001),CFrame = CFrame.new(4.71800089, 8.65003014, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",BoltP1,"Mesh",{Offset = Vector3.new(-0.0399999991, 0, 0),Scale = Vector3.new(0.200000003, 0.200000003, 1.20000005),})
Weld = New("ManualWeld",BoltP1,"Weld",{Part0 = BoltP1,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.674744606, 0.827680588, -0.149978638, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Bolt2 = New("Part",Rifle,"Bolt2",{Material = Enum.Material.SmoothPlastic,Transparency = 1,Transparency = 1,Size = Vector3.new(0.0999995619, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 9.05004692, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Bolt2,"Mesh",{Scale = Vector3.new(1, 0.400000006, 1.04999995),})
Weld = New("ManualWeld",Bolt2,"Weld",{Part0 = Bolt2,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.298851967, 0.690867424, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})

local Knife2 = New("Part",chara,"Knife2",{BrickColor = BrickColor.new("Really black"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.200000018, 3, 0.600000024),CFrame = CFrame.new(20.800066, 8.20085621, -102.600151, 0.999997199, -7.43909914e-05, -0.000123201287, 0.000132681176, 7.43816781e-05, 1.00000858, -8.01031129e-05, -0.999997139, 8.01140704e-05),CanCollide = false,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",Knife2,"Mesh",{MeshId = "rbxassetid://121944778",TextureId = "rbxassetid://121944805",MeshType = Enum.MeshType.FileMesh,})
Weld = New("ManualWeld",Knife2,"Weld",{Part0 = Knife2,Part1 = LeftArm,C0 = CFrame.new(0, 0, 0, 1, -1.83178334e-11, -9.29553131e-20, -8.93234474e-20, 1.9826904e-10, -1, 1.83178334e-11, 1, 1.9826904e-10),C1 = CFrame.new(0.0998783112, -1.00001431, 0.900054932, -0.999999046, -0.00013233356, 7.98649926e-05, -0.000129168649, 1.00000286, 7.99051195e-05, -7.79679685e-05, 7.79874026e-05, -0.999999046),})

SheathPart = New("Part",chara,"SheathPart",{BrickColor = BrickColor.new("Really black"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(-4.70037603, 7.11581182, -105.941528, 0.000411997637, 0.000128002648, 1, 0.765914023, -0.642943084, -0.00023325636, 0.642943025, 0.765914023, -0.000362930034),CanCollide = false,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",SheathPart,"Mesh",{Scale = Vector3.new(0.419999987, 2.5, 5),MeshId = "rbxassetid://504776834",MeshType = Enum.MeshType.FileMesh,})
Weld = New("ManualWeld",SheathPart,"Weld",{Part0 = SheathPart,Part1 = LeftLeg,C0 = CFrame.new(0, 0, 0, 0.000411997637, 0.765914023, 0.642943025, 0.000128002648, -0.642943084, 0.765914023, 1, -0.00023325636, -0.000362930034),C1 = CFrame.new(-0.399157524, -0.0849089622, 0.44103241, -1, -0.000285560207, 0.000172345346, -0.000285530492, 1, 0.000172423926, -0.000172394575, 0.000172374697, -1),})
local KnifeH = New("Part",chara,"KnifeH",{BrickColor = BrickColor.new("Really black"),FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(-4.70015621, 7.43445921, -105.543449, 1, -0.000408680877, -0.00014000498, -0.000222999661, -0.765914917, 0.642942011, -0.000369990012, -0.642941952, -0.765914917),CanCollide = false,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",KnifeH,"Mesh",{MeshId = "rbxassetid://121944778",TextureId = "rbxassetid://121944805",MeshType = Enum.MeshType.FileMesh,})
Weld = New("ManualWeld",KnifeH,"Weld",{Part0 = KnifeH,Part1 = LeftLeg,C0 = CFrame.new(0, 0, 0, 1, -0.000222999661, -0.000369990012, -0.000408680877, -0.765914917, -0.642941952, -0.00014000498, 0.642942011, -0.765914917),C1 = CFrame.new(-0.399399757, 0.23380661, 0.043006897, -1, -0.000285560207, 0.000172345346, -0.000285530492, 1, 0.000172423926, -0.000172394575, 0.000172374697, -1),})

Knife2.Transparency = 1
KnifeH.Transparency = 0

local lp = game:GetService("Players").LocalPlayer

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local attackm = nil
local hat = gp(cplayer, "VN9K [Back]", "Accessory")
local handle = gp(hat, "Handle", "BasePart")
local att = gp(handle, "att1_Handle", "Attachment")
att.Parent = Handaru
att.Position = v3(0, 0.28, 0)
att.Rotation = v3(0, 0, -15)

local hat2 = gp(cplayer, "Nightstick", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
--handle2.SpecialMesh:Destroy()
local att = gp(handle2, "att1_Handle", "Attachment")
att.Parent = KnifeH
--att.Position = v3(0, 0, 0)
att.Rotation = v3(-130, 0, 0)


local function knife1()
print(att.Parent)
	att.Parent = cplayer.Knife2
	
	--att.Position = v3(0, 0, 0)
	att.Rotation = v3(-130, 0, 0)
end

local function knife2()
print(att.Parent)
	att.Parent = cplayer.KnifeH
	--att.Position = v3(0, 0, 0)
	att.Rotation = v3(-130, 0, 0)
end

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
	if attack == false then
	fling(game:GetService("Players").LocalPlayer.Character["Model"].HumanoidRootPart.Position, 0.1)
	
	elseif attack == true then
	if attackm == "knife" then
	fling(cplayer.Knife2.Position, 0.1)
	elseif attackm == "gun" then
	if Player:GetMouse().Target ~= nil then
	fling(Player:GetMouse().Hit.p, 0.1)
	
	end
	end
	end
	end
	end)

for i, v in pairs(Rifle:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end

function CreateTrailObj(parent,color1,color2,ofsx,ofsz)
local Att1 =  New("Attachment",parent,"Att1",{Position = Vector3.new(ofsx,parent.Size.Y/2,ofsz)})
local Att2 =  New("Attachment",parent,"Att2",{Position = Vector3.new(ofsx,-(parent.Size.Y/2),ofsz)})
local TEff = New("Trail",parent,"TrailEff",{Color = ColorSequence.new({ColorSequenceKeypoint.new(0,BrickColor.new(color1).Color),ColorSequenceKeypoint.new(1,BrickColor.new(color2).Color)}),Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,.5),NumberSequenceKeypoint.new(1,1)}),Attachment0 = Att1,Attachment1 = Att2,Enabled = false,Lifetime = .5,MinLength = .001})
return TEff
end

LLTr = CreateTrailObj(LeftLeg,"White","White",0,0)
RLTr = CreateTrailObj(RightLeg,"White","White",0,0)
LATr = CreateTrailObj(LeftArm,"White","White",0,0)
RATr = CreateTrailObj(RightArm,"White","White",0,0)

local p1mit = Instance.new("ParticleEmitter",Knife2)
p1mit.Texture = "rbxasset://textures/particles/fire_main.dds"
p1mit.Color = ColorSequence.new(Color3.new(.6,0,0))
p1mit.Size = NumberSequence.new(1,0)
p1mit.Lifetime = NumberRange.new(2)
p1mit.Rate = 100
p1mit.Enabled = false
p1mit.Acceleration = Vector3.new(0,-10,0)
p1mit.Rotation = NumberRange.new(0,359)
p1mit.Speed = NumberRange.new(0)
p1mit.Enabled = false

local tr2
spawn(function()
local Att1 =  New("Attachment",Knife2,"Att1",{Position = Vector3.new(0,1.3,.2)})
local Att2 =  New("Attachment",Knife2,"Att2",{Position = Vector3.new(0,-.5,.2)})
tr2 = New("Trail",Knife2,"TrailEff",{Color = ColorSequence.new(Color3.new(.8,.8,.8)),Transparency = NumberSequence.new(0,1),Attachment0 = Att1,Attachment1 = Att2,Enabled = false,Lifetime = .5,MinLength = .001})
end)

local scr = Instance.new("ScreenGui",Player:FindFirstChildOfClass("PlayerGui"))
local fr1 = Instance.new("Frame",scr)
fr1.AnchorPoint = Vector2.new(1,.5)
fr1.BackgroundTransparency = 1
fr1.BorderSizePixel = 0
fr1.Position = UDim2.new(1,0,.6,0)
fr1.Size = UDim2.new(0,150,0,200)

local imgbase = Instance.new("ImageLabel")
imgbase.BackgroundTransparency = 1
imgbase.BorderSizePixel = 0
imgbase.Size = UDim2.new(0,50,0,50)
imgbase.ImageColor3 = Color3.new(.3,.3,.3)

local img1 = imgbase:Clone()
img1.Parent = fr1
img1.Image = "rbxassetid://50231593"
img1.ImageColor3 = Color3.new(1,1,1)

imgbase:Destroy()

local txtbase = Instance.new("TextLabel")
txtbase.BackgroundTransparency = 1
txtbase.BorderSizePixel = 0
txtbase.Size = UDim2.new(0,100,0,50)
txtbase.Font = "Highway"
txtbase.TextSize = 30
txtbase.TextColor3 = Color3.new(.3,.3,.3)
txtbase.TextStrokeColor3 = Color3.new(0,0,0)
txtbase.TextStrokeTransparency = 0

local txt1 = txtbase:Clone()
txt1.Parent = fr1
txt1.Text = "30/30"
txt1.TextColor3 = Color3.new(1,1,1)
txt1.Position = UDim2.new(0,50,0,0)

txtbase:Destroy()

local fr2 = Instance.new("Frame",scr)
fr2.AnchorPoint = Vector2.new(.5,.5)
fr2.BackgroundColor3 = Color3.new(0,0,0)
fr2.BorderColor3 = Color3.new(0,0,0)
fr2.BorderSizePixel = 5
fr2.Position = UDim2.new(.5,0,.8,0)
fr2.Size = UDim2.new(0,300,0,30)

local hpbar = Instance.new("Frame",fr2)
hpbar.BackgroundColor3 = Color3.new(0,1,0)
hpbar.BorderSizePixel = 0
hpbar.Size = UDim2.new(1,0,1,0)
local hptext = Instance.new("TextLabel",fr2)
hptext.BackgroundTransparency = 1
hptext.BorderSizePixel = 0
hptext.LayoutOrder = -1
hptext.Size = UDim2.new(0,100,1,0)
hptext.Font = "Highway"
hptext.Text = " + 100"
hptext.TextColor3 = Color3.new(1,1,1)
hptext.TextSize = 30
hptext.TextXAlignment = "Left"

coroutine.wrap(function()
while true do
swait()
txt1.Text = shots.."/30"
end
end)()

coroutine.wrap(function()
while true do
swait()
local hp = Humanoid.Health
local mhp = Humanoid.MaxHealth
hpbar.Size = UDim2.new(hp/mhp,0,1,0)
if healing == false then
hpbar.BackgroundColor3 = Color3.new(1-(hp/mhp),hp/mhp,0)
else
hpbar.BackgroundColor3 = Color3.new(1,1,0)
end
hptext.Text = " + "..(math.floor(hp))
end
end)()

local li = Instance.new("SpotLight",Head)
li.Angle = 90
li.Brightness = 50
li.Shadows = true
li.Range = 30
li.Enabled = false

function rayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function FindNearestTorso(Position, Distance, SinglePlayer)
if SinglePlayer then
return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
end
local List = {}
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") then
if v:findFirstChild("Head") then
if v ~= chara then
if (v.Head.Position - Position).magnitude <= Distance then
table.insert(List, v)
end 
end 
end 
end 
end
return List
end

EffectModel = Create("Model"){
Parent = chara,
Name = "Effects",
}

--Effect Functions--
Effects = {

Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("BlockMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
if spin == true then
p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
p:Destroy()
end)()
return p
end,

Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("CylinderMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}

function GetDudesTorso(c)
local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
if torsy ~= nil then
return torsy
end
end

function BodyVel(part,faws)
local bodyvel = Instance.new("BodyVelocity",part)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = faws
debby:AddItem(bodyvel,.2)
end

function Dmg(dude,dmg,env,faws,trip,efftyp,toim)
	if dude ~= nil and dude.Parent.Name ~= chara.Name and dude.Parent.Name ~= plr.Name and dude.Parent:FindFirstChild("Torso") ~= nil then
if dude:FindFirstChild("HITO") then return end
if toim ~= 0 then
local debounce = Instance.new("BoolValue",dude)
debounce.Name = "HITO"
debby:AddItem(debounce,toim)
end
local hum = dude:FindFirstChildOfClass("Humanoid")
local dam = dmg+math.random(0,0)
local teksu = "-"..dam
if hum then
local finhel = hum.Health - dam
if (finhel <= 0 and dude:FindFirstChild("DEATHED")==nil) or dmg == math.huge then
teksu = "DEATH"
--dude:BreakJoints()
Instance.new("BoolValue",dude).Name = "DEATHED"
--local soaa = Instance.new("Sound",dude.Head)
--local cho = math.random(1,5)
--if cho == 1 then
--soaa.SoundId = "rbxassetid://111896685"
--elseif cho == 2 then
--soaa.SoundId = "rbxassetid://535528169"
--elseif cho == 3 then
--soaa.SoundId = "rbxassetid://1080363252"
--elseif cho == 4 then
--soaa.SoundId = "rbxassetid://147758746"
--elseif cho == 5 then
--soaa.SoundId = "rbxassetid://626777433"
--soaa.Volume = .2
--soaa.TimePosition = 1
--end
--game:service'Debris':AddItem(soaa,6)
--soaa:Play()
end
if dmg ~= math.huge then
hum.Health = hum.Health - dam
end
end
coroutine.wrap(function()
local naeeym2 = Instance.new("BillboardGui",dude)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = dude:FindFirstChild("Head")
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = teksu
tecks2.Font = "Fantasy"
tecks2.TextSize = 24
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,1,1)
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
swait(10)
for i = 0,1,.05 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.005,0)
tecks2.TextStrokeTransparency = i
tecks2.TextTransparency = i
end
naeeym2:Destroy()
end)()
local torsy = GetDudesTorso(dude)
if torsy then
local amtt = dam/5
if amtt > 30 then
amtt = 30
end
for i=1,amtt do
local blp = Instance.new("Part",EffectModel)
blp.Size = Vector3.new(.3,.3,.3)
blp.BrickColor = BrickColor.new("Crimson")
blp.CFrame = torsy.CFrame*CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
blp.Velocity = torsy.CFrame.lookVector*math.random(-8,-8) + torsy.CFrame.rightVector*math.random(-8,8) + Vector3.new(0,math.random(0,5),0)
blp.RotVelocity = Vector3.new(math.random(-15,15),math.random(-15,15),math.random(-15,15))
--local blm = Instance.new("SpecialMesh",blp)
--blm.MeshType = "Sphere"
coroutine.wrap(function()
swait(10)
blp.Orientation = Vector3.new(0,blp.Orientation.y,0)
for i=0,1,.1  do
swait()
blp.Transparency = i
blp.Size = blp.Size + Vector3.new(.05,-.05,.05)
end
blp:Destroy()
end)()
end
if efftyp == "Blunt" then
puncheff(torsy)
elseif efftyp == "Sharp" then
slasheff(torsy)
coroutine.wrap(function()
if Knife2.Transparency == 0 then
p1mit.Enabled = true
swait(10)
p1mit.Enabled = false
end
end)()
elseif efftyp == "Shot" then
so(144884872,torsy,.9,1)
end
if faws ~= 0 then
BodyVel(torsy,faws)
end
if trip == true then
torsy.CFrame = torsy.CFrame * CFrame.Angles(math.rad(-90),0,0)
torsy.RotVelocity = Vector3.new(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
end
end

function MagnitudeDmg(par,magni,dmg,env,faws,trip,efftyp,toim)
for _, c in pairs(workspace:GetDescendants()) do
local hum = c:FindFirstChildOfClass("Humanoid")
if hum ~= nil and c:FindFirstChild("IsTeamMateOfCK")==nil then
local head = GetDudesTorso(c)
if head ~= nil then
local targ = head.Position - par.Position
local mag = targ.magnitude
if magni >= mag and c ~= chara then
Dmg(c,dmg,env,faws,trip,efftyp,toim)
end
end
end
end
end

function CamShake(par,magni,env,dur)
coroutine.wrap(function()
for i=0,dur*60 do
swait()
Humanoid.CameraOffset = Vector3.new(math.random(-(env*10),(env*10))/10,math.random(-(env*10),(env*10))/10,math.random(-(env*10),(env*10))/10)
end
Humanoid.CameraOffset = Vector3.new()
end)()
end

function puncheff(par)
if par.Parent:FindFirstChild("DebounceHit")==nil then
so(386946017,par,math.random(80,120)/100,1)
Effects.Sphere(par.CFrame,Vector3.new(1,1,1),Vector3.new(1,1,1),Vector3.new(.1,.1,.1),"Neon","White",false,.1)
end
end

function slasheff(par)
if par.Parent:FindFirstChild("DebounceHit")==nil then
local cho = math.random(1,3)
so(444667859,par,1,1)
Effects.Sphere(par.CFrame*CFrame.Angles(math.random(0,360),math.random(0,360),math.random(0,360)),Vector3.new(.5,.5,.5),Vector3.new(1,0,1),Vector3.new(-.1,5,-.1),"Neon","White",false,.1)
CamShake(par,3,.3,.5)
end
end

function gunreload()
local bolting = false
if shots < 1 then
bolting = true
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(7.16576396e-05, -8.09862577e-09, 5.8991347e-05, 0.866025805, 5.21622605e-05, -0.499999523, -8.21355061e-05, 1, -3.79384437e-05, 0.500003934, 7.39239331e-05, 0.866033435),
CFrame.new(-0.000200522729, 1.49998856, -2.10760772e-05, 0.866025805, -8.21355061e-05, 0.500003934, 5.21622605e-05, 1, 7.39239331e-05, -0.499999523, -3.79384437e-05, 0.866033435),
CFrame.new(1.19112039, 0.509645581, -0.936723173, 0.866108775, 0.469844252, -0.170603499, 0.000398069969, -0.34195143, -0.939717591, -0.499855638, 0.813835204, -0.296356052),
CFrame.new(-1.01784408, -0.307534277, 0.587668538, 0.813770115, -0.296275973, 0.499998927, 0.342069209, 0.939674795, 7.47573649e-05, -0.469858527, 0.170973375, 0.866026163),
CFrame.new(0.500045836, -2.00001574, 6.10351854e-05, 1.00000012, 0, 0, 0, 1, -1.09139364e-11, 0, -1.09139364e-11, 1.00000012),
CFrame.new(-0.499982297, -2.00001812, -1.68383121e-06, 0.866025805, 7.7745608e-07, 0.499999464, -9.20089349e-07, 1, 3.87553882e-08, -0.499999464, -4.93619154e-07, 0.866025805),
}, .4, false)
end
so(1550642637,RightArm,1,1)
local magh = Mag:Clone()
local magd = Mag:Clone()
magd.Parent = chara
magd:MoveTo(MagPart.Position)
magd.MagPart.CFrame = MagPart.CFrame
for i,v in pairs(Mag:children'') do
v.Transparency = 1
end
for i,v in pairs(magd:children'') do
v.CanCollide = true
end
coroutine.wrap(function()
swait(120)
for ab=0,1,.1 do
swait()
for i,v in pairs(magd:children'') do
v.Transparency = ab
end
end
magd:Destroy()
end)()
swait(10)
magh.MagPart.Weld.Part1 = LeftArm
magh.MagPart.Weld.C1 = CFrame.new()
magh.MagPart.Weld.C0 = CFrame.new(-1,0,-.1) * CFrame.Angles(math.rad(90),0,math.rad(90))
magh.Parent = chara
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(6.78431461e-05, -8.38813463e-09, 6.55982731e-05, 0.866028309, 5.21623115e-05, -0.500000954, -8.2135979e-05, 1, -3.7939295e-05, 0.500000954, 7.39235766e-05, 0.866028368),
CFrame.new(-0.000197320973, 1.4999876, -1.30886638e-05, 0.98481077, -8.24863091e-05, 0.173648238, 7.46281003e-05, 1, 5.17808985e-05, -0.173648268, -3.80359343e-05, 0.98481077),
CFrame.new(1.1081171, 0.229849994, -0.552296758, 0.32167092, 0.529445052, -0.784998, -0.865821123, -0.171100825, -0.47018975, -0.383253366, 0.83091414, 0.403366506),
CFrame.new(-0.717486799, 0.926528692, -1.03411949, 0.0336538404, -0.23535648, -0.971329331, -0.966074884, 0.241339579, -0.0919491872, 0.256061047, 0.941471338, -0.219250023),
CFrame.new(0.500048757, -2.00001621, 5.34072533e-05, 1.00000596, -8.18545232e-11, 0, -8.18545232e-11, 1, -5.85714588e-10, 0, -5.85714588e-10, 1.00000596),
CFrame.new(-0.499987721, -2.00001812, -2.68220901e-07, 0.866030872, 7.77390596e-07, 0.500002384, -9.19890795e-07, 1, 3.82206053e-08, -0.500002325, -4.94204869e-07, 0.866030872),
}, .4, false)
end
magh:Destroy()
so(1550643261,RightArm,1,1)
for i,v in pairs(Mag:children'') do
v.Transparency = 0
end
shots=1
if bolting then
shots=0
swait(10)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(7.16576469e-05, -8.0986311e-09, 5.89913543e-05, 0.866025865, 5.21622605e-05, -0.499999553, -8.2135557e-05, 1, -3.79385383e-05, 0.500003994, 7.39240495e-05, 0.866033494),
CFrame.new(-0.0471813381, 1.46578491, -0.0813962817, 0.866025865, -0.171088517, 0.4698219, 5.20799076e-05, 0.939667284, 0.342089593, -0.499999523, -0.296236575, 0.813792229),
CFrame.new(0.903510451, 0.733465374, -0.540370524, 0.0522459783, 0.845055699, 0.532124102, 0.996226788, -0.00712709641, -0.0864949599, -0.0693004429, 0.534644127, -0.842239022),
CFrame.new(-1.3147887, 0.362699449, -0.10727562, 0.924801946, -0.332139075, 0.18555221, 0.0397336259, -0.400726348, -0.915335894, 0.37838313, 0.853878319, -0.35739553),
CFrame.new(0.500048101, -2.00001764, 6.48489149e-05, 1.00000465, 6.20275387e-10, 7.62939453e-06, 6.20275387e-10, 1, 1.05501385e-09, 7.62939453e-06, 1.05501385e-09, 1.00001347),
CFrame.new(-0.499982387, -2.0000186, 2.08616257e-06, 0.866025865, 7.78074536e-07, 0.500008345, -9.20103844e-07, 1, 3.99777491e-08, -0.499999523, -4.92556865e-07, 0.866041124),
}, .4, false)
end
so(437204112,RightArm,1,1)
swait(5)
end
shots = shots+30
end

function wepknifestab()
knife1()
attackm = "knife"
attack = true
Humanoid.WalkSpeed = 2
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.000179143899, 4.94844912e-08, -0.000147477331, 0.500000775, 1.22923609e-06, -0.86602509, -0.000292493496, 1.00000012, -0.000167452119, 0.866025031, 0.000337032834, 0.500000775),
CFrame.new(-0.000420931523, 1.50010991, -7.43984856e-06, 0.500000775, -0.000292493496, 0.866025031, 1.22923609e-06, 1.00000012, 0.000337032834, -0.86602509, -0.000167452119, 0.500000775),
CFrame.new(0.839951992, 0.256004274, -0.958486319, 0.499996692, 0.813799739, 0.2961981, 4.75931301e-06, 0.342016816, -0.939693928, -0.866027415, 0.469845295, 0.171003401),
CFrame.new(-1.22089827, -0.164978445, -0.0866824239, 0.983905554, -0.138054684, 0.113450736, 0.176127508, 0.856396437, -0.485349834, -0.0301539302, 0.497520208, 0.866928339),
CFrame.new(0.500076354, -2.00016046, 1.52737084e-05, 1.00000012, -1.45519152e-11, 2.98023224e-08, -1.45519152e-11, 1.00000012, -7.27595761e-12, 2.98023224e-08, -7.27595761e-12, 1.00000012),
CFrame.new(-0.499987543, -2.00015903, -5.56111336e-05, 0.499999285, 9.37507139e-07, 0.866025865, -1.2402096e-06, 1.00000012, -3.66519089e-07, -0.866025925, -8.90795491e-07, 0.499999374),
}, .5, false)
end
so(211059653,Knife2,1,1)
Knife2.Transparency = 0
KnifeH.Transparency = 1
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.000175330031, 1.00539501e-06, -0.000154084992, 0.500003099, 1.22933841e-06, -0.866029263, -0.000292495621, 1.00000453, -0.000167453458, 0.866029143, 0.000337033416, 0.500003219),
CFrame.new(-0.00041242165, 1.50012219, -6.93052425e-06, 0.500003099, -0.000292495621, 0.866029143, 1.22933841e-06, 1.00000453, 0.000337033416, -0.866029263, -0.000167453458, 0.500003219),
CFrame.new(1.09288597, 0.364121079, -0.802504063, 0.748180747, 0.593714058, 0.296199232, 0.116981708, 0.321389914, -0.939695835, -0.653104663, 0.737710655, 0.171003729),
CFrame.new(-0.688675284, 1.32965851, -0.712965548, 0.334458649, -0.800666928, -0.49706617, -0.926752567, -0.375185549, -0.0192363095, -0.171089798, 0.46709004, -0.867502213),
CFrame.new(0.500086367, -2.00017858, 1.52748289e-05, 1.00000489, -7.13043846e-10, 2.98023224e-08, -7.13043846e-10, 1.00000441, -5.31144906e-10, 2.98023224e-08, -5.31144906e-10, 1.00000489),
CFrame.new(-0.499991834, -2.00017858, -5.22881746e-05, 0.500001609, 9.36794095e-07, 0.866030037, -1.24011513e-06, 1.00000441, -3.673631e-07, -0.866030157, -8.91312084e-07, 0.500001788),
}, .5, false)
end
tr2.Enabled = true
so(200632136,Knife2,math.random(9,11)/10,1)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(-2.50339508e-06, -0.116524018, -2.23838973, 0.342018872, -5.0964772e-08, -0.939693093, 0.321393877, 0.939692676, 0.11697726, 0.883022726, -0.342020035, 0.321392655),
CFrame.new(-6.99047723e-06, 1.49998283, -2.62057279e-06, 0.342018872, 1.1920929e-07, 0.939693093, -5.0964772e-08, 1, -1.49011612e-07, -0.939693093, -7.4505806e-09, 0.342018902),
CFrame.new(1.22636616, 0.263386577, -0.809811354, 0.939690471, 0.342026293, 1.16229057e-06, -0.0593909174, 0.163175166, -0.984808028, -0.336830378, 0.925414443, 0.173647419),
CFrame.new(-1.32934356, 1.10000336, -0.700607181, -1.1920929e-07, 0.342020571, -0.939692616, -1, -4.47034836e-08, 1.49011612e-07, 7.4505806e-09, 0.939692497, 0.342020541),
CFrame.new(0.977364421, -1.93956006, -0.0584065914, 0.854759812, -0.518661916, -0.0193820298, 0.5132581, 0.850225329, -0.116975099, 0.0771495849, 0.0900376588, 0.99294579),
CFrame.new(-0.972516656, -1.19701695, -0.393972486, 0.183487743, 0.321393877, 0.92899859, 0.0593910404, 0.939692676, -0.336824, -0.981226325, 0.11697726, 0.153334215),
}, .4, false)
MagnitudeDmg(Knife2,1.5,100,0,RootPart.CFrame.lookVector*5,false,"Sharp",.5)
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.000175330031, 1.00539501e-06, -0.000154084992, 0.500003099, 1.22933841e-06, -0.866029263, -0.000292495621, 1.00000453, -0.000167453458, 0.866029143, 0.000337033416, 0.500003219),
CFrame.new(-0.00041242165, 1.50012219, -6.93052425e-06, 0.500003099, -0.000292495621, 0.866029143, 1.22933841e-06, 1.00000453, 0.000337033416, -0.866029263, -0.000167453458, 0.500003219),
CFrame.new(1.09288597, 0.364121079, -0.802504063, 0.748180747, 0.593714058, 0.296199232, 0.116981708, 0.321389914, -0.939695835, -0.653104663, 0.737710655, 0.171003729),
CFrame.new(-0.688675284, 1.32965851, -0.712965548, 0.334458649, -0.800666928, -0.49706617, -0.926752567, -0.375185549, -0.0192363095, -0.171089798, 0.46709004, -0.867502213),
CFrame.new(0.500086367, -2.00017858, 1.52748289e-05, 1.00000489, -7.13043846e-10, 2.98023224e-08, -7.13043846e-10, 1.00000441, -5.31144906e-10, 2.98023224e-08, -5.31144906e-10, 1.00000489),
CFrame.new(-0.499991834, -2.00017858, -5.22881746e-05, 0.500001609, 9.36794095e-07, 0.866030037, -1.24011513e-06, 1.00000441, -3.673631e-07, -0.866030157, -8.91312084e-07, 0.500001788),
}, .5, false)
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.000179143899, 4.94844912e-08, -0.000147477331, 0.500000775, 1.22923609e-06, -0.86602509, -0.000292493496, 1.00000012, -0.000167452119, 0.866025031, 0.000337032834, 0.500000775),
CFrame.new(-0.000420931523, 1.50010991, -7.43984856e-06, 0.500000775, -0.000292493496, 0.866025031, 1.22923609e-06, 1.00000012, 0.000337032834, -0.86602509, -0.000167452119, 0.500000775),
CFrame.new(0.839951992, 0.256004274, -0.958486319, 0.499996692, 0.813799739, 0.2961981, 4.75931301e-06, 0.342016816, -0.939693928, -0.866027415, 0.469845295, 0.171003401),
CFrame.new(-1.22089827, -0.164978445, -0.0866824239, 0.983905554, -0.138054684, 0.113450736, 0.176127508, 0.856396437, -0.485349834, -0.0301539302, 0.497520208, 0.866928339),
CFrame.new(0.500076354, -2.00016046, 1.52737084e-05, 1.00000012, -1.45519152e-11, 2.98023224e-08, -1.45519152e-11, 1.00000012, -7.27595761e-12, 2.98023224e-08, -7.27595761e-12, 1.00000012),
CFrame.new(-0.499987543, -2.00015903, -5.56111336e-05, 0.499999285, 9.37507139e-07, 0.866025865, -1.2402096e-06, 1.00000012, -3.66519089e-07, -0.866025925, -8.90795491e-07, 0.499999374),
}, .5, false)
end
so(211134014,Knife2,1,1)
Knife2.Transparency = 1
KnifeH.Transparency = 0
Humanoid.WalkSpeed = 16
tr2.Enabled = false
attack = false
attackm = nil
knife2()
end

function gunshoot()
attackm = "gun"
attack = true
Humanoid.WalkSpeed = 2
repeat
for i=0,1 do
swait()
PlayAnimationFromTable({		
CFrame.new(9.81599442e-05, -3.13463495e-08, 0.000154759327, 0.499999762, 5.98886472e-05, -0.866025686, -0.000172460219, 1, -3.0416435e-05, 0.866025627, 0.000164563156, 0.499999762),
CFrame.new(0.110661574, 1.52556551, -0.192373157, 0.469904929, 0.170847476, 0.866025805, -0.341963649, 0.93971324, 0.000164846599, -0.813787699, -0.296226799, 0.499999464),
CFrame.new(0.900587499, 0.405391365, -0.749934435, 0.50007689, 0.865988314, 0.000331558258, 0.000377809047, 0.000164698489, -0.99999994, -0.865981102, 0.500081062, -0.000244814204),
CFrame.new(-1.05577028, 0.00611187518, -0.929771721, 0.258709729, 0.208402574, 0.94320631, 0.878974199, -0.455733538, -0.140396863, 0.400591552, 0.865375996, -0.301083267),
CFrame.new(0.500045836, -2.00001764, 6.86496642e-05, 1.00000012, 0, -2.98023224e-08, 0, 1, -3.63797881e-12, -2.98023224e-08, -3.63797881e-12, 1.00000012),
CFrame.new(-0.499984354, -2.00001764, 3.27825546e-06, 0.500000656, -9.88464308e-07, 0.86602515, 8.06332537e-07, 1, 6.75843694e-07, -0.86602515, 3.60366357e-07, 0.500000656),
}, .5, false)
end
CamShake(RightArm,3,.1,.05)
Bolt1.Transparency = 1
BoltP1.Transparency = 1
Bolt2.Transparency = 0
BoltP2.Transparency = 0
local part, pos = rayCast(MuzzleFlash.Position,((Mouse.Hit.p+Vector3.new(math.random(-10,10)/10,math.random(-10,10)/10,math.random(-10,10)/10)) - MuzzleFlash.Position),200,chara)
local aimo = Instance.new("Part",Camera)
aimo.Anchored = true
aimo.Size = Vector3.new()
aimo.Transparency = 1
aimo.CanCollide = false
aimo.CFrame = CFrame.new(pos)
Effects.Meshed(MuzzleFlash.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),Vector3.new(),Vector3.new(.0025,.0001,.0025),"","rbxassetid://662585058","",0,false,.1)
Effects.Block(MuzzleFlash.CFrame,Vector3.new(.4,.4,.4),Vector3.new(),Vector3.new(.3,.3,.3),"Neon","Bright yellow",true,false,.1)
Effects.Block(MuzzleFlash.CFrame,Vector3.new(.4,.4,.4),Vector3.new(),Vector3.new(.6,.6,.6),"Neon","Bright yellow",true,false,.1)
Effects.Block(CFrame.new(pos),Vector3.new(.4,.4,.4),Vector3.new(),Vector3.new(.1,.1,.1),"Neon","Bright yellow",true,false,.1)
Effects.Block(CFrame.new((MuzzleFlash.Position + pos)/2,pos),Vector3.new(.2,.2,(MuzzleFlash.Position - pos).magnitude),Vector3.new(0,0,1),Vector3.new(.1,.1,0),"Neon","Bright yellow",false,false,.1)
MagnitudeDmg(aimo,3,18,2,RootPart.CFrame.lookVector*2,false,"Shot",.1)
so(1583819337,Bolt1,math.random(90,110)/100,2)
local hitpt = Instance.new("Part",EffectModel)
hitpt.Size = Vector3.new(0,0,.3)
hitpt.CFrame = Bolt1.CFrame * CFrame.Angles(0,math.rad(90),0)
hitpt.Velocity = RootPart.CFrame.rightVector*10+Vector3.new(0,5,0)
local hitm = Instance.new("SpecialMesh",hitpt)
hitm.MeshId = "rbxassetid://94295100"
hitm.TextureId = "rbxassetid://94287792"
hitm.Scale = Vector3.new(2,2,4)
coroutine.wrap(function()
swait(120)
for i = 0,1,.1 do
swait()
hitpt.Transparency = i
end
hitpt:Destroy()
end)()
for i=0,1 do
swait()
PlayAnimationFromTable({		
CFrame.new(7.78138638e-05, -1.36256676e-05, 0.100157872, 0.499999881, 5.98886909e-05, -0.866025805, -0.000172460306, 1.00000012, -3.04165078e-05, 0.866040111, 0.000164565776, 0.500008047),
CFrame.new(0.110661842, 1.52556539, -0.192373574, 0.469904989, 0.170847505, 0.866040289, -0.341963649, 0.93971324, 0.000164849247, -0.813787758, -0.296226829, 0.500007749),
CFrame.new(1.073771, 0.405395687, -0.649899781, 0.50007695, 0.865988374, 0.000331558171, 0.000377809076, 0.000164698373, -0.99999994, -0.865981162, 0.500081062, -0.000244814291),
CFrame.new(-0.882619739, 0.00611773878, -0.829759479, 0.258715928, 0.208411366, 0.943215907, 0.878974259, -0.455733567, -0.140396863, 0.400595129, 0.865381122, -0.301077813),
CFrame.new(0.413464695, -2.00001669, -0.049946934, 1.00001276, 2.30284058e-09, 7.09295273e-06, 2.30284058e-09, 1, 1.3042154e-09, 7.09295273e-06, 1.3042154e-09, 1.00000441),
CFrame.new(-0.586589575, -2.00001693, -0.0500222594, 0.500000775, -9.86188752e-07, 0.866039634, 8.06332537e-07, 1, 6.78477591e-07, -0.866025209, 3.61660568e-07, 0.500009),
}, .5, false)
end
shots = shots - 1
aimo:Destroy()
if shots <= 0 then
gunreload()
end
Bolt1.Transparency = 0
BoltP1.Transparency = 0
Bolt2.Transparency = 1
BoltP2.Transparency = 1
until zhold == false
Humanoid.WalkSpeed = 16
attack = false
end

function heal()
attack = true
Humanoid.WalkSpeed = 2
local val = Instance.new("BoolValue",chara)
val.Name = "healcool"
debby:AddItem(val,30)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 1.00000131, 5.536549e-11, 0, 5.536549e-11, 1, 5.82076609e-11, 0, 5.82076609e-11, 1.00000131),
CFrame.new(-0.0470143259, 1.46578526, -0.0813575089, 0.866027415, -0.171009213, 0.46984449, 1.88792183e-06, 0.939693928, 0.342016727, -0.499997973, -0.296194941, 0.813800871),
CFrame.new(1.50003648, 0.699995697, 3.59429396e-05, 1.00000131, -2.06271608e-07, -6.67154382e-06, -2.06196262e-07, -1, 2.48575816e-07, -6.67157292e-06, -2.48721335e-07, -1.00000131),
CFrame.new(-1.2535826, -0.14593178, 0.0679161474, 0.941512227, -0.331708014, -0.0593915284, 0.331707656, 0.88120383, 0.336823434, -0.059390977, -0.33682391, 0.939694226),
CFrame.new(0.500059426, -2.00001574, 4.5761466e-05, 0.939693809, -1.38383513e-07, -0.342020601, -2.80560926e-08, 1, -4.82134055e-07, 0.342020571, 4.627218e-07, 0.939694047),
CFrame.new(-0.499963611, -2.0000174, 2.33203173e-05, 0.939694047, -1.69952145e-07, 0.342020452, 2.99973181e-07, 1, -3.27068847e-07, -0.342020482, 4.10043867e-07, 0.939694047),
}, .4, false)
end
local inj = New("Part",chara,"inj",{Size = Vector3.new(2.10000014, 0.299999982, 0.300000012),CFrame = CFrame.new(-37.1041107, 9.26048374, -70.1689682, -0.100794047, 0.957379222, 0.270676494, -0.129940063, 0.257064044, -0.957618713, -0.986385465, -0.131693989, 0.0984913707),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local iMesh = New("SpecialMesh",inj,"Mesh",{Scale = Vector3.new(0.00200000009, 0.00200000009, 0.00200000009),MeshId = "rbxassetid://504973881",MeshType = Enum.MeshType.FileMesh,})
local iWeld = New("ManualWeld",inj,"Weld",{Part0 = inj,Part1 = LeftArm,C0 = CFrame.new(0, 0, 0, -0.100794047, -0.129940063, -0.986385465, 0.957379222, 0.257064044, -0.131693989, 0.270676494, -0.957618713, 0.0984913707),C1 = CFrame.new(0.250003815, -1.05000305, -0.249992371, -0.270675898, 0.957618654, -0.0984939635, 0.957379043, 0.257062733, -0.131696969, -0.100796357, -0.129943267, -0.986384809),})
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 1.00000441, 2.30059527e-10, -1.45519152e-11, 2.30059527e-10, 1, 2.32830644e-10, -1.45519152e-11, 2.32830644e-10, 1.00000441),
CFrame.new(-0.0342181027, 1.48367238, -0.0925136507, 0.939694226, 1.76227331e-07, 0.342022419, -0.0593916923, 0.984807789, 0.163176015, -0.336826295, -0.173648849, 0.925418019),
CFrame.new(1.50004876, 0.69999665, 2.83136833e-05, 1.00000441, -2.06446316e-07, -6.67157292e-06, -2.06021568e-07, -1, 2.48401193e-07, -6.67160202e-06, -2.48895958e-07, -1.00000441),
CFrame.new(-1.32655382, 0.16053623, -0.618192732, 0.82254082, 0.00194577302, 0.568706632, 0.568639874, 0.0127443047, -0.82248795, -0.00884814467, 0.999919116, 0.00937626697),
CFrame.new(0.500066876, -2.00001621, 5.19603491e-05, 0.939696729, -1.38208819e-07, -0.342021674, -2.78232619e-08, 1, -4.81959432e-07, 0.342021644, 4.62896423e-07, 0.939696968),
CFrame.new(-0.499963373, -2.00001645, 2.26646662e-05, 0.939696968, -1.69777451e-07, 0.342021525, 3.00089596e-07, 1, -3.26806912e-07, -0.342021555, 4.1021849e-07, 0.939696968),
}, .4, false)
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 1.00000012, -3.48876483e-12, 0, -3.48876483e-12, 1, 0, 0, 0, 1.00000012),
CFrame.new(-2.27339151e-05, 1.46578801, -0.0939310491, 1.00000012, -3.72103386e-07, 1.64323137e-06, -2.12327393e-07, 0.939692557, 0.342020363, -1.67140388e-06, -0.342020422, 0.939692676),
CFrame.new(1.50005758, 0.699994743, 3.59426958e-05, 1.00000012, -2.06212761e-07, -6.67157292e-06, -2.06226048e-07, -1, 2.48663127e-07, -6.67157292e-06, -2.48663127e-07, -1.00000012),
CFrame.new(-0.943567514, 0.0578621849, -0.670854151, 0.270323098, -0.957491815, 0.100672945, 0.957676411, 0.256677359, -0.130279034, 0.0989006162, 0.131629527, 0.986353219),
CFrame.new(0.500069618, -2.00001717, 4.97102737e-05, 0.939692676, -1.38762402e-07, -0.342020184, -2.76195351e-08, 1, -4.81668394e-07, 0.342020184, 4.62023309e-07, 0.939692795),
CFrame.new(-0.499966532, -2.00001884, 2.46018171e-05, 0.939692795, -1.69370765e-07, 0.342019975, 2.99449312e-07, 1, -3.27592716e-07, -0.342020005, 4.10247594e-07, 0.939692795),
}, .5, false)
end
so(566593606,Torso,1,1)
coroutine.wrap(function()
healing = true
for i=1,200 do
swait()
Humanoid.Health = Humanoid.Health + 1
end
healing = false
end)()
swait(60)
inj:BreakJoints()
inj.CanCollide = true
inj.Velocity = RootPart.CFrame.rightVector*-30
coroutine.wrap(function()
swait(60)
for i=0,1,.1 do
swait()
inj.Transparency = i
end
inj:Destroy()
end)()
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 1.00000012, -7.41096073e-12, 0, -7.41096073e-12, 1, 2.91038305e-11, 0, 2.91038305e-11, 0.99999994),
CFrame.new(-3.04159403e-05, 1.46578789, -0.0939521194, 1.00000012, -4.05150786e-07, 1.62865035e-06, -1.76347669e-07, 0.939691484, 0.342023492, -1.66901737e-06, -0.342023432, 0.939691424),
CFrame.new(1.50005376, 0.699994802, 3.59716505e-05, 1.00000012, -1.58599477e-07, -6.6684006e-06, -1.58597771e-07, -1, 2.8318027e-07, -6.6684006e-06, -2.83209374e-07, -0.99999994),
CFrame.new(-1.64437401, 0.697701395, 0.19487834, 0.408384711, 0.907241344, 0.100674063, -0.898611128, 0.418956876, -0.130281046, -0.160374403, -0.0372620374, 0.986352742),
CFrame.new(0.500071704, -2.00001526, 2.73138285e-05, 0.939691603, 9.13247675e-07, -0.342023104, -1.21287303e-06, 1, -6.62083039e-07, 0.342023045, 1.03705679e-06, 0.939691603),
CFrame.new(-0.499963105, -2.00001931, 1.77323818e-05, 0.939691305, -1.36975643e-06, 0.342023998, 1.52508437e-06, 1, -1.85216777e-07, -0.342024028, 6.95697963e-07, 0.939691186),
}, .5, false)
end
attack = false
attackm = nil
Humanoid.WalkSpeed = 16
end

function doge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
CFrame.new(0.997828066, 1.40889716, 0.360830426, 0, 0.173647001, 0.984807968, 0.173647001, -0.969846725, 0.171008945, 0.984807968, 0.171008945, -0.030153282),
CFrame.new(-1.00000775, 1.48291457, 0.347779244, 0, -0.173647001, -0.984807968, -0.173647001, -0.969846725, 0.171008945, -0.984807968, 0.171008945, -0.030153282),
CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.000384914892, -2.50002575, -0.500230014, 1, 0.000325046538, 9.11258903e-05, -9.11258612e-05, -1.13315764e-07, 1, 0.000325047644, -1.00000298, -8.37171683e-08),
CFrame.new(-2.67028663e-05, 1.3837955, 0.294111609, 1, 7.27595761e-12, -7.27595761e-12, 0, 0.766044259, -0.642787933, -5.78026516e-12, 0.642787993, 0.766044199),
CFrame.new(1.49976707, 1.00041652, 0.300775796, -0.00040801923, -0.765891016, 0.642970264, 2.89759337e-05, -0.642970324, -0.765891075, 0.99999994, -0.000293867604, 0.000284536654),
CFrame.new(-1.42841077, 1.06972277, 0.174795836, 0.220292583, 0.604053974, -0.765891671, -0.261924088, -0.719712377, -0.642969549, -0.939610124, 0.34224686, -0.000331013813),
CFrame.new(0.500055313, -2, 3.8146969e-05, 1, 0, -5.78026516e-12, 0, 1, 0, -5.78026516e-12, 0, 1),
CFrame.new(-0.49997139, -2, -1.62124597e-05, 1, 0, -5.78026516e-12, 0, 1, 0, -5.78026516e-12, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,50,10 do
swait()
bodyvel.Velocity = RootPart.CFrame.lookVector*(50-i)
end
bodyvel:Destroy()
swait(10)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0.00016165484, -1.36983359, -0.0292072296, 1, 7.76843081e-05, -2.60516535e-05, -6.40891813e-05, 0.939692557, 0.342020124, 5.10504469e-05, -0.342021197, 0.939695537),
CFrame.new(-1.71661304e-05, 1.55976009, -0.1281178, 1, 7.27595761e-12, -7.27595761e-12, -3.63797881e-12, 0.939692616, 0.342020214, 2.91038305e-11, -0.342020303, 0.939692557),
CFrame.new(1.50001144, 1.00809121, -0.154073462, 1, 1.45519152e-11, -7.27595761e-12, -3.63797881e-12, -0.939692974, -0.342018962, 2.91038305e-11, 0.342018992, -0.939693034),
CFrame.new(-1.30754018, 0.449972421, -0.64069438, 0.262003481, 0.219851375, -0.939691246, -0.642790556, 0.766041994, 2.16066837e-06, 0.719843447, 0.604024053, 0.342024028),
CFrame.new(0.49989906, -0.431120992, -0.657953143, 1, -6.40891813e-05, 5.10504469e-05, 7.76843081e-05, 0.939692557, -0.342021197, -2.60516535e-05, 0.342020124, 0.939695537),
CFrame.new(-0.600045562, -1.23124671, 0.200614065, 1, -3.91021022e-05, -7.18890005e-05, 7.7586832e-05, 0.173648059, 0.984807789, -2.60246452e-05, -0.984807789, 0.173648089),
}, .3, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

function goright()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
BodyVel(RootPart,RootPart.CFrame.rightVector*40)
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.866025686, 9.42248391e-07, 0.500011504, -8.48485797e-08, 1, 2.03145464e-06, -0.499997288, 1.801709e-06, 0.866039157),
CFrame.new(0.0133891273, 1.49998093, -0.223221898, 0.999244928, 0.0180275738, 0.0343858302, -0.0296961162, 0.925415933, 0.377787739, -0.0250054598, -0.378526747, 0.92527163),
CFrame.new(0.597281635, 0.899970174, -0.636579931, -0.2961981, 0.81379801, 0.499997288, 0.939692438, 0.34202075, -1.801709e-06, -0.171011984, 0.469857872, -0.866039157),
CFrame.new(-1.5597142, 0.600028992, -0.496432245, 0.556670129, 0.663414598, -0.499997288, -0.766044378, 0.642787695, 1.801709e-06, 0.321399361, 0.38303256, 0.866039157),
CFrame.new(0.0669843927, -1.80000138, -0.249991581, 0.750000238, 0.433012992, -0.499997288, -0.499999464, 0.866025865, 1.801709e-06, 0.433021635, 0.250007659, 0.866039157),
CFrame.new(-1.01960945, -1.79999983, -0.300026655, 0.663413942, 0.556670904, -0.499997288, -0.642787337, 0.766044736, 1.801709e-06, 0.38302961, 0.321402997, 0.866039157),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

function goleft()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
BodyVel(RootPart,RootPart.CFrame.rightVector*-40)
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.866035402, 9.42248391e-07, -0.499995083, 1.7168677e-06, 1, 1.08920722e-06, 0.500013709, 1.801709e-06, 0.866029859),
CFrame.new(-0.100005262, 1.49997783, -0.173194915, 0.984938622, -0.171012864, -0.0261079669, 0.171011686, 0.939692199, 0.296198815, -0.0261065066, -0.296198487, 0.954771042),
CFrame.new(1.55997992, 0.600023985, -0.496356547, 0.433018357, -0.750008225, 0.500013709, 0.866026461, 0.499998212, 1.801709e-06, -0.249996096, 0.433009237, 0.866029859),
CFrame.new(-0.510781586, 0.89997524, -0.686506629, -0.296202958, -0.813806593, -0.500013709, -0.939693034, 0.342019022, -1.801709e-06, 0.171007261, 0.469842136, -0.866029859),
CFrame.new(0.975441694, -1.79999304, -0.250189304, 0.750009537, -0.433016449, 0.500013709, 0.500001013, 0.866024911, 1.801709e-06, -0.433007956, 0.249998584, 0.866029859),
CFrame.new(-0.282589972, -1.79999781, -0.149757206, 0.813807786, -0.296199739, 0.500013709, 0.34202078, 0.939692438, 1.801709e-06, -0.469841361, 0.171009272, 0.866029859),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

zhold = false
Mouse.Button1Down:connect(function()
zhold = true
if attack == false then
gunshoot()
end
end)

Mouse.Button1Up:connect(function()
zhold = false
end)

local sprintt = 0
Mouse.KeyDown:connect(function(k)
k = k:lower()
if attack == false then
if k == 'z' then
if Anim ~= "Fall" and Anim ~= "Jump" then
doge()
end
elseif k == 'x' then
wepknifestab()
elseif k == 'h' then
so(115959318,Torso,1,1)
if li.Enabled == true then
li.Enabled = false
else
li.Enabled = true
end
elseif k == 'f' and chara:FindFirstChild("healcool")==nil then
heal()
elseif k == 'q' then
goleft()
elseif k == 'e' then
goright()
elseif k == 'r' then
attack = true
Humanoid.WalkSpeed = 1
gunreload()
Humanoid.WalkSpeed = 16
attack = false
end
end
end)

coroutine.wrap(function()
game:GetService("RunService").Stepped:connect(function()
    for i,v in pairs(chara:GetDescendants()) do
    if v:IsA("BasePart") and v.Parent.Name ~= "FakeHeadM" and v.Name ~= "Head" and v.Parent:IsA("Accessory") == false then
    v.LocalTransparencyModifier = 0
    end
    end
end)
end)()

coroutine.wrap(function()
while 1 do
swait()
if doe <= 360 then
doe = doe + 2
else
doe = 0
end
end
end)()
while true do
swait()
while true do
swait()
Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
velocity = RootPart.Velocity.y
sine = sine + change
local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
if RootPart.Velocity.y > 1 and hit == nil then 
Anim = "Jump"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
CFrame.new(0.734604299, 0.30659169, -0.856673121, 0.173673332, 0.92531991, 0.337076902, 0.00030374527, 0.342228055, -0.939616919, -0.984803319, 0.163288772, 0.0591548085),
CFrame.new(-1.22185647, -0.0727021843, -0.0971833766, 0.0593958423, 0.336820453, 0.93969363, 0.934461474, 0.312310249, -0.171008497, -0.351075143, 0.888264716, -0.296195835),
CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .3, false)
end
elseif RootPart.Velocity.y < -1 and hit == nil then 
Anim = "Fall"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
CFrame.new(0.734604299, 0.30659169, -0.856673121, 0.173673332, 0.92531991, 0.337076902, 0.00030374527, 0.342228055, -0.939616919, -0.984803319, 0.163288772, 0.0591548085),
CFrame.new(-1.22185647, -0.0727021843, -0.0971833766, 0.0593958423, 0.336820453, 0.93969363, 0.934461474, 0.312310249, -0.171008497, -0.351075143, 0.888264716, -0.296195835),
CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
}, .3, false)
end
elseif Torsovelocity < 1 and hit ~= nil then
Anim = "Idle"
if attack == false then
change = 1
PlayAnimationFromTable({
CFrame.new(0, 0, 0, 1, -1.92557081e-12, 2.61934474e-10, -1.92557081e-12, 1, -8.73114914e-11, 2.61934474e-10, -8.73114914e-11, 1.00001419) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
CFrame.new(-1.71661413e-05, 1.49998856, 6.10358911e-05, 1, -1.92557081e-12, 2.61934474e-10, -1.92557081e-12, 1, -8.73114914e-11, 2.61934474e-10, -8.73114914e-11, 1.00001419),
CFrame.new(0.734604299, 0.30659169, -0.856673121, 0.173673332, 0.92531991, 0.337076902, 0.00030374527, 0.342228055, -0.939616919, -0.984803319, 0.163288772, 0.0591548085),
CFrame.new(-1.22185647, -0.0727021843, -0.0971833766, 0.0593958423, 0.336820453, 0.93969363, 0.934461474, 0.312310249, -0.171008497, -0.351075143, 0.888264716, -0.296195835),
CFrame.new(0.500044346, -2.00001574, 4.57773203e-05, 1, -1.92557081e-12, 2.61934474e-10, -1.92557081e-12, 1, -8.73114914e-11, 2.61934474e-10, -8.73114914e-11, 1.00001419) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
CFrame.new(-0.49998188, -2.00001717, -1.52589619e-05, 1, -1.92557081e-12, 2.61934474e-10, -1.92557081e-12, 1, -8.73114914e-11, 2.61934474e-10, -8.73114914e-11, 1.00001419) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
}, .3, false)
end
elseif Torsovelocity > 2 and hit ~= nil then
Anim = "Walk"
if attack == false then
Humanoid.WalkSpeed = 24
PlayAnimationFromTable({		
CFrame.new(-8.35164028e-05, -0.0110899508, 0.357279301, 1, 8.84765032e-05, -2.51957972e-05, -7.45232464e-05, 0.939692497, 0.342020363, 5.39370812e-05, -0.342020363, 0.939692557) * CFrame.new(0, 0- .08 * math.cos((sine) / 2.5), 0) * CFrame.Angles(0, math.rad(5*math.cos(sine/2.5)), 0),
CFrame.new(-6.53590978e-05, 1.54212451, 0.181138486, 1, -7.45232464e-05, 5.39370812e-05, 8.84765032e-05, 0.939692497, -0.342020363, -2.51957972e-05, 0.342020363, 0.939692557) * CFrame.Angles(0, math.rad(0 - 2.5 * math.cos((sine) / 2.5)), 0),
CFrame.new(0.734604299, 0.30659169, -0.856673121, 0.173673332, 0.92531991, 0.337076902, 0.00030374527, 0.342228055, -0.939616919, -0.984803319, 0.163288772, 0.0591548085),
CFrame.new(-1.22185647, -0.0727021843, -0.0971833766, 0.0593958423, 0.336820453, 0.93969363, 0.934461474, 0.312310249, -0.171008497, -0.351075143, 0.888264716, -0.296195835),
CFrame.new(0.500047803, -2.00001502, 3.05175763e-05, 1, -7.27595761e-12, 0, -7.27595761e-12, 0.999999881, 0, 0, 0, 0.99999994) * CFrame.new(0, 0, 0+ 1 * math.cos((sine) / 2.5)) * CFrame.Angles(math.rad(0 - 60 * math.cos((sine) / 2.5)), 0, 0),
CFrame.new(-0.499978185, -2.00001884, -1.52587882e-05, 1, -7.27595761e-12, 0, -7.27595761e-12, 0.999999881, 0, 0, 0, 0.99999994) * CFrame.new(0, 0, 0- 1 * math.cos((sine) / 2.5)) * CFrame.Angles(math.rad(0 + 60 * math.cos((sine) / 2.5)), 0, 0),
}, .3, false)
end
end
end
end
print("Loaded")
end)
Section:NewButton("FE Dual Pistols", "gives you 2 guns", function()
--i used stravants Beautifier so it might look a bit wonky


--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
    local unit = realPartVelocity.Unit
    if (unit.Y > 0.9) or (unit.Y < -0.9) then
        return realPartVelocity * (25.1 / realPartVelocity.Y)
    end
    realPartVelocity *= Vector3_101
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        realPartVelocity = unit * Vector3_101 * 100
    end
    return realPartVelocity + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local noclipAllParts = false --set it to true if you want noclip
local flingpart = "HumanoidRootPart" --the part that will be used to fling (ctrl + F "fling function")
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local noclipmodel = (noclipAllParts and c) or model
local noclipcon = nil
local function uncollide()
	if noclipmodel then
		for i, v in pairs(noclipmodel:GetDescendants()) do
		    if v:IsA("BasePart") then
			    v.CanCollide = false
		    end
		end
	else
		noclipcon:Disconnect()
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck = nil
	local conTorso = nil
	local contorso1 = nil
	local aligns = {}
	local function enableAligns()
	    conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
	    if table.find({"Part0", "Part1", "Parent"}, prop) then
	        enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

--[[
    fling function
    usage: fling(target, duration, velocity)
    target can be set to: basePart, CFrame, Vector3, character model or humanoid
    duration (fling time) can be set to a number or a string containing the number (in seconds) will be set to 0.5 if not provided,
    velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)
]]

local flingpart0 = gp(model, flingpart, "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0.Destroying:Connect(function()
        flingpart0 = nil
        fling = function() end
    end)
    flingpart0.Archivable = true
    flingpart1.Destroying:Connect(function()
        flingpart1 = nil
        fling = function() end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0.Destroying:Connect(function()
            att0 = nil
            fling = function() end
        end)
        att1.Destroying:Connect(function()
            att1 = nil
            fling = function() end
        end)
        local lastfling = nil
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    local parent = target.Parent
                    if not (parent and parent:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                return
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.Size = v3(0.01, 0.01, 0.01)
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Destroying:Connect(function()
                flingpart = nil
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = false
                end
            end
            local con = nil
            con = heartbeat:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rotVelocity
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            local steppedRotVel = v3(
                ((rotVelocity.X > 0) and -1) or 1,
                ((rotVelocity.Y > 0) and -1) or 1,
                ((rotVelocity.Z > 0) and -1) or 1
            )
            local con = nil
            con = stepped:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = steppedRotVel
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = true
                end
            end
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end



wait(8)


Meshes = {
	Blast = '20329976',
	Crown = '1323306',
	Ring = '3270017',
	Claw = '10681506',
	Crystal = '9756362',
	Coil = '9753878',
	Cloud = '1095708',
}
clangsounds = {
	'199149119',
	'199149109',
	'199149072',
	'199149025',
	'199148971'
}
hitsounds = {
	'199149137',
	'199149186',
	'199149221',
	'199149235',
	'199149269',
	'199149297'
}
blocksounds = {
	'199148933',
	'199148947'
}
armorsounds = {
	'199149321',
	'199149338',
	'199149367',
	'199149409',
	'199149452'
}
woosh = {
	Heavy1 = '320557353',
	Heavy2 = '320557382',
	Heavy3 = '320557453',
	Heavy4 = '199144226',
	Heavy5 = '203691447',
	Heavy6 = '203691467',
	Heavy7 = '203691492',
	Light1 = '320557413',
	Light2 = '320557487',
	Light3 = '199145095',
	Light4 = '199145146',
	Light5 = '199145887',
	Light6 = '199145913',
	Light7 = '199145841',
	Medium1 = '320557518',
	Medium2 = '320557537',
	Medium3 = '320557563',
	Medium4 = '199145204'
}
music = {--i like music a lot
	Breaking = '179281636',
	FinalReckoning = '357375770',
	NotDeadYet = '346175829',
	Intense = '151514610',
	JumpP1 = '160536628',
	JumpP2 = '60536666',
	SonsOfWar = '158929777',
	WrathOfSea = '165520893',
	ProtecTorsofEarth = '160542922',
	SkyTitans = '179282324',
	ArchAngel = '144043274',
	Anticipation = '168614529',
	TheMartyred = '186849544',
	AwakeP1 = '335631255',
	AwakeP2 = '335631297',
	ReadyAimFireP1 = '342455387',
	ReadyAimFireP2 = '342455399',
	DarkLordP1 = '209567483',
	DarkLordP2 = '209567529',
	BloodDrainP1 = '162914123',
	BloodDrainP2 = '162914203',
	DanceOfSwords = '320473062',
	Opal = '286415112',
	Calamity = '190454307',
	Hypnotica = '155968128',
	Nemisis = '160453802',
	Breathe = '276963903',
	GateToTheRift = '270655227',
	InfernalBeserking = '244143404',
	Trust = '246184492',
	AwakeningTheProject = '245121821',
	BloodPain = '242545577',
	Chaos = '247241693',
	NightmareFictionHighStake = '248062278',
	TheWhiteWeapon = '247236446',
	Gale = '256851659',
	ImperialCode = '256848383',
	Blitzkrieg = '306431437',
	RhapsodyRage = '348690251',
	TheGodFist = '348541501',
	BattleForSoul = '321185592',
	TheDarkColossus = '305976780',
	EmpireOfAngels = '302580452',
	Kronos = '302205297',
	Exorcist = '299796054',
	CrimsonFlames = '297799220',
	UltimatePower = '295753229',
	DrivingInTheDark = '295753229',
	AscendToPower = '293860654',
	GodOfTheSun = '293612495',
	DarkRider = '293861765',
	Vengeance = '293375555',
	SoundOfWar = '293376196',
	HellsCrusaders = '293012202',
	Legend = '293011823',
	RisingSouls = '290524959'
}
misc = {
	GroundSlam = '199145477',
	LaserSlash = '199145497',
	RailGunFire = '199145534',
	Charge1 = '199145659',
	Charge2 = '169380469',
	Charge3 = '169380479',
	EmptyGun = '203691822',
	GunShoot = '203691837',
	Stomp1 = '200632875',
	Stomp2 = '200632561',
	TelsaCannonCharge = '169445572',
	TelsaCannonShoot = '169445602',
	AncientHymm = '245313442'
}
wait()
local Player = game.Players.localPlayer
local Character = Player.Character
local Humanoid = Character.Humanoid
local mouse = Player:GetMouse()
local m = Instance.new('Model', Character)
m.Name = "WeaponModel"
local Effects = {}
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local cam = game.Workspace.CurrentCamera
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
--cam.CameraSubject = Head
local equipped = false
local attack = false
local Anim = 'Idle'
local idle = 0
local sprint = false
local battlestance = false
local attacktype = 1
local state = 'none'
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local on = false
local grabbed = false
local skill1 = false
local skill2 = false
local skill3 = false
local skill4 = false
local cooldown1 = 0
local cooldown2 = 0
local cooldown3 = 0
local cooldown4 = 0
local co1 = 10--how long it will take for skill to cooldown
local co2 = 15
local co3 = 15
local co4 = 35
local inputserv = game:GetService('UserInputService')
local typing = false
local crit = false
local critchance = 9999999--critical chance percentage
local critdamageaddmin = 9999999--minimum amount of critical damage being added to regular damage
local critdamageaddmax = 9999999--maximum amount
local maxstamina = 100--max amount of stamina
local stamina = 0--stamina you start out with
local skill1stam = 0--how much stamina is needed for a skill
local skill2stam = 0
local skill3stam = 0
local skill4stam = 0
local recoverEnergy = 9999999--how much Energy per second
local defensevalue = 9999999--how much defense this character has
local speedvalue = 1--how much speed this character has
--speed is 16*speedvalue
local mindamage = 9999999--self explanatory
local maxdamage = 9999999--self explanatory
local damagevalue = 999999--how much damage this character has
--damage is math.random(mindamage,maxdamage)*damagevalue
--damage(hit, mindamage, maxdamage, 1, 1, RootPart) 
--asd
local cn = CFrame.new-- make things easier :)
local mr = math.rad
local angles = CFrame.Angles
local ud = UDim2.new
local c3 = Color3.new
local skillcolorscheme = c3(1, 1, 1)--color scheme for skills lol
--asd
local NeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
Humanoid.Animator:Destroy()
Character.Animate:Destroy()

--Angles For RootJoint `~`
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
--Save Shoulders/Hips 
RSH, LSH = nil, nil 
RHS, LHS = nil, nil 
--Shoulders
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
--Hips
RH = Instance.new("Weld") 
LH = Instance.new("Weld")
--
Player = Player 
ch = Character
LHS = Torso["Left Hip"]
RHS = Torso["Right Hip"]
RSH = ch.Torso["Right Shoulder"] 
LSH = ch.Torso["Left Shoulder"] 
-- 
RSH.Parent = nil 
LSH.Parent = nil 
--
LHS.Parent = nil
RHS.Parent = nil
-- 
RW.Name = "RW"
RW.Part0 = ch.Torso 
RW.C0 = cn(1.5, 0.5, 0)
RW.C1 = cn(0, 0.5, 0) 
RW.Part1 = ch["Right Arm"] 
RW.Parent = ch.Torso 
-- 
LW.Name = "LW"
LW.Part0 = ch.Torso 
LW.C0 = cn(-1.5, 0.5, 0)
LW.C1 = cn(0, 0.5, 0) 
LW.Part1 = ch["Left Arm"] 
LW.Parent = ch.Torso 
--
LH.Name = "LH"
LH.Part0 = ch.Torso 
LH.C0 = cn(-0.5, -2, 0) 
LH.Part1 = ch["Left Leg"] 
LH.Parent = ch.Torso 
--
RH.Name = "RH"
RH.Part0 = ch.Torso 
RH.C0 = cn(0.5, -2, 0)
RH.Part1 = ch["Right Leg"] 
RH.Parent = ch.Torso 

local scrn = Instance.new('ScreenGui', Player.PlayerGui)
function makeframe(par, trans, pos, size, color)
	local frame = Instance.new('Frame', par)
	frame.BackgroundTransparency = trans
	frame.BorderSizePixel = 0
	frame.Position = pos
	frame.Size = size
	frame.BackgroundColor3 = color
	return frame
end
function makelabel(par, text)
	local label = Instance.new('TextLabel', par)
	label.BackgroundTransparency = 1
	label.Size = ud(1, 0, 1, 0)
	label.Position = ud(0, 0, 0, 0)
	label.TextColor3 = c3(255, 255, 255)
	label.TextStrokeTransparency = 0
	label.FontSize = Enum.FontSize.Size32
	label.Font = Enum.Font.SourceSansBold
	label.BorderSizePixel = 0
	label.TextScaled = true
	label.Text = text
end
framesk1 = makeframe(scrn, .5, ud(.23, 0, .93, 0), ud(.26, 0, .06, 0), skillcolorscheme)
framesk2 = makeframe(scrn, .5, ud(.5, 0, .93, 0), ud(.26, 0, .06, 0), skillcolorscheme)
framesk3 = makeframe(scrn, .5, ud(.5, 0, .86, 0), ud(.26, 0, .06, 0), skillcolorscheme)
framesk4 = makeframe(scrn, .5, ud(.23, 0, .86, 0), ud(.26, 0, .06, 0), skillcolorscheme)
bar1 = makeframe(framesk1, 0, ud(0, 0, 0, 0), ud(1, 0, 1, 0), skillcolorscheme)
bar2 = makeframe(framesk2, 0, ud(0, 0, 0, 0), ud(1, 0, 1, 0), skillcolorscheme)
bar3 = makeframe(framesk3, 0, ud(0, 0, 0, 0), ud(1, 0, 1, 0), skillcolorscheme)
bar4 = makeframe(framesk4, 0, ud(0, 0, 0, 0), ud(1, 0, 1, 0), skillcolorscheme)
text1 = makelabel(framesk1, '[t] Reflex')
text2 = makelabel(framesk2, '[f] Luxuriance')
text3 = makelabel(framesk3, "[r] Lucent Scatter")
text4 = makelabel(framesk4, '[q] Echo Barrage')
staminabar = makeframe(scrn, .5, ud(.23, 0, .82, 0), ud(.26, 0, .03, 0), BrickColor.new("Really black").Color)
staminacover = makeframe(staminabar, 0, ud(0, 0, 0, 0), ud(1, 0, 1, 0), BrickColor.new("Hot pink").Color)
staminatext = makelabel(staminabar, 'Photon Energy')
healthbar = makeframe(scrn, .5, ud(.5, 0, .82, 0), ud(.26, 0, .03, 0), c3(1, 1, 0))
healthcover = makeframe(healthbar, 0, ud(0, 0, 0, 0), ud(1, 0, 1, 0), BrickColor.new("Lime green").Color)
healthtext = makelabel(healthbar, 'Health')

local stats = Instance.new('Folder', Character)
stats.Name = 'Stats'
local block = Instance.new('BoolValue', stats)
block.Name = 'Block'
block.Value = false
local stun = Instance.new('BoolValue', stats)
stun.Name = 'Stun'
stun.Value = false
local defense = Instance.new('NumberValue', stats)
defense.Name = 'Defence'
defense.Value = defensevalue
local speed = Instance.new('NumberValue', stats)
speed.Name = 'Speed'
speed.Value = speedvalue
local damagea = Instance.new('NumberValue', stats)
damagea.Name = 'Damage'
damagea.Value = damagevalue
gyro = Instance.new("BodyGyro")
gyro.Parent = nil
gyro.P = 1e7
gyro.D = 1e3
gyro.MaxTorque = Vector3.new(0,1e7,0)

function atktype(s, e)
	coroutine.resume(coroutine.create(function()
		attacktype = e
		wait()
		attacktype = s
	end))
end

function turncrit()
	coroutine.resume(coroutine.create(function()
		print'CRITICAL!'
		crit = true
		wait()
		crit = false
	end))
end

function subtractstamina(k)
	if stamina >= k then
		stamina = stamina - k
	end
end

function clerp(a, b, t)
	return a:lerp(b, t)
end

function randomizer(percent)
	local randomized = math.random(0, 100)
	if randomized <= percent then
		return true
	elseif randomized >= percent then
		return false
	end
end
FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()

local RbxUtility = FELOADLIBRARY
local Create = RbxUtility.Create

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
	
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
	
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld"){
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1,
	}
	return Weld
end

function rayCast(pos, dir, maxl, ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(pos, dir.unit * (maxl or 999.999)), ignore) 
end 
--Effects
function makeeffect(par, size, pos1, trans, trans1, howmuch, delay1, id, type)
	local p = Instance.new('Part', par or workspace)
	p.CFrame = pos1
	p.Anchored = true
	p.Material = 'SmoothPlastic'
	p.CanCollide = false
	p.TopSurface = 0
	p.Size = Vector3.new(1, 1, 1)
	p.BottomSurface = 0
	p.Transparency = trans
	p.FormFactor = 'Custom'
	RemoveOutlines(p)
	local mesh = Instance.new('SpecialMesh', p)
	mesh.Scale = size
	if id ~= nil and type == nil then
		mesh.MeshId = 'rbxassetid://'..id
	elseif id == nil and type ~= nil then
		mesh.MeshType = type
	elseif id == nil and type == nil then
		mesh.MeshType = 'Brick'
	end
	coroutine.wrap(function()
		for i = 0, delay1, .1 do
			wait()
			p.CFrame = p.CFrame
			mesh.Scale = mesh.Scale + howmuch
			p.Transparency = p.Transparency + trans1
		end
		p:Destroy()
	end)()
	return p
end
function clangy(cframe)
	wait()
	local clang = {}
	local dis = 0
	local part = Instance.new('Part', nil)
	part.CFrame = cframe
	part.Anchored = true
	part.CanCollide = false
	part.BrickColor = BrickColor.new('New Yeller')
	part.FormFactor = 'Custom'
	part.Name = 'clanger'
	part.Size = Vector3.new(.2, .2, .2)
	part.TopSurface = 10
	part.BottomSurface = 10
	part.RightSurface = 10
	part.LeftSurface = 10
	part.BackSurface = 10
	part.FrontSurface = 10
	--part.Material='Neon'
	part:BreakJoints()
	local mesh = Instance.new('BlockMesh', part)
	coroutine.wrap(function()
		for i = 1, 7 do
			wait()
			dis = dis + .2
			local partc = part:clone()
			partc.Parent = workspace
			partc.CFrame = part.CFrame * CFrame.fromEulerAnglesXYZ(dis, 0, 0)
			partc.CFrame = partc.CFrame * CFrame.new(0, dis, 0)
			table.insert(clang, partc)
		end
		for i, v in pairs(clang) do
			coroutine.wrap(function()
				for i = 1, 10 do
					wait()
					v.Transparency = v.Transparency + .1
				end
				v:destroy()
			end)()
		end
	end)()
end
--damage effects
function circle(color, pos1)
	local p = Instance.new('Part', m)
	p.BrickColor = BrickColor.new(color)
	p.CFrame = pos1
	p.Anchored = true
	p.Material = 'Plastic'
	p.CanCollide = false
	p.TopSurface = 0
	p.Size = Vector3.new(1, 1, 1)
	p.BottomSurface = 0
	p.Transparency = 0.35
	p.FormFactor = 'Custom'
	local mesh = Instance.new('CylinderMesh', p)
	mesh.Scale = Vector3.new(0, 0, 0)
	coroutine.wrap(function()
		for i = 0, 5, .1 do
			wait()
			p.CFrame = p.CFrame
			mesh.Scale = mesh.Scale + Vector3.new(.5, 0, .5)
			p.Transparency = p.Transparency + .025
		end
		p:Destroy()
	end)()
end
function firespaz1(color, pos1)
	local p = Instance.new('Part', m)
	p.BrickColor = BrickColor.new(color)
	p.CFrame = pos1
	p.Anchored = true
	p.Material = 'Plastic'
	p.CanCollide = false
	p.TopSurface = 0
	p.Size = Vector3.new(1, 1, 1)
	p.BottomSurface = 0
	p.Transparency = 0.5
	p.FormFactor = 'Custom'
	local mesh = Instance.new('BlockMesh', p)
	mesh.Scale = Vector3.new(1, 1, 1)
	coroutine.wrap(function()
		for i = 0, 15, .1 do
			wait()
			p.CFrame = p.CFrame * CFrame.new(0, .1, 0)
			mesh.Scale = mesh.Scale - Vector3.new(.1, .1, .1)
			p.Transparency = p.Transparency + .025
		end
		p:Destroy()
	end)()
end

function pickrandom(tablesa)
	local randomized = tablesa[math.random(1, #tablesa)]	
	return randomized
end
function sound(id, pitch, volume, par, last)
	local s = Instance.new('Sound', par or Torso)
	s.SoundId = 'rbxassetid://'..id
	s.Pitch = pitch or 1
	s.Volume = volume or 1
	wait()
	s:play()
	game.Debris:AddItem(s, last or 120)
end
function clangy(cframe)
	wait()
	local clang = {}
	local dis = 0
	local part = Instance.new('Part', nil)
	part.CFrame = cframe
	part.Anchored = true
	part.CanCollide = false
	part.BrickColor = BrickColor.new('New Yeller')
	part.FormFactor = 'Custom'
	part.Name = 'clanger'
	part.Size = Vector3.new(.2, .2, .2)
	part.TopSurface = 10
	part.BottomSurface = 10
	part.RightSurface = 10
	part.LeftSurface = 10
	part.BackSurface = 10
	part.FrontSurface = 10
	--part.Material='Neon'
	part:BreakJoints()
	local mesh = Instance.new('BlockMesh', part)
	coroutine.wrap(function()
		for i = 1, 7 do
			wait()
			dis = dis + .2
			local partc = part:clone()
			partc.Parent = workspace
			partc.CFrame = part.CFrame * CFrame.fromEulerAnglesXYZ(dis, 0, 0)
			partc.CFrame = partc.CFrame * CFrame.new(0, dis, 0)
			table.insert(clang, partc)
		end
		for i, v in pairs(clang) do
			coroutine.wrap(function()
				for i = 1, 10 do
					wait()
					v.Transparency = v.Transparency + .1
				end
				v:destroy()
			end)()
		end
	end)()
end
--damage effects
--Effects
so = function(id, par, vol, pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound", par or workspace)
		sou.Volume = vol
		sou.Pitch = pit or 1
		sou.SoundId = id
		wait() 
		sou:play() 
		game:GetService("Debris"):AddItem(sou, 6)
	end))
end

local function getclosest(obj, distance)
	local last, lastx = distance + 1
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA'Model' and v ~= Character and v:findFirstChild('Humanoid') and v:findFirstChild('Torso') and v:findFirstChild('Humanoid').Health > 0 then
			local t = v.Torso
			local dist = (t.Position - obj.Position).magnitude
			if dist <= distance then
				if dist < last then
					last = dist
					lastx = v
				end
			end
		end
	end
	return lastx
end

function makegui(cframe, text)
	local a = math.random(-10, 10) / 100
	local c = Instance.new("Part")
	c.Transparency = 1
	Instance.new("BodyGyro").Parent = c
	c.Parent = m
	c.CFrame = CFrame.new(cframe.p + Vector3.new(0, 1.5, 0))
	local f = Instance.new("BodyPosition")
	f.P = 2000
	f.D = 100
	f.maxForce = Vector3.new(math.huge, math.huge, math.huge)
	f.position = c.Position + Vector3.new(0, 3, 0)
	f.Parent = c
	game:GetService("Debris"):AddItem(c, .5 + 6)
	c.CanCollide = false
	c.CanCollide = false
	local bg = Instance.new('BillboardGui', m)
	bg.Adornee = c
	bg.Size = UDim2.new(1, 0, 1, 0)
	bg.StudsOffset = Vector3.new(0, 0, 0)
	bg.AlwaysOnTop = false
	local tl = Instance.new('TextLabel', bg)
	tl.BackgroundTransparency = 1
	tl.Size = UDim2.new(1, 0, 1, 0)
	tl.Text = text
	tl.Font = 'SourceSansBold'
	tl.FontSize = 'Size42'
	if crit == true then
		tl.TextColor3 = Color3.new(180 / 255, 0, 0)
	else
		tl.TextColor3 = Color3.new(255, 180 / 255, 51 / 255)
	end
	tl.TextStrokeTransparency = 0
	tl.TextScaled = true
	tl.TextWrapped = true
	coroutine.wrap(function()
		wait()
		for i = 1, 10 do
			wait()
			tl.TextTransparency = tl.TextTransparency + .1
		end
	end)()
end

function tag(hum, Player)
	local creator = Instance.new('ObjectValue', hum)
	creator.Value = Player
	creator.Name = 'creator'
end
function untag(hum)
	if hum ~= nil then
		local tag = hum:findFirstChild("creator")
		if tag ~= nil then
			tag.Parent = nil
		end
	end
end

function tagPlayer(h)
	coroutine.wrap(function()
		tag(h, Player)
		wait()
		untag(h)
	end)()
end

function CheckClose(Obj,Dist)
	for _,v in pairs(workspace:GetChildren()) do
		if v:FindFirstChild('Humanoid') and v:FindFirstChild('Torso') and v ~= Character then
			local DistFromTorso = (v.Torso.Position - Obj.Position).magnitude
			if DistFromTorso < Dist then
				return v
			end
		end
	end
end

function damage(hit, mind, maxd, knock, type, prop)
	if hit.Parent.Name == Character.Name then
		return
	end
	--[[
		to apply it to a Player directly, make the first arg go to the Players Torso
		1 - normal type(damage and knockback)
		2 - drain type(damage no knockback)
		3 - lifesteal(absorbs hp) crit does not have an effect on how much life is absorbed
		4 - heal(heals target)
		5 - subtracts enemies defense
		6 - subtracts enemies speed
		7 -  
	]]
	if hit.Name:lower() == 'Hitbox' then
		local pos = CFrame.new(0, 1, -1)
		sound(pickrandom(clangsounds), math.random(100, 150) / 100, 1, Torso, 6)
		coroutine.wrap(function()
			for i = 1, 4 do
				--clangy(Torso.CFrame * pos * CFrame.Angles(0, math.rad(math.random(0, 360)), 0))
			end
		end)()
	end
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChild("Humanoid")
	for i, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if hit.Parent.Parent:FindFirstChild('Torso') ~= nil then
		h = hit.Parent.Parent:FindFirstChild('Humanoid')
	end
	if hit.Parent:IsA('Hat') then
		hit = hit.Parent.Parent:findFirstChild('Head')
	end
	local D = math.random(mind, maxd) * damagea.Value
	if h then
		if h.Parent:FindFirstChild('Stats') then
			D=D/h.Parent:FindFirstChild('Stats').Defence.Value
		elseif not h.Parent:FindFirstChild('Stats') then
			D=D
		end
	end
	if h then
		makegui(h.Parent.Head.CFrame, tostring(math.floor(D + .5)))
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if type == 1 then
			tagPlayer(h)
			local asd = randomizer(critchance)
			if asd == true then
				turncrit()
			end
			if crit == false then
				--h.Health = h.Health - D
			else
				--h.Health = h.Health - (D + math.random(critdamageaddmin, critdamageaddmax))
			end
			so("http://www.roblox.com/asset/?id=169462037", hit, 1, math.random(150, 200) / 100)
			local vp = Instance.new('BodyVelocity')
			vp.P = 500
			vp.maxForce = Vector3.new(math.huge, 0, math.huge)
			vp.velocity = prop.CFrame.lookVector * knock + prop.Velocity / 1.05
			if knock > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif type == 2 then
			so("http://www.roblox.com/asset/?id=169462037", hit, 1, math.random(150, 200) / 100)
			local asd = randomizer(critchance)
			if asd == true then
				turncrit()
			end
			if crit == false then
				--h.Health = h.Health - D
			else
				--h.Health = h.Health - (D + math.random(critdamageaddmin, critdamageaddmax))
			end
			tagPlayer(h)
		elseif type == 3 then
			tagPlayer(h)
			local asd = randomizer(critchance)
			if asd == true then
				turncrit()
			end
			if crit == false then
				--h.Health = h.Health - D
			else
				--h.Health = h.Health - (D + math.random(critdamageaddmin, critdamageaddmax))
			end
			--Character.Humanoid.Health = Character.Humanoid.Health + D / 2
			so("http://www.roblox.com/asset/?id=206083232", hit, 1, 1.5)
			for i = 1, 10 do
				firespaz1('Bright red', hit.CFrame * CFrame.Angles(math.random(0, 3), math.random(0, 3), math.random(0, 3)))
			end
		elseif type == 4 then
			--h.Health = h.Health + D
			so("http://www.roblox.com/asset/?id=186883084", hit, 1, 1)
			circle('Dark green', h.Parent.Torso.CFrame * CFrame.new(0, -2.5, 0))
		end
	end
end

function subtrackstamina(k)
	if stamina >= k then
		stamina = stamina - k
	end
end

HandleA=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,1,"Really black","HandleA",Vector3.new(0.200000003, 0.256000012, 0.896000028))
HandleAweld=CreateWeld(m,Character["Right Arm"],HandleA,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.969136477, -0.00157141685, 0.385794818, 1.8189894e-012, -0.999995947, 5.21540642e-007, 0.999999762, 1.81898897e-012, 9.74654385e-013, -7.32133104e-013, 5.21538425e-007, 1))
CreateMesh("BlockMesh",HandleA,"","",Vector3.new(0, 0, 0),Vector3.new(0.640000105, 1, 1))
HandleB=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,1,"Really black","HandleB",Vector3.new(0.200000003, 0.256000012, 0.896000028))
HandleBweld=CreateWeld(m,Character["Left Arm"],HandleB,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.969139576, -0.00157129765, 0.385794759, 1.81901087e-012, -0.999999881, 5.21546838e-007, 1, 1.8190113e-012, 1.20202969e-012, -1.20203066e-012, 5.21546781e-007, 1))
CreateMesh("BlockMesh",HandleB,"","",Vector3.new(0, 0, 0),Vector3.new(0.640000105, 1, 1))
FakeHandleA=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,1,"Really black","FakeHandleA",Vector3.new(0.200000003, 0.256000012, 0.496000051))
FakeHandleAweld=CreateWeld(m,HandleA,FakeHandleA,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.66893005e-006, -1.1920929e-007, 0, 0.999992013, 7.55563563e-018, 4.206413e-012, 7.01353372e-018, 0.999999404, 2.42520739e-013, 4.32009983e-012, 2.42522365e-013, 1))
CreateMesh("BlockMesh",FakeHandleA,"","",Vector3.new(0, 0, 0),Vector3.new(0.640000105, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.46283865, -0.0531138182, -0.000952363014, -0.999995947, 1.00897567e-012, 5.21538198e-007, -5.21540414e-007, -5.79337901e-013, -1, -1.00897871e-012, -0.999999642, 3.36817813e-013))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952482224, -0.446709782, -0.193131208, 2.83093277e-006, 0.999999642, -3.04522609e-006, -7.05200193e-007, -3.04522314e-006, -1, -0.999995947, 2.83094528e-006, 7.05190132e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Medium stone grey","Part",Vector3.new(0.262439996, 0.200000003, 0.255879134))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0690844059, -0.0718523264, 0.394913316, -0.707372546, 1.49017545e-008, -0.706838131, -7.89236623e-008, -0.999999642, 5.79014454e-008, -0.70683527, 9.67446709e-008, 0.707375348))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.22985673, 0.330393285, 0.128970504, -0.999995947, 2.91118395e-005, 0.000388933928, 0.000388931512, -2.88635401e-005, 1, 2.91229535e-005, 0.999999642, 2.88522242e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.118097998, 0.118097998, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.22985673, 0.330393285, 0.128970504, -0.999995947, 2.91118395e-005, 0.000388933928, 0.000388931512, -2.88635401e-005, 1, 2.91229535e-005, 0.999999642, 2.88522242e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.0787319914, 0.0918539986, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000954985619, 0.46309948, 0.577915907, 2.08608085e-007, 0.999999642, 4.43563515e-008, -0.999995947, 2.0860881e-007, 9.0896873e-007, 9.08969355e-007, -4.43562875e-008, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952601433, -0.46309948, -0.577939391, -5.96009748e-008, 0.999999642, 1.78326225e-008, 0.999995947, 5.96012093e-008, -7.89759383e-007, -7.8976052e-007, 1.78323258e-008, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952720642, -0.72529912, 0.577960372, 3.77829451e-007, -0.999999642, -5.66733604e-007, 0.999995947, 3.77831128e-007, -5.21538368e-007, 5.21540812e-007, -5.66732922e-007, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0618202686, -0.57786119, -0.000952601433, -0.999995947, 2.76042605e-010, 5.21538198e-007, -5.21540414e-007, -4.75706585e-010, -1, -2.76041356e-010, -0.999999642, 4.7546439e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Medium stone grey","Part",Vector3.new(0.262439996, 0.200000003, 0.255879134))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.394863844, -0.0697959661, -0.0693871975, -0.707371831, 1.49031312e-008, 0.706838787, -5.17638155e-009, 0.999999642, -2.62642939e-008, -0.706835926, -2.22377423e-008, -0.707374692))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.22960186, -0.325974345, 0.126894236, -0.999995947, -2.91118213e-005, -0.000387890788, 0.000387888373, 2.88337342e-005, -1, 2.91228953e-005, -0.999999642, -2.88224492e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.0787319914, 0.0918539986, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000954151154, 0.462881565, 0.0781461895, -4.01817232e-007, -0.999999642, 1.08038626e-006, -0.999990225, 4.0182158e-007, 5.21535412e-007, -5.21538084e-007, -1.08039217e-006, -0.999994278))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.393659979, 0.524879932))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.659671783, -0.315543771, -0.000952482224, -0.999995947, -7.10575912e-013, 5.21538198e-007, -5.21540414e-007, -6.60076464e-012, -1, 7.10569624e-013, -0.999999642, 6.35824596e-012))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.524879932))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.64371943, -0.184356153, -0.000952720642, -0.999995947, -2.84785216e-014, 5.21538198e-007, -5.21540414e-007, -1.32740338e-011, -1, 2.84781049e-014, -0.999999642, 1.30315177e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656100452, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.787320077, 0.262439996, 0.524879932))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.18442535, -0.118758678, -0.000952601433, -0.999995947, 2.01786829e-012, 5.21538198e-007, -5.21540414e-007, -1.28376595e-012, -1, -2.01786721e-012, -0.999999642, 1.04124662e-012))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.7749244, -0.0646617413, 0.446767867, 0.999995947, -1.47525031e-006, -1.80021914e-007, 1.47524486e-006, 0.999999642, 1.47599106e-008, 1.80025495e-007, -1.47599293e-008, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00095307827, -0.0694081783, 0.577923179, -1.12560102e-007, -0.999999642, 4.43628316e-008, 0.999995947, -1.12560521e-007, -1.34108177e-007, 1.34111957e-007, 4.43630412e-008, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.00095307827, -0.594094753, 0.0781440437, 4.17225039e-007, 0.999999642, -1.04824289e-006, 0.999990225, -4.17229472e-007, -5.03516958e-007, -5.03519686e-007, -1.04824858e-006, -0.999994278))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.22960186, -0.325974345, 0.126894236, -0.999995947, -2.91118213e-005, -0.000387890788, 0.000387888373, 2.88337342e-005, -1, 2.91228953e-005, -0.999999642, -2.88224492e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.118097998, 0.118097998, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.249317944, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0810444355, -0.13091433, -0.000957727432, 0.707103014, 1.57924467e-006, 0.707106233, -0.707106531, -3.81509017e-006, 0.707109034, 3.81435189e-006, -0.999999642, -1.58096839e-006))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.951344788, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.524879932, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000948548317, 0.0531208515, -0.65964818, 5.96030603e-008, 0.999999642, 1.09855229e-007, 5.97940073e-007, -1.0985498e-007, 1, 0.999995947, -5.96032166e-008, -5.97938197e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000953316689, 0.0694112778, -0.577948451, 5.12384233e-008, -0.999999642, 1.78378254e-008, -0.999995947, -5.12386045e-008, 2.53317438e-007, -2.53320735e-007, -1.78380741e-008, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.524879932, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381076962, -1.18433952, -0.000951886177, -4.61936025e-007, -4.84779994e-011, -1, 0.999995947, 7.64824488e-012, -4.61933581e-007, 7.64823274e-012, -0.999999642, 4.8235492e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000945568085, -0.725336075, -0.0530678928, 1.03413649e-005, 0.999999642, -1.3563623e-006, 0.999995947, -1.0341404e-005, -5.8640012e-007, -5.86416093e-007, -1.35635605e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.195877314, 0.315567017, 1.77494192, -2.13285796e-013, -0.999999642, -4.6366435e-007, 5.03123488e-007, -4.63663952e-007, 1, -0.999995947, -2.00015972e-014, 5.03121157e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.262439966, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.64357042, -0.381081522, -0.000952005386, -0.999995947, -2.84963025e-014, 5.21538198e-007, -5.21540414e-007, -1.368856e-010, -1, 2.85603552e-014, -0.999999642, 1.36643141e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.262439996, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.77479982, -0.381083727, -0.000951886177, -0.999995947, -2.85570179e-014, 5.21538198e-007, -5.21540414e-007, -1.45497003e-010, -1, 2.86255632e-014, -0.999999642, 1.45254545e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439996, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00095307827, 0.184345901, 1.77491713, -2.13323012e-013, -0.999999642, -4.63661678e-007, 5.03123488e-007, -4.6366128e-007, 1, -0.999995947, -1.99632164e-014, 5.03121157e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381089836, -0.856295109, -0.000952124596, -4.61936025e-007, -5.05883807e-011, -1, 0.999995947, 8.32963819e-012, -4.61933553e-007, 8.32962432e-012, -0.999999642, 5.03458698e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.77492106, -0.064658761, -0.31554234, -0.999995947, -1.22364965e-012, 5.39955295e-007, -9.5812659e-013, 0.999999642, 4.9172661e-007, -5.39957398e-007, 4.91726212e-007, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.524879932, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952839851, 0.0531313121, 1.64369941, -2.13395951e-013, -0.999999642, -4.63665572e-007, 5.03123488e-007, -4.63665174e-007, 1, -0.999995947, -1.98925264e-014, 5.03121157e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952959061, -0.577950954, 0.19316268, 3.2544206e-012, -0.999999642, 4.63510275e-007, -5.03123886e-007, -4.63510332e-007, -1, 0.999995947, 3.02113716e-012, -5.03121612e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439996, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.266271591, -0.577865899, -0.000952601433, -0.999995947, 4.89863532e-011, 5.21538198e-007, -5.21540414e-007, -1.56372887e-010, -1, -4.89860999e-011, -0.999999642, 1.56130456e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.465830922, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0548343658, -0.318395138, -0.000958204269, 0.707103014, 1.5792516e-006, 0.707106233, -0.707106531, -3.81508926e-006, 0.707109034, 3.81435621e-006, -0.999999642, -1.58096282e-006))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.656099856, 0.393659979, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.200451851, -0.315522313, -0.000952482224, -0.999995947, -3.1282919e-013, 5.21538198e-007, -5.21540414e-007, -6.28311465e-012, -1, 3.12824257e-013, -0.999999642, 6.04059554e-012))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.7749095, -0.0665602684, 0.446766496, -0.999995947, 3.94417901e-011, 5.03121157e-007, -3.96749439e-011, -0.999999642, -4.63689446e-007, 5.03123431e-007, -4.63689048e-007, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.656099916, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.382884979, -0.0559492111, -0.000958323479, 0.707103789, 1.57925547e-006, 0.707107008, -0.707104146, -3.81507652e-006, 0.70710665, 3.81435484e-006, -0.999999642, -1.58096418e-006))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.951344788, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.918540061, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.2500999, -0.315561235, -0.197781086, -0.999995947, -7.10677394e-013, 5.21538198e-007, -5.21540414e-007, -5.410158e-012, -1, 7.10670509e-013, -0.999999642, 5.16763889e-012))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.77491331, -0.0665630102, -0.315546811, 0.999995947, 1.47522928e-006, -8.63054538e-007, 1.47522383e-006, -0.999999642, -5.96148269e-008, -8.63055448e-007, 5.96132921e-008, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.00095307827, -0.0692355633, -0.0530753136, 4.17208184e-007, 0.999999642, -1.24864869e-006, 0.999995947, -4.17210487e-007, -6.0446132e-007, -6.04463764e-007, -1.24864835e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.594289541, -0.577865899, -0.000952482224, -0.999995947, 4.85845982e-011, 5.21538198e-007, -5.21540414e-007, -1.55332233e-010, -1, -4.85843449e-011, -0.999999642, 1.55089802e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952959061, -0.061965704, -0.0530880094, -4.01771786e-007, -0.999999642, 1.08025915e-006, -0.999995947, 4.01773832e-007, 5.21538254e-007, -5.21540869e-007, -1.08025893e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439996))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.324400663, -0.446751714, -0.000952601433, -0.999995947, -1.51789562e-012, 5.21538198e-007, -5.21540414e-007, 1.45567641e-010, -1, 1.51780715e-012, -0.999999642, -1.45810183e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381086797, -1.51240134, -0.000951886177, -4.61936025e-007, -5.05883252e-011, -1, 0.999995947, 8.3296087e-012, -4.61933553e-007, 8.32959483e-012, -0.999999642, 5.03458178e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262440026, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.70932698, -0.446754277, 0.195877552, -0.999995947, -2.85565842e-014, 5.21538198e-007, -5.21540414e-007, 3.59957689e-011, -1, 2.85304718e-014, -0.999999642, -3.62383006e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952839851, 0.331614971, -0.0531049073, -4.01787446e-007, -0.999999642, 1.0803011e-006, -0.999995947, 4.01789492e-007, 5.21538254e-007, -5.21540869e-007, -1.08030088e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.918540061, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.25009334, -0.315559089, 0.195877194, -0.999995947, -7.10700812e-013, 5.21538198e-007, -5.21540414e-007, -6.16940093e-012, -1, 7.10694307e-013, -0.999999642, 5.92688182e-012))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.19778192, 0.315561116, 1.77493024, -2.13241344e-013, -0.999999642, -4.63686348e-007, 5.03123488e-007, -4.6368595e-007, 1, -0.999995947, -2.00571083e-014, 5.03121157e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952363014, 0.446721375, 0.193159819, 4.75546358e-009, 0.999999642, -1.8624263e-006, 5.20043955e-007, 1.86242596e-006, 1, 0.999995947, -4.75644946e-009, -5.20041738e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439996))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.193187475, -0.315557897, -0.000952601433, -0.999995947, -1.39693855e-012, 5.21538198e-007, -5.21540414e-007, 1.66943959e-011, -1, 1.39691752e-012, -0.999999642, -1.69369241e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.59407711, -0.0531000197, -0.000952363014, -0.999990225, -3.56847798e-014, 5.21535242e-007, -5.21537459e-007, -2.62820841e-012, -0.999994278, 7.82880772e-014, -0.999999642, 2.61816176e-012))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262440026, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.70935547, -0.44676286, -0.197781682, -0.999995947, -2.85648241e-014, 5.21538198e-007, -5.21540414e-007, 4.92065971e-011, -1, 2.85318237e-014, -0.999999642, -4.94491323e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381075412, -1.78140426, -0.00095307827, -4.61936025e-007, -4.94634819e-011, -1, 0.999995947, 8.18711939e-012, -4.61933581e-007, 8.18710464e-012, -0.999999642, 4.92209745e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.262439996))
Partweld=CreateWeld(m,FakeHandleA,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.258820057, -0.184331298, -0.000952601433, -0.999995947, -9.58359694e-013, 5.21538198e-007, -5.21540414e-007, 1.63497792e-011, -1, 9.58340612e-013, -0.999999642, -1.65923074e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
BarrelA=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,1,"Hot pink","BarrelA",Vector3.new(0.200000003, 0.200000003, 0.512000024))
BarrelAweld=CreateWeld(m,FakeHandleA,BarrelA,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00648152828, -0.375403494, -1.62293732, 4.16029834e-005, -0.999999523, 4.46679103e-008, 4.43538624e-007, -4.46531416e-008, -0.999999881, 0.999992251, 4.16032817e-005, 4.43546355e-007))
CreateMesh("SpecialMesh",BarrelA,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.153600022, 0.140799999, 0.447999448))
FakeHandleB=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,1,"Really black","FakeHandleB",Vector3.new(0.200000003, 0.256000012, 0.496000051))
FakeHandleBweld=CreateWeld(m,HandleB,FakeHandleB,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0, 0, 0, 1, -2.36065456e-020, 0, -2.36065456e-020, 1, 0, 0, 0, 1))
CreateMesh("BlockMesh",FakeHandleB,"","",Vector3.new(0, 0, 0),Vector3.new(0.640000105, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.462830544, -0.0531138182, -0.000952243805, -0.999992132, 1.09443888e-012, 5.21542518e-007, -5.21546724e-007, -1.02038245e-012, -1, -1.09444235e-012, -0.999999523, 4.35311509e-013))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952363014, -0.446709752, -0.193128824, 2.83092186e-006, 0.999999523, -3.04522632e-006, -7.05205821e-007, -3.04522337e-006, -1, -0.999992132, 2.83094482e-006, 7.05194395e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Medium stone grey","Part",Vector3.new(0.262439996, 0.200000003, 0.255879134))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0690851212, -0.0718523264, 0.394912601, -0.707375407, 1.49016e-008, -0.706838131, -7.8923982e-008, -1, 5.79019144e-008, -0.706838131, 9.67448699e-008, 0.707375348))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.229856014, 0.330393344, 0.128970504, -1, 2.91118504e-005, 0.000388933928, 0.000388933084, -2.88635511e-005, 1, 2.91230717e-005, 1, 2.88522242e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.118097998, 0.118097998, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.229856014, 0.330393344, 0.128970504, -1, 2.91118504e-005, 0.000388933928, 0.000388933084, -2.88635511e-005, 1, 2.91230717e-005, 1, 2.88522242e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.0787319914, 0.0918539986, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000954866409, 0.463091612, 0.577915788, 2.08607375e-007, 0.999999523, 4.4356252e-008, -0.999992132, 2.08608867e-007, 9.08972993e-007, 9.08974243e-007, -4.43558399e-008, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952482224, -0.463091373, -0.577939391, -5.96006622e-008, 0.999999523, 1.78325248e-008, 0.999992132, 5.96011169e-008, -7.89763646e-007, -7.8976575e-007, 1.78318817e-008, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952601433, -0.725286722, 0.577960372, 3.77827917e-007, -0.999999523, -5.6673349e-007, 0.999992132, 3.77831014e-007, -5.21542631e-007, 5.21547122e-007, -5.6673241e-007, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0618202686, -0.57786119, -0.000952482224, -0.999992132, 2.76128037e-010, 5.21542518e-007, -5.21546781e-007, -4.76147566e-010, -1, -2.76125789e-010, -0.999999523, 4.75562811e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Medium stone grey","Part",Vector3.new(0.262439996, 0.200000003, 0.255879134))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.394863367, -0.0697958469, -0.0693879128, -0.707374692, 1.49032964e-008, 0.706838787, -5.17640242e-009, 1, -2.62647628e-008, -0.706838787, -2.22379111e-008, -0.707374692))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.229600906, -0.325974405, 0.126894355, -1, -2.91118322e-005, -0.000387890788, 0.000387889944, 2.88337451e-005, -1, 2.91230135e-005, -1, -2.88224492e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.0787319914, 0.0918539986, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000953912735, 0.46284461, 0.0781242549, -4.01818824e-007, -0.999999523, 1.08039103e-006, -0.999992132, 4.01822348e-007, 5.21542688e-007, -5.21547349e-007, -1.08039092e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.393659979, 0.524879932))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.659660816, -0.315543771, -0.000952363014, -0.999992132, -6.25112375e-013, 5.21542461e-007, -5.21546724e-007, -7.04180898e-012, -1, 6.25099527e-013, -0.999999523, 6.45673966e-012))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.524879932))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.64369273, -0.184356153, -0.000952601433, -0.999992132, 5.69847988e-014, 5.21542461e-007, -5.21546724e-007, -1.37150759e-011, -1, -5.69892034e-014, -0.999999523, 1.31300101e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656100452, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.787320077, 0.262439996, 0.524879932))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.18440604, -0.118758678, -0.000952482224, -0.999992132, 2.1033314e-012, 5.21542518e-007, -5.21546724e-007, -1.72481072e-012, -1, -2.10332684e-012, -0.999999523, 1.13974021e-012))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.77489591, -0.0646619797, 0.446767896, 0.999992132, -1.47525031e-006, -1.80026205e-007, 1.4752394e-006, 0.999999523, 1.4759812e-008, 1.8003314e-007, -1.47594861e-008, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952959061, -0.069406271, 0.577923179, -1.12559754e-007, -0.999999523, 4.43629311e-008, 0.999992132, -1.12560592e-007, -1.3411244e-007, 1.34119745e-007, 4.43634747e-008, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952959061, -0.594092369, 0.0781444907, 4.17223703e-007, 1, -1.04824346e-006, 1, -4.17224214e-007, -5.03528042e-007, -5.03528497e-007, -1.04824335e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.229600906, -0.325974405, 0.126894355, -1, -2.91118322e-005, -0.000387890788, 0.000387889944, 2.88337451e-005, -1, 2.91230135e-005, -1, -2.88224492e-005))
CreateMesh("SpecialMesh",Part,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.118097998, 0.118097998, 0.459269375))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.249317944, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.0810451508, -0.130914927, -0.000957846642, 0.707105875, 1.57924535e-006, 0.707106233, -0.707109392, -3.81509153e-006, 0.707109034, 3.81436735e-006, -1, -1.58096793e-006))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.951344788, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.524879932, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000948429108, 0.0531208515, -0.659636974, 5.96029182e-008, 0.999999523, 1.09855129e-007, 5.97946098e-007, -1.09854533e-007, 1, 0.999992132, -5.96032947e-008, -5.9794246e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000953197479, 0.0694093704, -0.577948451, 5.12381426e-008, -0.999999523, 1.78379249e-008, -0.999992132, -5.12385121e-008, 2.5332173e-007, -2.53328068e-007, -1.78385147e-008, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.524879932, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381076962, -1.18432021, -0.000951766968, -4.61942591e-007, -4.89190355e-011, -1, 0.999992132, 7.56278113e-012, -4.61937873e-007, 7.56273516e-012, -0.999999523, 4.83339826e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000945448875, -0.725324035, -0.053067863, 1.03413258e-005, 0.999999523, -1.3563623e-006, 0.999992132, -1.03414031e-005, -5.86404383e-007, -5.86422175e-007, -1.35635628e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.195877314, 0.315567106, 1.77491331, -2.98756218e-013, -0.999999523, -4.63664264e-007, 5.03129854e-007, -4.63663469e-007, 1, -0.999992132, 6.54619384e-014, 5.03125477e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.262439966, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.64354384, -0.381081581, -0.000951766968, -0.999992132, 5.69671263e-014, 5.21542518e-007, -5.21546724e-007, -1.37326636e-010, -1, -5.69069531e-014, -0.999999523, 1.36741632e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.262439996, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.77477098, -0.381083727, -0.000951647758, -0.999992132, 5.6906411e-014, 5.21542518e-007, -5.21546724e-007, -1.45938026e-010, -1, -5.68417451e-014, -0.999999523, 1.45353021e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439996, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952959061, 0.184345931, 1.77488852, -2.98793217e-013, -0.999999523, -4.63661593e-007, 5.03129854e-007, -4.63660797e-007, 1, -0.999992132, 6.55001024e-014, 5.03125477e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381089836, -0.856280804, -0.000952005386, -4.61942562e-007, -5.10294133e-011, -1, 0.999992132, 8.24417357e-012, -4.61937844e-007, 8.244125e-012, -0.999999523, 5.0444364e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.77489245, -0.0646588802, -0.31554237, -0.999992132, -1.13818612e-012, 5.39959558e-007, -8.72651452e-013, 0.999999523, 4.91726496e-007, -5.39963651e-007, 4.917257e-007, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.524879932, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952720642, 0.0531313121, 1.6436727, -2.98866156e-013, -0.999999523, -4.63665486e-007, 5.03129854e-007, -4.63664691e-007, 1, -0.999992132, 6.55707923e-014, 5.03125477e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952959061, -0.577952385, 0.193134546, 2.79130136e-010, -0.999999523, 4.63188996e-007, -5.03130252e-007, -4.63189366e-007, -1, 0.999992132, 2.78899154e-010, -5.03125875e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439996, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.266266823, -0.577865839, -0.000952482224, -0.999992132, 4.90718091e-011, 5.21542461e-007, -5.21546724e-007, -1.56813909e-010, -1, -4.90713789e-011, -0.999999523, 1.56228946e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.465830922, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0548336506, -0.318395734, -0.000958323479, 0.707105875, 1.57925228e-006, 0.707106233, -0.707109392, -3.81509062e-006, 0.707109034, 3.81437167e-006, -1, -1.58096236e-006))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Symmetric,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.656099856, 0.393659979, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.200448036, -0.315522313, -0.000952363014, -0.999992132, -2.27365869e-013, 5.21542461e-007, -5.21546724e-007, -6.72415856e-012, -1, 2.27355651e-013, -0.999999523, 6.13908924e-012))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.77488089, -0.0665599108, 0.446766585, -0.999992132, 3.95272495e-011, 5.0312542e-007, -3.9760268e-011, -0.999999523, -4.63689361e-007, 5.03129854e-007, -4.63688565e-007, 1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.656099916, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.382884026, -0.0559498072, -0.000958442688, 0.70710665, 1.57925615e-006, 0.707107008, -0.707107008, -3.81507789e-006, 0.70710665, 3.8143703e-006, -1, -1.58096373e-006))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.951344788, 1, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.918540061, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.25007939, -0.315561235, -0.197780728, -0.999992132, -6.25213856e-013, 5.21542461e-007, -5.21546724e-007, -5.85120234e-012, -1, 6.25200358e-013, -0.999999523, 5.26613258e-012))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.77488446, -0.0665627718, -0.315546811, 0.999992132, 1.47522906e-006, -8.63058801e-007, 1.47521814e-006, -0.999999523, -5.96147274e-008, -8.6306045e-007, 5.96128444e-008, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952959061, -0.0692336559, -0.0530753434, 4.17206678e-007, 0.999999523, -1.24864869e-006, 0.999992132, -4.17210515e-007, -6.0446564e-007, -6.04469733e-007, -1.24864869e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.594279528, -0.577865899, -0.000952363014, -0.999992132, 4.86700541e-011, 5.21542461e-007, -5.21546724e-007, -1.55773255e-010, -1, -4.86696274e-011, -0.999999523, 1.55188293e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952839851, -0.061965704, -0.0530880094, -4.01770336e-007, -0.999999523, 1.08025915e-006, -0.999992132, 4.0177386e-007, 5.21542518e-007, -5.21547179e-007, -1.08025915e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439996))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.324369669, -0.446746528, -0.000952601433, -0.999992132, -2.28737904e-010, 5.21542461e-007, -5.21546724e-007, 3.90042887e-010, -1, 2.28737695e-010, -0.999999523, -3.90628141e-010))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381086797, -1.51237679, -0.000951766968, -4.61942562e-007, -5.10293613e-011, -1, 0.999992132, 8.24414408e-012, -4.61937844e-007, 8.24409551e-012, -0.999999523, 5.04443119e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262440026, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.70929945, -0.446754336, 0.195877552, -0.999992132, 5.69068447e-014, 5.21542461e-007, -5.21546724e-007, 3.55547189e-011, -1, -5.69368364e-014, -0.999999523, -3.61398099e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000952720642, 0.331609011, -0.0531049073, -4.01785996e-007, -0.999999523, 1.0803011e-006, -0.999992132, 4.01789521e-007, 5.21542518e-007, -5.21547236e-007, -1.0803011e-006, -1))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.918540061, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.25007296, -0.315559149, 0.195877194, -0.999992132, -6.25237275e-013, 5.21542461e-007, -5.21546724e-007, -6.61044526e-012, -1, 6.25224156e-013, -0.999999523, 6.02537551e-012))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.197781563, 0.315561146, 1.77490151, -2.98711766e-013, -0.999999523, -4.63686263e-007, 5.03129854e-007, -4.63685438e-007, 1, -0.999992132, 6.54063189e-014, 5.03125477e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262439966, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000952243805, 0.446721435, 0.193157434, 4.75553064e-009, 0.999999523, -1.86242642e-006, 5.20050321e-007, 1.86242619e-006, 1, 0.999992132, -4.75653428e-009, -5.20046058e-007))
CreateMesh("SpecialMesh",Part,Enum.MeshType.Wedge,"",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.262439996))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.193185091, -0.315557897, -0.000952482224, -0.999992132, -1.3114748e-012, 5.21542461e-007, -5.21546724e-007, 1.62533511e-011, -1, 1.31144477e-012, -0.999999523, -1.683843e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.200000003, 0.200000003, 0.262439966))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.594074965, -0.0531003177, -0.000952243805, -1, 4.97786491e-014, 5.21546554e-007, -5.21546554e-007, -3.0692675e-012, -1, -4.97770262e-014, -1, 3.0692675e-012))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 1))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Hot pink","Part",Vector3.new(0.262440026, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.70932782, -0.44676286, -0.197781324, -0.999992132, 5.68986048e-014, 5.21542461e-007, -5.21546724e-007, 4.87655437e-011, -1, -5.6935488e-014, -0.999999523, -4.93506416e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,0,"Really black","Part",Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.381075472, -1.78137565, -0.000952839851, -4.61942591e-007, -4.99045215e-011, -1, 0.999992132, 8.10165563e-012, -4.61937873e-007, 8.10160619e-012, -0.999999523, 4.93194721e-011))
CreateMesh("CylinderMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(0.656099916, 0.656099916, 0.656099916))
Part=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,"Really black","Part",Vector3.new(0.262439966, 0.200000003, 0.262439996))
Partweld=CreateWeld(m,FakeHandleB,Part,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.258816719, -0.184331298, -0.000952482224, -0.999992132, -8.72896373e-013, 5.21542461e-007, -5.21546724e-007, 1.59087344e-011, -1, 8.72869593e-013, -0.999999523, -1.64938133e-011))
CreateMesh("BlockMesh",Part,"","",Vector3.new(0, 0, 0),Vector3.new(1, 0.656099916, 1))
BarrelB=CreatePart(Enum.FormFactor.Custom,m,Enum.Material.Neon,0,1,"Hot pink","BarrelB",Vector3.new(0.200000003, 0.200000003, 0.512000024))
BarrelBweld=CreateWeld(m,FakeHandleB,BarrelB,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00648140907, -0.375403613, -1.62292969, 4.16028452e-005, -1, 4.46680346e-008, 4.43528563e-007, -4.46495818e-008, -1, 1, 4.16028452e-005, 4.43526744e-007))
CreateMesh("SpecialMesh",BarrelB,Enum.MeshType.FileMesh,"http://www.roblox.com/asset/?id=18430887",Vector3.new(0, 0, 0),Vector3.new(0.153600022, 0.140799999, 0.447999448))

local lasrs = {} 
local lasrspd = 5
local maxTravelDistance = 300 
local maxRebounds = 2 


local lp = game:GetService("Players").LocalPlayer

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

--FakeHandleB
--FakeHandleA

local hat = gp(cplayer, "Meshes/1911RightAccessory", "Accessory")
local handle = gp(hat, "Handle", "BasePart")
local att = gp(handle, "att1_Handle", "Attachment")
att.Parent = FakeHandleA
att.Position = v3(0.5, 0, 0)
att.Rotation = v3(180, 0, 90)



local hat2 = gp(cplayer, "RightMk73LP", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
--handle2.SpecialMesh:Destroy()
local att = gp(handle2, "att1_Handle", "Attachment")
att.Parent = FakeHandleB
att.Position = v3(0.5, 0, 0)
att.Rotation = v3(180, 0, 90)



function RAY(pos, dir, collidedlist, startpos, endpos, distleft) 
	collidedlist = collidedlist or {Character} 
	startpos = startpos or pos 
	distleft = distleft or dir.unit * dir.magnitude 
	endpos = endpos or pos + distleft 
	local ray = Ray.new(pos, distleft) 
	local hitz,enz = workspace:FindPartOnRayWithIgnoreList(ray, collidedlist) 
	if hitz ~= nil and not hitz.Parent:findFirstChild("Humanoid") then 
		if hitz.CanCollide == false then 
			table.insert(collidedlist, hitz) 
			local newpos = enz 
			local newdistleft = distleft - (dir.unit * (pos - newpos).magnitude) 
			if newdistleft then 
				return RAY(newpos-(dir*0.01), dir, collidedlist, startpos, endpos, newdistleft+(dir*0.01)) 
			end 
		end 
	end 
	return hitz, enz, ray 
end 

function FindSurface(part, position) 
	local obj = part.CFrame:pointToObjectSpace(position) 
	local siz = part.Size/2 
	for i,v in pairs(Enum.NormalId:GetEnumItems()) do 
		local vec = Vector3.FromNormalId(v) 
		local wvec = part.CFrame:vectorToWorldSpace(vec) 
		local vz = (obj)/(siz*vec) 
		if (math.abs(vz.X-1) < 0.001 or math.abs(vz.Y-1) < 0.001 or math.abs(vz.Z-1) < 0.001) then
			return wvec,vec 
		end 
	end 
	if part.className == "WedgePart" then 
		local pos = (part.CFrame * CFrame.new(0,part.Size.y/2,part.Size.z/2)).p 
		local apos = (part.CFrame * CFrame.Angles(-math.atan2(part.CFrame:pointToObjectSpace(pos).y,part.CFrame:pointToObjectSpace(pos).z),0,0) * CFrame.new(0,1,0)).p 
		local wvec,vec = (apos - part.Position).unit, part.CFrame:pointToObjectSpace(apos) 
		return wvec,vec
	elseif part.className == "Part" and (part.Shape.Name == "Ball" or part.Shape.Name == "Cylinder") then 
		return (position - part.Position).unit, part.CFrame:vectorToObjectSpace((position - part.Position).unit) 
	end 
end 

function Reflect(direction, normal) 
	return direction - 2 * normal:Dot(direction) * normal 
end 

function ReflectShot(mouse,asd) 
	local dir = (mouse.Hit.p - Torso.Position).unit 
	local tabl 
	local tablnum = 0 
	for i, v in pairs(lasrs) do 
		if not v[1] then 
			tabl = v 
			tablnum = i 
			break 
		end 
	end 
	if not tabl then 
		tablnum = #lasrs + 1 
		tabl = {false,nil,nil,0,0,1,{},{},{},{}} 
		for i = 1, 2 do 
			for j = 1, 6 do 
				local p = Instance.new("Part") 
				p.FormFactor = "Custom" 
				p.CanCollide = false 
				p.Anchored = true 
				p.Locked = true 
				p.BrickColor = BarrelA.BrickColor 
				p.TopSurface = 10 
				p.BottomSurface = 10 
				p.RightSurface = 10 
				p.LeftSurface = 10 
				p.FrontSurface = 10 
				p.BackSurface = 10 
				p.Size = Vector3.new(.5,.5,.5) 
				p.Material = "Neon"
				p.Transparency = i == 1 and 0 or 0.6 
				local mesh = Instance.new("CylinderMesh",p) 
				table.insert(tabl[6+i],p) 
				table.insert(tabl[8+i],mesh) 
	end
		end 
		table.insert(lasrs,tabl) 
	end 
	-- isMoving,direction,lastPosition,rebounds,distance,recycleCount,middleLayer,outerLayer
	tabl[4],tabl[5] = 0,0 
	tabl[3] = asd.Position 
	tabl[2] = dir 
	tabl[1] = true 

end 

gun = false

shoot = false

gunidle = false

local GunA = true
local GunB = false

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, Character, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.1, 0.1, 0.1))
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 5)
	Effects[#Effects + 1] = {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3
	} --part, type, delay
end

function Shoot(asd, spread1, spread2)
	local MainPos = asd.Position
	local MainPos2 = mouse.Hit.p
	local spread = Vector3.new((math.random(-spread1, 0) + math.random()) * spread2, (math.random(-spread1, 0) + math.random()) * spread2, (math.random(-spread1, 0) + math.random()) * spread2) * (asd.Position - mouse.Hit.p).magnitude / 100
	local MouseLook = cn((MainPos + MainPos2) / 2, MainPos2 + spread)
	num = 30
	coroutine.resume(coroutine.create(function(Spreaded) 
		repeat
			wait()
			local hit, pos = rayCast(MainPos, MouseLook.lookVector, 10, RootPart.Parent)
			local TheHit = mouse.Hit.p
			local mag = (MainPos - pos).magnitude 
			CylinderEffect(BrickColor.new(asd.BrickColor.Color), CFrame.new((MainPos + pos) / 2, pos) * angles(1.57, 0, 0), 3, mag * 5, 3, .5, 0, 1.5, 0.1)
			MainPos = MainPos + (MouseLook.lookVector * 10)
			num = num - 1
			if hit ~= nil then
				num = 0
				damage(hit.Parent:WaitForChild("Torso"), math.random(5,8), math.random(8,10), 5, 1, RootPart)
			end
		until num <= 0
	end))
end

function Attackone()
attack = true
Con1 = LeftLeg.Touched:connect(function(hit) damage(hit, math.random(5,6), math.random(6,10), 1, 1, RootPart) Con1:disconnect() end) 
for i = 0,1,0.2 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(30)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-30)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(20)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-20)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(-30), math.rad(5)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(-30), math.rad(-5)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
end
so("http://roblox.com/asset/?id=320557413",LeftLeg,1,1)
for i = 0,1,0.15 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(-30), math.rad(0), math.rad(-30)), .5)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(10), math.rad(30)), .5)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(20)), .5)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(-20)), .5)
RH.C0 = clerp(RH.C0, cn(0.55, -2, .5) * angles(math.rad(-30), math.rad(30), math.rad(10)), .5)
LH.C0 = clerp(LH.C0, cn(-1.3, -1, -1.3) * angles(math.rad(80), math.rad(-10), math.rad(-30)), .5)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
end
attack = false
Con1:disconnect()
end

function Attacktwo()
attack = true
Con1 = LeftArm.Touched:connect(function(hit) damage(hit, math.random(5,6), math.random(6,10), 1, 1, RootPart) Con1:disconnect() end) 
for i = 0,1,0.2 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-80)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(10), math.rad(50)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(20)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.5, -.5) * angles(math.rad(0), math.rad(-150), math.rad(-90)), .3)
RH.C0 = clerp(RH.C0, cn(0.8, -2, 0) * angles(math.rad(-10), math.rad(30), math.rad(10)), .3)
LH.C0 = clerp(LH.C0, cn(-0.8, -2, 0) * angles(math.rad(0), math.rad(30), math.rad(-10)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(70), math.rad(0)), .4)
end
so("http://roblox.com/asset/?id=320557413",LeftArm,1,1.2)
for i = 0,1,0.15 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(80)), .35)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(-5), math.rad(-80)), .35)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, 0) * angles(math.rad(50), math.rad(20), math.rad(30)), .35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(-10), math.rad(-90)), .35)
RH.C0 = clerp(RH.C0, cn(0.8, -2, 0) * angles(math.rad(-10), math.rad(-40), math.rad(10)), .35)
LH.C0 = clerp(LH.C0, cn(-0.8, -2, 0) * angles(math.rad(-10), math.rad(-40), math.rad(-10)), .35)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-90), math.rad(0)), .3)
end
attack = false
Con1:disconnect()
end

function Attackthree()
attack = true
Con1 = RightArm.Touched:connect(function(hit) damage(hit, math.random(5,6), math.random(6,10), 1, 1, RootPart) Con1:disconnect() end) 
for i = 0,1,0.2 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-70)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(70)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, 0) * angles(math.rad(160), math.rad(0), math.rad(20)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.5) * angles(math.rad(0), math.rad(-150), math.rad(-90)), .3)
RH.C0 = clerp(RH.C0, cn(0.57, -2, 0) * angles(math.rad(0), math.rad(40), math.rad(7)), .3)
LH.C0 = clerp(LH.C0, cn(-0.57, -2, 0) * angles(math.rad(0), math.rad(40), math.rad(-7)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, -.1) * angles(math.rad(0), math.rad(150), math.rad(0)), .4)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
end
so("http://roblox.com/asset/?id=320557413",RightArm,1,1.3)
for i = 0,1,0.13 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(70)), .35)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(-5), math.rad(-70)), .35)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.4, -.3) * angles(math.rad(30), math.rad(-50), math.rad(-20)), .35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-30)), .35)
RH.C0 = clerp(RH.C0, cn(0.57, -2, 0) * angles(math.rad(0), math.rad(-40), math.rad(7)), .35)
LH.C0 = clerp(LH.C0, cn(-0.57, -2, 0) * angles(math.rad(0), math.rad(-40), math.rad(-7)), .35)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .4)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .4)
end
attack = false
Con1:disconnect()
end

function Attackfour()
attack = true
for i = 0,1,0.2 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(-70)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(3), math.rad(70)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(30)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.3) * angles(math.rad(120), math.rad(0), math.rad(40)), .3)
RH.C0 = clerp(RH.C0, cn(0.7, -2, .3) * angles(math.rad(3), math.rad(70), math.rad(5)), .3)
LH.C0 = clerp(LH.C0, cn(-0.7, -2, -.3) * angles(math.rad(3), math.rad(70), math.rad(-5)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(-130), math.rad(0)), .7)
end
so("http://roblox.com/asset/?id=320557413",LeftArm,1,0.9)
for i = 0,1,0.15 do 
wait()
so("http://roblox.com/asset/?id=199145534",BarrelA,.5,math.random(150,200)/100) 
OrbEffect(BarrelA.BrickColor,cn(BarrelA.Position),.3,.3,.3,.3,.3,.3,0.1)
Shockwave(BarrelA.BrickColor,cn(BarrelA.Position),.3,.3,.3,.3,.3,.3,0.1)
local target=CheckClose(BarrelA,5)
if target then
damage(target.Torso, math.random(1,2), math.random(2,3), 1, 1, RootPart)
end
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(100)), .35)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(-3), math.rad(-100)), .35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(60), math.rad(70)), .35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.3) * angles(math.rad(-20), math.rad(0), math.rad(-40)), .35)
RH.C0 = clerp(RH.C0, cn(0.58, -2, 0) * angles(math.rad(3), math.rad(0), math.rad(8)), .35)
LH.C0 = clerp(LH.C0, cn(-0.58, -2, 0) * angles(math.rad(3), math.rad(0), math.rad(-8)), .35)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(-130), math.rad(0)), .7)
end
attack = false
end

function GunStance()
attack=true
gun=true
speedvalue = 1
gyro.Parent = RootPart
if GunA == true then
for i=0,1,0.2 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(5), math.rad(-90)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(30), math.rad(90)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(-10)), .25)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), 5*i, math.rad(0)), .75)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
end
for i=0,1,0.1 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(-90)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-10)), .25)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
end
elseif GunB == true then
for i=0,1,0.2 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(-5), math.rad(90)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(10)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(-30), math.rad(-90)), .25)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), 5*i, math.rad(0)), .75)
end
for i=0,1,0.1 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(90)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(10)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-90)), .25)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
end
end
local offset = nil
gunidle=true
while gun==true do
wait()
local gunpos = Vector3.new(mouse.Hit.p.x, Head.Position.Y, mouse.Hit.p.z)
offset = (Torso.Position.y - mouse.Hit.p.y) / 60
local mag = (Torso.Position - mouse.Hit.p).magnitude / 80
offset = offset / mag 
if GunA == true and GunB == false then
RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(offset, 0, 0), .5)
elseif GunB == true and GunA == false then
LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(offset, 0, 0), .5)
end
end
if shoot==true then
gunidle=false
if GunA == true then
so("http://www.roblox.com/asset/?id=199144089", BarrelA, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelA, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelA, 1, 1.5)
GunA = false
Shoot(BarrelA, 0, 0)
for i=0,1,0.15 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(80)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(5), math.rad(-80)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.7, 0) * angles(math.rad(90), math.rad(60), math.rad(80)), .55)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(-15)), .3)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, -.1) * angles(math.rad(5), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, .1) * angles(math.rad(-5), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(20), math.rad(0)), .75)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(30), math.rad(0)), .3)
end
GunB = true
elseif GunB == true then
so("http://www.roblox.com/asset/?id=199144089", BarrelB, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelB, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelB, 1, 1.5)
GunB = false
Shoot(BarrelB, 0, 0)
for i=0,1,0.15 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-80)), .3)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(-5), math.rad(80)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(15)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.7, 0) * angles(math.rad(90), math.rad(-60), math.rad(-80)), .55)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, .1) * angles(math.rad(-5), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, -.1) * angles(math.rad(5), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(30), math.rad(0)), .3)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(20), math.rad(0)), .75)
end
GunA = true
end
end
gyro.Parent = nil
speedvalue = 2.5
gun=false
gunidle=false
shoot=false
attack=false
end

function EchoBarrage()
attack = true
gyro.Parent = RootPart
speedvalue = 1
for i = 0,1,0.1 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(80), math.rad(0), math.rad(10)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(80), math.rad(0), math.rad(-10)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(3), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(3), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 10*i, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), -10*i, math.rad(0)), .7)
end
for i = 1,2 do
for i = 0,1,0.3 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.2) * angles(math.rad(90), math.rad(0), math.rad(0)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.2) * angles(math.rad(90), math.rad(0), math.rad(0)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
ReflectShot(mouse,BarrelA)
so("http://www.roblox.com/asset/?id=199144089", BarrelA, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelA, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelA, 1, 1.5)
--so("http://www.roblox.com/asset/?id=360087120", Torso, .5, 1)
for i = 0,1,0.35 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), .4)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(20)), .4)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.4) * angles(math.rad(150), math.rad(0), math.rad(-20)), .4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.4) * angles(math.rad(90), math.rad(0), math.rad(0)), .4)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(20), math.rad(3)), .4)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(20), math.rad(-3)), .4)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
for i = 0,1,0.3 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.2) * angles(math.rad(90), math.rad(0), math.rad(0)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.2) * angles(math.rad(90), math.rad(0), math.rad(0)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
ReflectShot(mouse,BarrelB)
so("http://www.roblox.com/asset/?id=199144089", BarrelB, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelB, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelB, 1, 1.5)
--so("http://www.roblox.com/asset/?id=360087120", Torso, .5, 1)
for i = 0,1,0.35 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(20)), .4)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(-20)), .4)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.4) * angles(math.rad(90), math.rad(0), math.rad(0)), .4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.4) * angles(math.rad(150), math.rad(0), math.rad(20)), .4)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(-20), math.rad(3)), .4)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(-20), math.rad(-3)), .4)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
end
gyro.Parent = nil
attack = false
speedvalue = 2.5
end

function LucentScatter()
attack = true
gyro.Parent = RootPart
speedvalue = 1
for i = 0,1,0.1 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(-70)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(70)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(30)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.3) * angles(math.rad(120), math.rad(0), math.rad(40)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(3), math.rad(70), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(3), math.rad(70), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), -10*i, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(-130), math.rad(0)), .7)
end
for i = 0,1,0.2 do 
wait()
Shoot(BarrelA, 0, 0)
so("http://www.roblox.com/asset/?id=199144089", BarrelA, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelA, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelA, 1, 1.5)
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(100)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-100)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.5, -.5) * angles(math.rad(130), math.rad(50), math.rad(30)), .2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.3) * angles(math.rad(-20), math.rad(0), math.rad(-40)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(3), math.rad(-70), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(3), math.rad(-70), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(-130), math.rad(0)), .7)
end
for i=0,1,0.3 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(90)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(10)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-90)), .25)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
end
for i = 1,5 do
Shoot(BarrelB, 0, 0)
so("http://www.roblox.com/asset/?id=199144089", BarrelB, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelB, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelB, 1, 1.5)
for i=0,1,0.3 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-80)), .5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(-5), math.rad(80)), .5)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(50), math.rad(0), math.rad(15)), .5)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.7, 0) * angles(math.rad(90), math.rad(-60), math.rad(-80)), .55)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, .1) * angles(math.rad(-5), math.rad(0), math.rad(3)), .5)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, -.1) * angles(math.rad(5), math.rad(0), math.rad(-3)), .5)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(30), math.rad(0)), .3)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(20), math.rad(0)), .75)
end
for i=0,1,0.3 do
wait()
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), .8)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(90)), .5)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(10)), .8)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-90)), .8)
				RH.C0 = clerp(RH.C0, cn(0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .5)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .5)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .5)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .5)
end
end
gyro.Parent = nil
attack = false
speedvalue = 2.5
end

function OrbEffect(brickcolor, cframe, x1, y1, z1, x2, y2, z2, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CanCollide=false
	prt.CFrame = cframe*cn(0,-1,0)*angles(math.rad(math.random(-90,90)),math.rad(math.random(-90,90)),math.rad(math.random(-90,90)))
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		for i = 0, 1, delay do
			wait(0)
			Part.CFrame = Part.CFrame
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x2, y2, z2)
		end
		Part.Parent = nil
	end), prt, msh)
end

function Shockwave(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe*cn(0,-1,0)
	--prt.Material = "Neon"
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh) 
		for i = 0, 1, delay do
			wait(0)
			Part.CFrame = Part.CFrame
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
		end
		Part.Parent = nil
	end), prt, msh)
end

function Reflex()
attack = true
gyro.Parent = RootPart
speedvalue = 1
for i = 0,1,0.1 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.55) * angles(math.rad(5), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.5, -.2) * angles(math.rad(0), math.rad(100), math.rad(50)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.2) * angles(math.rad(0), math.rad(-100), math.rad(-50)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -1.5, .5) * angles(math.rad(-60), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -1.45, -.5) * angles(math.rad(-5), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
so("http://roblox.com/asset/?id=199145534",BarrelA,1,math.random(150,200)/100) 
for i=1,math.random(3,6) do
OrbEffect(BarrelA.BrickColor,cn(BarrelA.Position),1,1,1,1,1,1,0.025)
Shockwave(BarrelA.BrickColor,cn(BarrelA.Position),1,1,1,1,1,1,0.025)
end
local target=CheckClose(BarrelA,30)
if target then
damage(target.Torso, 5, math.random(15,20), math.random(15,16), 1, RootPart)
end
Humanoid.Jump=true
Torso.Velocity=Vector3.new(0,7.5,0)
Torso.Velocity=RootPart.CFrame.lookVector*-100
Humanoid.WalkSpeed = 16*speed.Value
for i = 0,1,0.1 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(-6*i, math.rad(0), math.rad(0)), .4)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .4)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.7, 0) * angles(math.rad(-30), math.rad(0), math.rad(130)), .4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.7, 0) * angles(math.rad(-30), math.rad(0), math.rad(-130)), .4)
RH.C0 = clerp(RH.C0, cn(0.6, -1.5, -.3) * angles(math.rad(0), math.rad(0), math.rad(5)), .4)
LH.C0 = clerp(LH.C0, cn(-0.6, -1.8, -.2) * angles(math.rad(0), math.rad(0), math.rad(-5)), .4)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-150), math.rad(0)), .25)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-150), math.rad(0)), .25)
RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
end
gyro.Parent = nil
attack = false
speedvalue = 2.5
end

function Luxuriance()
attack = true
gyro.Parent = RootPart
for i = 0,1,0.1 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -.5) * angles(math.rad(20), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(15), math.rad(0), math.rad(70)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(15), math.rad(0), math.rad(-70)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -1.7, .4) * angles(math.rad(-20), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -1.45, -.5) * angles(math.rad(5), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 10*i, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), -10*i, math.rad(0)), .7)
end
for i = 0,1,0.3 do 
wait()
ReflectShot(mouse,BarrelA)
so("http://www.roblox.com/asset/?id=199144089", BarrelA, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelA, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelA, 1, 1.5)
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(100)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-100)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.5, -.5) * angles(math.rad(130), math.rad(50), math.rad(30)), .2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.3) * angles(math.rad(-20), math.rad(0), math.rad(-40)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(3), math.rad(-70), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(3), math.rad(-70), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(-130), math.rad(0)), .7)
end
for i = 0,1,0.2 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(15), math.rad(0), math.rad(70)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(15), math.rad(0), math.rad(-70)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 10*i, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), -10*i, math.rad(0)), .7)
end
for i = 0,1,0.3 do 
wait()
ReflectShot(mouse,BarrelB)
so("http://www.roblox.com/asset/?id=199144089", BarrelB, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelB, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelB, 1, 1.5)
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(-100)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(100)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.3) * angles(math.rad(-20), math.rad(0), math.rad(-40)), .2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.5) * angles(math.rad(130), math.rad(-50), math.rad(-30)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(3), math.rad(70), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(3), math.rad(70), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(-130), math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .7)
end
for i = 0,1,0.1 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(3), math.rad(0), math.rad(0)), .3)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(0)), .3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(80), math.rad(0), math.rad(10)), .3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(80), math.rad(0), math.rad(-10)), .3)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(3), math.rad(0), math.rad(3)), .3)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(3), math.rad(0), math.rad(-3)), .3)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 10*i, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), -10*i, math.rad(0)), .7)
end
for i = 1,5 do
Shoot(BarrelA, 0, 0)
so("http://www.roblox.com/asset/?id=199144089", BarrelA, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelA, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelA, 1, 1.5)
for i = 0,1,0.35 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(-20)), .4)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(20)), .4)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.4) * angles(math.rad(150), math.rad(0), math.rad(-20)), .4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.4) * angles(math.rad(90), math.rad(0), math.rad(0)), .4)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(20), math.rad(3)), .4)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(20), math.rad(-3)), .4)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
Shoot(BarrelB, 0, 0)
so("http://www.roblox.com/asset/?id=199144089", BarrelB, 1, .9)
so("http://www.roblox.com/asset/?id=200633327", BarrelB, 1, 1.2)
so("http://www.roblox.com/asset/?id=200633780", BarrelB, 1, 1.5)
for i = 0,1,0.35 do 
wait()
RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(20)), .4)
Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(-20)), .4)
RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.5, -.4) * angles(math.rad(90), math.rad(0), math.rad(0)), .4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.5, -.4) * angles(math.rad(150), math.rad(0), math.rad(20)), .4)
RH.C0 = clerp(RH.C0, cn(0.55, -2, 0) * angles(math.rad(0), math.rad(-20), math.rad(3)), .4)
LH.C0 = clerp(LH.C0, cn(-0.55, -2, 0) * angles(math.rad(0), math.rad(-20), math.rad(-3)), .4)
FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), 0, math.rad(0)), .7)
end
end
gyro.Parent = nil
attack = false
end

mouse.Button1Down:connect(function()
if gun==true and shoot==false then
shoot=true
gun=false
end
if attack == false and attacktype == 1 then
Attackone()
attacktype = 2
elseif attack == false and attacktype == 2 then
Attacktwo()
attacktype = 3
elseif attack == false and attacktype == 3 then
Attackthree()
attacktype = 4
elseif attack == false and attacktype == 4 then
Attackfour()
attacktype = 1
end
end)

mouse.KeyDown:connect(function(k)
	k = k:lower()
	if k=='e' and gun==false and shoot==false and attack==false then
	GunStance()
	end
	if k=='e'and shoot==false then
		if gun==true then
		gun=false
		end
	end
	if k=='q' and gun==false and shoot==false and attack==false and cooldown1 >= co1 and stamina>=skill1stam then
	cooldown1=0
	subtractstamina(skill1stam)
	EchoBarrage()
	end
	if k=='r' and gun==false and shoot==false and attack==false and cooldown2 >= co2 and stamina>=skill2stam then
	cooldown2=0
	subtractstamina(skill2stam)
	LucentScatter()
	end
	if k=='t' and gun==false and shoot==false and attack==false and cooldown3 >= co3 and stamina>=skill3stam then
	cooldown3=0
	subtractstamina(skill3stam)
	Reflex()
	end
	if k=='f' and gun==false and shoot==false and attack==false and cooldown4 >= co4 and stamina>=skill4stam then
	cooldown4=0
	subtractstamina(skill4stam)
	Luxuriance()
	end
end)


inputserv.InputBegan:connect(function(k)
	if k.KeyCode == Enum.KeyCode.One and typing == false and cooldown3 >= co1 and stamina >= skill1stam then
	elseif k.KeyCode == Enum.KeyCode.Two and typing == false and cooldown3 >= co2 and stamina >= skill2stam then
	elseif k.KeyCode == Enum.KeyCode.Three and typing == false and cooldown3 >= co3 and stamina >= skill3stam then
	elseif k.KeyCode == Enum.KeyCode.Four and typing == false and cooldown3 >= co4 and stamina >= skill4stam then
	end
end)

inputserv.InputBegan:connect(function(k)
	if k.KeyCode == Enum.KeyCode.Slash then
		local fin = nil
		typing = true
		fin = inputserv.InputBegan:connect(function(k)
			if k.KeyCode == Enum.KeyCode.Return or k.UserInputType == Enum.UserInputType.MouseButton1 then
				typing = false
				fin:disconnect()
			end
		end)
	end
end)

local ReboundCount = 0

function updateskills()
	if cooldown1 <= co1 then
		cooldown1 = cooldown1 + 1 
	end
	if cooldown2 <= co2 then
		cooldown2 = cooldown2 + 1
	end
	if cooldown3 <= co3 then
		cooldown3 = cooldown3 + 1 
	end
	if cooldown4 <= co4 then
		cooldown4 = cooldown4 + 1 
	end
	if stamina <= maxstamina then
		stamina = stamina + recoverEnergy
	end
end

game:GetService'RunService'.Heartbeat:connect(function()
	updateskills()
	gyro.CFrame = CFrame.new(Vector3.new(),(mouse.Hit.p -RootPart.CFrame.p).unit * 100)
	healthcover:TweenSize(ud(1 * (Character.Humanoid.Health / Character.Humanoid.MaxHealth), 0, 1, 0), 'Out', 'Quad', .5)
	staminacover:TweenSize(ud(1 * (stamina / maxstamina), 0, 1, 0), 'Out', 'Quad', .5)
	bar4:TweenSize(ud(1 * (cooldown1 / co1), 0, 1, 0), 'Out', 'Quad', .5)
	bar3:TweenSize(ud(1 * (cooldown2 / co2), 0, 1, 0), 'Out', 'Quad', .5)
	bar1:TweenSize(ud(1 * (cooldown3 / co3), 0, 1, 0), 'Out', 'Quad', .5)
	bar2:TweenSize(ud(1 * (cooldown4 / co4), 0, 1, 0), 'Out', 'Quad', .5)
	Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
	velocity = RootPart.Velocity.y
	sine = sine + change
	local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
	Character.Humanoid.WalkSpeed = 16 * speed.Value
	if equipped == true or equipped == false then
		if RootPart.Velocity.y > 1 and hit == nil and stun.Value ~= true then 
			Anim = "Jump"
			if attack == false then
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(10), math.rad(0), math.rad(0)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(50)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-40), math.rad(0), math.rad(-50)), .25)
				RH.C0 = clerp(RH.C0, cn(0.4, -1.5, -.5) * angles(math.rad(-20), math.rad(0), math.rad(-5)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -2, 0) * angles(math.rad(-10), math.rad(0), math.rad(5)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .25)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .25)
                RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
                LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
			end
		elseif RootPart.Velocity.y < -1 and hit == nil and stun.Value ~= true then 
			Anim = "Fall"
			if attack == false then
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(15), math.rad(0), math.rad(0)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(70)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-70)), .25)
				RH.C0 = clerp(RH.C0, cn(0.6, -1.5, -.3) * angles(math.rad(0), math.rad(0), math.rad(5)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -1.8, -.2) * angles(math.rad(0), math.rad(0), math.rad(-5)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .25)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .25)
                RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
                LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
			end
		elseif Torsovelocity < 1 and hit ~= nil and stun.Value ~= true then
			Anim = "Idle"
			if attack == false then
				change = 1
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, -0.1+0.1*math.cos(sine/25), -0.1+0.05*math.cos(sine/25)) * angles(math.rad(0), math.rad(0), math.rad(-30)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10+5*math.cos(sine/25)), math.rad(0), math.rad(30)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.4, -.2) * angles(math.rad(50-5*math.cos(sine/25)), math.rad(0), math.rad(10)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.4, -.2) * angles(math.rad(50-5*math.cos(sine/25)), math.rad(0), math.rad(-10)), .25)
				RH.C0 = clerp(RH.C0, cn(0.7, -1.9-.05*math.cos(sine/25), 0) * angles(math.rad(0), math.rad(30), math.rad(5))* angles(math.rad(-5+1*math.cos(sine/25)), math.rad(0), math.rad(0)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.6, -1.9-.05*math.cos(sine/25), 0) * angles(math.rad(0), math.rad(30), math.rad(-3))* angles(math.rad(-3+1*math.cos(sine/25)), math.rad(0), math.rad(0)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
                RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
                LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
			end
		elseif Torsovelocity > 2 and hit ~= nil and stun.Value ~= true then
			Anim = "Walk"
			if attack == false then
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(20+1*math.cos(sine/5)), math.rad(0), math.rad(5*math.cos(sine/4.5))), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-10), math.rad(0), math.rad(-5*math.cos(sine/4.5))), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.4, 0.45, 0) * angles(math.rad(-40), math.rad(0), math.rad(20+1*math.cos(sine/5))), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.4, 0.45, 0) * angles(math.rad(-40), math.rad(0), math.rad(-20+1*math.cos(sine/5))), .25)
				RH.C0 = clerp(RH.C0, cn(0.55, -2, 1*math.cos(sine/4.5)) * angles(math.rad(-50*math.cos(sine/4.5)), math.rad(0), math.rad(3)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.55, -2, -1*math.cos(sine/4.5)) * angles(math.rad(50*math.cos(sine/4.5)), math.rad(0), math.rad(-3)), .25)
				FakeHandleAweld.C0 = clerp(FakeHandleAweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .25)
				FakeHandleBweld.C0 = clerp(FakeHandleBweld.C0, cn(0, 0, .8) * angles(math.rad(0), math.rad(-170), math.rad(0)), .25)
                RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
                LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
			end
		elseif stun.Value == true then
			if attack == false then
				Character.Humanoid.WalkSpeed = 0
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
				RH.C0 = clerp(RH.C0, cn(0.5, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
				LH.C0 = clerp(LH.C0, cn(-0.5, -2, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .25)
                RW.C1 = clerp(RW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
                LW.C1 = clerp(LW.C1, cn(0, 0.5, 0) * CFrame.fromEulerAnglesXYZ(0, 0, 0), .3)
			end
		end
	end
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.FromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, .5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
	for _, lasr in pairs(lasrs) do 
		for i, v in pairs(lasr[9]) do 
			if lasr[7][i].Parent then 
				v.Scale = v.Scale + Vector3.new(-0.1,0,-0.1) 
				lasr[10][i].Scale = lasr[10][i].Scale + Vector3.new(-0.1,0,-0.1) 
				if v.Scale.x < 0.1 then 
					lasr[7][i].Parent = nil 
					lasr[8][i].Parent = nil 
				end 
			end 
		end 

		if lasr[1] then 
			local hitz, enz = RAY(lasr[3],lasr[2]*lasrspd) 
			lasr[5] = lasr[5] + (lasr[3] - enz).magnitude 

			lasr[7][lasr[6]].Parent = m 
			lasr[7][lasr[6]].CFrame = CFrame.new((lasr[3] + enz)/2,enz) * CFrame.Angles(math.pi/2,0,0) 
			lasr[9][lasr[6]].Scale = Vector3.new(0.7,(lasr[3] - enz).magnitude*5,0.7) 

			lasr[8][lasr[6]].Parent = m 
			lasr[8][lasr[6]].CFrame = lasr[7][lasr[6]].CFrame 
			lasr[10][lasr[6]].Scale = Vector3.new(1.3,(lasr[3] - enz).magnitude*5 + 0.02,1.3) 

			lasr[3] = enz 
			lasr[6] = lasr[6]%#lasr[7] + 1 

			if hitz then 
				lasr[4] = lasr[4] + 1 
				if lasr[4] == maxRebounds then 
					lasr[1] = false 
				so("http://www.roblox.com/asset/?id=200633327", hitz, 1, 2)
                damage(hitz.Parent:WaitForChild("Torso"), math.random(5,10), math.random(10,20), 5, 1, RootPart)
                print(ReboundCount)
				else 
					local norm = FindSurface(hitz,enz) 
					lasr[2] = Reflect(lasr[2],norm)
				so("http://www.roblox.com/asset/?id=200633327", hitz, 1, 2) 
				damage(hitz.Parent:WaitForChild("Torso"), math.random(5,10), math.random(10,20), 5, 1, RootPart)
				print(ReboundCount)
				end 
			end 
			if lasr[5] > maxTravelDistance then 
				lasr[1] = false 
			end 
		end 
	end 
end)
print("Loaded")
end)
Section:NewButton("FE Exotic Cannon", "ButtonInfo", function()
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('SpecialMesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['Starslayer Railgun'].Handle,char['Right Arm'],false)
local cf = char['Right Arm'].CFrame*CFrame.new(0,-2,-0.50)*CFrame.Angles(math.rad(0),math.rad(100),175.25)
hat[1].CFrame = cf:Inverse() * char['Right Arm'].CFrame
--//====================================================\\--
--||			  Created By ExoticCult, CONVERTED BY MELON	,Edited By Dummy			||--
--\\====================================================//--
local script = game:GetObjects("rbxassetid://10118489206")[1]


Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,30,0)
wait(0.5)
end)
end
end
local p = game.Players.LocalPlayer
local char = p.Character
local mouse = p:GetMouse()
local larm = char["Left Arm"]
local rarm = char["Right Arm"]
local lleg = char["Left Leg"]
local rleg = char["Right Leg"]
local hed = char.Head
local torso = char.Torso
local hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
local root = char.HumanoidRootPart
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

hed.Massless = true
hed.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
torso.Massless = true
torso.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
rarm.Massless = true
rarm.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
larm.Massless = true
larm.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
lleg.Massless = true
lleg.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
rleg.Massless = true
rleg.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
root.Massless = true
root.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
warn("Netless Activated!")
Bypass = "Death"
plr = game.Players.LocalPlayer
dead = false
char = plr.Character



bullet = workspace[plr.Name]["HumanoidRootPart"]
bullet.Transparency = 0
bhandle = bullet
bullet.Massless = true

mouse = plr:GetMouse()
head = char.Head
camera = workspace.CurrentCamera
lt = true
ltt = false

local function IsFirstPerson()
     return (head.CFrame.p - camera.CFrame.p).Magnitude < 1
end

     bbv = Instance.new("BodyPosition",bhandle)
     bbv.Position = char.Torso.CFrame.p
   
     
     
     mouse.Button1Down:Connect(function()
         if dead == false then
        lt = false
        ltt = false
     bbav = Instance.new("BodyAngularVelocity",bhandle)
     bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
     bbav.P = 1000000000000000000000000000
     bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
     game:GetService("Debris"):AddItem(bbav,0.1)
        if game.Players:GetPlayerFromCharacter(mouse.Target.Parent) then
            if mouse.Target.Parent.Name == char.Name or mouse.Target.Parent.Name == "non" then return end
              --repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bbv.Position = (CFrame.new(mouse.Target.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            bhandle.Position = (CFrame.new(mouse.Target.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            wait(1)
            --until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        elseif game.Players:GetPlayerFromCharacter(mouse.Target.Parent.Parent) then
            if mouse.Target.Parent.Name == char.Name or mouse.Target.Parent.Name == "non" then return end
            --repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bbv.Position = (CFrame.new(mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            bhandle.Position = (CFrame.new(mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            wait(1)
            --until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
            
            else
       -- repeat 
        game:GetService("RunService").RenderStepped:Wait()
        wait(1)
        --until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        end
        wait()
        lt = true
         end
         end)
         
    spawn(
        function()
            while true do
                game:GetService("RunService").Heartbeat:Wait()
                bullet.Velocity = Vector3.new(0,26,0)
         end
    end)

 plr:GetMouse().Button1Down:Connect(function()
attackingwithhrp = true	
end)

 
plr:GetMouse().Button1Up:Connect(function()
attackingwithhrp = false
end)

plr:GetMouse().Button1Down:Connect(function()
repeat wait() until attackingwithhrp == true
repeat
game:GetService("RunService").Heartbeat:Wait()
if plr:GetMouse().Target ~= nil then
bullet.Position = game:GetService("Players").LocalPlayer:GetMouse().Hit.p
end
until attackingwithhrp == false
end)
Player = game:GetService("Players").LocalPlayer
local USERNAME = Player.Name
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Workspace.non
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local info = false
local TIME = 0
local Throttle = 0
local doe = 0
local LookUp = false
local sick = Instance.new("Sound",Torso)
sick.Parent = Torso
sick:Play()
sick.Volume = 8.2
sick.Pitch = 1
sick.SoundId = "rbxassetid://6174456295"
sick.Looped = true
sick.TimePosition = 0
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local alreadyfixing = false
local hue = 0;

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
local FORCERESET = false
Frame_Speed = 1 / 60
local Speed = 50
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = true
local COMBO = 3
local Rooted = false
local SINE = 5
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local WEAPONGUI = IT("ScreenGui", PlayerGui)
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
local targetted = nil
script.Parent = PlayerGui
local mde = 0
local sine = 5
local Sine = 5
local stopeverything = false
local ROOTC02 = CFrame.new(0,3,0 * math.cos(sine/15)) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local change = 1
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local PotentialCFrame = Torso.Position
local random = math.random
local ocr=MRANDOM(0,255)
local orangecolorrandom=C3(ocr/255,ocr/355,0)
local bcr=MRANDOM(0,96)
local bluecolorrandom=C3(0,bcr/390,bcr/255)
local TEXTCOLOR = Color3.new(1, 1, 1)
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local Plrs = S.Players
if mde == 12 then
	if MRANDOM(1,2)==1 then	
		TEXTCOLOR = orangecolorrandom
	elseif MRANDOM(1,2)==2 then	
		TEXTCOLOR = bluecolorrandom
	elseif mde ~= 12 then
		Color3.new(1, 1, 1)
	end
end
local cn,euler,rad,v3,c3,sin,cos,clamp = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,Vector3.new,Color3.fromRGB,math.sin,math.cos,math.clamp
local partexclusion = {}
local run = game:GetService("RunService")
local ts = game:GetService("TweenService")
local SIZEE = 1
function cn2(x,y,z)
	return cn(x*SIZEE,y*SIZEE,z*SIZEE)
end

--//=================================\\
--|| 	          WINGS
--\\=================================//


local LWing = Instance.new("Part")
LWing.Parent = Character
LWing.Reflectance = -1
LWing.Size = Vector3.new(4, 1, 2)
LWing.Name = "LWing"
LWing.Anchored = false
LWing.Locked = true
local LWingMsh = Instance.new("SpecialMesh")
LWingMsh.Parent = LWing
LWingMsh.Offset = Vector3.new()
LWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
LWingMsh.MeshType = "FileMesh"
LWingMsh.MeshId = "rbxassetid://1553468234"
local RWing = Instance.new("Part")
RWing.Parent = Character
RWing.Reflectance = -1
RWing.Size = Vector3.new(4, 1, 2)
RWing.Name = "RWing"
RWing.Anchored = false
RWing.Locked = true
local RWingMsh = Instance.new("SpecialMesh")
RWingMsh.Parent = RWing
RWingMsh.Offset = Vector3.new()
RWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
RWingMsh.MeshType = "FileMesh"
RWingMsh.MeshId = "rbxassetid://1553468709"
local LWingWld = Instance.new("Motor6D")
LWingWld.Parent = LWing
LWingWld.Part0 = Torso
LWingWld.Part1 = LWing
LWingWld.C0 = CFrame.new(-0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
LWingWld.C1 = CFrame.new(1.1, 1, 0.95)
local RWingWld = Instance.new("Motor6D")
RWingWld.Parent = RWing
RWingWld.Part0 = Torso
RWingWld.Part1 = RWing
RWingWld.C0 = CFrame.new(0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
RWingWld.C1 = CFrame.new(1.1, 1, -0.95)

--//=================================\\
--|| 	      Begin HELL
--\\=================================//

--//Start Here For Anti Death\\-- 
--[[
local function refit() -- Hopefully it works?
	alreadyfixing = true
	local newChar = Character:Clone()
	newChar.Name = "ExoticCult"
	newChar.Parent = game.ServerStorage
	local camerapos = workspace.CurrentCamera.CFrame
	pcall(function()
		Character:Destroy()
	end)
	Character = game.ServerStorage.ExoticCult
	Character.Parent = workspace
	Humanoid = Character.Humanoid
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	if Player.Name == USERNAME then
		workspace.CurrentCamera.CameraSubject = Humanoid
		workspace.CurrentCamera.CameraType = "Scriptable"
		workspace.CurrentCamera.CFrame = camerapos
		coroutine.resume(coroutine.create(function()
			swait(5)
			workspace.CurrentCamera.CameraType = "Custom"
		end))
	end

	--Body parts
	LeftArm = Character["Left Arm"]
	RightArm = Character["Right Arm"]
	LeftLeg = Character["Left Leg"]
	RightLeg = Character["Right Leg"]
	Head = Character["Head"]
	Torso = Character["Torso"]
	RootPart = Character["HumanoidRootPart"]
	if Player.Name == USERNAME then
		Character = Player.Character
	end
	--Root Joints
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	Effects = IT("Folder", Character)
	--Wings
	LWing.Parent = Character
	LWing.Reflectance = -1
	LWing.Size = Vector3.new(4, 1, 2)
	LWing.Name = "LWing"
	LWing.Anchored = false
	LWing.Locked = true

	LWingMsh.Parent = LWing
	LWingMsh.Offset = Vector3.new()
	LWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
	LWingMsh.MeshType = "FileMesh"
	LWingMsh.MeshId = "rbxassetid://1553468234"

	LWingWld.Parent = LWing
	LWingWld.Part0 = Torso
	LWingWld.Part1 = LWing
	LWingWld.C0 = CFrame.new(-0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
	LWingWld.C1 = CFrame.new(1.1, 1, 0.95)
	--Left Wing above, Right Wing below
	RWing.Parent = Character
	RWing.Reflectance = -1
	RWing.Size = Vector3.new(4, 1, 2)
	RWing.Name = "RWing"
	RWing.Anchored = false
	RWing.Locked = true

	RWingMsh.Parent = RWing
	RWingMsh.Offset = Vector3.new()
	RWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
	RWingMsh.MeshType = "FileMesh"
	RWingMsh.MeshId = "rbxassetid://1553468709"

	RWingWld.Parent = RWing
	RWingWld.Part0 = Torso
	RWingWld.Part1 = RWing
	RWingWld.C0 = CFrame.new(0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
	RWingWld.C1 = CFrame.new(1.1, 1, -0.95)
	alreadyfixing = false
end
]]
--//=================================\\
--|| 	      End HELL
--\\=================================//

--//=================================\\
--|| 	          Head Stuff
--\\=================================//

local hea = script.GlowyParts:Clone()
hea.Parent = Character
hea.Name = "hea"
hea.Anchored = false
hea.Locked = true
local heaWld = Instance.new("Motor6D")
heaWld.Parent = hea
heaWld.Part0 = Head
heaWld.Part1 = hea
heaWld.C0 = CFrame.new(0,0,0)*CFrame.Angles(0,-190,0)
heaWld.C1 = CFrame.new(0,0,0)

--//=================================\\
--|| 	          Scythe Stuff
--\\=================================//

local ScytheWeld = script.Scythe.RightArm:WaitForChild'REF'
for i, v in pairs (script.Scythe.RightArm:GetChildren()) do
	v.Anchored = false
end
local SRightAWeld = IT("Weld")
SRightAWeld.Parent = RightArm
SRightAWeld.Part0 = RightArm
SRightAWeld.Part1 = ScytheWeld
SRightAWeld.Name = "Scythe"
SRightAWeld.C1 = CF(0, 0, 0) * ANGLES(0, 0, 0)
local Scythe = script.Scythe
Scythe.Parent = nil

--//=================================\\
--|| 	          Anti Bullet
--\\=================================//

local Shield = Instance.new("Part", workspace)
Shield.Name = "Baseplate"
Shield.CanCollide = false
Shield.Transparency = 1
Shield.Material = "ForceField"
Shield.Locked = true
Shield.Massless = true
Shield.BrickColor = BrickColor.new("fat")
Shield.Size = Vector3.new(7,7.5,7)
Shield.CFrame = Torso.CFrame
local Wed = Instance.new("Weld", Shield)
Wed.Part0 = Shield
Wed.Name = "Baseplate"
Wed.Part1 = Torso


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//





function randomstring()
	local e = {}
	for i = 1,random(5,50) do
		table.insert(e,#e+1,string.char(random(10,100)))
	end
	return table.concat(e)
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end


function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Color3.new(1,1,1))
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,Color3.new(0,0,0),"Effect",Vector3.new(1,1,1),true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeverything and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = Color3.new(0,0,0)
					Swait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		if mde==12 then
			coroutine.resume(coroutine.create(function()
				while wait() do
					if MRANDOM(1,2)==1 then
						EFFECT.Color = orangecolorrandom
					elseif MRANDOM(1,2)==2 then
						EFFECT.Color = bluecolorrandom
					end
				end
			end))
		end	
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","471124085","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeverything then wait(math.huge) end Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
	local magz = (Part0 - Part1).Magnitude
	local Times = math.floor(math.clamp(magz/10,1,20))
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1,Times do
		local li = Instance.new("Part",Effects)
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.Color = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(.1,.1,magz/Times)
		local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
		local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).Magnitude
			li.Size = Vector3.new(.1,.1,magz2)
			li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
		else
			li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
		end
		curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
		li:Destroy()
		Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
		Swait()
	end
end

function AttackGyro()
	local GYRO = Instance.new("BodyGyro",RootPart)
	GYRO.D = 25
	GYRO.P = 20000
	GYRO.MaxTorque = Vector3.new(0,4000000,0)
	GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
	coroutine.resume(coroutine.create(function()
		repeat if stopeverything then wait(math.huge) end
			swait()
			GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
		until not ATTACK
		GYRO:Destroy()
	end))
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "471124085", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function ShakeCam(Length,Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			Humanoid.CameraOffset = Vector3.new(RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)))
			Cam.CFrame = Cam.CFrame * CF(RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity))) * EULER(RAD(MRANDOM(-intensity, intensity)) * rotM, RAD(MRANDOM(-intensity, intensity)) * rotM, RAD(MRANDOM(-intensity, intensity)) * rotM)
		end
		Humanoid.CameraOffset = Vector3.new(0, 0, 0)
	end))
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

FXFolder = script.ShakeEffects
FXFolder.Parent = nil

function CamShake(who,times,intense,origin) 
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = intense
			cam:WaitForChild'times'.Value = times

			if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
			cam.Parent = who
			wait()
			cam.Disabled = false
		end
	end)()
end

function CamShakeAll(times,intense,origin)
	for _,v in next, Plrs:players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
	end
end

function WACKYEFFECThid(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Lightning" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "5655974069", "", SIZE, VT(0,0,0))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1236145839", "", VT(SIZE.X,1,SIZE.X), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "471124085", "", SIZE, VT(0,0,0))
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1236145839", "", VT(0.1,0.1,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "471124085", "", SIZE, VT(0,0,0))
		elseif TYPE == "Hat" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "173774068", "", SIZE, VT(0,0,0))
		elseif TYPE == "Arm" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2828256740", "", SIZE, VT(0,0,0))
		elseif TYPE == "torso" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "48112070", "", SIZE, VT(0,0,0))
		elseif TYPE == "Head" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "539723444", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "Really red", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

Debris = game:GetService("Debris")
debris = Debris

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

local function FixLightning()
	for i, v in pairs(game.Lighting:GetChildren()) do
		if v.ClassName == "BlurEffect" or v.ClassName == "BloomEffect" or v.ClassName == "ColorCorrectionEffect" or v.ClassName == "SunRaysEffect" or v.ClassName == "Sky" then
			v:Destroy()
		end
	end
	game.Lighting.FogEnd = 1000000000000000000000000
	game.Lighting.ClockTime = 14
	game.Lighting.Brightness = 2
	game.Lighting.TimeOfDay = 14
	game.Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
end

 function SendMessage(StarterText,Text)
	for _,v in pairs(game:GetService("Players"):GetPlayers()) do
		local ClientMessage = script.Message:Clone()
		ClientMessage.Name = StarterText
		local ClientText = Instance.new("StringValue")
		ClientText.Value = Text
		ClientText.Parent = ClientMessage
		ClientMessage.Disabled = false
		ClientMessage.Parent = v:FindFirstChildOfClass("PlayerGui") or v:FindFirstChildOfClass("Backpack") or Instance.new("Backpack",v)
		game:GetService("Debris"):AddItem(ClientMessage,5)
	end
end

function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
	if DoesCourontine == false then
		local Direction = CFrame.new(Part.Position,ToLocation)
		local Distance = (Part.Position - ToLocation).Magnitude
		for i = 1,AmountOfTime do
			swait()
			Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
			Direction = Part.CFrame
		end
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CFrame.new(Part.Position,ToLocation)
			local Distance = (Part.Position - ToLocation).Magnitude
			for i = 1,AmountOfTime do
				swait()
				Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
				Direction = Part.CFrame
			end
		end))
	end
end

function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 

local function SkiddedSendMessage(StarterText,Text)
	for _,v in pairs(game:GetService("Players"):GetPlayers()) do
		local ClientMessage = script.SkiddedMessage:Clone()
		ClientMessage.Name = StarterText
		local ClientText = Instance.new("StringValue")
		ClientText.Value = Text
		ClientText.Parent = ClientMessage
		ClientMessage.Disabled = false
		ClientMessage.Parent = v:FindFirstChildOfClass("PlayerGui") or v:FindFirstChildOfClass("Backpack") or Instance.new("Backpack",v)
		game:GetService("Debris"):AddItem(ClientMessage,5)
	end
end

local Chatted = Player.Chatted:Connect(function(Message)
	if mde ~= 27 or mde ~= 30 then
		local Message,Message_ = Message,Message
		if string.sub(Message,1,3) == "/e " then
			Message = string.sub(Message,4)
		end
		if string.sub(string.lower(Message),1,3) == "lc/" then
			Message = string.sub(Message,4)
		end
		if Message == Message_ then
			SendMessage("["..Player.Name.."]: ",Message)
		end
	end	
end)

local Chatted = Player.Chatted:Connect(function(Message)
	if mde == 27 or mde == 30 then
		local Message,Message_ = Message,Message
		if string.sub(Message,1,3) == "/e " then
			Message = string.sub(Message,4)
		end
		if string.sub(string.lower(Message),1,3) == "lc/" then
			Message = string.sub(Message,4)
		end
		if Message == Message_ then
			SkiddedSendMessage("["..Player.Name.."]: ",Message)
		end
	end	
end)

function WACKYEFFECTa(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "471124085", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

local CreatorName = "ExoticCult"

local GUN = script:FindFirstChild("M82A1")
local GUN = GUN:Clone()
GUN.Parent = Character
local GunJoint = CreateWeldOrSnapOrMotor("Weld", GUN.Handle, RightArm, GUN.Handle, CF(.05,-1,-.15)*ANGLES(RAD(-90),RAD(0),RAD(0)), CF(0, 0, 0))
local Hole = GUN.Hole
local Holetwo = GUN.Hole2
local shade = GUN.NeonParts.Color

local SWORD = script:FindFirstChild("ShadowSword")
local Blade = SWORD:Clone()
Blade.Parent = nil
local SwordJoint = CreateWeldOrSnapOrMotor("Weld", Blade.Handle, RightArm, Blade.Handle, CF(0, -1, 0)*ANGLES(RAD(90),RAD(0),RAD(0)), CF(0, 0, 0))
local BLADEAAAA = Blade.SlashPart

local SDGUN = script:WaitForChild("GUN")
local GUNA = SDGUN:Clone()
GUNA.Parent = Character
local GunJoint2 = CreateWeldOrSnapOrMotor("Weld", GUNA.Handle, RightArm, GUNA.Handle, CF(.05,-1,-.15)*ANGLES(RAD(-180),RAD(-180),RAD(0)), CF(0, 0, 0))

local ShadedFolder = IT("Model",Character)
ShadedFolder.Name = "Shaded"
ShadedFolder.Parent = nil
for i = 1, 10 do
	local FACE = CreatePart(3, ShadedFolder, "Fabric", 0, 0+(i-1)/10.2, "Really black", "FaceGradient", VT(1.01,0.65,1.01),false)
	FACE.Color = C3()
	Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.25-(i-1)/40,0), CF(0, 0, 0))
end
EYE = CreatePart(3, ShadedFolder, "Neon", 0, 0, "Institutional white", "Eyeball", VT(0.2,0.2,0.2),false)
MakeForm(EYE,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, EYE, CF(0.15,0.23,-0.55), CF(0, 0, 0))

local hitb = Instance.new("Part", Character)
hitb.Anchored = true
hitb.CanCollide = false
hitb.FormFactor = 3
hitb.Name = "Ring"
hitb.Material = "Neon"
hitb.Size = Vector3.new(1, 1, 1)
hitb.Transparency = 1
hitb.TopSurface = 0
hitb.BottomSurface = 0
TEXTCOLOR = orangecolorrandom
if MRANDOM(1,2)==1 then	
	TEXTCOLOR = orangecolorrandom
elseif MRANDOM(1,2)==2 then	
	TEXTCOLOR = bluecolorrandom
end
hitb.CFrame = RootPart.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9))

local chat = script.t
chat.Parent = nil
local chatweld = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, chat, CF(0, 0, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 1))
chat.Parent = nil
chat.CanCollide = false
chat.Archivable = false
surfacegui = chat.chat
chatinput = surfacegui.input
chatbox = surfacegui.chatbox
local ModeName = surfacegui.ModeName
ModeName.Text = "Mode: None"

local chat2 = script.t2
chat2.Parent = nil
local chatweld2 = CreateWeldOrSnapOrMotor("Weld", RootPart, RootPart, chat2, CF(0, 0, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 1))
chat2.Parent = nil
chat2.CanCollide = false
chat2.Archivable = false
surfacegui2 = chat2.chat
chatinput2 = surfacegui2.input
SK1 = surfacegui2.SK1
SK2 = surfacegui2.SK2

--//=================================\\
--||			DAMAGING
--\\=================================//

function dmg(dude)
end

function mdmg(Part,Magnitude)
end

local USERNAME = Player.Name
local Parents = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"}
function shieldmg(centerofeffect,range,Foe)
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function attackone()
	if GUN.Parent == nil then return end
	ATTACK = true
	AttackGyro()
	for i = 0,.5,.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,2 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
	end
	Effect({Time = 25,EffectType = "Ring",Size = Vector3.new(),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 6150717352,SoundPitch = .4,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Ring",Size = Vector3.new(),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Wave",Size = Vector3.new(),Size2 = Vector3.new(4,0,4),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Wave",Size = Vector3.new(),Size2 = Vector3.new(4,0,4),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	local mousehit = Mouse.Hit
	local DISTANCE = (Holetwo.Position - mousehit.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,Color3.new(1,1,1),"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,mousehit.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	for i = 1,4 do
		coroutine.resume(coroutine.create(function()
			Lightning(Holetwo.Position,mousehit.p,15,3.5,Color3.new(0, 0, 0),25,0,1,0,true,55)
		end))
	end
	coroutine.resume(coroutine.create(function()
		Lightning(Holetwo.Position,mousehit.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
		Effect({Time = 25,EffectType = "Ring",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0,0,0),SoundID = 6150717352,SoundPitch = .4,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Ring",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Wave",Size = Vector3.new(),Size2 = Vector3.new(5,0,5),Transparency = 0,Transparency2 = 1,CFrame = mousehit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Wave",Size = Vector3.new(),Size2 = Vector3.new(5,0,5),Transparency = 0,Transparency2 = 1,CFrame = mousehit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		mdmg(mousehit.p,10)
	end))
	for i = 0,.5,.075 do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,2 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
	end
	ATTACK = false
end

function attackone2()
	if GUN.Parent == nil then return end
	ATTACK = true
	AttackGyro()
	for i = 0,.5,.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,2 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 6150717352,SoundPitch = .2,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	CamShakeAll(50,200)
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	local mousehit = Mouse.Hit
	local DISTANCE = (Holetwo.Position - mousehit.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,Color3.new(1,1,1),"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Holetwo.Position,mousehit.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	for i = 1,4 do
		coroutine.resume(coroutine.create(function()
			Lightning(Holetwo.Position,mousehit.p,15,3.5,Color3.new(0, 0, 0),25,0,1,0,true,55)
		end))
	end
	coroutine.resume(coroutine.create(function()
		Lightning(Holetwo.Position,mousehit.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0,0,0),SoundID = 6150717352,SoundPitch = .2,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = mousehit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = mousehit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = mousehit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		shieldmg(mousehit.p,10)
	end))
	for i = 0,.5,.075 do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,2 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
	end
	ATTACK = false
end

local Backups =  script.Garbage
local Instance_ = Instance.new
function IT_(ClassType,Parent,Properties)
	local NewInstance
	if typeof(Backups[ClassType]) == "Instance" then
		NewInstance = Backups[ClassType]:Clone()
	else
		NewInstance = Instance_(ClassType)
	end
	if type(Properties) == "table" then
		for i,v in pairs(Properties) do
			NewInstance[i] = v
		end
	end
	if typeof(Parent) == "Instance" then
		NewInstance.Parent = Parent
	end
	return NewInstance
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

function CreateWelde(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
	local weld = Instance.new("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
	weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
	return weld
end


function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("WedgePart", Character)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1,1,1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://6921767935"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://6921767935"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			wait(0.001)
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/0.1),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/0.1),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/0.1, 0, scaler2*bonuspeed/0.1)
		end
		rng:Destroy()
	end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", Character)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0/1000,0/1000,0/1000)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = VT(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function slash2(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part", Character)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", Character)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

--[[local bguis = Instance.new("BillboardGui",Torso)
bguis.Size = UDim2.new(8, 0, 8, 0)
bguis.AlwaysOnTop = true
local imgca = Instance.new("ImageLabel",bguis)
imgca.BackgroundTransparency = 1
imgca.ImageTransparency = 0
imgca.Size = UDim2.new(1,0,1,0)
imgca.Image = "rbxassetid://3980946361"
imgca.ImageColor3 = Color3.new(1,1,1)

function colmo(Col1,Col2)
	local MAINRUINCOLOR = BrickColor.new("Medium blue")
	local MAINRUINCOLOR2 = BrickColor.new("Institutional white")
	imgca.ImageColor3 = Col2
	for i = 0 , 19 do
		sphereMK(7.5,math.random(15,50)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR2,0)
		slash(math.random(50,100)/10,5,true,"Round","Add","Out",Torso.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),VT(0.01,0.01,0.01),math.random(5,50)/250,MAINRUINCOLOR2)
	end
end
]]
function SingularityBeam()
	if GUN.Parent == nil then return end
	ATTACK = true
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		if mde ~= 18 then
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		elseif mde == 18 then
			GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(-180),math.rad(0)),1/2)
		end	
	end
	local HoleDist = (Hole.Position - Holetwo.Position).Magnitude
	local chargebeam = CreatePart(3,Effects,"Neon",0,0,Color3.new(0, 0, 0),"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
	MakeForm(chargebeam,"Cyl")
	chargebeam.CFrame = CFrame.new(Hole.Position,Holetwo.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	local chargeweld = weldBetween(GUN.Joint,chargebeam)
	local chargeball = CreatePart(3,Effects,"Neon",0,0,Color3.new(1, 1, 1),"Charge Ball",Vector3.new(.5,.5,.5),false)
	chargeball.Shape = "Ball"
	chargeball.CFrame = Holetwo.CFrame
	weldBetween(Holetwo,chargeball)
	CreateSound(342793847,Hole,10,1,false)
	local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
	bigball:Play()
	bigball.Completed:Wait()
	chargebeam:Destroy()
	local KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude
	coroutine.resume(coroutine.create(function()
		repeat if stopeverything then wait(math.huge) end KillDist = (Holetwo.Position - Mouse.Hit.p).Magnitude Swait() until attack == false
	end))
	local killbeam = CreatePart(3,Effects,"Neon",0,0,Color3.new(1, 1, 1),"Kill Beam",Vector3.new(2.5,KillDist,2.5))
	MakeForm(killbeam,"Cyl")
	killbeam.Touched:Connect(function(victim)
		if stopeverything then wait(math.huge) end
		mdmg(victim.Position,5)
	end)
	coroutine.resume(coroutine.create(function()
		while not stopeverything and ATTACK do
			mdmg(Mouse.Hit.p,5)
			Swait(6)
		end
	end))
	coroutine.resume(coroutine.create(function()
		local isdoingathing = false
		while not stopeverything and ATTACK do
			isdoingathing = not isdoingathing
			if Player.Name == Player.Name then
				RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,.1)
			end
			killbeam.Size = Vector3.new(2.5,KillDist,2.5)
			killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.p) * CFrame.new(0,0,-KillDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
			if isdoingathing then
				Lightning(Holetwo.Position,Mouse.Hit.p,15,3,Color3.new(0,0,1),10,0,1,0,true,55)
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = GUN.NeonParts.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = GUN.NeonParts.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = GUN.NeonParts.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			end
			Swait()
		end
	end))
	CreateSound(138677306,Holetwo,10,1,false)
	CreateSound(415700134,Holetwo,10,1,false)
	Swait(150)
	CreateSound(3264923,Holetwo,10,1,false)
	Swait(30)
	chargeball:Destroy()
	killbeam:Destroy()
	ATTACK = false
end


function attacktwo()
	if GUN.Parent == nil then return end
	ATTACK = true
	AttackGyro()
	local gBullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BullyFuck",Vector3.new())
	MakeForm(gBullet,"Ball")
	gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
	CreateSound(2785493,gBullet,2,0.8)
	for i = 0,1.25,0.025 do
		swait()
		Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(0.5,0.5,0.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).p,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
		gBullet.Size = gBullet.Size * 1.085
		gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-30)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine/12)),math.rad(0),math.rad(30)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5 + 0.1 * math.cos(sine/12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(sine/12)),math.rad(0 - 6 * math.cos(sine/12)),math.rad(-30 - 6 * math.cos(sine/12))) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local bullets = {}
	for i = 1,math.random(27,41) do
		swait()
		local Bullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BulletFuck",Vector3.new(0.6,0.6,0.6))
		MakeForm(Bullet,"Ball")
		Bullet.CFrame = gBullet.CFrame
		Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = 0.4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		table.insert(bullets,Bullet)
	end
	local oofing = false
	for b = 1,#bullets do
		swait()
		local part,pos = rayCast(LeftArm.CFrame*CFrame.new(0,-1.5,0).p,((Mouse.Hit.p+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - LeftArm.CFrame*CFrame.new(0,-1.5,0).p),500,Character)
		coroutine.resume(coroutine.create(function()
			FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
			Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(0.6,0.6,0.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
			swait(math.random(55,65))
			for i = 1,3 do
				Effect({Time = math.random(45,65),EffectType = "Sphere",Size = Vector3.new(0.6,6,0.6)*math.random(-1.05,1.25),Size2 = Vector3.new(1.6,10,1.6)*math.random(-1.05,1.25),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 20,SizeBoomerang = 35})
			end
			for i = 0,10 do
				swait()
				bullets[b].Transparency = bullets[b].Transparency + 0.1
			end
			oofing = not oofing
			if oofing then
				mdmg(bullets[b].Position,10)
			end
			local EEEBRUHEEE = CreateSound(168513088,bullets[b],3.5,1.1,false)
			bullets[b].Transparency = 1
			EEEBRUHEEE.Ended:Connect(function()
				if stopeverything then wait(math.huge) end
				bullets[b]:Destroy()
			end)
		end))
	end
	for i = 0,10 do
		swait()
		gBullet.Transparency = gBullet.Transparency + 0.1
	end
	gBullet:Destroy()
	ATTACK = false
end

--//=================================\\
--||	  		Flight
--\\=================================//



--//=================================\\
--||	 		 END FLIGHT
--\\=================================//

function hedshoot()
	if GUN.Parent == nil then return end
	ATTACK = true
	CreateSound(235097614,RootPart,6,1.5,false)
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = 6150717352,SoundPitch = 0.35,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(0,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	mdmg(RootPart.Position,14)
	for i = 1,4 do
		RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,-25)
		mdmg(RootPart.Position,14)
		Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,shade,math.random(30,45),0.5,1.5,0,true,60) Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Color3.new(0,0,1),math.random(30,45),0.5,1.5,0,true,60)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(0, 0, 0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,1,1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,0.5,0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),0.7/3)
		Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1/3)
		RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1/3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	ATTACK = false
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

SendMessage("[EXC V.1]: ","EXC V.1 loaded")

function MouseDown(Mouse)
	if ATTACK == false then
		attackone()
	end
end	

function MouseUp(Mouse)
	HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "e" and ATTACK == false then
		local Size,StudsAway = Vector3.new(2.5,9,2.5),-4
		for i = 1,50 do
			local Shard = IT_("Ring",workspace,{Material = Enum.Material.Glass,Reflectance = 3,CFrame = RootPart.CFrame*CFrame.new(math.random(-2,2)/4,-3-Size.Y/2,StudsAway+math.random(-2,2)/4)*CFrame.fromEulerAnglesXYZ(100,math.random(0,180),.4),Anchored = true,CanCollide = false,Size = Size})
			game:GetService("Debris"):AddItem(Shard,3)
			game:GetService("TweenService"):Create(Shard,TweenInfo.new(.3),{CFrame = Shard.CFrame*CFrame.new(0,Size.Y,0)}):Play()
			game:GetService("TweenService"):Create(Shard,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.In,0,false,2),{Transparency = 1}):Play()
			StudsAway = StudsAway-2
			Size = Vector3.new(2.5,9,2.5)*(1+i/10)
			wait()
		end
	end

	if Key == "k" and ATTACK == false and mde == 20 then
		LookUp = true
	end	
	if Key == "l" and ATTACK == false and mde == 20 then
		LookUp = false
	end
	if Key == "n" and ATTACK == false and mde == 1 then
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://611191130"
		SendMessage("[EXC V.1]: ","Secret song!")
	end
	if Key == "[" and ATTACK == false then
		print("yes")
	end	
	if Key == "r" and ATTACK == false and info == false then
		info = true
	elseif Key == "r" and ATTACK == false and info == true then
		info = false
	end
	if Key == "t" and ATTACK == false then
		refit()
	end
	if Key == "q" and ATTACK == false then
		RootPart.CFrame = CFrame.new(1,10,1)
	end

	if Key == "z" and ATTACK == false then
		hedshoot()
	end

	if Key == "v" and ATTACK == false then
		attacktwo()
	end

	if Key == "c" and ATTACK == false then
		attackone2()
	end

	if Key == "n" and mde == 27 then
		SkiddedSendMessage("[EXC V.1]: ","SKID.")
		wait(1.2)
		CreateSound(4138167041,Head,10,1,false)
	end

	if Key == "m" and ATTACK == false and mde == 0 then
		mde = 1
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1591072638"
		ModeName.Text = "Mode: Insane"
	elseif Key == "m" and ATTACK == false and mde == 1 then
		mde = 2
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://481104377"
		ModeName.Text = "Mode: Error"
	elseif Key == "m" and ATTACK == false and mde == 2 then
		mde = 3
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://2297862957"
		ModeName.Text = "Mode: Glitch"
	elseif Key == "m" and ATTACK == false and mde == 3 then
		mde = 4
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://4185475912"
		ModeName.Text = "Mode: Lord"
	elseif Key == "m" and ATTACK == false and mde == 4 then
		mde = 5
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://5170646860"
		ModeName.Text = "Mode: Lost"
	elseif Key == "m" and ATTACK == false and mde == 5 then
		mde = 6
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://4911242029"
		ModeName.Text = "Mode: Calm"
	elseif Key == "m" and ATTACK == false and mde == 6 then
		mde = 7
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://348832364"
		ModeName.Text = "Mode: SolidLC"
	elseif Key == "m" and ATTACK == false and mde == 7 then
		mde = 8
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://6556569538"
		ModeName.Text = "Mode: Cradles"
	elseif Key == "m" and ATTACK == false and mde == 8 then
		mde = 9
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://4557673096"
		ModeName.Text = "Mode: KarMa"
	elseif Key == "m" and ATTACK == false and mde == 9 then
		mde = 10
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://6294793094"
		ModeName.Text = "Mode: Reincarnation"
	elseif Key == "m" and ATTACK == false and mde == 10 then
		mde = 11
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://573736432"
		sick.PlaybackSpeed = .8
		ModeName.Text = "Mode: ECHO"
	elseif Key == "m" and ATTACK == false and mde == 11 then
		mde = 12
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://3049104895"
		sick.PlaybackSpeed = 1
		SendMessage("[EXC V.1]: ","Our Trauma.")
		ModeName.Text = "Mode: The Origins?"
	elseif Key == "m" and ATTACK == false and mde == 12 then
		mde = 13
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://723652641"
		SendMessage("[EXC V.1]: ","Darkness.")
		ModeName.Text = "Mode: Darkness"
	elseif Key == "m" and ATTACK == false and mde == 13 then
		mde = 14
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1180273873"
		ModeName.Text = "Mode: Over"
	elseif Key == "m" and ATTACK == false and mde == 14 then
		mde = 15
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://789657160"
		sick.Pitch = 1.18
		ModeName.Text = "Mode: Crystal"	
	elseif Key == "m" and ATTACK == false and mde == 15 then
		mde = 16
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://2920078671"
		sick.Pitch = 1
		ModeName.Text = "Mode: Fastboi"
	elseif Key == "m" and ATTACK == false and mde == 16 then
		mde = 17
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1338971957"
		sick.Pitch = 1
		ModeName.Text = "Mode: Chill."
	elseif Key == "m" and ATTACK == false and mde == 17 then
		mde = 18
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://3979209289"
		sick.Pitch = 1
		ModeName.Text = "Mode: Studio Dummy"
	elseif Key == "m" and ATTACK == false and mde == 18 then
		mde = 19
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://6049110238"
		sick.Pitch = 1
		ModeName.Text = "Mode: Immortality Lord"
	elseif Key == "m" and ATTACK == false and mde == 19 then
		mde = 20
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://3254997454"
		sick.Pitch = 1
		ModeName.Text = "Mode: TinyIL"
	elseif Key == "m" and ATTACK == false and mde == 20 then
		mde = 21
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://4527441029"
		sick.Pitch = 1
		ModeName.Text = "Mode: Toxenity"
	elseif Key == "m" and ATTACK == false and mde == 21 then
		mde = 22
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://3134116147"
		sick.Pitch = 1
		ModeName.Text = "Mode: Dream"
	elseif Key == "m" and ATTACK == false and mde == 22 then
		mde = 23
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://5618245296"
		sick.Pitch = 1
		ModeName.Text = "Mode: Sniper"
	elseif Key == "m" and ATTACK == false and mde == 23 then
		mde = 24
		Scythe.Parent = nil
		sick.TimePosition = 0 -- MODE --
		sick.SoundId = "rbxassetid://577543579"
		sick.Pitch = 1
		ModeName.Text = "Mode: ?"
	elseif Key == "m" and ATTACK == false and mde == 24 then
		mde = 25
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://170282324"
		sick.Pitch = 1
		SendMessage("[EXC V.1]: ","C Y B E R B I L I T Y . . . ")
		ModeName.Text = "Mode: Cyberbility"
	elseif Key == "m" and ATTACK == false and mde == 25 then
		mde = 26
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1466489435"
		sick.Pitch = 1
		ModeName.Text = "Mode: Visualizer"
	elseif Key == "m" and ATTACK == false and mde == 26 then
		mde = 27
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://844654533"
		sick.Pitch = 1
		sick.Volume = 1
		SkiddedSendMessage("[EXC V.1]: ","Too many SKIDSSSSS")
		ModeName.Text = "Mode: SKID."
	elseif Key == "m" and ATTACK == false and mde == 27 then
		mde = 28
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1986375341"
		sick.Pitch = 1
		sick.Volume = 10
		ModeName.Text = "Mode: AOS"
	elseif Key == "m" and ATTACK == false and mde == 28 then
		mde = 29
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://611191130"
		sick.Pitch = 1
		ModeName.Text = "Mode: Bad-Karma"
	elseif Key == "m" and ATTACK == false and mde == 29 then
		mde = 30
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1103329236"
		sick.Pitch = 1
		SkiddedSendMessage("[EXC V.1]: ","I am the end")
		ModeName.Text = "Mode: TrUe SlAyEr!!11!1"
	elseif Key == "m" and ATTACK == false and mde == 30 then
		mde = 31
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://2598224585"
		sick.Pitch = 1
		ModeName.Text = "Mode: MARENOL"
	elseif Key == "m" and ATTACK == false and mde == 31 then
		mde = 32 
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://2192509503"
		sick.Pitch = 1
		SendMessage("[EXC V.1]: ","Let the hunt begin")
		ModeName.Text = "Mode: Hunter"
	elseif Key == "m" and ATTACK == false and mde == 32 then
		mde = 33
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1074563286"
		sick.Pitch = 1
		SendMessage("[EXC V.1]: ","Abyss..")
		ModeName.Text = "Mode: Abyss Eye"
	elseif Key == "m" and ATTACK == false and mde == 33 then
		mde = 34
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://929330882"
		sick.Pitch = 1
		ModeName.Text = "Mode: Injustice"
	elseif Key == "m" and ATTACK == false and mde == 34 then
		mde = 35
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://6206729783"
		sick.Pitch = 1
		ModeName.Text = "Mode: Psycho"
	elseif Key == "m" and ATTACK == false and mde == 35 then
		mde = 36
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1931001768"
		sick.Pitch = 1
		ModeName.Text = "Mode: Fate"
	elseif Key == "m" and ATTACK == false and mde == 36 then
		mde = 37
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1012206928"
		sick.Pitch = 1
		ModeName.Text = "Mode: Mystery"
	elseif Key == "m" and ATTACK == false and mde == 37 then
		mde = 38
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://3192740317"
		sick.Pitch = 1
		ModeName.Text = "Mode: Death"
	elseif Key == "m" and ATTACK == false and mde == 38 then
		mde = 39
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1138145518"
		sick.Pitch = 1
		ModeName.Text = "Mode: CREAM"
	elseif Key == "m" and ATTACK == false and mde == 39 then
		mde = 40
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://1046135187"
		ModeName.Text = "Mode: Red"
	elseif Key == "m" and ATTACK == false and mde == 40 then
		mde = 41
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://259554386"
		SendMessage("[EXC V.1]: ","Hexagon.")
		ModeName.Text = "Mode: Hexagon"
	elseif Key == "m" and ATTACK == false and mde == 41 then
		mde = 42
		Scythe.Parent = nil
		sick.TimePosition = 0
		sick.SoundId = "rbxassetid://492361565"
		ModeName.Text = "Mode: Heavenly"
	elseif Key == "m" and ATTACK == false and mde == 42 then
		mde = 43
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://5704085503"
		ModeName.Text = "Mode: Indefiance"
	elseif Key == "m" and ATTACK == false and mde == 43 then
		mde = 44
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://1282491661"
		ModeName.Text = "Mode: Jingles"
	elseif Key == "m" and ATTACK == false and mde == 44 then
		mde = 45
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://5707455397"
		ModeName.Text = "Mode: Lost Soul"
	elseif Key == "m" and ATTACK == false and mde == 45 then
		mde = 46
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://5640628952"
		ModeName.Text = "Mode: Extravagent"
	elseif Key == "m" and ATTACK == false and mde == 46 then
		mde = 47
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 9.5
		sick.Volume = 10
		sick.SoundId = "rbxassetid://6969198609"
		ModeName.Text = "Mode: Eternal"
	elseif Key == "m" and ATTACK == false and mde == 47 then
		mde = 48
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://2904137450"
		ModeName.Text = "Mode: Glitcher"
	elseif Key == "m" and ATTACK == false and mde == 48 then
		mde = 49
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://3693522491"
		ModeName.Text = "Mode: Friend"
	elseif Key == "m" and ATTACK == false and mde == 49 then
		mde = 50
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://5817546077"
		ModeName.Text = "Mode: CPS"
	elseif Key == "m" and ATTACK == false and mde == 50 then
		mde = 51
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://301089564"
		ModeName.Text = "Mode: FBI"
	elseif Key == "m" and ATTACK == false and mde == 51 then
		mde = 52
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://1269076536"
		ModeName.Text = "Mode: Vibe"
	elseif Key == "m" and ATTACK == false and mde == 52 then
		mde = 53
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://4602123805"
		ModeName.Text = "Mode: Edge"
	elseif Key == "m" and ATTACK == false and mde == 53 then
		mde = 54
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://344884629"
		ModeName.Text = "Mode: Stronger"
	elseif Key == "m" and ATTACK == false and mde == 54 then
		mde = 55
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://6037311620"
		ModeName.Text = "Mode: MAYHEM"
	elseif Key == "m" and ATTACK == false and mde == 55 then
		mde = 56
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://3633767782"
		ModeName.Text = "Mode: Giorno"
	elseif Key == "n" and ATTACK == false then
		mde = 57
		Scythe.Parent = Character
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://7146075180"
		ModeName.Text = "Mode: Fallen"
	elseif Key == "b" and ATTACK == false then
		mde = 58
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://3289312660"
		ModeName.Text = "Mode: DOOM"
	elseif Key == "l" and ATTACK == false  then
		mde = 59
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://3458712840"
		ModeName.Text = "Mode: Linger"
	elseif Key == "m" and ATTACK == false and mde == 59 then
		mde = 0
		Scythe.Parent = nil
		sick.PlaybackSpeed = 1
		sick.Pitch = 1
		sick.TimePosition = 0
		sick.Volume = 10
		sick.SoundId = "rbxassetid://604910909"
		ModeName.Text = "Mode: None"
	end
end	

function KeyUp(Key)
	KEYHOLD = false
end

Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)

--//=================================\\
--\\=================================//

game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "Melon's (FE) Scripts";
	Text = "Loading, enjoy!/editer by dummy";
	Icon = "rbxthumb://type=Asset&id=7969699183&w=150&h=150"})
Duration = 16;
wait(0)

function unanchor()
	if UNANCHOR == true then
		g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

coroutine.wrap(function()
	while not stopeverything do
		swait()
		if doe < 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()

local CONNECT = nil

local isbruhhcircle = false

function CreateStar(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,ori)
	isbruhhcircle = not isbruhhcircle
	local isbruhcircle = isbruhhcircle
	local type = type
	local rng = Instance.new("Part")
	rng.Anchored = true
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if isbruhcircle then
		rng.Color = GUN.NeonParts.Color
		rng.Color = GUN.Mag.Color
	else
		rng.Color = shade
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh")
	rngm.MeshType = "Sphere"
	--rngm.MeshId = "rbxassetid://3054497727"
	rngm.Scale = Vector3.new(x1*20,y1*20,z1*20)
	rngm.Parent = rng
	rng.Parent = Effects
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		if ori == true then
			rng.Orientation = Vector3.new(0,0,0)
		end
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if isbruhcircle then
				rng.Color = GUN.NeonParts.Color
				rng.Color = GUN.Mag.Color
			else
				rng.Color = shade
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end
local antivoid = Instance.new("Part")
antivoid.Size = Vector3.new(400,10,400)
antivoid.Anchored = true
antivoid.Transparency = 1
antivoid.Parent = workspace
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if not alreadyfixing then
			antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
		end
	end
end))
if not script then
	antivoid:Destroy()
end

Player.Chatted:connect(function(message)
	if mde == 26 then
		if message:sub(1,5) == "play/" then
			sick.SoundId = "rbxassetid://"..message:sub(6)
		elseif message:sub(1,6) == "pitch/" then
			sick.PlaybackSpeed = message:sub(7)
		elseif message:sub(1,4) == "vol/" then
			sick.Volume = message:sub(5) 
		elseif message:sub(1,5) == "skip/" then
			sick.TimePosition = message:sub(6)
		end
	end
end)

local norot = Instance.new("Part",Character)
norot.Size = Vector3.new(0.05,0.05,0.05)
norot.Transparency = 1
norot.Anchored = true
norot.CanCollide = false

while true do
	norot.Position = RootPart.Position
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
		v:Stop();
	end
	if Player == Player then
		Torsovelocity = (RootPart.Velocity).Magnitude
	end
	local sensitivity = 25
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * Vector3.new(1,0,1)).Magnitude 
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	sine = sine + change
	Sine = Sine + change
	SINE = SINE + CHANGE
	if mde == 11 then
		GUN.NeonParts.Color = Color3.fromRGB(100*sick.PlaybackLoudness/500,0,0)
		GUN.Mag.Color = Color3.fromRGB(100*sick.PlaybackLoudness/500,0,0)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	elseif mde ~= 11 then
		GUN.NeonParts.Color = Color3.new(1, 1, 1)
		GUN.Mag.Color = Color3.fromRGB(1, 1, 1)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	if mde == 16 then
		GUN.NeonParts.Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255))
		GUN.Mag.Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255))
		hea.Color = GUN.NeonParts.Color
		RWing.Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255))
		LWing.Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255))
	end
	if mde == 13 then
		GUN.NeonParts.Color = Color3.fromRGB(0,math.clamp(sick.PlaybackLoudness/1.8,0,255),math.clamp(sick.PlaybackLoudness/1.8,0,255))
		GUN.Mag.Color = Color3.fromRGB(0,math.clamp(sick.PlaybackLoudness/1.8,0,255),math.clamp(sick.PlaybackLoudness/1.8,0,255))
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end

	if mde == 18 then
		GUNA.gun.Transparency = 0
		GUN.Base.Transparency = 1
		GUN.GunAdditions.Transparency = 1
		GUN.NeonParts.Transparency = 1
		GUN.Mag.Transparency = 1
		GUN.Trigger.Transparency = 1
		GUN.scope1.Transparency = 1
		GUN.scope.Transparency = 1
		GUN.Holding.Transparency = 1
		GUN.Hole.Transparency = 1
		GUN.Stock.Transparency = 1
		GUNA.gun.Color = BrickColor.new("Royal purple").Color
		RWing.Color = Color3.fromRGB(98, 37, 209)
		LWing.Color = Color3.fromRGB(98, 37, 209)
		hea.Color = BrickColor.new("Royal purple").Color
	elseif mde ~= 18 then
		GUNA.gun.Transparency = 1
		GUN.Base.Transparency = 0
		GUN.GunAdditions.Transparency = 0
		GUN.NeonParts.Transparency = 0
		GUN.Mag.Transparency = 0
		GUN.Trigger.Transparency = 0
		GUN.scope1.Transparency = 0
		GUN.scope.Transparency = 0
		GUN.Hole.Transparency = 0
		GUN.Stock.Transparency = 0
		GUN.Holding.Transparency = 0
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
		GUN.Mag.Color = GUN.NeonParts.Color
		hea.Color = GUN.NeonParts.Color
	end
	
	if mde == 43 then
		GUN.NeonParts.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		GUN.Mag.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		Torso.Color = Color3.fromRGB(0,0,0)
		Head.Color = Color3.fromRGB(0,0,0)
		LeftArm.Color = Color3.fromRGB(0,0,0)
		RightArm.Color = Color3.fromRGB(0,0,0)
		LeftLeg.Color = Color3.fromRGB(0,0,0)
		RightLeg.Color = Color3.fromRGB(0,0,0)
		LWing.Color = Color3.fromRGB(0,0,0)
		RWing.Color = Color3.fromRGB(0,0,0)
	elseif mde ~= 43 then
		Torso.Color = Color3.fromRGB(0,0,0)
		Head.Color = Color3.fromRGB(255, 255, 255)
		LeftArm.Color = Color3.fromRGB(255, 255, 255)
		RightArm.Color = Color3.fromRGB(255, 255, 255)
		LeftLeg.Color = Color3.fromRGB(255, 255, 255)
		RightLeg.Color = Color3.fromRGB(255, 255, 255)
	end
	
	if mde == 45 then
		WACKYEFFECT({Time = 25, EffectType = "Swirl", Size = VT(0.5,0.5,0.5), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end
	
	if mde == 46 then
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(2+sick.PlaybackLoudness/10,2,2+sick.PlaybackLoudness/10), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end
	
	if mde == 47 then
		WACKYEFFECT({Time = 25, EffectType = "Round Slash", Size = VT(0.01,0.01,0.01), Size2 = VT(0.1+sick.PlaybackLoudness/1000,0.1,0.1+sick.PlaybackLoudness/1000), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end
	if mde == 19 then
	WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+0*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end	
	if mde == 51 then
		GUN.NeonParts.Color = Color3.fromRGB(100*sick.PlaybackLoudness/500,0,0)
		GUN.Mag.Color = Color3.fromRGB(100*sick.PlaybackLoudness/500,0,0)
		LWing.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		hea.Color = GUN.NeonParts.Color
		RightArm.Color = GUN.NeonParts.Color
	end
	if mde == 52 then
		GUN.NeonParts.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		GUN.Mag.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LWing.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		hea.Color = GUN.NeonParts.Color
		RightArm.Color = GUN.NeonParts.Color
		LeftArm.Color = GUN.NeonParts.Color
		RightLeg.Color = GUN.NeonParts.Color
		LeftLeg.Color = GUN.NeonParts.Color
		WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	local MAINRUINCOLOR = BrickColor.new("Teal")
	local MAINRUINCOLOR2 = BrickColor.new("Institutional white")
	if mde == 48 then
		sphere2(8,"Add",RightLeg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),VT(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(8,"Add",RightLeg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),VT(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(8,"Add",LeftLeg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),VT(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(8,"Add",LeftLeg.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),VT(1,1,1),-0.01,0.05,-0.01,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		slash2(math.random(91,96)/10,5,true,"Round","Add","Out",RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),VT(0.000001,0.000001,0.000001),math.random(5,504)/250,BrickColor.new("White"))
		slash2(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+2*math.cos(sine/30),-0)*CFrame.Angles(math.rad(math.random(-0,0)),math.rad(math.random(-360,360)),math.rad(math.random(-0,0))),VT(0.05,0.001,0.05),0,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+2*math.cos(sine/30),6),VT(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+2*math.cos(sine/30),-6),VT(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR2)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
	end
	if mde == 49 then
		WACKYEFFECT({Time = 12, EffectType = "Ring", Size = VT(sick.PlaybackLoudness/100,sick.PlaybackLoudness/100,sick.PlaybackLoudness/100)/4, Size2 = VT(1,1,1)/4, Transparency = .5, Transparency2 = 1, CFrame = Torso.CFrame*CF(3,0.5,-1), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = Color3.fromRGB(sick.PlaybackLoudness/0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Ring", Size = VT(sick.PlaybackLoudness/100,sick.PlaybackLoudness/100,sick.PlaybackLoudness/100)/4, Size2 = VT(1,1,1)/4, Transparency = .5, Transparency2 = 1, CFrame = Torso.CFrame*CF(-3,0.5,-1), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = Color3.fromRGB(sick.PlaybackLoudness/0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	if mde == 53 then
		GUN.NeonParts.Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0)
		GUN.Mag.Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0)
		hea.Color = GUN.NeonParts.Color
		LeftLeg.Color = GUN.NeonParts.Color
		RightArm.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		RightLeg.Color = Color3.fromRGB(0,0,0)
		LeftArm.Color = Color3.fromRGB(0,0,0)
		WACKYEFFECT({Time = 70,EffectType = "Sphere", Size = VT(10,0.05,10), Size2 = VT(0,0.05,0), Transparency = 0, Transparency2 = 0, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	if mde == 48 then
		GUN.NeonParts.Color = Color3.fromRGB(0,math.clamp(sick.PlaybackLoudness/1.8,0,255),math.clamp(sick.PlaybackLoudness/1.8,0,255))
		GUN.Mag.Color = Color3.fromRGB(0,math.clamp(sick.PlaybackLoudness/1.8,0,255),math.clamp(sick.PlaybackLoudness/1.8,0,255))
		Torso.Color = Color3.fromRGB(0,0,0)
		Head.Color = Color3.fromRGB(0,0,0)
		LeftArm.Color = GUN.NeonParts.Color
		RightArm.Color = GUN.NeonParts.Color
		LeftLeg.Color = GUN.NeonParts.Color
		RightLeg.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		hea.Color = GUN.NeonParts.Color
	end
	if mde == 55 then
		local maincolor = BrickColor.new("Dark blue")
		GUN.NeonParts.Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255))
		GUN.Mag.Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255))
		LWing.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		hea.Color = GUN.NeonParts.Color
		sphereMK(7.5,math.random(15,50)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,maincolor,0)
		slash(math.random(50,100)/10,5,true,"Round","Add","Out",RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),VT(0.01,0.01,0.01),math.random(5,50)/250,maincolor)
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0,0,math.clamp(sick.PlaybackLoudness-191,0,255)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	if mde == 56 then
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/7,1), Size2 = VT(1,1,1), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(4,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/7,1), Size2 = VT(1,1,1), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,4), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/7,1), Size2 = VT(1,1,1), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(-4,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/30,1), Size2 = VT(0.3,0.3,0.3), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(-2,-3,2), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/30,1), Size2 = VT(0.3,0.3,0.3), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(2,-3,2), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/30,1), Size2 = VT(0.3,0.3,0.3), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(-1,-3,1), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,sick.PlaybackLoudness/30,1), Size2 = VT(0.3,0.3,0.3), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(1,-3,1), MoveToPos = nil, RotationX = 0, RotationY = 45, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(210,180,140), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		CamShakeAll(1,75)
		GUN.NeonParts.Color = Color3.fromRGB(210,180,140)
		GUN.Mag.Color = Color3.fromRGB(210,180,140)
		hea.Color = GUN.NeonParts.Color
		LeftArm.Color = GUN.NeonParts.Color
		RightArm.Color = GUN.NeonParts.Color
		LeftLeg.Color = GUN.NeonParts.Color
		RightLeg.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
	end
	if mde == 57 then
		GUN.NeonParts.Color =  C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		GUN.Mag.Color =  C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		LeftArm.Color = Color3.fromRGB(0,0,0)
		RightArm.Color = Color3.fromRGB(0,0,0)
		LeftLeg.Color = Color3.fromRGB(0,0,0)
		RightLeg.Color = Color3.fromRGB(0,0,0)
		LWing.Color = Color3.fromRGB(0,0,0)
		RWing.Color = Color3.fromRGB(0,0,0)
		Scythe.Scythe.NeonParts.Color = GUN.NeonParts.Color
		GUN.Base.Transparency = 1
		GUN.GunAdditions.Transparency = 1
		GUN.NeonParts.Transparency = 1
		GUN.Mag.Transparency = 1
		GUN.Trigger.Transparency = 1
		GUN.scope1.Transparency = 1
		GUN.scope.Transparency = 1
		GUN.Holding.Transparency = 1
		GUN.Hole.Transparency = 1
		GUN.Stock.Transparency = 1
	elseif mde ~= 57 then
		GUN.Base.Transparency = 0
		GUN.GunAdditions.Transparency = 0
		GUN.NeonParts.Transparency = 0
		GUN.Mag.Transparency = 0
		GUN.Trigger.Transparency = 0
		GUN.scope1.Transparency = 0
		GUN.scope.Transparency = 0
		GUN.Hole.Transparency = 0
		GUN.Stock.Transparency = 0
		GUN.Holding.Transparency = 0
	end
	if mde == 19 then
		Torso.Color = Color3.fromRGB(0,0,0)
		Head.Color = Color3.fromRGB(0,0,0)
		LeftArm.Color = Color3.fromRGB(0,0,0)
		RightArm.Color = Color3.fromRGB(0,0,0)
		LeftLeg.Color = Color3.fromRGB(0,0,0)
		RightLeg.Color = Color3.fromRGB(0,0,0)
		LWing.Color = Color3.fromRGB(0,0,0)
		RWing.Color = Color3.fromRGB(0,0,0)
	end
	if mde == 44 then
		CamShakeAll(sick.PlaybackLoudness/50,sick.PlaybackLoudness/50)
	end
	if mde == 59 then	
		Torso.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		Head.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		LeftArm.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		RightArm.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		LeftLeg.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		RightLeg.Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		LWing.Color =Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
		RWing.Color =Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0)
	end
	if mde == 37 then
		GUN.NeonParts.Color = Color3.fromRGB(0,0+89*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		GUN.Mag.Color = Color3.fromRGB(0,0+89*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	if mde == 38 then
		GUN.NeonParts.Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
		GUN.Mag.Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	if mde == 39 then
		GUN.NeonParts.Color = BrickColor.new("Maroon").Color
		GUN.Mag.Color = BrickColor.new("Maroon").Color
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	GUN.Base.Color = Color3.new()
	GUN.GunAdditions.Color = Color3.new()
	GUN.Base.Reflectance = -2
	GUN.GunAdditions.Reflectance = -2
	if mde == 12 then
		ocr=MRANDOM(0,255)
		orangecolorrandom=C3(ocr/255,ocr/355,0)
		bcr=MRANDOM(0,96)
		bluecolorrandom=C3(0,bcr/350,bcr/275)
		gC = MRANDOM(0,255)
		hitb.Parent = Character
		hitb.CFrame = RootPart.CFrame*CF(MRANDOM(-9,9),MRANDOM(-9,9),MRANDOM(-9,9))
		if MRANDOM(1,2)==1 then	
			GUN.NeonParts.Color = orangecolorrandom
			GUN.Mag.Color = orangecolorrandom
			RWing.Color = GUN.NeonParts.Color
			LWing.Color = GUN.NeonParts.Color
			hea.Color = GUN.NeonParts.Color
		elseif MRANDOM(1,2)==2 then	
			GUN.NeonParts.Color = bluecolorrandom
			GUN.Mag.Color = bluecolorrandom
			hea.Color = GUN.NeonParts.Color
			RWing.Color = GUN.NeonParts.Color
			LWing.Color = GUN.NeonParts.Color
		elseif mde ~= 12 then
			hitb.Parent = nil
			hitb.CFrame = RootPart.CFrame*CF(0,0,0)
			GUN.NeonParts.Color = Color3.new(1, 1, 1)
			GUN.Mag.Color = Color3.new(1 ,1, 1)
			hea.Color = GUN.NeonParts.Color
			RWing.Color = GUN.NeonParts.Color
			LWing.Color = GUN.NeonParts.Color
		end
	end
	if mde == 19 then
		if mde == 20 then
			Humanoid.HipHeight = 0
		elseif mde == 19 then
			Humanoid.HipHeight = 2*SIZEE
		end
		Blade.Parent = Character
		GUN.Parent = nil
	elseif mde ~= 19 then
		Humanoid.HipHeight = 0
		Blade.Parent = nil
		if mde == 20 then
			Blade.Parent = Character
			GUN.Parent = nil
		elseif mde ~= 19 or mde ~= 20 then
			Blade.Parent = nil
			GUN.Parent = Character
		end
	end
	if mde == 25 then
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECThid({Time = 0.9, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	if mde == 19 then
		CreateStar(6,math.random(5,15)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.045,0.045,0.045,0,BrickColor.new("Really black"),0)
		CreateStar(6,math.random(5,15)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.045,0.045,0.045,0,BrickColor.new("Really black"),0)
	end
	if mde == 29 then
		CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.cos(sine/16)*5,math.cos(sine/32)*5,math.sin(sine/16)*5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
		CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.cos(sine/16)*5,math.cos(sine/32)*5,math.sin(sine/16)*5)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
		CreateStar(6,math.random(5,15)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.045,0.045,0.045,0,BrickColor.new("Institutional white"),0)
		CreateStar(6,math.random(5,15)/45,"Add",RootPart.CFrame*CFrame.new(math.random(-10,10),-5,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.045,0.045,0.045,0,BrickColor.new("Institutional white"),0)
		CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.cos(sine/16)*-5,math.cos(sine/32)*-5,math.sin(sine/16)*-5)*CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
		CreateStar(5,1/45,"Add",RootPart.CFrame*CFrame.new(math.cos(sine/16)*-5,math.cos(sine/32)*-5,math.sin(sine/16)*-5)*CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),0.08,0.08,0.08,0,BrickColor.new("Institutional white"),0)
	end
	if mde ~= 29 then
		ShadedFolder.Parent = nil
	elseif mde == 29 then
		ShadedFolder.Parent = Character
	end
	if mde == 24 then
		GUN.NeonParts.Color = Color3.fromRGB(math.random(0,255),255,255)
		GUN.Mag.Color = Color3.fromRGB(math.random(0,255),255,255)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	if mde == 25 then
		GUN.NeonParts.Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
		GUN.Mag.Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	if mde == 40 then
		GUN.NeonParts.Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
		GUN.Mag.Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
	end
	if mde == 26 then
		GUN.Base.Transparency = 1
		GUN.GunAdditions.Transparency = 1
		GUN.NeonParts.Transparency = 1
		GUN.Mag.Transparency = 1
		GUN.Trigger.Transparency = 1
		GUN.scope1.Transparency = 1
		GUN.scope.Transparency = 1
		GUN.Hole.Transparency = 1
		GUN.Stock.Transparency = 1
		GUN.Holding.Transparency = 1
		WACKYEFFECT({TIME = math.random(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * cos(sine/4),3 + 2 * cos(sine/4),3 + 2 * cos(sine/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(math.random(-20,20),2,math.random(-20,20))), MoveToPos = Torso.Position+VT(0,math.random(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(hue/360,1,math.min(sick.PlaybackLoudness/7.5,1)), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		GUN.NeonParts.Color = Color3.fromHSV(hue/360,1,math.min(sick.PlaybackLoudness/7.5,1))
		GUN.Mag.Color = Color3.fromHSV(hue/360,1,math.min(sick.PlaybackLoudness/7.5,1))
		hea.Color = GUN.NeonParts.Color
		RWing.Color = GUN.NeonParts.Color
		LWing.Color = GUN.NeonParts.Color
		if(hue > 360)then hue = 0 end
		hue=hue+1
	end
	if mde == 32 then
		WACKYEFFECT({Time = 25, EffectType = "Swirl", Size = VT(0,0,0), Size2 = VT(15+sick.PlaybackLoudness/35,10,15+sick.PlaybackLoudness/35), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(0),RAD(180*COS(SINE/7)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	RWingWld.C0 = Clerp(RWingWld.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(sine/25)),0),.25)
	LWingWld.C0 = Clerp(LWingWld.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(sine/25)),0),.25)
	if TORSOVELOCITY < 1 then
		ANIM = "Idle"
		if ATTACK == false then
			if mde == 0 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 1 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(sine/100)),math.rad(0)),1)
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)	
			elseif mde == 2 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/15)) * CFrame.Angles(math.rad(0),math.rad(-10*math.cos(sine/30)),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(0),math.rad(-15*math.cos(sine/30)),math.rad(0)),1/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135+-15*math.cos(sine/30)),math.rad(0),math.rad(25+15*math.cos(sine/30))) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(5),math.rad(5),math.rad(-10+15*math.cos(sine/30))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(10+10*math.sin(sine/15))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-10-10*math.sin(sine/15))),1/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 3 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(135+5*math.sin(sine/9)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+10*math.cos(sine/9))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 4 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC02*CFrame.new(0,math.cos(sine/25),-math.sin(sine/25)+2)*CFrame.Angles(math.rad(5*math.sin(sine/25)),0,0),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(math.rad(5*math.cos(sine/25)),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(sine/25)))* RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-15+5*math.sin(sine/25)))* LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.1*math.sin(sine/25),-.01)*CFrame.Angles(0,math.rad(80),0),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.5-.25*math.sin(sine/25),-.51)*CFrame.Angles(math.rad(-10),math.rad(-80),0),.25)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 5 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0*CFrame.new(0,0,.05*math.cos(SINE/12))*CFrame.Angles(math.rad(15),0,0),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(-15-3*math.cos(SINE/12)),math.rad(5-5*math.sin(SINE/12)),0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(SINE/12),0)*CFrame.Angles(math.rad(-53.75+1.75*math.cos(SINE/12)),0,math.rad(5))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.1*math.sin(SINE/12),0)*CFrame.Angles(math.rad(15),0,math.rad(-5+5*math.cos(SINE/12)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.05*math.cos(SINE/12),-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(0)),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1-.05*math.cos(SINE/12),-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(0)),.25)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)	
			elseif mde == 6 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3+0.5*math.cos(sine / 41)) * CFrame.Angles(math.rad(0+1*math.cos(sine / 41)), math.rad(0+1*math.cos(sine / 27)), math.rad(0+1*math.cos(sine / 32))),0.35)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(20+5*math.cos(sine / 40)), math.rad(0+1*math.cos(sine / 12)), math.rad(0)),0.35)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-0.6, 0.5, -0.3) * CFrame.Angles(math.rad(60+1*math.cos(sine / 22)), math.rad(0+1*math.cos(sine / 25)), math.rad(70+1*math.cos(sine / 30))) * LEFTSHOULDERC0,0.35)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, -1) * CFrame.Angles(math.rad(90), math.rad(-20), math.rad(-70)) * CFrame.Angles(math.rad(0+1*math.cos(sine / 23)), math.rad(90+1*math.cos(sine / 34)), math.rad(0+1*math.cos(sine / 31))),0.35)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0)) * CFrame.Angles(math.rad(0+1*math.cos(sine / 26)), math.rad(-90+1*math.cos(sine / 20)), math.rad(0+1*math.cos(sine / 30))),0.35)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(-.02,-10,0) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),1)
			elseif mde == 7 then
				if NeckSnap then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(sine/100)),0),1)
					NeckSnap = false
				else
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(sine/100)),0),.25)
				end
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120),math.rad(0),math.rad(0)),1/2)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50))*CFrame.Angles(math.rad(-25+5*math.sin(sine/50)),0,0),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30+5*math.sin(sine/50)),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(13 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
			elseif mde == 8 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 9 then
				local headsnap = math.random(1,60);
				local headsnapping=false;
				if headsnap == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 3 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(20), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-10-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 10 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),.7/3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(25), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, 0) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 11 then
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/25,0.05,1*sick.PlaybackLoudness/25), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(100*sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 5)
				if math.random(1,5) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(sine/25)))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(sine / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(sine / 12)), RAD(-12 - 7.5 * SIN(sine / 12))) * LEFTSHOULDERC0, 0.15 / 5)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(sine / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
			elseif mde == 12 then
				Effect({Time = MRANDOM(80,100),EffectType = "Box",Size = VT(2.75,2.75,2.75), Size2 = VT(0,0,0),Transparency = 0, Transparency2 = 1,CFrame = hitb.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))),MoveToPos = nil,RotationX = MRANDOM(-100/100,100/100), RotationY = MRANDOM(-100/100,100/100), RotationZ = MRANDOM(-100/100,100/100),Material = "Neon",Color = C3(),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-30.5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 45) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(-10 + MRANDOM(-4,4))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145 + MRANDOM(-20,20)), RAD(0 + MRANDOM(-20,20)), RAD(0 + MRANDOM(-20,20))) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(165 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(25 + MRANDOM(-4,4))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.05*math.cos(SINE/12),-.01)*CFrame.Angles(math.rad(-30.2),math.rad(80),math.rad(0)),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1-.05*math.cos(SINE/12),-.01)*CFrame.Angles(math.rad(-31.9),math.rad(-80),math.rad(0)),.25)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 13 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0 - 10 * COS(SINE / 12)), RAD(0 + 15 * COS(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -1 + 0.02 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0 - 5 * COS(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(25 + 8.5 * COS(SINE / 12))), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4+ 0.01 * COS(SINE / 12), -1) * ANGLES(RAD(0), RAD(90), RAD(0 - 5 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.5+ 0.01 * COS(SINE / 12), -0.5) * ANGLES(RAD(-90 + 5 * COS(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif mde == 14 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-30)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(30)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145 + 5.5 * COS(SINE / 12)), RAD(0 - 20 * COS(SINE / 12)), RAD(0 - 2 * COS(SINE / 12))) * ANGLES(RAD(0 + 20 * COS(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0 + 3 * COS(SINE / 12)), RAD(0)), 1 / 5)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 15 then
				Effect({Time = 10,EffectType = "Ring",Size = VT(0,0,0), Size2 = VT(0.1,0.3,0.1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CF(0,-1,0)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = BrickColor.new("Pastel Blue").Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50))* CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(35)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(10),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(10)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 16 then
				GUN.Base.Transparency = 1
				GUN.GunAdditions.Transparency = 1
				GUN.NeonParts.Transparency = 1
				GUN.Mag.Transparency = 1
				GUN.Trigger.Transparency = 1
				GUN.scope1.Transparency = 1
				GUN.Hole.Transparency = 1
				GUN.Stock.Transparency = 1
				GUN.scope.Transparency = 1
				GUN.Holding.Transparency = 1
				if not Character:FindFirstChild("WalkingWheel") and ANIM == "Idle" and ATTACK == false then
					local ww = Instance.new("Model")
					ww.Name = "WalkingWheel"
					for i = 1,36 do
						local wwpart = Instance.new("Part")
						wwpart.Size = Vector3.new(2,.2,.56)
						wwpart.CFrame = RootPart.CFrame * CFrame.new(0,.01,0) * CFrame.Angles(math.rad(85+(10*i)),0,0) * CFrame.new(0,3.1,0)
						weldBetween(RootPart,wwpart)
						wwpart.Material = "Neon"
						if i <= 18 then
							wwpart.CanCollide = false
						end
						wwpart.Color = Color3.new()
						wwpart.Parent = ww
					end
					ww.Parent = Character
					coroutine.resume(coroutine.create(function()
						repeat if stopeverything then wait(math.huge) end 
							for i,v in pairs(ww:GetChildren()) do 
								v.Color = GUN.NeonParts.Color 
							end 
							swait() 
						until ATTACK or ANIM ~= "Idle" or mde ~= 16
						alreadyfixing = true
						ww:Destroy()
						alreadyfixing = false
					end))
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,-.2) * CFrame.Angles(math.rad(-sine*6),math.rad(0),math.rad(0)),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0,.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(75*math.sin(sine/5)),math.rad(90),math.rad(0)),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-75*math.sin(sine/5)),math.rad(-90),math.rad(0)),.25)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 17 then
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				GUN.Mag.Transparency = 0
				GUN.Trigger.Transparency = 0
				GUN.scope1.Transparency = 0
				GUN.scope.Transparency = 0
				GUN.Stock.Transparency = 0
				GUN.Hole.Transparency = 0
				GUN.Holding.Transparency = 0
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1,.75,.1) * CFrame.Angles(math.rad(-165),math.rad(0),math.rad(40)) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-12.5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(12.5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 18 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(20)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-45 + 10.5 * COS(SINE / 12)), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-10 + 8 * COS(SINE / 12)), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 19 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,-.5*math.sin(sine/25))*CFrame.Angles(math.rad(20),0,0),.25)
				if NeckSnap then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(sine/50)),0),1)
					NeckSnap = false
				else
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(sine/50)),0),.25)
				end
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(sine/50))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-10),0,0)*RIGHTSHOULDERC0,.25)
				SwordJoint.C0 = Clerp(SwordJoint.C0,CFrame.new(0,-1,0)*CFrame.Angles(math.rad(154.35-5.65*math.sin(sine/25)),0,0),.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.cos(sine/25)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.cos(sine/25))),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.cos(sine/25))),.25)
			elseif mde == 20 then
				if LookUp == false then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0,0)*CFrame.Angles(math.rad(0+1*math.cos(sine/25)),0,0),.25)
				elseif LookUp == true then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0,0)*CFrame.Angles(math.rad(-30+1*math.cos(sine/25)),0,0),.25)
				end
				SwordJoint.C0 = Clerp(SwordJoint.C0,CFrame.new(0,-0,-.5)*CFrame.Angles(0,math.rad(170),math.rad(-10)),.25)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0, 0, -0.051 + 0.022 * math.cos(sine / 34))*CFrame.Angles(0,0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(80+5*math.cos(sine/34)),0,math.rad(45))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(5 * math.cos(sine / 24)),0,math.rad(-10 - 5.5 * math.cos(sine / 34)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1- 0.05 * math.cos(sine / 34),0)*CFrame.Angles(math.rad(0),math.rad(80),math.rad(0)),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1 - 0.05 * math.cos(sine / 34),0)*CFrame.Angles(math.rad(0),math.rad(-80),math.rad(0)),.25)
			elseif mde == 21 then
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(10,0.05,10), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,75,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-30)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(30)), 0.15 / Animation_Speed)
				if math.random(1,25) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.75, 0) * ANGLES(RAD(170 - 15 * SIN(SINE / 6)), RAD(0), RAD(12 - 15 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(100.5), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 22 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-69.5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-1), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(100), RAD(-15)) * ANGLES(RAD(0), RAD(-15), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)	
			elseif mde == 23 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(-70)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(10), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 1 * COS(SINE / 12))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(50), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 24 then
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = Vector3.new(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = Vector3.new(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(sick.PlaybackLoudness/666),math.rad(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = Vector3.new(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = Vector3.new(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(sick.PlaybackLoudness/666),math.rad(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = Vector3.new(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = Vector3.new(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(sick.PlaybackLoudness/666),math.rad(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/20)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/20))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 25 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-30 - 10 * SIN(SINE / 12))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 10 * SIN(SINE / 12)), RAD(30 - 10 * SIN(SINE / 12))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-83.5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(40)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 26 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1-sick.PlaybackLoudness/10), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 27 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55))), 1.5 / 3)	
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 - 3 * COS(SINE / 2)) * ANGLES(RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(165 + MRANDOM(-55,55)), RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55)))* RIGHTSHOULDERC0, 3 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.5) * ANGLES(RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55))) * LEFTSHOULDERC0, 3 / Animation_Speed)				
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-55,55)), RAD(90 + MRANDOM(-55,55)), RAD(MRANDOM(-55,55))) * ANGLES(RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55))), 3 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-55,55)), RAD(-90 + MRANDOM(-55,55)), RAD(MRANDOM(-55,55))) * ANGLES(RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55)), RAD(MRANDOM(-55,55))), 3 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90+MRANDOM(-55,55)),math.rad(MRANDOM(-55,55)),math.rad(MRANDOM(-55,55))),1)
			elseif mde == 28 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(15)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(-30)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(175 + 5 * COS(SINE / 12)), RAD(0), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, 0.5) * ANGLES(RAD(0), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(15)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
			elseif mde == 29 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 - 0.5 * COS(SINE / 15)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15+MRANDOM(-2,2)), RAD(MRANDOM(-2,2)), RAD(MRANDOM(-2,2))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(165 + 15 * COS(SINE / 15)), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				snap = math.random(1,60)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))), 3 / Animation_Speed)
				end
				snap2 = math.random(1,60)
				if snap2 == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * RIGHTSHOULDERC0, 3 / Animation_Speed)
				end
				snap3 = math.random(1, 60)
				if snap3 == 1 then
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * LEFTSHOULDERC0, 3 / Animation_Speed)
				end
				snap4 = math.random(1, 60)
				if snap4 == 1 then
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 70 * SIN(SINE / 6))), 1 / Animation_Speed)
				end
				snap4 = math.random(1, 60)
				if snap4 == 1 then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(90+MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))), 3 / Animation_Speed)
				end
				snap5 = math.random(1, 60)
				if snap5 == 1 then
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(90+MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))), 3 / Animation_Speed)
				end
				snap6 = math.random(1, 60)
				if snap6 == 1 then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))), 3 / Animation_Speed)
				end
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.2 * COS(SINE / 15), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 20 * COS(SINE / 15))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-60), RAD(30)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 30 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90))* RIGHTSHOULDERC0, 0.100000000000000 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.100000000000000 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),1)
			elseif mde == 31 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.8 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(10 + 5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.7, 0) * ANGLES(RAD(180), RAD(0), RAD(-30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.7, 0) * ANGLES(RAD(180), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.2 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(10 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(10 + 5 * SIN(SINE / 12)), RAD(-90), RAD(50)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 32 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 - 1.5 * COS(SINE / 28)) * ANGLES(RAD(0), RAD(20*COS(SINE/28)), RAD(-75)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(70)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40*COS(SINE/32)), RAD(0), RAD(1*COS(SINE/15))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(25 * COS(SINE / 35)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-55 * COS(SINE/32)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90-10*SIN(SINE/15)),math.rad(0),math.rad(0)),1)
			elseif mde == 33 then
				Humanoid.HipHeight = 1.5
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(-00.1*COS(SINE/12), 0, 00.1*COS(SINE/15)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(165), RAD(0), RAD(20))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.4, -0.7) * ANGLES(RAD(86), RAD(9), RAD(75)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.6 - 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(5*COS(SINE/15)), RAD(70), RAD(0)) * ANGLES(RAD(-0.5*COS(SINE/15)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(-5*COS(SINE/15)), RAD(-70), RAD(0)) * ANGLES(RAD(-0.5*COS(SINE/15)), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 34 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(175+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-3.5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-3.5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 35 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(10-15*COS(SINE/20)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(175+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(10-15*COS(SINE/20)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1+0.1*COS(SINE/20) - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(10-15*COS(SINE/20)), RAD(90), RAD(0)) * ANGLES(RAD(-3.5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1+0.1*COS(SINE/20) - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(10-15*COS(SINE/20)), RAD(-90), RAD(0)) * ANGLES(RAD(-3.5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 36 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-20,20) - 4 * COS(SINE / 12)), RAD(MRANDOM(-20,20)), RAD(MRANDOM(-20,20))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(175+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5 - 0.1 * COS(SINE / 12), -0.9) * ANGLES(RAD(0), RAD(10), RAD(90)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 37 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-55)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(55)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(175+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.9) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 38 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15) + MRANDOM(-20,20)), RAD(0 + MRANDOM(-20,20)), RAD(-10 + MRANDOM(-20,20))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(165), RAD(0), RAD(20))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(165 + MRANDOM(-20,20)), RAD(0 + MRANDOM(-20,20)), RAD(22 + MRANDOM(-20,20))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 39 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(16)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, 0.5) * ANGLES(RAD(-15), RAD(12), RAD(43)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 40 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(20), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 41 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(00.5*SIN(SINE/24), 0, 0 + 0.05 * COS(SINE / 24)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(20)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(165), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, 0.5) * ANGLES(RAD(0), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 + 0.05*SIN(SINE/24), -1 - 0.05 * COS(SINE / 24), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 + 0.05*SIN(SINE/24), -1 - 0.05 * COS(SINE / 24), 0) * ANGLES(RAD(0), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 42 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 24)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(10), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(190), RAD(30), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.3, 0.5, -0.3) * ANGLES(RAD(25), RAD(-30), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.1 - 0.05 * COS(SINE / 24), 0) * ANGLES(RAD(25), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.1 - 0.05 * COS(SINE / 24), 0) * ANGLES(RAD(25), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 43 then	
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(math.random(1,15)/8+30), RAD(math.random(1,50)/8 + 5.5 * COS(SINE / 34)), RAD(0 + 5.5 * COS(SINE / 34))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40-8 * COS(SINE / 24)), RAD(0), RAD(10 + 5.5 * COS(SINE / 34))) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 5- 1 * COS(SINE / 21)) * ANGLES(RAD(40-5 * COS(SINE / 24)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40-8 * COS(SINE / 24)), RAD(0), RAD(-10 - 5.5 * COS(SINE / 34))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 34), -0.01) * ANGLES(RAD(40-5 * COS(SINE / 24)), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 34), -0.01) * ANGLES(RAD(40-5 * COS(SINE / 24)), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 44 then
				SIZE = 1
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1*SIZE) - 1)) * ANGLES(RAD(20 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(180 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(-25 + MRANDOM(-24,24))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(180 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(25 + MRANDOM(-24,24))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(85 + MRANDOM(-24,24)), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-85 + MRANDOM(-24,24)), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)		
			elseif mde == 45 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, sick.PlaybackLoudness / 600 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, sick.PlaybackLoudness / 600 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(-10 - 2.5 * SIN(SINE / 10)), RAD(20 * COS(SINE / 10))), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 46 then
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end		
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, sick.PlaybackLoudness/400 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
				snap = math.random(1,72)
			elseif mde == 47 then
				snap = math.random(1,6)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-1000,1000)),math.rad(math.random(-1000,100)),math.rad(math.random(-1000,1000))),1/Animation_Speed)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(-25), RAD(25 + 8 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(25), RAD(-25 - 8 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.65 - 0.2 * COS(SINE / 12), -0.35) * ANGLES(RAD(-25 + 6 * COS(SINE / 12)), RAD(80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(-5 + 2 * COS(SINE / 12)), RAD(-80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 48 then
				RootCF=euler(-1.57,0,3.14)
				necko=CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
				RightHip.C0=Clerp(RightHip.C0,CF(1,-1,0)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
				LeftHip.C0=Clerp(LeftHip.C0,CF(-1,-0.5,-0.5)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
				RootJoint.C0=Clerp(RootJoint.C0,RootCF*CF(0,0,2-1 * math.cos(sine / 30))*ANGLES(math.rad(0),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=Clerp(Torso.Neck.C0,necko*ANGLES(math.rad(0+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
				RightShoulder.C0=Clerp(RightShoulder.C0,CF(1.2,0.5,0)*ANGLES(math.rad(10- 10 * math.cos(sine / 30)),math.rad(50- 20 * math.cos(sine / 30)),math.rad(50+ 10 * math.cos(sine / 30))),.1)
				LeftShoulder.C0=Clerp(LeftShoulder.C0,CF(-1.5,0.5,0)*ANGLES(math.rad(10- 10 * math.cos(sine / 30)),math.rad(20),math.rad(-50- 10 * math.cos(sine / 30))),.1)
			elseif mde == 49 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(SINE / 15) + 0.05 * SIN(SINE / 15), 0, 0 + 0.05 * COS(SINE / 20)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4, 0.35, 0.4) * ANGLES(RAD(135), RAD(0), RAD(3)) * ANGLES(RAD(0 - 1.5 * COS(SINE / 15) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.35, 0.4) * ANGLES(RAD(15), RAD(0), RAD(12)) * ANGLES(RAD(0 - 1.5 * COS(SINE / 15) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 - 0.05 * COS(SINE / 15) + 0.05 * SIN(SINE / 15), -1 - 0.05 * COS(SINE / 20), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 50 then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 1.5 + 0.5 * COS(Sine / 32)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.4 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(7 + 6.5 * SIN(Sine / 24)), RAD(10*SIN(Sine/24)), RAD(6*SIN(Sine/24))), 0.5 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(120 + 6.5 * SIN(Sine / 34)), RAD(5*SIN(Sine/34)), RAD(10 * SIN(Sine / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(1), RAD(0), RAD(22)) * LEFTSHOULDERC0, 0.4 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CF(1,-0.4,-0.5)*ANGLES(RAD(0 + 6.5 * SIN(Sine/12)),RAD(90),RAD(40*SIN(Sine/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(Sine / 36)),RAD(-10 - 2 * COS(Sine / 39))),0.2)
				LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1,0)*ANGLES(RAD(10 + 4.6 * SIN(Sine/12)),RAD(-90),RAD(20*SIN(Sine/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(Sine / 36)),RAD(10 + 6 * COS(Sine / 31))),0.2)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 51 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 - 0.1 * COS(SINE / 3) + ((1) - 1)) * ANGLES(RAD(30 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 24)), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, 0.5) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 52 then
				bouncyboi = sick.PlaybackLoudness / 1200
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 2 + 0.5 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(-60 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 1 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 - 2.5 * SIN(SINE / 99)), RAD(-45 + 7.5 * SIN(SINE / 99))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 + 2.5 * SIN(SINE / 99)), RAD(45 - 7.5 * SIN(SINE / 99))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif mde == 53 then
					local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
					WACKYEFFECT({Time = 50, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = .5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+5*math.sin(sine/12),0+2*math.sin(sine/32),0+5*math.cos(sine/12)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 50, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = .5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+7*math.sin(sine/5),0+2*math.sin(sine/12),0+7*math.cos(sine/5)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = 50, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = .5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+9*math.sin(sine/55),0+2*math.sin(sine/75),0+9*math.cos(sine/55)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1 + 0.1 * COS(SINE / 20)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 4.5 * SIN(sine / 20)), RAD(15 - 4.5 * SIN(sine / 20)), RAD(5 - 20 * SIN(sine / 20))), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(.75, 0.5 + 0.1 * SIN(sine / 20)*1, -0.6*1) * ANGLES(RAD(0), RAD(0), RAD(-85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.3136189, 0.462844551+.1*M.C(sine/32), 0) * ANGLES(RAD(-200), RAD(0+20*SIN(sine/1)), RAD(30+15*SIN(sine/.9))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.9 - 0.1 * COS(sine / 20)*1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-6.5), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.9 - 0.1 * COS(sine / 20)*1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-6.5), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif mde == 54 then
				sphereMK(2,math.random(20,30)/35,"Add",RootPart.CFrame*CFrame.new(math.random(-11,11),-10,math.random(-8,8))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.40,0.40,5.35,0,BrickColor.new("Institutional white"),0)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.075 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(0), RAD(-10)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-30 - 2.5 * COS(SINE / 12)), RAD(0), RAD(40)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-10 + 2.5 * COS(SINE / 12)), RAD(10 - 3 * COS(SINE / 12)), RAD(0 - 2.5 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.15 - 0.1 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * COS(SINE / 12)), RAD(5), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.075 * COS(SINE / 12), 0.1) * ANGLES(RAD(-15), RAD(80), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.075 * COS(SINE / 12), 0.1) * ANGLES(RAD(-10), RAD(-70), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 55 then
				local snap = math.random(1,10)
					if snap == 1 then
						Neck.C0 = Clerp(Neck.C0,NECKC0*ANGLES(RAD(23 + math.random(-5,5)),RAD(math.random(-5,5)),RAD(22 + math.random(-5,5))),1)
					end
					RightHip.C0 = Clerp(RightHip.C0,CF(1,-1 - 0.1 * COS(sine / 32),0 - 0.1 * COS(sine / 32))*ANGLES(RAD(0),RAD(90),RAD(0))*ANGLES(RAD(-3),RAD(-5.5 - 2 * COS(sine / 56)),RAD(-12 - 2 * COS(sine / 32))),.1)
					LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1 - 0.1 * COS(sine / 32),0 - 0.1 * COS(sine / 32))*ANGLES(RAD(0),RAD(-90),RAD(0))*ANGLES(RAD(-6),RAD(22 - 2 * COS(sine / 56)),RAD(-1 + 2 * COS(sine / 32))),.1)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CF(0,0,0 + 0.1 * COS(sine / 32))*ANGLES(RAD(1 - 2 * COS(sine / 32)),RAD(0),RAD(-22 + 2 * COS(sine / 56))),.1)
					Neck.C0 = Clerp(Neck.C0,NECKC0*ANGLES(RAD(23 - 2 * COS(sine / 37)),RAD(0 + 5 * COS(sine / 43) - 5 * COS(sine / 0.25)),RAD(22 - 2 * COS(sine / 56))),.1)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5 + 0.025 * COS(sine / 45),0)*ANGLES(RAD(5 + 3 * COS(sine / 43)),RAD(-16 - 5 * COS(sine / 52)),RAD(13 + 9 * COS(sine / 45))),.1)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CF(-1.35,1 + 0.025 * COS(sine / 45),-0.2)*ANGLES(RAD(148 - 2 * COS(sine / 51)),RAD(0 - 4 * COS(sine / 64)),RAD(22 - 2 * COS(sine / 45))),.1)
					GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 56 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(34)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - sick.PlaybackLoudness/50), RAD(0), RAD(-20)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.3, 0) * ANGLES(RAD(30 + sick.PlaybackLoudness/50), RAD(0), RAD(20))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.3, 0.5) * ANGLES(RAD(0), RAD(0), RAD(20)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + sick.PlaybackLoudness/550, -0.01) * ANGLES(RAD(10), RAD(40), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif mde == 57 then
				Neck.C0=CFrame.new(0,1,0)*CFrame.Angles(math.rad(90 + 5 * math.cos(SINE/60)),math.rad(180),math.rad(0 + 5 * math.cos(SINE/60)))
				RootJoint.C0=CFrame.new(0 + 3 * math.cos(SINE/50),0 + 1 * math.cos(SINE/80),0 + 1 * math.cos(SINE/70))*CFrame.Angles(math.rad(90),math.rad(180),math.rad(0))
				RightShoulder.C0=CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(5 + 5 * math.cos(SINE/40)))
				LeftShoulder.C0=CFrame.new(-1,0,0.4)*CFrame.Angles(math.rad(-30.7 + 5 * math.cos(SINE/60)),math.rad(9.1 + 5 * math.cos(SINE/50)),math.rad(32.1 + 5 * math.cos(SINE/40)))
				RightHip.C0 = CFrame.new(0.5,-0.7,0.3)*CFrame.Angles(math.rad(-10 + 10 * math.cos(SINE/45)),math.rad(0),math.rad(1 + 1 * math.cos(SINE/50)))
				LeftHip.C0=CFrame.new(-0.5,-1,0.3)*CFrame.Angles(math.rad(0 + 5 * math.cos(SINE/50)),math.rad(0),math.rad(1 - 1 * math.cos(SINE/50)))
			elseif mde == 58 then
				WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				CamShakeAll(sick.PlaybackLoudness/45,sick.PlaybackLoudness/45)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(-0.5*COS(SINE / 40),0,3-2*COS(SINE / 40))*ANGLES(RAD(-70 + 20 *COS(SINE / 40)),RAD(0),RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 25*COS(SINE / 40)), RAD(0), RAD(21 + 2.5 * SIN(SINE / 40))), 1 / Animation_Speed) 
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(0), RAD(-100)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.3 + 0.05 * SIN(SINE / 12), -0.35) * ANGLES(RAD(0), RAD(0), RAD(70)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-20+40*COS(SINE / 40)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-10+40*COS(SINE / 40)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif mde == 59 then
				WACKYEFFECT({Time = 2.5, EffectType = "Slash", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				CamShakeAll(sick.PlaybackLoudness/70,sick.PlaybackLoudness/70)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 45) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(-10 + MRANDOM(-4,4))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.1 * COS(SINE / 45), 0.4) * ANGLES(RAD(-40), RAD(0), RAD(-38)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.15 + 0.12 * COS(SINE / 45), -0.05 + 0.1 * COS(SINE / 45)) * ANGLES(RAD(-10.5 - 6 * COS(SINE / 45)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.8 + 0.1 * COS(SINE /35),0) * ANGLES(RAD(165 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(25 + MRANDOM(-4,4))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 45), -0.01) * ANGLES(RAD(-15- 6 * COS(SINE / 45)), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 45), -0.01) * ANGLES(RAD(-15- 6 * COS(SINE / 45)), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.8 / Animation_Speed)
		end		
	end	
	elseif TORSOVELOCITY > 1 then
		ANIM = "Walk"
		if ATTACK == false then
			if mde == 0 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 1 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),math.rad(0),math.rad(0)),1 / 2)
			elseif mde == 2 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/15)) * CFrame.Angles(math.rad(40),math.rad(-5*math.cos(sine/30)),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 3 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(20-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(-50+5*math.sin(sine/9)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 4 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC02*CFrame.new(0,math.cos(sine/25),-math.sin(sine/25)+2)*CFrame.Angles(math.rad(5*math.sin(sine/25)),0,math.rad(70)),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.Angles(0,0,math.rad(-70))*CFrame.Angles(math.rad(5*math.cos(sine/25)),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))* RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-20+5*math.sin(sine/25)))* LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1-.1*math.sin(sine/25),-.01)*CFrame.Angles(0,math.rad(80),0),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.5-.25*math.sin(sine/25),-.51)*CFrame.Angles(math.rad(-10),math.rad(-80),0),.25)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 5 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,.125*math.sin(sine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(-10*math.cos(sine/12)),math.rad(-5*math.cos(sine/12))),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(10-5*math.cos(sine/12)),math.rad(10*math.cos(sine/12)),math.rad(5*math.cos(sine/12))),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(sine/12)),math.rad(-10+5*math.sin(sine/12)),math.rad(10))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-30*math.sin(sine/12)),math.rad(5*math.cos(sine/12)),0)*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.9-.2*math.cos(sine/12),.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(sine/12)),math.rad(90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(sine/12),-.5*math.sin(sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(sine/12)),math.rad(-90+5*math.cos(sine/12)),math.rad(2.5*math.cos(sine/12))),.25)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)	
			elseif mde == 6 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3+0.5*math.cos(sine / 41)) * CFrame.Angles(math.rad(0+1*math.cos(sine / 41)), math.rad(0+1*math.cos(sine / 27)), math.rad(0+1*math.cos(sine / 32))),0.35)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(20+5*math.cos(sine / 40)), math.rad(0+1*math.cos(sine / 12)), math.rad(0)),0.35)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-0.6, 0.5, -0.3) * CFrame.Angles(math.rad(60+1*math.cos(sine / 22)), math.rad(0+1*math.cos(sine / 25)), math.rad(70+1*math.cos(sine / 30))) * LEFTSHOULDERC0,0.35)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, -1) * CFrame.Angles(math.rad(90), math.rad(-20), math.rad(-70)) * CFrame.Angles(math.rad(0+1*math.cos(sine / 23)), math.rad(90+1*math.cos(sine / 34)), math.rad(0+1*math.cos(sine / 31))),0.35)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0)) * CFrame.Angles(math.rad(0+1*math.cos(sine / 26)), math.rad(-90+1*math.cos(sine / 20)), math.rad(0+1*math.cos(sine / 30))),0.35)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(-.02,-10,0) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),1)
			elseif mde == 8 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 7 then
				Speed = 50
				if NeckSnap then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(sine/100)),0),1)
					NeckSnap = false
				else
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(sine/100)),0),.25)
				end
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(sine/37)),0,0),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(sine/41)),0,0),.25)
			elseif mde == 9 then
				Speed = 50
				local headsnap = math.random(1,60);
				local headsnapping=false;
				if headsnap == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 3 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(25-math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(sine/25)), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
				RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-30-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 10 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(25), RAD(5)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, 0) * ANGLES(RAD(300), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-50), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 11 then
				Speed = 50
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/25,0.05,1*sick.PlaybackLoudness/25), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(100*sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(Sine / 3.5) + -SIN(Sine / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(Sine / 3.5)), RAD(0) - Character.Torso.RotVelocity.Y / 75, RAD(15 * COS(Sine / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 3)
				if math.random(1,5) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
				end
				RightHip.C0 = Clerp(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(Sine / 7) / 2* 1, 0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(Sine / 7)) - Character["Right Leg"].RotVelocity.Y / 75 + -SIN(Sine / 7) / 2.5, RAD(90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(Sine / 7) / 2* 1, -0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(Sine / 7)) + Character["Left Leg"].RotVelocity.Y / 75 + SIN(Sine / 7) / 2.5, RAD(-90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(Sine / 30)* 1, -0.34 * COS(Sine / 7* 1)) * ANGLES(RAD(-110)  * COS(Sine / 7) , RAD(-90) ,	RAD(-13) + Character["Left Arm"].RotVelocity.Y / 75), 0.15)
			elseif mde == 12 then
				Speed = 50
				Effect({Time = MRANDOM(80,100),EffectType = "Box",Size = VT(2.75,2.75,2.75), Size2 = VT(0,0,0),Transparency = 0, Transparency2 = 1,CFrame = hitb.CFrame*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))),MoveToPos = nil,RotationX = MRANDOM(-100/100,100/100), RotationY = MRANDOM(-100/100,100/100), RotationZ = MRANDOM(-100/100,100/100),Material = "Neon",Color = C3(),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.15* SIN(SINE / 3)) * ANGLES(RAD(15+3 * SIN(SINE / 3)), RAD(0), RAD(0+5 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250 + MRANDOM(-4,4)), math.rad(20 + MRANDOM(-4,4)), math.rad(-80 + MRANDOM(-4,4)))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.8, 0) * ANGLES(RAD(165 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(25 + MRANDOM(-4,4))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 70 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 70 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 13 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.15* SIN(SINE / 3)) * ANGLES(RAD(15+3 * SIN(SINE / 3)), RAD(0), RAD(0+5 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10 - 2* SIN(SINE / 3)), RAD(0), RAD(0+10* SIN(SINE / 6))), 0.8 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0-0.3* SIN(SINE / 6)) * ANGLES(RAD(0+70* SIN(SINE / 6)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 70 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 70 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 14 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0 + 8.5 * COS(SINE / 12))), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145 + 5.5 * COS(SINE / 12)), RAD(0 - 20 * COS(SINE / 12)), RAD(0 - 2 * COS(SINE / 12))) * ANGLES(RAD(0 + 20 * COS(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)	
			elseif mde == 15 then
				Speed = 50
				Effect({Time = 10,EffectType = "Ring",Size = VT(0,0,0), Size2 = VT(0.1,0.3,0.1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CF(0,-1,0)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = BrickColor.new("Pastel Blue").Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(10),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 16 then
				Speed = 300
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				GUN.Mag.Transparency = 0
				GUN.Trigger.Transparency = 0
				GUN.scope1.Transparency = 0
				GUN.Stock.Transparency = 0
				GUN.scope.Transparency = 0
				GUN.Hole.Transparency = 0
				GUN.Holding.Transparency = 0
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,-0.2) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.25/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),0.25/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.75/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,0.75/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(75*math.sin(sine/2)),math.rad(90),math.rad(0)),1)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-75*math.sin(sine/2)),math.rad(-90),math.rad(0)),1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			elseif mde == 17 then
				Speed = 50
				GUN.Base.Transparency = 0
				GUN.GunAdditions.Transparency = 0
				GUN.NeonParts.Transparency = 0
				GUN.Mag.Transparency = 0
				GUN.Trigger.Transparency = 0
				GUN.scope1.Transparency = 0
				GUN.Stock.Transparency = 0
				GUN.Hole.Transparency = 0
				GUN.scope.Transparency = 0
				GUN.Holding.Transparency = 0
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,-.1) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 18 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0 + 10 * COS(SINE / 50))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-45 + 25.5 * COS(SINE / 12)), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 19 then
				Speed = 16*SIZEE
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,-.5*math.sin(sine/25))*CFrame.Angles(math.rad(20),0,0),.25)
				if NeckSnap then
					Neck.C0 = Clerp(Neck.C0,NECKC0,1)
					NeckSnap = false
				else
					Neck.C0 = Clerp(Neck.C0,NECKC0,.25)
				end
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-10),0,0)*RIGHTSHOULDERC0,.25)
				SwordJoint.C0 = Clerp(SwordJoint.C0,CFrame.new(0,-1,0)*CFrame.Angles(math.rad(154.35-5.65*math.sin(sine/25)),0,0),.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.cos(sine/25)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0)*CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.cos(sine/25))),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.cos(sine/25))),.25)
			elseif mde == 20 then
				Speed = 16*SIZEE
				SwordJoint.C0 = Clerp(SwordJoint.C0,CFrame.new(0,-0,-.5)*CFrame.Angles(0,math.rad(170),math.rad(-10)),.25)
				if LookUp == false then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0,0)*CFrame.Angles(math.rad(-5+3*math.cos(sine/25)),0,0),.25)
				elseif LookUp == true then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.new(0,0,0)*CFrame.Angles(math.rad(-30+3*math.cos(sine/25)),0,0),.25)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,0+0.15* math.sin(sine / 3))*CFrame.Angles(math.rad(15+3 * math.cos(sine / 3)),0,0),.25)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(80+5*math.sin(sine/3)),0,math.rad(45))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(0 + 70 * math.sin(sine / 6)),0,math.rad(-5))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,0)*CFrame.Angles(math.rad(5 + 70 * math.sin(sine / 6)),math.rad(90),math.rad(0)),.25)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(5 - 70 * math.sin(sine / 6)),math.rad(-90),math.rad(0)),.25)	
			elseif mde == 21 then
				Speed = 10
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(10,0.05,10), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,75,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.115)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				if math.random(1,25) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.75, 0) * ANGLES(RAD(170 - 15 * SIN(SINE / 6)), RAD(0), RAD(12 - 15 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.100)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.100)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 22 then
				Speed = 55
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-69.5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)	
			elseif mde == 23 then
				Speed = 25
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			elseif mde == 24 then
				Speed = 50
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = Vector3.new(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = Vector3.new(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(sick.PlaybackLoudness/666),math.rad(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = Vector3.new(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = Vector3.new(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(sick.PlaybackLoudness/666),math.rad(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = Vector3.new(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = Vector3.new(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(sick.PlaybackLoudness/666),math.rad(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = GUN.NeonParts.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/9)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.7/3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,.5,-.1) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(135),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 25 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 10 * SIN(SINE / 12)), RAD(30 - 10 * SIN(SINE / 12))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(30), RAD(40.5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(sine/12)),0,0),.25)		
			elseif mde == 26 then
				Speed = 25
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 27 then
				Speed = 357
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.15* SIN(SINE / 3)) * ANGLES(RAD(15+3 * SIN(SINE / 3)), RAD(0), RAD(0+5 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-1000000,1000000)), RAD(MRANDOM(-1000000,1000000)), RAD(MRANDOM(-1000000,1000000))), 3 / Animation_Speed)	
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(165 + MRANDOM(-1000000,1000000)), RAD(MRANDOM(-1000000,1000000)), RAD(MRANDOM(-1000000,1000000)))* RIGHTSHOULDERC0, 3 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.5) * ANGLES(RAD(MRANDOM(-1000000,1000000)), RAD(MRANDOM(-1000000,1000000)), RAD(MRANDOM(-1000000,1000000))) * LEFTSHOULDERC0, 3 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 70 * SIN(SINE / 6))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 70 * SIN(SINE / 6))), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90+MRANDOM(-1000000,1000000)),math.rad(MRANDOM(-1000000,1000000)),math.rad(MRANDOM(-1000000,1000000))),1)
			elseif mde == 28 then
				Speed = 55
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.15* SIN(SINE / 3)) * ANGLES(RAD(15+3 * SIN(SINE / 3)), RAD(0), RAD(0+5 * SIN(SINE / 6))), 0.8 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(175 + 5 * COS(SINE / 12)), RAD(0), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, 0.5) * ANGLES(RAD(0), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 70 * SIN(SINE / 6))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 70 * SIN(SINE / 6))), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
			elseif mde == 29 then
				Speed = 65
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 - 0.5 * COS(SINE / 15)) * ANGLES(RAD(30), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-30+MRANDOM(-2,2)), RAD(MRANDOM(-2,2)), RAD(MRANDOM(-2,2))), 1 / Animation_Speed)	
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(165 + 15 * COS(SINE / 15)), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(120), RAD(0), RAD(-10 + 15 * COS(SINE / 15))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				snap = math.random(1,60)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))), 3 / Animation_Speed)
				end
				snap2 = math.random(1,60)
				if snap2 == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * RIGHTSHOULDERC0, 3 / Animation_Speed)
				end
				snap3 = math.random(1, 60)
				if snap3 == 1 then
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * LEFTSHOULDERC0, 3 / Animation_Speed)
				end
				snap4 = math.random(1, 60)
				if snap4 == 1 then
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 70 * SIN(SINE / 6))), 1 / Animation_Speed)
				end
				snap4 = math.random(1, 60)
				if snap4 == 1 then
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(90+MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))), 3 / Animation_Speed)
				end
				snap5 = math.random(1, 60)
				if snap5 == 1 then
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(90+MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))), 3 / Animation_Speed)
				end
				snap6 = math.random(1, 60)
				if snap6 == 1 then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000)), RAD(MRANDOM(-10000,10000))), 3 / Animation_Speed)
				end
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-60), RAD(15)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 30 then
				Speed = 459.5
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90))* RIGHTSHOULDERC0, 0.100000000000000 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.100000000000000 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.100000000000000 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),1)
			elseif mde == 31 then
				Speed = 27
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1.5 + 1.1 * SIN(SINE / 26)) * ANGLES(RAD(40 - 2.5*SIN(SINE/24)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(41), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(185), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40), RAD(0), RAD(5)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, -0.5) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(20), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 32 then
				Speed = 105
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 - 1.5 * COS(SINE / 28)) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(120), RAD(0), RAD(1*COS(SINE/15))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(-30), RAD(80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-30), RAD(-80), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90-10*SIN(SINE/15)),math.rad(0),math.rad(0)),1)
			elseif mde == 33 then
				Humanoid.HipHeight = 1.5
				Speed = 20
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(-00.1*COS(SINE/12), 0, 00.1*COS(SINE/15)) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(165), RAD(0), RAD(20))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.4, -0.7) * ANGLES(RAD(86), RAD(9), RAD(75)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.6 - 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(-35)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(-15), RAD(-70), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 34 then
				Speed = 85
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(20), RAD(0), RAD(20 * COS(SINE/10))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(-8 * COS(SINE/10))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-75), RAD(0), RAD(-8)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(60 * COS(SINE/10)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-60 * COS(SINE/10)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 35 then
				Speed = 85
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(20), RAD(0), RAD(20 * COS(SINE/10))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(-8 * COS(SINE/10))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(55 * COS(SINE/15)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(60 * COS(SINE/10)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-60 * COS(SINE/10)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 36 then
				Speed = 18
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-20,20) - 4 * COS(SINE / 12)), RAD(MRANDOM(-20,20)), RAD(MRANDOM(-5,5))), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 37 then
				Speed = 24
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 38 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(SINE / 3.5)), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(15 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15) + MRANDOM(-20,20)), RAD(0 + MRANDOM(-20,20)), RAD(-10 + MRANDOM(-20,20))), 3 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(SINE / 7) / 2* 1, 0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(SINE / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(SINE / 7) / 2.5, RAD(90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(SINE / 7) / 2* 1, -0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(SINE / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(SINE / 7) / 2.5, RAD(-90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(165 + MRANDOM(-20,20)), RAD(0 + MRANDOM(-20,20)), RAD(22 + MRANDOM(-20,20))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 39 then
				Speed = 25
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145+5*COS(SINE/12)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, 0.5) * ANGLES(RAD(-15), RAD(12), RAD(43)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 40 then
				Speed = 125
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(SINE / 3.5)), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(15 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(SINE / 7) / 2* 1, 0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(SINE / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(SINE / 7) / 2.5, RAD(90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(SINE / 7) / 2* 1, -0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(SINE / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(SINE / 7) / 2.5, RAD(-90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 41 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * COS(SINE / 6)) * ANGLES(RAD(25), RAD(0), RAD(8*COS(SINE/12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(-6*COS(SINE/12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-65), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(60*COS(SINE/12)), RAD(-10), RAD(10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(60*COS(SINE/12)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(-60*COS(SINE/12)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 42 then
				Speed = 22
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(8*COS(SINE/16))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(10), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(190), RAD(30), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.5, -0.4) * ANGLES(RAD(25), RAD(-30), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(40*COS(SINE/16)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(-40*COS(SINE/16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 43 then		
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-40), RAD(0 + 1.5 * COS(SINE / 34)), RAD(0 + 1.5 * COS(SINE / 34))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15+ 5 * COS(SINE / 19))) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2.5 + 0.5 * COS(SINE / 19)) * ANGLES(RAD(90), RAD(0), RAD(0+ 4 * COS(SINE / 19))), 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15- 5 * COS(SINE / 19))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3 - 0.1 * COS(SINE / 34), -0.5) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 34), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 44 then
				Speed = 19
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(0), RAD(0), RAD(0)), 0.3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(70) * COS(SINE / 7) , RAD(90), RAD(5)), 0.1)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 45 then
				Speed = 20
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 46 then
				Speed = 25
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 1.3 + 0.5 * COS(SINE / 24)) * ANGLES(RAD(24), RAD(-5 * SIN(SINE / 24)), RAD(0)), 0.4 / Animation_Speed*3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-24), RAD(5 * SIN(SINE / 24)), RAD(MRANDOM(-5.5,5.5))), 0.2)			
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.15 * COS(SINE / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(14 + 6.5* SIN(SINE / 24)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.15 * COS(SINE / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(-14 - 6.5 * SIN(SINE / 24))) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 24), 0) * ANGLES(RAD(-25), RAD(78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.3 - 0.1 * COS(SINE / 24), -0.5) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 47 then
				Speed = 16
				snap = math.random(1,6)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-1000,1000)),math.rad(math.random(-1000,100)),math.rad(math.random(-1000,1000))),1/Animation_Speed)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(-25), RAD(25 + 8 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(25), RAD(-25 - 8 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.65 - 0.2 * COS(SINE / 12), -0.35) * ANGLES(RAD(-25 + 6 * COS(SINE / 12)), RAD(80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(-5 + 2 * COS(SINE / 12)), RAD(-80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 48 then
				Speed = 40
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 1.3 + 0.5 * COS(SINE / 24)) * ANGLES(RAD(24), RAD(-5 * SIN(SINE / 24)), RAD(0)), 0.4 / Animation_Speed*3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-24), RAD(5 * SIN(SINE / 24)), RAD(MRANDOM(-5.5,5.5))), 0.2)			
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.15 * COS(SINE / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(14 + 6.5* SIN(SINE / 24)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.15 * COS(SINE / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(-14 - 6.5 * SIN(SINE / 24))) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 24), 0) * ANGLES(RAD(-25), RAD(78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.3 - 0.1 * COS(SINE / 24), -0.5) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 49 then
				Speed = 20
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(0), RAD(0), RAD(0)), 0.3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(140 + 6.5 * SIN(Sine / 34)), RAD(5*SIN(Sine/34)), RAD(10 * SIN(Sine / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / 3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)	
			elseif mde == 50 then
				Speed = 30
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 1.3 + 0.5 * COS(SINE / 24)) * ANGLES(RAD(24), RAD(-5 * SIN(SINE / 24)), RAD(0)), 0.4 / Animation_Speed*3)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-24), RAD(5 * SIN(SINE / 24)), RAD(MRANDOM(-5.5,5.5))), 0.2)			
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(120 + 6.5 * SIN(Sine / 34)), RAD(5*SIN(Sine/34)), RAD(10 * SIN(Sine / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.15 * COS(SINE / 24), 0) * ANGLES(RAD(-45), RAD(0), RAD(-14 - 6.5 * SIN(SINE / 24))) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 24), 0) * ANGLES(RAD(-25), RAD(78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.3 - 0.1 * COS(SINE / 24), -0.5) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(-5 * SIN(SINE / 24)), RAD(0), RAD(5)), 0.4 / Animation_Speed)	
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 51 then
				Speed = 20
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(0), RAD(0), RAD(0)), 0.3)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(140 + 6.5 * SIN(Sine / 34)), RAD(5*SIN(Sine/34)), RAD(10 * SIN(Sine / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / 3)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 52 then
				Speed = 22
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,2+0.5*COS(SINE / 12))*ANGLES(RAD(25+2.5*COS(SINE / 12)),RAD(0-RootPart.RotVelocity.y),RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/7)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/7)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 53 then
				Speed = 13
				WACKYEFFECT({Time = 50, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),0,0) , SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10 - 2* SIN(SINE / 6)), RAD(0+5* SIN(SINE / 12)), RAD(0)), 0.8 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0-60* SIN(SINE / 12)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+60* SIN(SINE / 12)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.1* SIN(SINE / 6)) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1.01 , -1, 0-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.01, -1, 0+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 54 then
				Speed = 15
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(8*COS(SINE/16))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(10), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(190), RAD(30), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.5, -0.4) * ANGLES(RAD(25), RAD(-30), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(40*COS(SINE/16)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(-40*COS(SINE/16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 55 then
				Speed = 50
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * COS(SINE / 6)) * ANGLES(RAD(25), RAD(0), RAD(8*COS(SINE/12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(-6*COS(SINE/12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-65), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(60*COS(SINE/12)), RAD(-10), RAD(10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(60*COS(SINE/12)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(-60*COS(SINE/12)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / Animation_Speed)
				GunJoint.C0 = Clerp(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			elseif mde == 56 then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * COS(SINE / 6)) * ANGLES(RAD(25), RAD(0), RAD(8*COS(SINE/12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.5) * ANGLES(RAD(150), RAD(0), RAD(-55))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.2, -0.7) * ANGLES(RAD(50), RAD(15), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(60*COS(SINE/12)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(-60*COS(SINE/12)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / Animation_Speed)
			elseif mde == 57 then
				Speed = 20
				--[[ Neck.C0=CFrame.new(0,1,0)*CFrame.Angles(math.rad(90 + 5 * math.cos(SINE/60)),math.rad(180),math.rad(0 + 5 * math.cos(SINE/60)))
				RootJoint.C0=CFrame.new(0 + 1 * math.cos(SINE/50),0 + 1 * math.cos(SINE/80),0 + 1 * math.cos(SINE/70))*CFrame.Angles(math.rad(60),math.rad(180),math.rad(0))
				RightShoulder.C0=CFrame.new(1.5,0.5,-0.5)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(5 + 5 * math.cos(SINE/40)))
				LeftShoulder.C0=CFrame.new(-1,0,0.4)*CFrame.Angles(math.rad(-30.7 + 5 * math.cos(SINE/60)),math.rad(9.1 + 5 * math.cos(SINE/50)),math.rad(32.1 + 5 * math.cos(SINE/40)))
				RightHip.C0 = CFrame.new(0.5,-0.7,0.3)*CFrame.Angles(math.rad(-10 + 10 * math.cos(SINE/45)),math.rad(0),math.rad(1 + 1 * math.cos(SINE/50)))
				LeftHip.C0=CFrame.new(-0.5,-1,0.3)*CFrame.Angles(math.rad(0 + 5 * math.cos(SINE/50)),math.rad(0),math.rad(1 - 1 * math.cos(SINE/50))) ]]
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * COS(SINE / 6)) * ANGLES(RAD(25), RAD(0), RAD(8*COS(SINE/12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.5) * ANGLES(RAD(150), RAD(0), RAD(-55))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.2, -0.7) * ANGLES(RAD(50), RAD(15), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(60*COS(SINE/12)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 6), 0) * ANGLES(RAD(-60*COS(SINE/12)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / Animation_Speed)
			elseif mde == 58 then
				Speed = 35
				WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				CamShakeAll(sick.PlaybackLoudness/45,sick.PlaybackLoudness/45)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			elseif mde == 59 then
				WACKYEFFECT({Time = 2.5, EffectType = "Slash", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(100*sick.PlaybackLoudness/0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				CamShakeAll(sick.PlaybackLoudness/70,sick.PlaybackLoudness/70)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.1 * COS(SINE /12), 0) * ANGLES(RAD(0+ 40 * COS(SINE / 12) + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(12 + MRANDOM(-4,4))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.15 + 0.1 * COS(SINE / 12), -0.05 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(15 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.8, 0) * ANGLES(RAD(165 + MRANDOM(-4,4)), RAD(0 + MRANDOM(-4,4)), RAD(25 + MRANDOM(-4,4))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 0.15 / Animation_Speed)
			end
		end
	end
	
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	if info == false then
		chat.Parent = nil
		chat2.Parent = nil
	elseif info == true then
		chat.Parent = Character
		chat2.Parent = Character
	end
	if info == true then
		chatweld.C0 = Clerp(chatweld.C0, CF(5,2,-4.5) * ANGLES(RAD(RAD(-15)),RAD(130),RAD(-4)), 1)
		chatweld2.C0 = Clerp(chatweld2.C0, CF(-5,2,-4.5) * ANGLES(RAD(RAD(15)),RAD(-130),RAD(4)), 1)
		chat.Color = GUN.NeonParts.Color
		chat2.Color = GUN.NeonParts.Color
		for _,v in pairs(surfacegui:children()) do
			if v:IsA("Frame") then
				if v.Name=="chatbox" then
					v:TweenSize(UDim2.new(0.014, 0, 0.014-sick.PlaybackLoudness/2500*math.random(1,6), 0), "Out", "Quad", .5,true)
					v.BackgroundColor3 = GUN.NeonParts.Color
				end
			end
		end
	end
	if mde ~= 1 or mde ~= 20 or mde ~= 27 then
		SK1.Text = "None"
		SK2.Text = "None"
	end
	if mde == 1 then
		SK1.Text = "N - Secret song"
		SK2.Text = "None"
	elseif mde == 20 then
		SK1.Text = "K - Look Up"
		SK2.Text = "L - Look Straight"
	elseif mde == 27 then
		SK1.Text = "N - 'SKID.' Taunt(VERY SPAMMABLE)"
		SK2.Text = "None"
	end
end
print("Loaded")
end)
Section:NewButton("FE Andrfix Studio Dummy", "a studio dummy yes", function()
game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-40,0,-10)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local CDDF = {}
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	CDDF[DmgPer] = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	CDDF[DmgPer] = false; StateMover = true
end

for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end


--[[
get real 
]]
function randomstring()
	local e = {}
	for i = 1,math.random(1,10) do
		table.insert(e,#e+1,utf8.char(math.random(0,10175)))
	end
	return table.concat(e)
end

local event,connection,backups = nil,nil,{}
local cn,euler,rad,random,c3,v3,clamp,sin,cos = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,math.random,Color3.fromRGB,Vector3.new,math.clamp,math.sin,math.cos
local hc0,lac0,rac0,llc0,rlc0,sine,animspeed,attack,keys,poscframe,ypos,yvelo,raycastparams,changingsoundvolume,partexclusion,gay,songid,loudnerd,firstperson,moving,velocity = cn(0,1.5,0),cn(-1.5,0,0),cn(1.5,0,0),cn(-0.5,-2,0),cn(0.5,-2,0),0,0.8/4,false,{w=false,a=false,s=false,d=false,space=false},cn(),50,0,RaycastParams.new(),false,{},"angry",5551904754,false,false,false,v3()
script.Name = randomstring()
game:GetService("RunService").RenderStepped:Wait()
script:Destroy()
local other = false
local ScriptSignals = {}
local speak = false
local unfairtables = false
if not game:IsLoaded() then game.Loaded:Wait() end
local plrs,run,insert,rf,debris,workspace,ts,uis,pps = game:GetService("Players"),game:GetService("RunService"),game:GetService("ProximityPromptService"),game:GetService("ReplicatedFirst"),game:GetService("Debris"),workspace,game:GetService("TweenService"),game:GetService("UserInputService"),game:GetService("ProximityPromptService")

local localplayer,username = plrs.LocalPlayer,game:GetService("Players").LocalPlayer.Name
local userid,mouse,localuserid = game:GetService("Players").LocalPlayer.UserId,localplayer:GetMouse(),localplayer.UserId
local c,r,h,t,la,ra,ll,rl,face,gun,cm,rm,hm,tm,lam,ram,llm,rlm,gunm
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset,gunoffset,eventname = hc0,cn(),lac0,rac0,llc0,rlc0,cn(-0.125,-0.898999929,0.95400238)*euler(0,rad(90),rad(-172.5)),script:GetAttribute("EventName")
raycastparams.FilterType,raycastparams.IgnoreWater = Enum.RaycastFilterType.Blacklist,true
local Character
local plr = game:GetService("Players").LocalPlayer
local Player = plrs:FindFirstChild(username)
local Meshs
local hicolor
local eventremoved
local cam = workspace.CurrentCamera
local camerapos = nil
local Materials = {"Brick","Cobblestone","Concrete","Fabric","Granite","Grass","Glass","Marble","Neon","Pebble","Plastic","Sand","SmoothPlastic","Slate","Wood","WoodPlanks"}
function tween(instance,properties,duration,easingdirection,easingstyle)
	pcall(function()
	if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
	ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)	
	end
local Parents3 = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService","RunService","Debris","StarterGui","StarterPlayer"}
local sexe = 0
local isceat_ceat = userid == 466270319 or userid == 2252833773 or userid == 1668392794 or userid == 2373291799

local StudioDum
local Wowie
local Fly
local ActiveFly
local FlyDown
local FlyUp
local Attack
local LoudMode
local ActiveLoud
local Types
local Types_2
local Mode
local HeartUndertale
local Attack_2

function change(instance,properties)
	for i, v in next, properties do
		instance[i] = v
	end
end
function create(class,properties)
	local instance = Instance.new(class)
	instance.Name = randomstring()
	change(instance,properties)
	return instance
end
local modes = nil

function gettransparency(transparency)
	if firstperson then
		return 1
	else
		return transparency
	end
end



function Swait(num)
	if num == 0 or num == nil then
		game:GetService("RunService").RenderStepped:Wait()
	else
		for i = 1, num do
			game:GetService("RunService").RenderStepped:Wait()
		end
	end
end
swait = Swait
function newmode(howtouseindexlol)
	gay = howtouseindexlol
end

if not table.find(partexclusion,workspace.non) then
	table.insert(partexclusion,workspace.non)
end
	if not Effects or Effects.Parent ~= workspace.Terrain or Effects.Archivable ~= false then
		
		Effects = Instance.new("WorldModel")
		Effects.Parent = workspace.Terrain
		Effects.Name = randomstring()
		Effects.Archivable = false
	end
	if not c or c.Parent ~= playerss or c.Transparency ~= 1 or c.CastShadow or not c.Anchored or c.CanCollide or c.Archivable or not c.Locked then
		
		c = Instance.new("Part")
		c.Transparency = 1
		c.Name = randomstring()
		c.CanCollide = true
		c.Anchored = true
		c.CanTouch = false
		c.Locked = true
		c.CastShadow = false
	    c.Parent = workspace
		c.Archivable = false
end
if not table.find(partexclusion,c) then
	table.insert(partexclusion,c)
end
	if not r or r.Parent ~= playerss or r.Transparency ~= 1 or r.CastShadow or not r.Anchored or r.CanCollide or r.Archivable or not r.Locked then
	r = playerss.HumanoidRootPart
		r.CFrame = poscframe
		
		RootPart = r
		
end

if not table.find(partexclusion,r) then
	table.insert(partexclusion,r)
end
	if not face or face.Parent ~= h or face.Texture ~= "rbxasset://textures/face.png" or face.Color3 ~= c3(255,255,255) or face.Transparency ~= 0 or face.Face ~= Enum.NormalId.Front then
		if h then
			
		end
	end
	if not t or t.Parent ~= playerss or t.Transparency ~= 0 or t.LocalTransparencyModifier ~= 0 or t.CastShadow or not t.Anchored or t.CanCollide or t.Archivable or not t.Locked then
	t = playerss.Torso
		t.CFrame = r.CFrame*toffset
		
end
if not table.find(partexclusion,t) then
	table.insert(partexclusion,t)
end
	if not h or h.Parent ~= playerss or h.Transparency ~= 0 or h.LocalTransparencyModifier ~= 0 or h.CastShadow or not h.Anchored or h.CanCollide or h.Archivable or not h.Locked then
	h = playerss.Head
		h.CFrame = t.CFrame*hoffset
		
		face = Instance.new("Decal",h)
		face.Texture = "rbxasset://textures/face.png"
		face.Transparency = 0
		face.Face = Enum.NormalId.Front
end
if not table.find(partexclusion,h) then
	table.insert(partexclusion,h)
end
	if not la or la.Parent ~= playerss or la.Transparency ~= 0 or la.LocalTransparencyModifier ~= 0 or la.Reflectance ~= 0 or la.CastShadow or not la.Anchored or la.CanCollide or la.Archivable or not la.Locked then
	la = playerss["Left Arm"]
		la.CFrame = t.CFrame*laoffset
		
end
if not table.find(partexclusion,la) then
	table.insert(partexclusion,la)
end
	if not ra or ra.Parent ~= playerss or ra.Transparency ~= 0 or ra.LocalTransparencyModifier ~= 0 or t.CastShadow or not ra.Anchored or ra.CanCollide or ra.Archivable or not ra.Locked then
	ra = playerss["Right Arm"]
		ra.CFrame = t.CFrame*raoffset
		
end
if not table.find(partexclusion,ra) then
	table.insert(partexclusion,ra)
end
	if not ll or ll.Parent ~= playerss or ll.Transparency ~= 0 or ll.LocalTransparencyModifier ~= 0 or ll.CastShadow or not ll.Anchored or ll.CanCollide or ll.Archivable or not ll.Locked then
	ll = playerss["Left Leg"]
		ll.CFrame = t.CFrame*lloffset
		
		
end
if not table.find(partexclusion,ll) then
	table.insert(partexclusion,ll)
end
	if not rl or rl.Parent ~= playerss or rl.Transparency ~= 0 or rl.LocalTransparencyModifier ~= 0 or rl.CastShadow or not rl.Anchored or rl.CanCollide or rl.Archivable or not rl.Locked then
	rl = playerss["Right Leg"]
		rl.CFrame = t.CFrame*rloffset
	
	
end

if not table.find(partexclusion,rl) then
	table.insert(partexclusion,rl)
end
	if not gun or gun.Parent ~= playerss or gun.Transparency ~= 0 or gun.LocalTransparencyModifier ~= 0 or gun.CastShadow or not gun.Anchored or gun.CanCollide or gun.Archivable or not gun.Locked then
		
		gun = Instance.new("Part"):Clone()
		gun.Material = "Neon"
		gun.Color = Color3.new(1,1,1)
		gun.CFrame = ra.CFrame*gunoffset
		gun.CanCollide = true
		gunlight = Instance.new("PointLight")
		gunlight.Parent = gun
		gunlight.Range = 6
		gunlight.Brightness = 7.06
		gun.Transparency = 0
		gun.Name = randomstring()
		gun.Anchored = true
		gun.CanTouch = false
		gun.CastShadow = false
		gun.Locked = true
		gun.Archivable = false
		gun.Parent = playerss
end
if not table.find(partexclusion,gun) then
	table.insert(partexclusion,gun)
end

	if not rlm or rlm.Parent ~= rl then
		debris:AddItem(rlm,0)
		rlm = Instance.new("SpecialMesh")
		rlm.TextureId = "rbxassetid://5891509571"
		rlm.MeshId = "rbxassetid://7136860472"
		rlm.Parent = rl
		rlm.Archivable = false
		rlm.Name = randomstring()
	end
	if not llm or llm.Parent ~= ll then
		debris:AddItem(llm,0)
		llm = Instance.new("SpecialMesh")
		llm.MeshId = "rbxassetid://7136860472"
		llm.TextureId = "rbxassetid://5891509571"
		llm.Parent = ll
		llm.Archivable = false
		llm.Name = randomstring()
	end
	if not hm or hm.Parent ~= h then
		debris:AddItem(hm,0)
		hm = Instance.new("SpecialMesh")
		hm.TextureId = "rbxassetid://5891509571"
		hm.MeshId = "rbxassetid://7136622085"
		hm.Parent = h
		hm.Archivable = false
		hm.Name = randomstring()
	end
	if not ram or ram.Parent ~= ra then
		debris:AddItem(ram,0)
		ram = Instance.new("SpecialMesh")
		ram.TextureId = "rbxassetid://5891509571"
		ram.MeshId = "rbxassetid://7136860472"
		ram.Parent = ra
		ram.Archivable = false
		ram.Name = randomstring()
	end
	if not lam or lam.Parent ~= la then
		debris:AddItem(lam,0)
		lam = Instance.new("SpecialMesh")
		lam.TextureId = "rbxassetid://5891509571"
		lam.MeshId = "rbxassetid://7136860472"
		lam.Archivable = false
		lam.Parent = la
		lam.Name = randomstring()
	end
	if not tm or tm.Parent ~= t then
		debris:AddItem(tm,0)
		tm = Instance.new("SpecialMesh")
		tm.TextureId = "rbxassetid://5891509571"
		tm.MeshId = "rbxasset://fonts/torso.mesh"
		tm.Parent = t
		tm.Archivable = false
		tm.Name = randomstring()
	end
	if not gunm or gunm.Parent ~= gun then
		debris:AddItem(gunm,0)
		gunm = Instance.new("SpecialMesh")
		gunm.TextureId = "rbxassetid://55260662"
		gunm.MeshId = "rbxassetid://1736736188"
		gunm.VertexColor = Vector3.new(255,255,255)
		gunm.Parent = gun
		gunm.Archivable = false
		gunm.Name = randomstring()
	end
	if r.CFrame.X >= 3000 or r.CFrame.Y >= 3000 or r.CFrame.Z >= 3000 or r.CFrame.X <= -3000 or r.CFrame.Y <= -3000 or r.CFrame.Z <= -3000 then
		refresh()
		respawnchr()
end

local function AlignHat(p1,p2,nomesh)
	pcall(function()
		p1:FindFirstChildOfClass("Weld"):Destroy()
		if nomesh then 
			p1:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end)
	--p1.AccessoryWeld:Destroy()
	A1 = Instance.new("Attachment", p1) 
	A2 = Instance.new("Attachment", p2)
	Mover = Instance.new("AlignPosition", p1)
	Mover.RigidityEnabled = false
	Mover.Attachment0 = A1
	Mover.Attachment1 = A2
	Mover.Responsiveness = 200
	Mover.MaxVelocity = math.huge
	Mover.MaxForce = math.huge
	Rotater = Instance.new("AlignOrientation", p1)
	Rotater.RigidityEnabled = false
	Rotater.Attachment0 = A1
	Rotater.Attachment1 = A2
	Rotater.Responsiveness = 200
	Rotater.MaxAngularVelocity = math.huge
	Rotater.MaxTorque = math.huge
end

pcall(function()
	Railgun = workspace.non["Meshes/archangelrifleAccessory"].Handle
	AlignHat(Railgun,gun,false)
	Railgun.Attachment.Rotation = Vector3.new(-0, -180, 0)
	Railgun.Attachment.Position = Vector3.new(0, -0.02, 0)
	--Railgun.Attachment.CFrame = CFrame.new(-1.29999995, 0.200000003, 0, -4.37113883e-08, 0.707106829, -0.707106829, 0, 0.707106829, 0.707106829, 1, 3.09086232e-08, -3.09086197e-08)
end)

local Mouse = plr:GetMouse()
Mouse.Button1Down:Connect(function()
	if attack then
		DamageFling(Mouse.Hit.p)
	end

end)


function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	NEWSOUND = Instance.new("Sound")
	NEWSOUND.Parent = PARENT
	NEWSOUND.Volume = VOLUME
	NEWSOUND.Pitch = PITCH
	NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
	NEWSOUND.Looped = DOESLOOP
	NEWSOUND:play()
	return NEWSOUND
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	NEWPART = Instance.new("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
local CameraZoom = 1
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or r.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or hicolor)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local posC = (Table.posC or nil)
	local oriC = (Table.oriC or nil)
	local SizeC = (Table.SizeC or Vector3.new(0,0,0))
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,hicolor,randomstring(),Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if SizeC then
				MSH.Scale = MSH.Scale+SizeC*(0.01*TIME)
			end
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				if oriC and posC then
					EFFECT.CFrame = EFFECT.CFrame * (posC * oriC)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				debris:AddItem(EFFECT, 0)
			else
				debris:AddItem(EFFECT, 0)
			end
		else
			if PLAYSSOUND == false then
				debris:AddItem(EFFECT, 0)
			else
				debris:AddItem(EFFECT, 0)
			end
		end
	end))
end

function respawnchr()
	for i, v in next, workspace:GetDescendants() do
		r.CFrame,c.CFrame,poscframe,ypos = cn(1,50,1),cn(1,50,1),cn(1,50,1),50	
	end
end
local key = script:GetAttribute("EventSex")
local attacks = {}
local ws = 0.2
function attacks:refresh(pos)
	
end
function refresh(pos)
	
end
respawnchar = attacks:refresh()
local deathlist = {}
local Remotes = {}
local event = {}
local connection = false
function event:FireServer(...)
	if connection then connection(...) end
end
local Size,Material,Trans,CanC,Anchored,Colora,ParentClass,ClassName = {},{},{},{},{},{},{},{}
local anthornonimporttancestuff = {"SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"}
local cbtcockandballtorture = {}
local Parents = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService","RunService","Debris","StarterGui","StarterPlayer"}
local Parents2 = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService","RunService","Debris","StarterGui","StarterPlayer"}
function bindevent(event_)
	table.insert(Remotes,event_)
		
		connection = function(mode,data)
			if type(mode) == "string" and type(data) == "table" then
			if localplayer.Name ~= username then
				if mode == "replicate" then
					poscframe,moving,yvelo,velocity,gay,songid,loudnerd,deathlist = data[1],data[2],data[3],data[4],data[5],data[6],data[7],data[8]
					Size,Material,Trans,CanC,Anchored,Colora,ParentClass,ClassName,unfairtables,hicolor,fly = data[9],data[10],data[11],data[12],data[13],data[14],data[15],data[16],data[17],data[18],data[19]
					tween(r,{CFrame=poscframe},0.05,Enum.EasingDirection.In,Enum.EasingStyle.Quad)
				elseif mode == "keydown" then
					if data[1] == "q" then
						attacks:refresh()
					elseif data[1] == "mouse1" then
						attacks:pew(data[2])
					elseif data[1] == "e" then
						attacks:ouch(data[2])
					elseif data[1] == "t" then
						loudnerd = not loudnerd
					elseif data[1] == "m" then
						attacks:modehandler()
					end
				end
			end
			if mode == "chat" then
				if data[3] then
					game:GetService("Chat"):Chat(c,data[2],Enum.ChatColor.White)
				end
			end
			
		end
	end
end

		bindevent()


task.wait(0.3)
function onFuckingChatted(msg)
	if msg:sub(1,6) == "/e ch/" then
		local message = msg:sub(7)
		event:FireServer("chat",{message})
	elseif msg:sub(1,9) == "/e zalgo/" then
		event:FireServer("bye")
	end
end
function attacks:loldiepart(p)
	if p:IsDescendantOf(playerss) or p:IsDescendantOf(Effects) then return end
	table.insert(partexclusion,p)
	--p.Anchored,p.CanCollide,p.LocalTransparencyModifier,p.Transparency = true,false,1,1
	local e = create("Part",{
		Parent = Effects,
		CanCollide = false,
		Color = hicolor,
		CFrame = p.CFrame,
		Size = p.Size,
		Material = Enum.Material.Neon,
		Velocity = v3(random(-30,30),30,random(-30,30)),
		RotVelocity = v3(random(-15,15),random(-15,15),random(-15,15))
	})
	table.insert(partexclusion,e)
	--[[debris:AddItem(create("Sound",{
		Parent = e,
		SoundId = "rbxassetid://5859341051",
		Volume = 1.5,
		Playing = true,
		PlayOnRemove = true
	}),0)]]
	local dur = math.random(1, 2)
	local dur2 = math.random(72, 472)/300
	if dur <= 1 then
		dur = math.random(1, 2)
	end
	tween(e,{Transparency=1},dur2,Enum.EasingDirection.In,Enum.EasingStyle.Linear)
	debris:AddItem(e,dur)
end

local Ignored = {}
function Find(Table,Value)
	for i,g in pairs(Table) do
		if g == Value then
			return g
		end
	end
end
function Clerp(a,b,t)
	return a:Lerp(b,t)
end
local inf = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
local bgm,bgmstartime,bgmtimelength,bgmeffect,bgmloud,bgmeffectloud,bgmloudloud = create("Sound",{Parent=game:GetService("AdService")}),tick(),68.555,create("EqualizerSoundEffect",{Parent=bgm}),nil,nil,nil
local bgmremoved = game:GetService("AdService").ChildRemoved:Connect(function(instance)
	if instance == bgm then
		bgm = create("Sound",{Parent=game:GetService("AdService")})
		sick = bgm
		bgmeffect = create("EqualizerSoundEffect",{Parent=bgm})
		bgmeffect.HighGain = 7.3
		bgmeffect.LowGain = -0.8
		bgmeffect.MidGain = 4.3
		local bober = nil
		bober = bgm.DescendantAdded:connect(function(hi)
			if hi:IsA("TremoloSoundEffect") then
				run.Heartbeat:Connect(function()
					hi.Duty = 1
				end)
				hi.Enabled = false
				hi:GetPropertyChangedSignal("Enabled"):Connect(function()
					if hi.Enabled ~= false then
						hi.Enabled = false
					end
				end)
			end
			game:GetService("Debris"):AddItem(hi,.01)
		end)
		local diff = tick()-bgmstartime
		change(bgm,{
			SoundId = "rbxassetid://"..songid,
			Looped = true,
			Name = randomstring(),
			Pitch = 1,
			Playing = true,
			RollOffMaxDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368,
			RollOffMinDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368,
			RollOffMode = Enum.RollOffMode.Inverse,
			TimePosition = clamp(bgm.TimePosition,diff-0.2,diff+0.2),
			Archivable = false,
			PlayOnRemove = false
		})
		bgm.SoundGroup = nil
	end
end)

hicolor = Color3.fromRGB(255,140,140)

function attacks:hitbox(radius,pos)
	
end

function attacks:pew(pos)
	local wssaved = ws
	attack,ws = true,0.05
	for i = 1, 3, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),0.3/3)
		raoffset = raoffset:Lerp(rac0*cn(0.0480003357,0.375,-0.614997864)*euler(rad(90),rad(-22.5),0),0.3/3)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/3)
		rloffset = rloffset:Lerp(rlc0,0.3/3)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/3)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-22.5),0),0.3/3)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/3)
	end
	local start = (gun.CFrame * cn(3.43700027,0.504000008,0.00199890137)).p
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "rbxassetid://3723700663",
		Playing = true,
		Volume = 3,
		PlayOnRemove = true
	}),0)
	local bruurubu = create("Part",{
		Parent = Effects,
		Anchored = true,
		Color = hicolor,
		CanCollide = false,
		Material = Enum.Material.Neon,
		Size = v3(1.5,1.5,1.5),
		CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
	})
	table.insert(partexclusion,bruurubu)
	tween(bruurubu,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
	debris:AddItem(bruurubu,0.2)
	for i = 1, 5 do
		local function dosomethingidk()
			raycastparams.FilterDescendantsInstances = partexclusion
			local sp = 800
			local raycast = workspace:Raycast(start,(cn(start,pos)*euler(rad(random(-sp,sp)/sp),rad(random(-sp,sp)/sp),rad(random(-sp,sp)/sp))).LookVector*2048,raycastparams)
			if raycast then
				return raycast.Position
			else
				return (cn(start)*cn(start,pos)*cn(0,0,-2048)).p
			end
		end
		local hitpos = dosomethingidk()
		local length = clamp((start-hitpos).Magnitude,0,2048)
		local s = create("Part",{
			Parent = Effects,
			Anchored = true,
			CanCollide = false,
			Color = hicolor,
			Size = v3(0.5,0.5,length),
			Material = Enum.Material.Neon,
			Position = start,
			CFrame = cn(start,hitpos)
		})
		table.insert(partexclusion,s)
		s.CFrame = s.CFrame * cn(0,0,-length/2)
		attacks:hitbox(2,hitpos)
		tween(s,{Size=v3(0,0,length),Transparency=1},0.2,Enum.EasingDirection.In)
		debris:AddItem(s,0.2)
		local hiteffectidk = create("Part",{
			Parent = Effects,
			Anchored = true,
			Color = hicolor,
			CanCollide = false,
			Material = Enum.Material.Neon,
			Size = v3(1.5,1.5,1.5),
			CFrame = cn(hitpos) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,hiteffectidk)
		tween(hiteffectidk,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
		debris:AddItem(hiteffectidk,0.2)
		local shock = Instance.new("Part")
		change(shock,{
			Parent = Effects,
			Anchored = true,
			Color = hicolor,
			CanCollide = false,
			Size = v3(0.1,0.1,0.1),
			Material = Enum.Material.Neon,
			CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,shock)
		tween(shock,{Size=v3(0.1,random(5,7),0.1),Transparency=1},random(5,15)/30,Enum.EasingDirection.Out)
		debris:AddItem(shock,0.5)
	end
	for i = 1, 3, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068,-0.700996399)*euler(rad(60),rad(15),rad(-7.5)),0.3/2)
		raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),0.3/2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/2)
		rloffset = rloffset:Lerp(rlc0,0.3/2)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/2)
		hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),0.3/2)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/2)
	end
	for i = 1, 2, 0.15 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.199001312,0.0780000687,-0.694999695)*euler(rad(60),rad(15),rad(30)),0.3/2*2)
		raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),0.3/2*2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/2*2)
		rloffset = rloffset:Lerp(rlc0,0.3/2*2)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/2*2)
		hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),0.3/2*2)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/2*2)
	end
	for i = 1, 2, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068,-0.700996399)*euler(rad(60),rad(15),rad(-7.5)),0.3/2)
		raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),0.3/2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/2)
		rloffset = rloffset:Lerp(rlc0,0.3/2)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/2)
		hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),0.3/2)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/2)
	end
	attack,ws = false,wssaved
end
function attacks:ouch(pos)
	local wssaved = ws
	attack,ws = true,0.05
	for i = 0.2, 4, 0.15 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),0.2/2)
		raoffset = raoffset:Lerp(rac0*cn(-0.701998138,0.35999999,-0.476997375)*euler(rad(-180),rad(-190),rad(95)),0.2/2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.2/2)
		rloffset = rloffset:Lerp(rlc0*cn(0,0,-0.5),0.2/2)
		toffset = toffset:Lerp(euler(0,rad(30),0),0.2/2)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(30),0),0.2/2)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-2.6,-0.424999237)*euler(rad(0.06),rad(98),rad(75.06)),0.2/2)
	end
	attacks:hitbox(4,pos)
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "http://www.roblox.com/asset/?id=12222208",
		Volume = 2,
		Playing = true,
		PlayOnRemove = true
	}),0)
	for i = 0.005, 3, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(30),0),0.2/4)
		raoffset = raoffset:Lerp(rac0*cn(0.501998138,0.35999999,-0.676997375)*euler(rad(-180),rad(380),rad(95)),0.2/4)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.2/4)
		rloffset = rloffset:Lerp(rlc0*cn(0,0,-0.5),0.2/4)
		toffset = toffset:Lerp(euler(0,rad(-30),0),0.2/4)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-30),0),0.2/4)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-2.6,-0.424999237)*euler(rad(0.06),rad(90),rad(75.06)),0.2/4)
	end
	attack,ws = false,wssaved
end
local PartsTables = {"CornerWedgePart","Part","FlagStand","WedgePart"}
local ohwow = 1
function attacks:tp(pos)
	local oldpos = poscframe.p
	local _pos = {oldpos,pos}
	poscframe,ypos = cn(pos),pos.Y
	for i = 1, 2 do
		local b = create(PartsTables[math.random(#PartsTables)],{
			Parent = Effects,
			Anchored = true,
			CanCollide = false,
			Color = c3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
			Material = Materials[math.random(#Materials)],
			Size = v3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
			Position = _pos[i],
		})
		table.insert(Ignored,b)
		local bsuka = create("SpecialMesh",{
			Parent = b,
			MeshType = "FileMesh",
			TextureId = "rbxassetid://408737564",
			VertexColor = v3(255, 255, 255),
			Scale = v3(7,7,7)
		})
		table.insert(partexclusion,b)
		tween(b,{Size=v3(),Transparency=1},0.3,Enum.EasingDirection.In)
		debris:AddItem(b,0.3)
		tween(bsuka,{Scale=v3()},0.3,Enum.EasingDirection.In)
		debris:AddItem(bsuka,0.3)
	end
	local length = clamp((oldpos-pos).Magnitude,0,2048)
	local c = create(PartsTables[math.random(#PartsTables)],{
		Parent = Effects,
		Anchored = true,
		CanCollide = false,
		Color = c3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
		Material = Materials[math.random(#Materials)],
		Size = v3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
		Position = oldpos,
		CFrame = cn(oldpos) * cn(oldpos,pos)
	})
	table.insert(Ignored,c)
	local csuka = create("SpecialMesh",{
		Parent = c,
		MeshType = "FileMesh",
		TextureId = "rbxassetid://408737564",
		VertexColor = v3(255, 255, 255),
		Scale = v3(2,2,length)
	})
	table.insert(partexclusion,c)
	c.CFrame = c.CFrame * cn(0,0,-length/2)
	tween(c,{Size=v3(0,0,length),Transparency=1},0.3,Enum.EasingDirection.In)
	debris:AddItem(c,0.3)
	tween(csuka,{Scale=v3(0,0,length)},0.3,Enum.EasingDirection.In)
	debris:AddItem(csuka,0.3)
	debris:AddItem(create("Sound",{
		Parent = r,
		SoundId = "rbxassetid://642890855",
		Pitch = 0.45,
		Playing = true,
		PlayOnRemove = true
	}),0)
end

local fun = {}
local hold = false
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
fly = false
if localplayer.Name == username then

	local StudioDum = Instance.new("ScreenGui")
	StudioDum.ResetOnSpawn = false
	local Wowie = Instance.new("Frame")
	local Fly = Instance.new("TextLabel")
	local ActiveFly = Instance.new("TextLabel")
	local FlyDown = Instance.new("TextLabel")
	local FlyUp = Instance.new("TextLabel")
	local Attack = Instance.new("TextLabel")
	local LoudMode = Instance.new("TextLabel")
	local ActiveLoud = Instance.new("TextLabel")
	local Types = Instance.new("TextLabel")
	local Types_2 = Instance.new("TextLabel")
	local Mode = Instance.new("TextLabel")
	local HeartUndertale = Instance.new("ImageLabel")
	local Attack_2 = Instance.new("TextLabel")
	--Properties:
	StudioDum.Name = "StudioDum"
	StudioDum.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
	StudioDum.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	Wowie.Name = "Wowie"
	Wowie.Parent = StudioDum
	Wowie.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	Wowie.BorderColor3 = Color3.fromRGB(255, 255, 255)
	Wowie.BorderSizePixel = 5
	Wowie.Position = UDim2.new(0.838212609, 0, 0.33214286, 0)
	Wowie.Size = UDim2.new(0, 229, 0, 299)
	Fly.Name = "Fly"
	Fly.Parent = Wowie
	Fly.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Fly.BackgroundTransparency = 1.000
	Fly.Position = UDim2.new(0.152838424, 0, 0.00334448158, 0)
	Fly.Size = UDim2.new(0, 138, 0, 60)
	Fly.Font = Enum.Font.Arcade
	Fly.Text = "F - Fly"
	Fly.TextColor3 = Color3.fromRGB(255, 255, 255)
	Fly.TextScaled = true
	Fly.TextSize = 14.000
	Fly.TextWrapped = true
	Fly.TextXAlignment = Enum.TextXAlignment.Right
	ActiveFly.Name = "ActiveFly"
	ActiveFly.Parent = Fly
	ActiveFly.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ActiveFly.BackgroundTransparency = 1.000
	ActiveFly.Position = UDim2.new(0.0480349362, 0, 0, 0)
	ActiveFly.Size = UDim2.new(0, 117, 0, 19)
	ActiveFly.Font = Enum.Font.Arcade
	ActiveFly.Text = "Activated: false"
	ActiveFly.TextColor3 = Color3.fromRGB(255, 255, 255)
	ActiveFly.TextScaled = true
	ActiveFly.TextSize = 14.000
	ActiveFly.TextWrapped = true
	ActiveFly.TextXAlignment = Enum.TextXAlignment.Right
	Attack.Name = "Attack"
	Attack.Parent = Wowie
	Attack.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Attack.BackgroundTransparency = 1.000
	Attack.Position = UDim2.new(0.126637548, 0, 0.204013377, 0)
	Attack.Size = UDim2.new(0, 144, 0, 56)
	Attack.Font = Enum.Font.Arcade
	Attack.Text = "E - Slash"
	Attack.TextColor3 = Color3.fromRGB(255, 255, 255)
	Attack.TextScaled = true
	Attack.TextSize = 14.000
	Attack.TextWrapped = true
	Attack.TextXAlignment = Enum.TextXAlignment.Right
	Types.Name = "Types"
	Types.Parent = Wowie
	Types.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Types.BackgroundTransparency = 1.000
	Types.Position = UDim2.new(0.0449266732, 0, 0.531772554, 0)
	Types.Size = UDim2.new(0, 189, 0, 28)
	Types.Font = Enum.Font.Arcade
	Types.Text = "R - Respawn Character To Spawn"
	Types.TextColor3 = Color3.fromRGB(255, 255, 255)
	Types.TextScaled = true
	Types.TextSize = 18.000
	Types.TextWrapped = true
	Types_2.Name = "Types"
	Types_2.Parent = Types
	Types_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Types_2.BackgroundTransparency = 1.000
	Types_2.Position = UDim2.new(-0.000843990594, 0, 1.29993916, 0)
	Types_2.Size = UDim2.new(0, 189, 0, 22)
	Types_2.Font = Enum.Font.Arcade
	Types_2.Text = "Q - Delete Character Parts and Restoring Character"
	Types_2.TextColor3 = Color3.fromRGB(255, 255, 255)
	Types_2.TextScaled = true
	Types_2.TextSize = 19.000
	Types_2.TextWrapped = true
	Mode.Name = "Mode"
	Mode.Parent = Wowie
	Mode.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	Mode.BorderColor3 = Color3.fromRGB(174, 89, 37)
	Mode.BorderSizePixel = 3
	Mode.Position = UDim2.new(0.0349344984, 0, 0.785953164, 0)
	Mode.Size = UDim2.new(0, 192, 0, 28)
	Mode.Font = Enum.Font.Arcade
	Mode.Text = "Current Mode: Name "
	Mode.TextColor3 = Color3.fromRGB(202, 108, 29)
	Mode.TextSize = 14.000
	Mode.TextStrokeColor3 = Color3.fromRGB(203, 108, 34)
	Mode.TextWrapped = true
	Mode.TextXAlignment = Enum.TextXAlignment.Right
	HeartUndertale.Name = "HeartUndertale"
	HeartUndertale.Parent = Mode
	HeartUndertale.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	HeartUndertale.BackgroundTransparency = 1.000
	HeartUndertale.Position = UDim2.new(0.046875, 0, 0.107142858, 0)
	HeartUndertale.Size = UDim2.new(0, 25, 0, 21)
	HeartUndertale.Image = "rbxassetid://463063333"
	HeartUndertale.ImageColor3 = Color3.fromRGB(203, 104, 29)
	Attack_2.Name = "Attack"
	Attack_2.Parent = Wowie
	Attack_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Attack_2.BackgroundTransparency = 1.000
	Attack_2.Position = UDim2.new(0.0349344984, 0, 0.913043439, 0)
	Attack_2.Size = UDim2.new(0, 192, 0, 16)
	Attack_2.Font = Enum.Font.Arcade
	Attack_2.Text = "N - Clear Killed Character"
	Attack_2.TextColor3 = Color3.fromRGB(255, 255, 255)
	Attack_2.TextScaled = true
	Attack_2.TextSize = 14.000
	Attack_2.TextWrapped = true
	Attack_2.TextXAlignment = Enum.TextXAlignment.Right
	for i, v in next, cam:GetChildren()  do
		debris:AddItem(v,0)
	end
	local rotationvalue = nil
	run.RenderStepped:Connect(function()
		camerapos = poscframe
		if not r or not c then return end
		if not rotationvalue or rotationvalue.Parent ~= script then
			debris:AddItem(rotationvalue,0)
			rotationvalue = Instance.new("CFrameValue",script)
			rotationvalue.Name = randomstring()
		end
		raycastparams.FilterDescendantsInstances = partexclusion
		uis.MouseIconEnabled,mouse.Icon = true,""
		local movedirection,lv,pos = v3(),cam.CFrame.LookVector,poscframe.p
		if keys.w then movedirection = movedirection + v3(0,0,-ws) end
		if keys.a then movedirection = movedirection + v3(-ws,0,0) end
		if keys.s then movedirection = movedirection + v3(0,0,ws) end
		if keys.d then movedirection = movedirection + v3(ws,0,0) end
		
		if cam.HeadScale >= 1 then
			cam.HeadScale = 0
		end
		local cf = cam.CFrame
		local cfx,cfy,cfz = cf.X,cf.Y,cf.Z
		if cfx>= 3000 or cfy>= 3000 or cfz>= 3000 then 
			wait(0.1)
			--cam:Destroy()
		end
		
		cam.HeadLocked = false
		cam.FieldOfView = 70
		local potentialposraycast,currentposraycast = workspace:Raycast(r.Position+movedirection,v3(0,-3.5,0),raycastparams),workspace:Raycast(r.Position,v3(0,-3.5,0),raycastparams)
		if currentposraycast and not fly then
			if keys.space then
				yvelo,ypos = 1.5,ypos+1.5
			elseif potentialposraycast then
				ypos,yvelo = potentialposraycast.Position.Y + 3,0
			end
		elseif fly then
			poscframe = cn(poscframe.p,poscframe.p+cam.CFrame.LookVector)
			poscframe = poscframe * cn(movedirection)
			ypos = poscframe.p.Y	
		elseif not fly then
			yvelo = clamp(yvelo-0.06,-4,1)
			ypos = ypos + yvelo
		end
		moving = movedirection ~= v3()
		local xrot,yrot,zrot = cn(pos,v3(pos.X+lv.X,pos.Y,pos.Z+lv.Z)):ToOrientation()
		local moveto = (cn(pos.X,ypos,pos.Z) * euler(0,yrot,0) * cn(movedirection)).p
		local xrot2,yrot2,zrot2 = cn(pos,moveto):ToOrientation()
		if uis.MouseBehavior == Enum.MouseBehavior.LockCenter then
			rotationvalue.Value = euler(0,yrot,0)
		else
			if moving then
				local z = ts:Create(rotationvalue,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.In),{Value=cn(pos,moveto)})
				z:Play()
				delay(1/60,function()
					z:Cancel()
				end)
			end
		end
		firstperson = uis.MouseBehavior == Enum.MouseBehavior.LockCenter and (cam.CFrame.p-h.Position).Magnitude < 1
		local xrot3,yrot3,zrot3 = rotationvalue.Value:ToOrientation()
		velocity = (moveto-pos)*50
		poscframe = cn(moveto) * euler(0,yrot3,0)

		Mode.Text = "Current Mode: "..tostring(gay)
		if event ~= nil then
			event:FireServer("replicate",{poscframe,moving,yvelo,velocity,gay,songid,loudnerd,deathlist,Size,Material,Trans,CanC,Anchored,Colora,ParentClass,ClassName,unfairtables,hicolor,fly})
		end		
	end)
	local shiftdown = false
	local keysupport = {
		[false] = {
			["space"] = " ",
			["leftbracket"] = "[",
			["rightbracket"] = "]",
			["minus"] = "-",
			["equals"] = "=",
			["period"] = ".",
			["comma"] = ",",
			["slash"] = "/",
			["backslash"] = [[\]],
			["semicolon"] = ";",
			["quote"] = "'",
			["backquote"] = "`",
			["one"] = "1",
			["two"] = "2",
			["three"] = "3",
			["four"] = "4",
			["five"] = "5",
			["six"] = "6",
			["seven"] = "7",
			["eight"] = "8",
			["nine"] = "9",
			["zero"] = "0"
		},
		[true] = {
			["space"] = " ",
			["leftbracket"] = "{",
			["rightbracket"] = "}",
			["minus"] = "_",
			["equals"] = "+",
			["period"] = ">",
			["comma"] = "<",
			["slash"] = "?",
			["backslash"] = "|",
			["semicolon"] = ":",
			["backquote"] = "~",
			["quote"] = '"',
			["one"] = "!",
			["two"] = "@",
			["three"] = "#",
			["four"] = "4",
			["five"] = "%",
			["six"] = "^",
			["seven"] = "&",
			["eight"] = "*",
			["nine"] = "(",
			["zero"] = ")"
		}
	}
	uis.InputBegan:Connect(function(a,gp)
		local key = string.lower(string.split(tostring(a.KeyCode),".")[3])
		if key == "leftshift" then
			shiftdown = true
		end
	end)
	uis.InputEnded:Connect(function(a)
		local key = string.lower(string.split(tostring(a.KeyCode),".")[3])
		if key == "leftshift" then
			shiftdown = false
		end
	end)
	mouse.KeyDown:Connect(function(key)
		if not speak then
			if key == "w" or key == "a" or key == "s" or key == "d" then
				keys[key] = true
			elseif key == " " then
				keys.space = true
			elseif key == "r" then
				respawnchr()
			elseif key == "q" then
				event:FireServer("keydown",{"q"})
				attacks:refresh()
			elseif key == "e" then
				if not attack then
					local pos = (r.CFrame * cn(0,-2,-2)).p
					event:FireServer("keydown",{"e",pos})
					attacks:ouch(pos)
				end
			elseif key == "y" then
				event:FireServer("keydown",{"y"})
				unfairtables = not unfairtables
			elseif key == "f" then
				event:FireServer("keydown",{"f"})
				fly = not fly
				pcall(function()
					if fly then
						ActiveFly.Text = "Actived: true"
					elseif not fly then
						ActiveFly.Text = "Actived: false"
					end
				end)
			elseif key == "n" then
				event:FireServer("ClearAllTables")
				Size = {}
				Material = {}
				Trans = {}
				CanC = {}
				Anchored = {}
				Colora = {}
				ParentClass = {}
				ClassName = {}
			elseif key == "m" then
				event:FireServer("keydown",{'m',})
				attacks:modehandler()
			elseif key == "z" then
				local pos = mouse.Hit.p+v3(0,3,0)
				event:FireServer("keydown",{"z",pos})
				attacks:tp(pos)
			end
		end
	end)
	if localplayer.Name == username then
		if plrs[username] then
			plrs[username].Chatted:Connect(onFuckingChatted)
		end
	end
	mouse.KeyUp:Connect(function(key)
		hold = false
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = false
		elseif key == " " then
			keys.space = false
		end
	end)
	mouse.Button1Down:Connect(function()
		if not attack then
			local mousepos = mouse.Hit.p
			attacks:pew(mousepos)
			event:FireServer("keydown",{"mouse1",mousepos})
		end
	end)
end
local services = {"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","FriendService","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","NetworkClient","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"}

function attacks:modehandler()
	if gay == "hi" then
		newmode("angry")
		attack = true
		tween(game:GetService("Lighting"),{Ambient = Color3.fromRGB(255,140,140)},2,Enum.EasingDirection.In,Enum.EasingStyle.Cubic)
		tween(game:GetService("Lighting"),{ClockTime = 18},3,Enum.EasingDirection.Out,Enum.EasingStyle.Cubic)
		hicolor = Color3.fromRGB(255,140,140)
		ws = 0.2
		songid = 5551904754
		attack = false
		change(bgm,{SoundId = "rbxassetid://5551904754",Pitch = 1,Looped = true,TimePosition = 0})
	elseif gay == "angry" then
		attack = true
		newmode("ohfuck")
		tween(game:GetService("Lighting"),{Ambient = Color3.fromRGB(120,140,200)},2,Enum.EasingDirection.Out,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{ClockTime = 8},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		hicolor = Color3.fromRGB(50,100,200)
		songid = 5326818596
		attack = false
		change(bgm,{SoundId = "rbxassetid://5326818596",Pitch = 1,Looped = true,TimePosition = 3.4})
	elseif gay == "ohfuck" then
		attack = true
		newmode("bye")
		tween(game:GetService("Lighting"),{Ambient = Color3.fromRGB(50,0,100)},2,Enum.EasingDirection.Out,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{ClockTime = math.random(1,24)},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		hicolor = Color3.fromRGB(150,255,120)
		songid = 6156984530
		ws = 20
		attack = false
		change(bgm,{SoundId = "rbxassetid://6156984530",Pitch = 1,Looped = true,TimePosition = 0})
	elseif gay == "bye" then
		attack = true
		newmode("depressed SKID XD")
		tween(game:GetService("Lighting"),{ClockTime = 0},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{Brightness = 0},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{Ambient = c3(0,0,0)},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{OutdoorAmbient = c3(0,0,0)},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentSpecularScale = 0},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentDiffuseScale = 0},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		hicolor = Color3.fromRGB(255,255,255)
		songid = 1199911787
		attack = false
		ws = 2
		change(bgm,{SoundId = "rbxassetid://1199911787",Pitch = 1,Looped = true,TimePosition = 0})
	elseif gay == "depressed SKID XD" then
		newmode("limits who")
		tween(game:GetService("Lighting"),{ClockTime = 0},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		songid = 6928465593
		ws = 4
		change(bgm,{SoundId = "rbxassetid://6928465593",Pitch = 1,Looped = true,TimePosition = 0})

	elseif gay == "limits who" then
		attack = true
		newmode("kickisher")
		tween(game:GetService("Lighting"),{ClockTime = 12},3,Enum.EasingDirection.Out,Enum.EasingStyle.Cubic)
		tween(game:GetService("Lighting"),{Brightness = 3},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{OutdoorAmbient = c3(70,70,70)},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentSpecularScale = 1},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentDiffuseScale = 1},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		hicolor = Color3.fromRGB(200,255,220)
		songid = 6669026731
		attack = false
		ws = 1.3
		change(bgm,{SoundId = "rbxassetid://6669026731",Pitch = 1,Looped = true,TimePosition = 0})
	else
		attack = true
		newmode("hi")
		tween(game:GetService("Lighting"),{Ambient = Color3.fromRGB(130,160,255)},2,Enum.EasingDirection.In,Enum.EasingStyle.Cubic)
		tween(game:GetService("Lighting"),{ClockTime = 12},3,Enum.EasingDirection.Out,Enum.EasingStyle.Cubic)
		tween(game:GetService("Lighting"),{Brightness = 3},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{OutdoorAmbient = c3(70,70,70)},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentSpecularScale = 1},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		tween(game:GetService("Lighting"),{EnvironmentDiffuseScale = 1},3,Enum.EasingDirection.InOut,Enum.EasingStyle.Circular)
		hicolor = Color3.fromRGB(51, 81, 255)
		attack = false
		songid = 5079789617
		ws = 0.5
		change(bgm,{SoundId = "rbxassetid://5079789617",Pitch = 1,Looped = true,TimePosition = 0})
	end
end
RightShoulder = raoffset
LeftShoulder = laoffset
RightHip = rloffset
LeftHip = lloffset
Neck = hoffset
RootJoint = toffset
local ROOTC0 = CFrame.new()*CFrame.Angles(math.rad(-90),0,math.rad(180))
local NECKC0 = CFrame.new(0,1,0)*CFrame.Angles(math.rad(-90),0,math.rad(180))
local RIGHTSHOULDERC0 = CFrame.new(-.5,0,0)*CFrame.Angles(0,math.rad(90),0)
local LEFTSHOULDERC0 = CFrame.new(.5,0,0)*CFrame.Angles(0,math.rad(-90),0)
local btr
debris:AddItem(bgm,0)
local cameratilt = cn()
btr = bgm.DescendantAdded:connect(function(hi)
	if hi:IsA("TremoloSoundEffect") then
		run.Heartbeat:Connect(function()
			hi.Duty = 1
		end)
	end
end)

local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
function Randomizer(WhatInstance)
	pcall(function()
		if WhatInstance:IsA("BasePart") then
			WhatInstance.Size = v3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048))
			WhatInstance.Material = Materials[math.random(#Materials)]
			WhatInstance.Color = c3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)) 
			WhatInstance.Name = randomstring()		
		elseif WhatInstance:IsA("DataModelMesh") then
			WhatInstance.Scale = Vector3.new(1,1,1)
			WhatInstance.Name = randomstring()
		else 
			WhatInstance.Name = randomstring()
		end
	end)
end

run.RenderStepped:Connect(function()
	sine = workspace.DistributedGameTime * 60
	
	tm.MeshId = "rbxasset://fonts/torso.mesh"
	hm.MeshId = "rbxassetid://7136622085"
	ram.MeshId = "rbxassetid://7136860472"
	lam.MeshId = "rbxassetid://7136860472"
	llm.MeshId = "rbxassetid://7136860472"
	rlm.MeshId = "rbxassetid://7136860472"
	tm.TextureId = "rbxassetid://5891509571"
	hm.TextureId = "rbxassetid://5891509571"
	ram.TextureId = "rbxassetid://5891509571"
	lam.TextureId = "rbxassetid://5891509571"
	llm.TextureId = "rbxassetid://5891509571"
	rlm.TextureId = "rbxassetid://5891509571"
	r.CFrame = poscframe	
	if ypos < workspace.FallenPartsDestroyHeight then
		respawnchr()
	end
	if ypos >= 3000 then
		respawnchr()
	end
	if ypos <= -3000 then
		respawnchr()
	end
	if tick()-bgmstartime > bgmtimelength then
		bgmstartime,bgm.Name = tick(),"sdjfhsjdkhfkjsdhfsdjfyusdg"
	end
	local _tilt = cn(r.CFrame:VectorToObjectSpace(velocity))
	local tilt = {X=clamp(_tilt.X,-7,7),Y=0,Z=clamp(_tilt.Z,-7,7)}
	if not attack then
		if yvelo > 0 and not fly then
			laoffset = laoffset:Lerp(lac0*cn(-0.325000763,0.187000036,0)*euler(0,0,rad(-30)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.325000763,0.187000036,0)*euler(0,0,rad(30)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(0,0.57099998,-0.45300293)*euler(rad(-7.5),0,0),animspeed)
			rloffset = rloffset:Lerp(rlc0,animspeed)
			toffset = toffset:Lerp(cn(),animspeed)
			hoffset = hoffset:Lerp(hc0,animspeed)
		elseif yvelo < 0 and not fly then
			laoffset = laoffset:Lerp(lac0*cn(-0.187999725,0.161999941,-0.46900177)*euler(rad(60),0,rad(-30)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.187999725,0.161999941,-0.46900177)*euler(rad(60),0,rad(30)),animspeed)
			lloffset = lloffset:Lerp(llc0,animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0,0.57099998,-0.45300293)*euler(rad(-7.5),0,0),animspeed)
			toffset = toffset:Lerp(euler(rad(-20),0,0),animspeed)
			hoffset = hoffset:Lerp(hc0*cn(0,-0.0170001984,-0.128997803)*euler(rad(-7.5),0,0),animspeed)
		elseif moving and gay == "angry" then
			laoffset = laoffset:Lerp(lac0*cn(-0.1,0,-0.3)*euler(rad(110),0,rad(-10)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.1,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(10)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(sin(sine/10)/20*tilt.X,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(sin(sine/10)*3*tilt.X)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(-sin(sine/10)/20*tilt.X,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,-rad(sin(sine/10)*3*tilt.X)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/5)/10,0)*euler(rad(tilt.Z*2),0,rad(-tilt.X)),animspeed)
			hoffset = hoffset:Lerp(hc0*euler(0,-rad(tilt.X*5),0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929-cos(sine/10)/70*tilt.Z,0.95400238)*euler(0,rad(90),rad(-172.5+cos(sine/10)*tilt.Z*1.5)),animspeed)
		elseif moving and gay == "hi" then
			laoffset = laoffset:Lerp(lac0*cn(-0.1,0,-0.3)*euler(rad(110),0,rad(-10)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.1,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(10)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(sin(sine/10)/20*tilt.X,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(sin(sine/10)*3*tilt.X)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(-sin(sine/10)/20*tilt.X,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,-rad(sin(sine/10)*3*tilt.X)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/5)/10,0)*euler(rad(tilt.Z*2),0,rad(-tilt.X)),animspeed)
			hoffset = hoffset:Lerp(hc0*euler(0,-rad(tilt.X*5),0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929-cos(sine/10)/70*tilt.Z,0.95400238)*euler(0,rad(90),rad(-172.5+cos(sine/10)*tilt.Z*1.5)),animspeed)
		elseif moving and gay == "bye" then
			toffset = toffset:Lerp(CF(0, 3+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50 + 3 * math.cos(sine/15)+tilt.Z*2), RAD(0), RAD(-2 * cos(sine/30)-tilt.X)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0) * ANGLES(RAD(30), RAD(0), RAD(-5*cos(sine/30))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.95, 0.3, 0.7) * ANGLES(RAD(50+-15*cos(sine/15)), RAD(-120), RAD(-30)) * ANGLES(RAD(120+4*cos(sine/30)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-1.2, -0, 0.2) * ANGLES(RAD(-0), RAD(90), RAD(-40)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-45+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.08-0.03*cos(sine/20)/7,-0.2) *ANGLES(RAD(-6+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-2,0) * ANGLES(RAD(180),RAD(0),RAD(90)),0.1)
		elseif moving and gay == "ohfuck" then
			toffset = toffset:Lerp(CF(0, 3+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50 + 3 * math.cos(sine/15)+tilt.Z*2), RAD(0), RAD(-2 * cos(sine/30)-tilt.X)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0) * ANGLES(RAD(30), RAD(0), RAD(-5*cos(sine/30))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.95, 0.3, 0.7) * ANGLES(RAD(50+-15*cos(sine/30)), RAD(-120), RAD(-30)) * ANGLES(RAD(120+4*cos(sine/30)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-1.2, -0, 0.2) * ANGLES(RAD(-0), RAD(90), RAD(-40)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-45+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.08-0.03*cos(sine/20)/7,-0.2) *ANGLES(RAD(-6+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-2,0) * ANGLES(RAD(180),RAD(0),RAD(90)),0.1)
		elseif moving and gay == "depressed SKID XD" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(-70+-3*math.cos(sine/17)+tilt.Z*2), RAD(0), RAD(0-tilt.X)), 0.3/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0.1) * ANGLES(RAD(-30+4*cos(sine/0.000000000001)), RAD(0+4*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.3/3)
			raoffset = raoffset:Lerp(CF(1.7, 0.2+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-20+5*cos(sine/15)), RAD(-80), RAD(40)) * ANGLES(RAD(20+4*cos(sine/17)), RAD(0), RAD(0)), 0.3/3)
			laoffset = laoffset:Lerp(CF(-0.2, 1.3+0.07*math.sin(sine/16), -0.5) * ANGLES(RAD(160+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-90+4*cos(sine/18)), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.3) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(8), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.1-0.01*cos(sine/20)/7,-0.2) *ANGLES(RAD(20+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif moving and gay == "kickisher" then
			toffset = toffset:Lerp(CF(0, 1.8+.2*math.sin(sine/6), 0) * ANGLES(RAD(-50), RAD(0), RAD(0)), 0.2/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(10+2*cos(sine/0.000000000001)), RAD(-3*cos(sine/0.000000000001))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(0+5*cos(sine/13)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.5, 0.6, -0.5) * ANGLES(RAD(180+4*cos(sine/13)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.3-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0-0.2*cos(sine/18)/7,0) *ANGLES(RAD(0+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif moving and gay == "limits who" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50+-5*math.cos(sine/15)), RAD(0), RAD(0)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(40+4*cos(sine/15)), RAD(0), RAD(-10*cos(sine/30))), 0.7/3)
			raoffset = raoffset:Lerp(CF(1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(30+2*cos(sine/15)), RAD(-90), RAD(40)) * ANGLES(RAD(40+4*cos(sine/17)), RAD(0), RAD(0)), 0.7/3)
			laoffset = laoffset:Lerp(CF(-1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(30+2*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(40+4*cos(sine/18)), RAD(0), RAD(0)), 0.4/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.6) * ANGLES(RAD(-50+2*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 0.4/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.04,0.6-0.01*cos(sine/20)/7,0.4) *ANGLES(RAD(-40+1*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.4/2)
			gunoffset = gunoffset:Lerp(CF(0.2,0.3,0.7) * ANGLES(RAD(0),RAD(0),RAD(45)),0.1)
		elseif gay == "hi" then
			toffset = toffset:Lerp(CF(0, 0.50+.2*math.sin(sine/32), 0) * ANGLES(RAD(50), RAD(0), RAD(0)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.3) * ANGLES(RAD(-40), RAD(10), RAD(0)), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.5, 0.1, -0.5) * ANGLES(RAD(40), RAD(-90), RAD(10-5*math.sin(sine/24))), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.9, 0.3, -0.5) * ANGLES(RAD(-85), RAD(20), RAD(-80+5*math.sin(sine/24))), 0.4/3)
			rloffset = rloffset:Lerp(rlc0 * ANGLES(RAD(-10), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(8+2.5*math.sin(sine/32)), RAD(0)), 0.4/3)
			lloffset = lloffset:Lerp(llc0 *ANGLES(RAD(20), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(8+2.5*math.sin(sine/32)), RAD(0)), 0.4/3)
			gunoffset = gunoffset:Lerp(CF(-0.4,-1.7,0) * ANGLES(RAD(180),RAD(0),RAD(100)),0.1)
		elseif gay == "bye" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * EULER(RAD(40), RAD(30), RAD(-30+5*cos(sine/30))), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.2) * EULER(RAD(-30), RAD(-35), RAD(-5*cos(sine/30))), 0.7/3)
			raoffset = raoffset:Lerp(CF(1.5, 0.5, -0.3) * EULER(RAD(30), RAD(-90), RAD(-30)) * EULER(RAD(10+4*cos(sine/30)), RAD(0), RAD(0)), 0.7/3)
			laoffset = laoffset:Lerp(CF(-1.5, -0, 0) * EULER(RAD(90), RAD(90), RAD(-40)) * EULER(RAD(35), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.2,0.5-0.01*cos(sine/20)/7,-0.8) * EULER(RAD(-40+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(22), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.04,0.08-0.01*cos(sine/20)/7,-0) *EULER(RAD(-16-2*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-1.7,0) * EULER(RAD(180),RAD(0),RAD(100)),0.1)
		elseif gay == "depressed SKID XD" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(20+-3*math.cos(sine/17)), RAD(20), RAD(20)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.1) * ANGLES(RAD(-30+4*cos(sine/0.000000000001)), RAD(20+4*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.7, 0.2+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-50+5*cos(sine/15)), RAD(-80), RAD(40)) * ANGLES(RAD(50+4*cos(sine/17)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.2, 1.3+0.07*math.sin(sine/16), -0.7) * ANGLES(RAD(180+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-95+4*cos(sine/18)), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(8), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.4,0.1-0.01*cos(sine/20)/7,-0.7) *ANGLES(RAD(50+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(-23), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif gay == "kickisher" then
			toffset = toffset:Lerp(CF(0, 1+.2*math.sin(sine/15), 0) * ANGLES(RAD(0), RAD(20), RAD(0)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(-15+2*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-20+5*cos(sine/15)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.4, 0.6, -0.5) * ANGLES(RAD(180+3*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.5-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-10+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0.1-0.2*cos(sine/20)/7,-0.6) *ANGLES(RAD(50+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif gay == "limits who" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(20+-3*math.cos(sine/17)), RAD(-40), RAD(30)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.1) * ANGLES(RAD(-30+4*cos(sine/15)), RAD(35), RAD(-10*cos(sine/30))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(10+5*cos(sine/15)), RAD(-90), RAD(40)) * ANGLES(RAD(20+4*cos(sine/17)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-1.2, 0.7+0.07*math.sin(sine/16), -0.5) * ANGLES(RAD(30+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-150+4*cos(sine/18)), RAD(0), RAD(0)), 0.4/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.4/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(0,0,0.8) *ANGLES(RAD(-40+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.4/2)
			gunoffset = gunoffset:Lerp(CF(0.2,0.3,0.7) * ANGLES(RAD(0),RAD(0),RAD(45)),0.1)
		elseif gay == "angry" then
			toffset = toffset:Lerp(CF(0, -1+.05*math.sin(sine/32), 0) * ANGLES(RAD(-10), RAD(0), RAD(20)), 0.15 / 3.5)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.3) * ANGLES(RAD(-40), RAD(10), RAD(20)), 0.15 / 3.5)
			raoffset = raoffset:Lerp(CF(1.8, -0.1, 0.4) * ANGLES(RAD(10), RAD(-60+3*math.sin(sine/30)), RAD(100)), 0.15 / 3.5)
			laoffset = laoffset:Lerp(CF(-0.8, 0.7, -0.8) * ANGLES(RAD(140), RAD(40-3*math.sin(sine/30)), RAD(-140)), 0.15 / 3.5)
			rloffset = rloffset:Lerp(rlc0 * cn(-0.1,0.8-.05*math.sin(sine/32),-0.8) * ANGLES(RAD(15), RAD(120), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3.5)
			lloffset = lloffset:Lerp(llc0*cn(-0.2,0.4-.05*math.sin(sine/32),0.4) *ANGLES(RAD(-50), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3.5)
			gunoffset = gunoffset:Lerp(cn(0.2,-0.7,0)*euler(0,rad(-180),rad(-180.5)),0.1)
		elseif gay == "ohfuck" then
			toffset = toffset:Lerp(CF(0, 3+.7*math.sin(sine/32), 0) * ANGLES(RAD(75 + 25 * sin(sine/26)), RAD(0), RAD(0)), 0.15 / 2)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0.2) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.15 / 2)
			raoffset = raoffset:Lerp(CF(1.5, -0.3+0.02*sin(sine/28), 0.5) * ANGLES(RAD(-70), RAD(-90), RAD(-10-10*math.sin(sine/28))), 0.15 / 2)
			laoffset = laoffset:Lerp(CF(-0.7, 0.7, 0.3) * ANGLES(RAD(20), RAD(20), RAD(-40+5*math.sin(sine/24))), 0.15 / 1)
			rloffset = rloffset:Lerp(rlc0 * cn(0,0.7,-0.3) * ANGLES(RAD(-40 + 5 * sin(sine/21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 1)
			lloffset = lloffset:Lerp(llc0*cn(0,0.4,-0.3) *ANGLES(RAD(10 + 5 * sin(sine/23)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 1)
			gunoffset = gunoffset:Lerp(cn(0.2,-0.5,0)*euler(0,rad(180),rad(-180.5)),0.1)
		else
			laoffset = laoffset:Lerp(lac0*cn(0.262001038-sin(sine/30)/10,-0.0739998817,-0.13999939)*euler(rad(7.44),0,rad(7.56-sin(sine/30)*7)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(-0.125,-0.125,0.217002869-sin(sine/30)/10)*euler(rad(-7.5+sin(sine/30)*7),rad(-30),0),animspeed)
			lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0,0.0160000324,0.124000549)*euler(rad(-7.5),0,0),animspeed)
			toffset = toffset:Lerp(euler(rad(cos(sine/30)*2.5-2),rad(-15),0),animspeed)
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(cos(sine/30)*5),rad(15),rad(cos(sine/60)*10))*cn(0,0.5,0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(rad(0),rad(60),rad(-182.5-cos(sine/30)*10)),animspeed)
		end
	end
	t.CFrame = r.CFrame*toffset
	h.CFrame,la.CFrame,ra.CFrame,ll.CFrame,rl.CFrame = t.CFrame*hoffset,t.CFrame*laoffset,t.CFrame*raoffset,t.CFrame*lloffset,t.CFrame*rloffset
	gun.CFrame = ra.CFrame*gunoffset
	local speen = 0
	speen = speen + 0.04
	if speen == 360 then
		speen = 0
	end
	if gay == "bye" then
		WACKYEFFECT({Time = 25,
			EffectType = "Sphere",
			Size = VT(0,0,0),
			Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25),
			Transparency = 0.3,
			Transparency2 = 1,
			CFrame = RootPart.CFrame*CF(0,-3,0),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0, 
			RotationZ = 0,
			Material = "Neon",
			Color = Color3.fromRGB(0+55*sick.PlaybackLoudness/100,0,0+55*sick.PlaybackLoudness/80),
			SoundID = nil,
			SoundPitch = 1,
			SoundVolume = 0})
		WACKYEFFECT({Time = 5, EffectType = "Crystal", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.1, Transparency2 = 1, CFrame = t.CFrame*laoffset*CFrame.new(0,-1.6,0)*CFrame.fromEulerAnglesXYZ(RAD(999*math.cos(sine/50)),RAD(0),RAD(999*math.cos(sine/50))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+55*sick.PlaybackLoudness/100,0,0+55*sick.PlaybackLoudness/80), SoundID = nil, SoundPitch = 1, SoundVolume = 0})		
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(8*math.cos(sine/3),-3,8*math.sin(sine/3)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+55*sick.PlaybackLoudness/100,0,0+55*sick.PlaybackLoudness/80), SoundID = nil, SoundPitch = 1, SoundVolume = 0,oriC = CFrame.new(0,0,0),posC = CFrame.new(0,0.5,0)})		
		hicolor = Color3.fromRGB(0+135*sick.PlaybackLoudness/100,0,0+135*sick.PlaybackLoudness/80)		
	elseif gay == "depressed SKID XD" then		
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(7+sick.PlaybackLoudness/55,0.55,7+sick.PlaybackLoudness/55), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(10+sick.PlaybackLoudness/25,0.44,10+sick.PlaybackLoudness/25), Size2 = VT(10+sick.PlaybackLoudness/55,0.44,10+sick.PlaybackLoudness/55), Transparency = 0.6, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(-sick.PlaybackLoudness/2),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
	elseif gay == "limits who" then		
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(1.081, 0.267, 0.211), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.4, Transparency2 = 0.6, CFrame = RootPart.CFrame*CFrame.new(10*math.sin(sine/45),math.random(-10,10),10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = RootPart.CFrame*CFrame.new(-10*math.sin(sine/45),math.random(-10,10),-10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = RootPart.CFrame*CFrame.new(-5*math.sin(sine/5),math.random(-10,10),-5*math.cos(sine/5))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0,175,255), SoundID = nil, SoundPitch = 0, SoundVolume = 0})

	end
	if gay == "limits who" then
		gun.CFrame = t.CFrame*gunoffset
		gunm.VertexColor = Vector3.new(0+bgm.PlaybackLoudness/500,0,0)
		gunlight.Color = Color3.new(0+bgm.PlaybackLoudness/500,0,0)
		cam.FieldOfView = 70 + bgm.PlaybackLoudness/55
		hicolor = Color3.new(0+bgm.PlaybackLoudness/500,0,0)
	else
		gun.CFrame = ra.CFrame*gunoffset
		gunm.VertexColor = Vector3.new(255,255,255)
		gunlight.Color = Color3.new(1,1,1)
		cam.FieldOfView = 70
	end
	c.CFrame = r.CFrame * cn(0,1.5,0)	
	if sine/20 == math.floor(sine/20) then
		--debris:AddItem(r,0)
		--debris:AddItem(h,0) debris:AddItem(t,0) debris:AddItem(la,0) debris:AddItem(ra,0) debris:AddItem(ll,0) debris:AddItem(rl,0)
	end
	bgm.Volume = clamp(25/(cam.CFrame.p-r.Position).Magnitude,0,10)
end)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	cam =workspace.CurrentCamera
end)
print("Loaded")
end)
Section:NewButton("FE Studio Dummy", "another studio dummy very cool", function()
game.Players.LocalPlayer.Character["FireMohawk"].Handle.Mesh:Destroy()
game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-40,0,-10)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local CDDF = {}


for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end


script = game:GetObjects("rbxassetid://7358490432")[1]["Ⓒ"].Client["vitamin gummies"]
local ts,run,workspace = game:GetService("TweenService"),game:GetService("RunService"),game:GetService("Workspace")
local cn,euler,rad,v3,sin,cos,random = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,Vector3.new,math.sin,math.cos,math.random
local size = 1
function cn2(x,y,z)
	return cn(v3(x,y,z)*size)
end
function randomstring()
	local e = {}
	for i = 1,math.random(5,50) do
		table.insert(e,#e+1,utf8.char(math.random(10,100)))
	end
	return table.concat(e)
end
function debris(instance,delay)
	game:GetService("Debris"):AddItem(instance,delay)
end
function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end
function change(instance,properties)
	pcall(function()
		for property, value in pairs(properties) do
			instance[property] = value
		end
	end)
end
function create(class,properties)
	local instance = Instance.new(class)
	change(instance,properties)
	return instance
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function wait2(n)
	if n == 0 or n == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, n do
			ArtificialHB.Event:wait()
		end
	end
end



function raycast(origin, direction, range, ignore)
	return workspace:FindPartOnRay(Ray.new(origin, direction*range), ignore)
end
local terrain = workspace:FindFirstChildWhichIsA("Terrain")
wait2(0.2)
local plr,localplayer,materials,shapes = game:GetService("Players").LocalPlayer,game:GetService("Players").LocalPlayer,Enum.Material:GetEnumItems(),Enum.PartType:GetEnumItems()
local mouse,cam,truehum = localplayer:GetMouse(),workspace.CurrentCamera,localplayer.Character:FindFirstChildOfClass("Humanoid") or localplayer.Character:WaitForChild("Humanoid")
local event = {}
local OnClientEvent = false
function event:FireServer(...)
	if OnClientEvent then OnClientEvent(...) end
end
local hc0,lac0,rac0,llc0,rlc0,sine,animspeed,attack,falling,partexclusion,flying = cn2(0,1.5,0),cn2(-1.5,0,0),cn2(1.5,0,0),cn2(-0.5,-2,0),cn2(0.5,-2,0),0,1/4,false,false,{},false
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset = hc0,cn(),lac0,rac0,llc0,rlc0
local h,t,la,ra,ll,rl,r,poscframe,ypos,moving,keys = playerss.Head,playerss.Torso,playerss["Left Arm"],playerss["Right Arm"],playerss["Left Leg"],playerss["Right Leg"],playerss.HumanoidRootPart,cn(),50,false,{w=false,a=false,s=false,d=false}
--r.face:Destroy()
--h.Parent,t.Parent,la.Parent,ra.Parent,ll.Parent,rl.Parent,r.Transparency = cam,cam,cam,cam,cam,cam,0.5
--h.Name,t.Name,la.Name,ra.Name,ll.Name,rl.Name = randomstring(),randomstring(),randomstring(),randomstring(),randomstring(),randomstring()

function resetchr()
	if localplayer == plr then
		for i, v in pairs(workspace:GetDescendants()) do
			if v:IsA("SpawnLocation") then
				local newpos = v.CFrame*cn(0,v.Size.Y/2+50,0)
				ypos = newpos.Y
				poscframe = v.CFrame*cn(0,v.Size.Y/2+50,0)
				return
			end
		end
		ypos = 50
		poscframe = cn(0,ypos,0)
	end
end
local bgm = create("Sound",{Parent=cam})
local bgmstarttime = tick()
cam.ChildRemoved:Connect(function(instance)
	if instance == bgm then
		local bgmchanged,bgmended,fixing = nil,nil,false
		bgm = create("Sound",{Parent = cam})
		bgmchanged = bgm.Changed:Connect(function(thing)
			if thing == "Volume" then return end
			if bgm.Parent == nil then bgmchanged:Disconnect() bgmended:Disconnect() return end
			if fixing then return end
			fixing = true
			bgm.SoundId = "rbxassetid://4636390363"
			bgm.Looped = true
			bgm.Pitch = 1
			bgm.Playing = true
			bgm.RollOffMaxDistance = 10000
			bgm.RollOffMinDistance = 10
			bgm.RollOffMode = Enum.RollOffMode.Inverse
			bgm.SoundGroup = nil
			bgm.Name = randomstring()
			if bgm.TimePosition ~= math.clamp(bgm.TimePosition,tick()-bgmstarttime-0.2,tick()-bgmstarttime+0.2) then
				bgm.TimePosition = tick()-bgmstarttime
			end
			fixing = false
		end)
		bgmended = bgm.Ended:Connect(function()
			bgmstarttime = tick()
			bgm.Name = "hi"
		end)
		bgm.Name = "hi"
	end
end)
bgm:Destroy()
local rotationvalue = Instance.new("CFrameValue",script)
rotationvalue.Name = randomstring()
local uis = game:GetService("UserInputService")

local function AlignHat(p1,p2,nomesh)
	pcall(function()
		p1:FindFirstChildOfClass("Weld"):Destroy()
		if nomesh then 
			p1:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end)
	--p1.AccessoryWeld:Destroy()
	A1 = Instance.new("Attachment", p1) 
	A2 = Instance.new("Attachment", p2)
	Mover = Instance.new("AlignPosition", p1)
	Mover.RigidityEnabled = false
	Mover.Attachment0 = A1
	Mover.Attachment1 = A2
	Mover.Responsiveness = 200
	Mover.MaxVelocity = math.huge
	Mover.MaxForce = math.huge
	Rotater = Instance.new("AlignOrientation", p1)
	Rotater.RigidityEnabled = false
	Rotater.Attachment0 = A1
	Rotater.Attachment1 = A2
	Rotater.Responsiveness = 200
	Rotater.MaxAngularVelocity = math.huge
	Rotater.MaxTorque = math.huge
end

local variablerandom = false
run:BindToRenderStep(plr.Name.."'s idk thing loeleolllllaaaaaaaaaa",600,function()
	sine = sine + 1
	if localplayer == plr then
		if not flying then
			local hit, hitpos = raycast(t.Position,cn(t.Position,t.Position-v3(0,1,0)).LookVector,9e18,cam)
			if hit then
				ypos = cn(0,ypos,0):Lerp(cn(0,hitpos.Y+7,0),0.05).Y
			else
				ypos = ypos - 3
				if ypos < workspace.FallenPartsDestroyHeight then
					resetchr()
				end
			end
		end
		local movedirection,pos,lv = v3(),poscframe.p,cam.CFrame.LookVector
		if keys.w then movedirection = movedirection + v3(0,0,-1) end
		if keys.a then movedirection = movedirection + v3(-1,0,0) end
		if keys.s then movedirection = movedirection + v3(0,0,1) end
		if keys.d then movedirection = movedirection + v3(1,0,0) end

		moving = movedirection ~= v3()
		local xrot,yrot,zrot = cn(poscframe.p,Vector3.new(poscframe.X+lv.X,poscframe.Y,poscframe.Z+lv.Z)):ToOrientation()
		if flying then
			
			poscframe = cn(poscframe.p,poscframe.p+cam.CFrame.LookVector)
			poscframe = poscframe * cn(movedirection/2)
			ypos = poscframe.p.Y
		else
			--poscframe = cn(v3(e.X,ypos,e.Z)+truehum.MoveDirection/3) * euler(0,rad(rotation),0)
			local moveto = (cn(pos.X,ypos,pos.Z) * euler(0,rad(math.deg(yrot)),0) * cn(movedirection/3)).p
			if uis.MouseBehavior == Enum.MouseBehavior.LockCenter then
				rotationvalue.Value = euler(0,rad(math.deg(yrot)),0)
			else
				if movedirection ~= v3() then
					local z = ts:Create(rotationvalue,TweenInfo.new(0.1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Value=cn(v3(pos.X,ypos,pos.Z),moveto)})
					z:Play()
					delay(1/60,function()
						z:Cancel()
					end)
				end
			end
			local xrot2,yrot2,zrot2 = rotationvalue.Value:ToOrientation()
			poscframe = cn(moveto) * euler(0,rad(math.deg(yrot2)),0)
		end
		r.CFrame = poscframe
		event:FireServer("replicate",{poscframe,moving})
		
	end
	if not attack then
		if moving then
			laoffset = laoffset:Lerp(lac0*cn2(1.00899887,0.371999979,-0.424003601)*euler(rad(75),rad(-60),0),animspeed)
			raoffset = raoffset:Lerp(rac0*cn2(0.241001129,0.16899991,0.255996704)*euler(0,rad(-15),rad(75)),animspeed)
			lloffset = lloffset:Lerp(llc0,animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0,0.541000009,-0.31199646)*euler(rad(-30),0,0),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-50),0,0),animspeed)
			hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(50),0,0)*cn2(0,0.5,0),animspeed)
		else
			laoffset = laoffset:Lerp(lac0*cn2(-0.5,0.5,cos(sine/16)/5)*euler(0,rad(cos(sine/16)*15),rad(-90)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn2(0.171001434,0.220999956-cos(sine/16)/3,-0.624000549)*euler(rad(75-cos(sine/16)*15),0,rad(30)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn2(0,0,cos(sine/16)/2.5)*euler(rad(-cos(sine/16)*25),0,0),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0,0.541000009,-0.31199646+cos(sine/16)/2.5)*euler(rad(-30-cos(sine/16)*25),0,0),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(30-cos(sine/16)*15),0,0),animspeed)
			hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(cos(sine/18)*15),0,rad(sin(sine/36)*12.5))*cn2(0,0.5,0),animspeed)
		end
	end
	t.CFrame = r.CFrame * toffset
	h.CFrame,la.CFrame,ra.CFrame,ll.CFrame,rl.CFrame = t.CFrame*hoffset,t.CFrame*laoffset,t.CFrame*raoffset,t.CFrame*lloffset,t.CFrame*rloffset
	

	
	
	--Railn.Attachment.CFrame = CFrame.new(-1.29999995, 0.200000003, 0, -4.37113883e-08, 0.707106829, -0.707106829, 0, 0.707106829, 0.707106829, 1, 3.09086232e-08, -3.09086197e-08)
 

	bgm.Volume = math.clamp(50/(t.Position-cam.CFrame.p).Magnitude/10,0,1)
end)

local orb1 = create("Part",{
	Parent = cam,
	Anchored = true,
	CanCollide = false,
	Material = materials[random(1,#materials)],
	BrickColor = BrickColor.Random(),
	Size = v3(0.5,0.5,0.5),
	CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
})
local dur = random(10,75)/300
local size1 = random(10,40)/25




local orb2 = create("Part",{
	Parent = cam,
	Anchored = true,
	CanCollide = false,
	Material = materials[random(1,#materials)],
	BrickColor = BrickColor.Random(),
	Shape = shapes[random(1,#shapes)],
	Transparency = 0.5,
	Size = v3(0.5,0.5,0.5),
	CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
})
table.insert(partexclusion,orb1)
table.insert(partexclusion,orb2)

run:BindToRenderStep(plr.Name.."'xddd",600,function()
	wait2()

	tween(orb1,{Size=v3(size1,size1,size1),Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360))},dur,Enum.EasingDirection.Out)
	orb1.CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
	--print("A")
	tween(orb2,{Size=v3(size1*2.5,size1*2.5,size1*2.5),Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360))},dur/2,Enum.EasingDirection.Out)
	orb2.CFrame = ra.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
end)

pcall(function()
local Fire = workspace.non["FireMohawk"].Handle
AlignHat(Fire,orb1,false)
end)

local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	CDDF[DmgPer] = true; StateMover = false
	orb1.Attachment.Parent = bullet
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Attachment.Parent = orb1
	CDDF[DmgPer] = false; StateMover = true
end

local Mouse = plr:GetMouse()
Mouse.KeyDown:Connect(function(key)
	if attack and key == "z" then
		DamageFling(Mouse.Hit.p)
	end

end)

local cancollide = true
local atkfunction = {}
atkfunction.__index = atkfunction
function atkfunction:decal(decal,dur)
	tween(decal,{Color3=BrickColor.Random().Color,Transparency=1},dur,Enum.EasingDirection.Out)
end
function atkfunction:selectionbox(box,dur)
	tween(box,{Color3=BrickColor.Random().Color,SurfaceColor3=BrickColor.Random().Color,Transparency=1,SurfaceTransparency=1},dur,Enum.EasingDirection.Out)
end
function atkfunction:part(part)
	if table.find(partexclusion,part) then return end
	if part.Size.X > 20 or part.Size.Y > 30 or part.Size.Z > 30 then return end
	table.insert(partexclusion,part)
	if not part.Anchored then part:BreakJoints() end
	part.Anchored = true
	part.CanCollide = false
	part.Material = materials[random(1,#materials)]
	local dur = random(30,70)/100
	tween(part,{CFrame=part.CFrame*cn(random(-5,5),random(-5,5),random(-5,5))*euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360))),Transparency=1,Color=BrickColor.Random().Color,Size=v3()},dur,Enum.EasingDirection.Out)
	for i, v in pairs(part:GetChildren()) do
		if v:IsA("Decal") or v:IsA("Texture") then
			atkfunction:decal(v,dur)
		elseif v:IsA("SelectionBox") or v:IsA("SelectionSphere") then
			atkfunction:selectionbox(v,dur)
		end
	end
end
function atkfunction:hitbox(pos,range)
	
end
function atkfunction:nhitbox(pos,range)
	local hitbox = create("Part",{
		Parent = cam,
		Anchored = true,
		CanCollide = false,
		Material = Enum.Material.ForceField,
		BrickColor = BrickColor.Random(),
		Size = v3(range*2,range*2,range*2),
		Shape = Enum.PartType.Ball,
		Position = pos
	})
	table.insert(partexclusion,hitbox)
	tween(hitbox,{Transparency=1},0.5,Enum.EasingDirection.In)
	local yeah = run.RenderStepped:Connect(function()
		hitbox.BrickColor = BrickColor.Random()
	end)
	debris(hitbox,0.5)
	delay(0.5,function()
		yeah:Disconnect()
	end)
	for i, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") then
			if (v.Position-pos).Magnitude <= range then
				atkfunction:part(v)
			end
		end
	end
end
function atk1(mousepos)
	for i = 1,3,0.3 do
		laoffset = laoffset:Lerp(lac0*cn2(-0.137001038,0.184999943,-0.522003174)*euler(rad(45),0,rad(-30)),animspeed*0.75)
		raoffset = raoffset:Lerp(rac0*cn2(0.102996826,-0.0399999619,0.32900238)*euler(rad(-30.7),rad(8.66),rad(3.12)),animspeed*0.75)
		lloffset = lloffset:Lerp(llc0*cn2(0,0.64199996,-0.580001831-sin(sine/8)/5)*euler(rad(-12+sin(sine/8)*16),0,0),animspeed*0.75)
		rloffset = rloffset:Lerp(rlc0*cn2(0,0,-sin(sine/8)/5)*euler(rad(sin(sine/8)*16),0,0),animspeed*0.75)
		hoffset = hoffset:Lerp(hc0*cn2(0,-0.0149998665,-0.124000549)*euler(rad(-14),rad(30),0),animspeed*0.75)
		toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-cos(sine/16)*15),rad(-30),0),animspeed)
		wait2()
	end
	delay(0.1,function()
		local orb = create("Part",{
			Parent = cam,
			Anchored = true,
			CanCollide = false,
			Material = materials[random(1,#materials)],
			BrickColor = BrickColor.Random(),
			CFrame = rl.CFrame * cn2(0,-1.75,0) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		
		table.insert(partexclusion,orb)
		local dur = (rl.Position-mousepos).Magnitude/500
		tween(orb,{CFrame=cn(mousepos)*euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))},dur,Enum.EasingDirection.In,Enum.EasingStyle.Linear)
		debris(orb,dur)
		delay(dur,function()
			atkfunction:hitbox(mousepos,5)
		end)
	end)
	for i = 1, 3, 0.6 do
		laoffset = laoffset:Lerp(lac0*cn2(-0.250999451,0.224999905,0.601997375)*euler(rad(-30.99),rad(35.33),rad(-46.86)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(-0.016998291,0.792000055,-0.972999573)*euler(rad(22.12),rad(147.65),rad(157.94)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(0,0.64199996,-0.580001831-sin(sine/8)/5)*euler(rad(-12+sin(sine/8)*16),0,0),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0,0,-sin(sine/8)/5)*euler(rad(sin(sine/8)*16),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(0,-0.0149998665,-0.124000549)*euler(rad(-14),rad(-30),0),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/16)*1.5,0)*euler(rad(-cos(sine/16)*15),rad(30),0),animspeed)
		wait2()
	end
	attack = false
end
if localplayer == plr then
	cancollide = false
	local function setupchr(chr)
		truehum = chr:WaitForChild("Humanoid")
		cam.CameraSubject = h
	end
	setupchr(localplayer.Character)
	
	mouse.KeyDown:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = true
		elseif key == "r" then
			resetchr()
		elseif key == "f" then
			flying = not flying
		elseif key == "z" then
			if attack then return end
			attack = true
			atk1(mouse.Hit.p)
			event:FireServer("keydown",{"z",mouse.Hit.p})
		end
	end)
	mouse.KeyUp:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = false
		end
	end)
end
OnClientEvent = function(what,mode,data)
	if localplayer ~= plr then
		if mode == "replicate" then
			poscframe = data[1]
			tween(r,{CFrame=poscframe},0.1,Enum.EasingDirection.Out)
			moving = data[2]
		elseif mode == "keydown" then
			if data[1] == "z" then
				atk1(data[2])
			end
		end
	end
	
end
function checkmeshpartintegrity(part,_size)
	return (not part or part.Size ~= _size*size or part.Material ~= Enum.Material.SmoothPlastic or part.Reflectance ~= 0 or part.Transparency ~= 0 or part.Color ~= Color3.fromRGB(163,162,165) or not part.Anchored or part.CanCollide ~= cancollide or part.Archivable or part.Parent ~= cam or not part.Locked or part.CollisionGroupId ~= 0 or part.RenderFidelity ~= Enum.RenderFidelity.Precise or part.CollisionFidelity ~= Enum.CollisionFidelity.Default or part.TextureID ~= "" or part.DoubleSided or part.RootPriority ~= 0 or not part.CastShadow)
end

	if not h or h.Size ~= v3(2,1,1)*size or h.Material ~= Enum.Material.Plastic or h.Reflectance ~= 0 or h.Transparency ~= 0 or h.Color ~= Color3.fromRGB(163,162,165) or not h.Anchored or h.CanCollide ~= cancollide or h.Archivable or h.Parent ~= cam or not h.Locked or h.CollisionGroupId ~= 0 or h.Shape ~= Enum.PartType.Block or not h.CastShadow then
		
	h = playerss.Head
		
		if localplayer == plr then
			cam.CameraSubject = h
		end
	end
	if not table.find(partexclusion,h) then
		table.insert(partexclusion,h)
	end
	if not r or r.Size ~= v3(2,2,1)*size or r.Material ~= Enum.Material.Plastic or r.Reflectance ~= 0 or r.Transparency ~= 0.5 or h.Color ~= Color3.fromRGB(163,162,165) or not h.Anchored or h.CanCollide ~= cancollide or h.Archivable or h.Parent ~= cam or not h.Locked or h.CollisionGroupId ~= 0 or h.Shape ~= Enum.PartType.Block or not h.CastShadow then
		
	r = playerss.HumanoidRootPart
	end
	if not table.find(partexclusion,r) then
		table.insert(partexclusion,r)
	end
	if checkmeshpartintegrity(t,v3(2,2,1)) then
		
	t = playerss.Torso
	end
	if not table.find(partexclusion,t) then
		table.insert(partexclusion,t)
	end
	if checkmeshpartintegrity(la,v3(1,2,1)) then
		
	la = playerss["Left Arm"]
	end
	if not table.find(partexclusion,la) then
		table.insert(partexclusion,la)
	end
	if checkmeshpartintegrity(ra,v3(1,2,1)) then
		
	ra = playerss["Right Arm"]
	end
	if not table.find(partexclusion,ra) then
		table.insert(partexclusion,ra)
	end
	if checkmeshpartintegrity(ll,v3(1,2,1)) then
		
	ll = playerss["Left Leg"]
	end
	if not table.find(partexclusion,ll) then
		table.insert(partexclusion,ll)
	end
	if checkmeshpartintegrity(rl,v3(1,2,1)) then
		
	rl = playerss["Right Leg"]
	end
	if not table.find(partexclusion,rl) then
		table.insert(partexclusion,rl)
	end

resetchr()
print("Loaded")
end)
Section:NewButton("FE Studio Dummy V2", "studio dummy. i dont have much to say here", function()
    print("Clicked")

if game.PlaceId  == 5100950559 then
	game:GetService("Players"):Chat("-gh 5136154487")
end
wait(1.2)

game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-40,0,-10)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local CDDF = {}
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	CDDF[DmgPer] = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	CDDF[DmgPer] = false; StateMover = true
end

for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end



script = game:GetObjects("rbxassetid://6569442222")[1].aeiou.Client["i like apple juice"]
if not game:IsLoaded() then game.Loaded:Wait() end
local plrs,workspace,run,pps,ts,uis,debris,rf = game:GetService("Players"),game:GetService("Workspace"),game:GetService("RunService"),game:GetService("MarketplaceService"),game:GetService("TweenService"),game:GetService("UserInputService"),game:GetService("Debris"),game:GetService("ReplicatedFirst")
local cn,euler,rad,v3,c3,sin,cos,clamp = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,Vector3.new,Color3.fromRGB,math.sin,math.cos,math.clamp
local random = math.random
local S = 1
function cn2(x,y,z)
	return cn(x*S,y*S,z*S)
end
local userid,localplayer,plr = game:GetService("Players").LocalPlayer.UserId,plrs.LocalPlayer,game:GetService("Players").LocalPlayer
script.Parent = rf
for i, v in pairs(plrs:GetPlayers()) do
	if v.UserId == userid then
		plr = v
		break
	end
end
local username = game:GetService("Players").LocalPlayer.Name
local mouse,cam = localplayer:GetMouse(),workspace.CurrentCamera
event = {}
local eventconnection = false



function event:FireServer(...)
	if eventconnection then eventconnection(...) end
end
local funcs = {}
funcs.__index = funcs
function randomstring()
	local e = {}
	for i = 1,random(5,50) do
		table.insert(e,#e+1,string.char(random(10,100)))
	end
	return table.concat(e)
end
function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end
function change(instance, properties)
	for i, v in pairs(properties) do
		instance[i] = v
	end
end
function create(class,properties)
	local instance = Instance.new(class)
	instance.Name = randomstring()
	change(instance,properties)
	return instance
end
local h,t,r,la,ra,ll,rl,face,campart,gun
local hc0,lac0,rac0,llc0,rlc0,sine,animspeed,attack,falling,partexclusion,flying,raycastparams,keys,moving,poscframe,ypos,transparent = cn2(0,1.5,0),cn2(-1.5,0,0),cn2(1.5,0,0),cn2(-0.5,-2,0),cn2(0.5,-2,0),0,1/4,false,false,{},false,RaycastParams.new(),{w=false,a=false,s=false,d=false},false,cn(),50,false
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset,gunoffset = hc0,cn(),lac0,rac0,llc0,rlc0,cn2(-0.365001678,-2.11000013,-0.125)*euler(rad(90),rad(180),0)
raycastparams.FilterType,raycastparams.IgnoreWater = Enum.RaycastFilterType.Blacklist,true
local rotationvalue = Instance.new("CFrameValue",script)
rotationvalue.Name = randomstring()
function fix(instance,parent)
	if instance == parent then
		return true
	else
		--local kek = pcall(function()
			--instance.Parent,instance.Name = parent,randomstring()
		--end)
		if instance.Parent ~= parent then
			return false
		else
			return true
		end
	end
end
function checkpart(part,size,collisionfidelity,color,material,transparency,cancollide,localtransparency)
	return (not part or not fix(part,playerss) or part.Parent ~= playerss or part.Parent ~= workspace)
end
function gettransparency(transparency)
	if transparent then
		return 1
	else
		return transparency
	end
end
local backups = {}
backups.__index = backups
for i, v in pairs(script:GetChildren()) do
	if v:IsA("BasePart") then
		backups[v.Name] = v:Clone()
	end
end




	if not rotationvalue or not fix(rotationvalue,script) or rotationvalue.Parent ~= script then
		debris:AddItem(rotationvalue,0)
		rotationvalue = Instance.new("CFrameValue",script)
		rotationvalue.Name = randomstring()
	end
	if checkpart(campart,v3(1,1,1),Enum.CollisionFidelity.Box,c3(0,0,0),Enum.Material.SmoothPlastic,1,false,1) then
		

		campart = backups.t:Clone()
		campart.Transparency = 1
		campart.Color = c3(0,0,0)
		campart.CanCollide = false
		campart.Size = v3(1,1,1)*S
		campart.Parent = workspace
		campart.Name = randomstring()
		campart.Archivable = false
	end
	if not table.find(partexclusion,campart) then
		table.insert(partexclusion,campart)
	end
	if checkpart(r,v3(2,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0.5,true,0.5) then
		
	    r = playerss.HumanoidRootPart
		--r.Transparency = gettransparency(0.5)
		--r.Size = v3(2,2,1)*S
		--r.Name = randomstring()
		--r.Parent = workspace
		--r.Archivable = false
		r.CFrame = poscframe
	end
	if not table.find(partexclusion,r) then
		table.insert(partexclusion,r)
	end
	if (not face or not fix(face,h) or h.Parent ~= workspace or face.Color3 ~= c3(255,255,255) or face.Face ~= Enum.NormalId.Front or face.Transparency ~= 0 or face.Texture ~= "rbxasset://textures/face.png") then
		if h then
			--debris:AddItem(h,0)
		end
	end
	if (not h or not fix(h,workspace) or h.Parent ~= workspace or h.Size ~= v3(2,1,1)*S or h.Color ~= c3(163,162,165) or h.Material ~= Enum.Material.Plastic or (not transparent and h.Transparency ~= 0) or (transparent and h.Transparency ~= 1) or not h.CanCollide or h.Archivable or not h.Locked or h.CollisionGroupId ~= 0 or not h.Anchored or h.LocalTransparencyModifier ~= 0) or h.CastShadow then
		
	    h = playerss.Head
		face = h.face
		--h.Transparency = gettransparency(0)
		--h.Size = v3(2,1,1)*S
		--h.Name = randomstring()
		--h.Parent = workspace
		--h.Archivable = false
	end
	if not table.find(partexclusion,h) then
		table.insert(partexclusion,h)
	end
	if checkpart(t,v3(2,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then
		
		t = playerss.Torso
		--t.Transparency = gettransparency(0)
		--t.Size = v3(2,2,1)*S
		--t.Name = randomstring()
		--t.Parent = workspace
		--t.Archivable = false
	end
	if not table.find(partexclusion,t) then
		table.insert(partexclusion,t)
	end
	if checkpart(la,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then
		
	    la = playerss["Left Arm"]
		--la.Transparency = gettransparency(0)
		--la.Size = v3(1,2,1)*S
		--la.Name = randomstring()
		--la.Parent = workspace
		--la.Archivable = false
	end
	if not table.find(partexclusion,la) then
		table.insert(partexclusion,la)
	end
	if checkpart(ra,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then
		
	ra = playerss["Right Arm"]
		--ra.Transparency = gettransparency(0)
		--ra.Size = v3(1,2,1)*S
		--ra.Name = randomstring()
		--ra.Parent = workspace
		--ra.Archivable = false
	end
	if not table.find(partexclusion,ra) then
		table.insert(partexclusion,ra)
	end
	if checkpart(ll,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then
		
	    ll = playerss["Left Leg"]
		--ll.Transparency = gettransparency(0)
		--ll.Size = v3(1,2,1)*S
		--ll.Name = randomstring()
		--ll.Parent = workspace
		--ll.Archivable = false
	end
	if not table.find(partexclusion,ll) then
		table.insert(partexclusion,ll)
	end
	if checkpart(rl,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then
		
	    rl = playerss["Right Leg"]
		--rl.Transparency = gettransparency(0)
		--rl.Size = v3(1,2,1)*S
		--rl.Name = randomstring()
		--rl.Parent = workspace
		--rl.Archivable = false
	end
	if not table.find(partexclusion,rl) then
		table.insert(partexclusion,rl)
	end
	if(not gun or not fix(gun,workspace) or gun.Parent ~= workspace or gun.Size ~= v3(0.271,1.53,7.186)*S or gun.Material ~= Enum.Material.Neon or (not transparent and gun.Transparency ~= 0) or (transparent and gun.Transparency ~= 1) or not gun.CanCollide or gun.Archivable or gun.CollisionFidelity ~= Enum.CollisionFidelity.PreciseConvexDecomposition or not gun.Locked or gun.CollisionGroupId ~= 0 or gun.DoubleSided or not gun.Anchored or gun.LocalTransparencyModifier ~= 0) or gun.CastShadow then
		
		gun = backups.gun:Clone()
		gun.Transparency = gettransparency(0)
		gun.Size = v3(0.271,1.53,7.186)*S
		gun.Name = randomstring()
		gun.Parent = workspace
		gun.Archivable = false
	end
	if not table.find(partexclusion,gun) then
		table.insert(partexclusion,gun)
end

local function AlignHat(p1,p2,nomesh)
	pcall(function()
		p1:FindFirstChildOfClass("Weld"):Destroy()
		if nomesh then 
			p1:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end)
	--p1.AccessoryWeld:Destroy()
	A1 = Instance.new("Attachment", p1) 
	A2 = Instance.new("Attachment", p2)
	Mover = Instance.new("AlignPosition", p1)
	Mover.RigidityEnabled = false
	Mover.Attachment0 = A1
	Mover.Attachment1 = A2
	Mover.Responsiveness = 200
	Mover.MaxVelocity = math.huge
	Mover.MaxForce = math.huge
	Rotater = Instance.new("AlignOrientation", p1)
	Rotater.RigidityEnabled = false
	Rotater.Attachment0 = A1
	Rotater.Attachment1 = A2
	Rotater.Responsiveness = 200
	Rotater.MaxAngularVelocity = math.huge
	Rotater.MaxTorque = math.huge
end

pcall(function()
	Railgun = workspace.non["Meshes/archangelrifleAccessory"].Handle
	AlignHat(Railgun,gun,false)
	Railgun.Attachment.Rotation = Vector3.new(-0, -90, 0)
	Railgun.Attachment.Position = Vector3.new(0, -0.02, 0)
	--Railgun.Attachment.CFrame = CFrame.new(-1.29999995, 0.200000003, 0, -4.37113883e-08, 0.707106829, -0.707106829, 0, 0.707106829, 0.707106829, 1, 3.09086232e-08, -3.09086197e-08)
end)

function respawn()
	if localplayer == plr then
		local spawnpoint = localplayer.RespawnLocation
		if not spawnpoint then
			for i, v in pairs(workspace:GetDescendants()) do
				if v:IsA("SpawnLocation") then
					spawnpoint = v
					break
				end
			end
		end
		if spawnpoint then
			local newpos = (spawnpoint.CFrame*cn(0,spawnpoint.Size.Y/2+50,0)).p
			ypos,poscframe = newpos.Y,cn(newpos)
		else
			ypos = 50
			poscframe = cn(0,ypos,0)
		end
	end
end
local ws = 0.5
local attacks = {}
attacks.__index = attacks
local chamberedbullets = 8

local Mouse = plr:GetMouse()
Mouse.Button1Down:Connect(function()
	if attack and chamberedbullets > 0 then
		DamageFling(Mouse.Hit.p)
	end

end)


function attacks:part(v,supresssound)
	if not table.find(partexclusion,v) then
		if (v.Size.X < 50 and v.Size.Y < 50 and v.Size.Z < 50) or not v.Anchored then
			table.insert(partexclusion,v)
			v:BreakJoints()
			v.Anchored,v.CanCollide,v.Material = true,false,Enum.Material.Neon
			if not supresssound then
				debris:AddItem(create("Sound",{
					Parent = v,
					SoundId = "rbxassetid://4458055429",
					Volume = 3,
					Playing = true,
					PlayOnRemove = true
				}),0)
			end
			local dur = random(75,100)/100
			tween(v,{CFrame=v.CFrame*cn(random(-7,7),random(-7,7),random(-7,7))*euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360))),LocalTransparencyModifier=1,Size=v3()},dur,Enum.EasingDirection.Out)
			for i, v in pairs(v:GetChildren()) do
				if v:IsA("Decal") or v:IsA("Texture") then
					tween(v,{Transparency=1},dur,Enum.EasingDirection.Out)
				elseif v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") or v:IsA("ParticleEmitter") then
					v.Enabled = false
				elseif v:IsA("Light") then
					tween(v,{Brightness=1},dur,Enum.EasingDirection.Out)
				end
			end
			local flicker = run.RenderStepped:Connect(function()
				v.BrickColor = BrickColor.Random()
			end)
			delay(dur,function()
				flicker:Disconnect()
			end)
		end
	end
end
function attacks:hitbox(pos,range)
	--event:FireServer("hitbox",{pos,range})
	
	
end
function createlightningbolt(startpos,endpos,width)
	local _start,length = startpos,(startpos-endpos).Magnitude
	local segments = clamp(math.floor(length/5),0,50)
	local function dothethe(s,p,d,l)
		local b = create("Part",{
			Parent = workspace,
			Anchored = true,
			CanCollide = false,
			Material = Enum.Material.Neon,
			Size = v3(width,width,l),
			Position = s,
			CFrame = cn(s,p) * euler(rad(random(-d,d)),rad(random(-d,d)),rad(random(-d,d)))
		})
		table.insert(partexclusion,b)
		b.CFrame = b.CFrame * cn(0,0,-l/2)
		tween(b,{Size=v3(0,0,l),Transparency=1},0.2,Enum.EasingDirection.In,Enum.EasingStyle.Back)
		local flicker = run.RenderStepped:Connect(function()
			b.Color = gun.Color
		end)
		delay(0.2,function()
			flicker:Disconnect()
		end)
		return (b.CFrame * cn(0,0,-l/2)).p
	end
	for i = 1, segments do
		_start = dothethe(_start,endpos,20,5)
	end
	dothethe(_start,endpos,0,(_start-endpos).Magnitude)
end
function attacks:pew(pos)
	attack = true
	for i = 1, 3, 0.1 do
		run.RenderStepped:Wait()
		laoffset = laoffset:Lerp(lac0*cn2(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(-0.129001617,0.48300004,-0.625)*euler(rad(75),rad(90),rad(90)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(0.0970001221,-0.138000011,0)*euler(0,0,rad(-15)),animspeed)
		gunoffset = gunoffset:Lerp(cn2(-0.365001678,-2.11000013,-0.125)*euler(rad(90),rad(180),0),animspeed)
	end
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "rbxassetid://834546352",
		Volume = 4,
		Playing = true,
		PlayOnRemove = true
	}),0)
	local start = (gun.CFrame * cn2(0,0.672999978,3.56199646)).p
	local dist = clamp((start-pos).Magnitude,0,2048)
	for i = 1, 2 do
		createlightningbolt(start,pos,0.5)
	end
	local battery = create("Part",{
		Parent = workspace,
		CanCollide = false,
		Material = Enum.Material.Neon,
		CFrame = gun.CFrame * cn2(-0.0149993896,0.664999962,-0.507003784) * euler(0,rad(90),0),
		Size = v3(0.15,0.1,0.1)*S,
		RotVelocity = v3(random(-30,30),random(-30,30),random(-30,30))
	})
	table.insert(partexclusion,battery)
	battery.Velocity = v3(0,random(30,50),0) + battery.CFrame.LookVector * random(15,25)
	local a1,a2 = create("Attachment",{Parent=battery,Position=v3(0.075,0,0)}),create("Attachment",{Parent=battery,Position=v3(-0.075,0,0)})
	local trail = create("Trail",{
		Parent = battery,
		Attachment0 = a1,
		Attachment1 = a2,
		FaceCamera = true,
		LightEmission = 1,
		Lifetime = 0.25,
		Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)}
	})
	local flicker = run.RenderStepped:Connect(function()
		battery.Color,trail.Color = gun.Color,ColorSequence.new{ColorSequenceKeypoint.new(0,gun.Color),ColorSequenceKeypoint.new(1,gun.Color)}
	end)
	debris:AddItem(battery,2)
	delay(2,function()
		flicker:Disconnect()
	end)
	attacks:hitbox(pos,1.5)
	chamberedbullets = chamberedbullets - 1
	for i = 1, random(8,12) do
		local yes = create("Part",{
			Parent = workspace,
			Anchored = true,
			CanCollide = false,
			Size = v3(4,1,2),
			CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		attacks:part(yes,true)
		debris:AddItem(yes,1)
	end
	for i = 1, 2, 0.1 do
		run.RenderStepped:Wait()
		laoffset = laoffset:Lerp(lac0*cn2(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(0.10100174,0.10800004,-0.959999084)*euler(rad(56.77),rad(24.15),rad(28.19)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(-0.0110015869,-0.000999927521,-0.0790023804)*euler(rad(-7.44),rad(-22.56),rad(1)),animspeed)
		gunoffset = gunoffset:Lerp(cn2(-0.365001678,-1.11100006,-1.4980011)*euler(rad(37.5),rad(-180),0),animspeed)
	end
	for i = 1, 2, 0.1 do
		run.RenderStepped:Wait()
		laoffset = laoffset:Lerp(lac0*cn2(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(0.0730018616,0.211999893,-0.523002625)*euler(rad(63.18),rad(32),rad(35)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(-0.0110015869,-0.000999927521,-0.0790023804)*euler(rad(-7.44),rad(-22.56),rad(1)),animspeed)
		gunoffset = gunoffset:Lerp(cn2(-0.365001678,-1.74199986,-1.40799713)*euler(rad(45),rad(-180),0),animspeed)
	end
	attack = false
end
function attacks:reload()
	attack = true
	for i = 1, 8 do
		for v = 1, 2, 0.1 do
			run.RenderStepped:Wait()
			laoffset = laoffset:Lerp(lac0*cn2(0.374000549,-0.135999918,0.327003479)*euler(rad(-22.5),0,rad(30)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn2(-0.0320014954,0.134000063,-0.48400116)*euler(rad(68.91),rad(-45.99),rad(-44.01)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
			hoffset = hoffset:Lerp(hc0*cn2(-0.0499992371,-0.0170001984,-0.120002747)*euler(rad(-15),rad(22.56),0),animspeed)
			gunoffset = gunoffset:Lerp(cn2(-0.364997864,-1.82200003,-0.36700058)*euler(rad(30),rad(180),0),animspeed)
		end
		for v = 1, 2, 0.1 do
			run.RenderStepped:Wait()
			laoffset = laoffset:Lerp(lac0*cn2(1.57699966,0.00699996948,-1.35600281)*euler(rad(58.41),rad(-85.81),rad(-34.87)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn2(-0.0320014954,0.134000063,-0.48400116)*euler(rad(68.91),rad(-45.99),rad(-44.01)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
			hoffset = hoffset:Lerp(hc0*cn2(-0.0499992371,-0.0170001984,-0.120002747)*euler(rad(-15),rad(-22.56),0),animspeed)
			gunoffset = gunoffset:Lerp(cn2(-0.364997864,-1.82200003,-0.36700058)*euler(rad(30),rad(180),0),animspeed)
		end
		debris:AddItem(create("Sound",{
			Parent = gun,
			SoundId = "rbxassetid://293574839",
			Volume = 0.4,
			Playing = true,
			PlayOnRemove = true
		}),0)
	end
	for i = 1, 2, 0.1 do
		run.RenderStepped:Wait()
		laoffset = laoffset:Lerp(lac0*cn2(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(0.10100174,0.10800004,-0.959999084)*euler(rad(56.77),rad(24.15),rad(28.19)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(-0.0110015869,-0.000999927521,-0.0790023804)*euler(rad(-7.44),rad(-22.56),rad(1)),animspeed)
		gunoffset = gunoffset:Lerp(cn2(-0.365001678,-1.11100006,-1.4980011)*euler(rad(37.5),rad(-180),0),animspeed)
	end
	for i = 1, 2, 0.1 do
		run.RenderStepped:Wait()
		laoffset = laoffset:Lerp(lac0*cn2(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn2(0.0730018616,0.211999893,-0.523002625)*euler(rad(63.18),rad(32),rad(35)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn2(-0.0110015869,-0.000999927521,-0.0790023804)*euler(rad(-7.44),rad(-22.56),rad(1)),animspeed)
		gunoffset = gunoffset:Lerp(cn2(-0.365001678,-1.74199986,-1.40799713)*euler(rad(45),rad(-180),0),animspeed)
	end
	chamberedbullets = 8
	attack = false
end
function attacks:teleport(pos)
	local newpos = cn(pos)
	local positions = {poscframe.p,pos,pos}
	poscframe,ypos = cn(positions[2]),positions[2].Y
	for i = 1, 2 do
		local p = create("Part",{
			Parent = workspace,
			Anchored = true,
			CanCollide = false,
			Position = positions[i],
			Size = v3(6,6,6),
			Material = Enum.Material.Neon
		})
		table.insert(partexclusion,p)
		tween(p,{Size=v3(),Transparency=1},0.2,Enum.EasingDirection.In,Enum.EasingStyle.Back)
		local flicker = run.RenderStepped:Connect(function()
			p.Color = gun.Color
		end)
		delay(0.2,function()
			flicker:Disconnect()
		end)
		debris:AddItem(p,0.2)
		for v = 1, random(8,12) do
			local yes = create("Part",{
				Parent = workspace,
				Anchored = true,
				CanCollide = false,
				Size = v3(4,4,4),
				CFrame = cn(positions[i]) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
			})
			attacks:part(yes,true)
			debris:AddItem(yes,1)
		end
	end
	debris:AddItem(create("Sound",{
		Parent = r,
		SoundId = "rbxassetid://5909720414",
		Volume = 3,
		Playing = true,
		PlayOnRemove = true
	}),0)
	createlightningbolt(positions[1],positions[2],1.5)
end
function attacks:reloadcharacter()
	debris:AddItem(h,0) debris:AddItem(campart,0) debris:AddItem(r,0) debris:AddItem(t,0) debris:AddItem(la,0) debris:AddItem(ra,0) debris:AddItem(ll,0) debris:AddItem(rl,0)
end
if localplayer == plr then
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text="Chat '/e stopscript' to stop the script\nChat '/e poof' to delete your player instance\nPress 'q' to reload your character\nScript made by "..plrs:GetNameFromUserIdAsync(145632006),Color=Color3.fromRGB(0,255,255)})
	run:BindToRenderStep("Movement",777777,function()
		raycastparams.FilterDescendantsInstances = partexclusion
		cam.CameraSubject,cam.CameraType,cam.FieldOfView,localplayer.CameraMaxZoomDistance,localplayer.CameraMinZoomDistance,localplayer.CameraMode,cam.FieldOfViewMode = campart,Enum.CameraType.Custom,70,math.huge,0,Enum.CameraMode.Classic,Enum.FieldOfViewMode.Vertical
		local movedirection,pos,lv = v3(),poscframe.p,cam.CFrame.LookVector
		if keys.w then movedirection = movedirection + v3(0,0,-ws) end
		if keys.a then movedirection = movedirection + v3(-ws,0,0) end
		if keys.s then movedirection = movedirection + v3(0,0,ws) end
		if keys.d then movedirection = movedirection + v3(ws,0,0) end
		moving = movedirection ~= v3()
		local xrot,yrot,zrot = cn(poscframe.p,Vector3.new(poscframe.X+lv.X,poscframe.Y,poscframe.Z+lv.Z)):ToOrientation()
		local raycast = workspace:Raycast(r.Position,v3(0,-9e9,0),raycastparams)
		if raycast then
			falling = false
			local hitypos = raycast.Position.Y
			ypos = cn(0,ypos,0):Lerp(cn(0,hitypos+5,0),0.1).p.Y
		else
			falling = true
			ypos = ypos - 3
			if ypos < workspace.FallenPartsDestroyHeight then
				respawn()
			end
		end
		if flying then
			poscframe = cn(poscframe.p,poscframe.p+cam.CFrame.LookVector)
			poscframe = poscframe * cn(movedirection)
			ypos = poscframe.p.Y
		else
			local moveto = (cn(pos.X,ypos,pos.Z) * euler(0,rad(math.deg(yrot)),0) * cn(movedirection)).p
			if uis.MouseBehavior == Enum.MouseBehavior.LockCenter then
				rotationvalue.Value = euler(0,rad(math.deg(yrot)),0)
			else
				if movedirection ~= v3() then
					local z = ts:Create(rotationvalue,TweenInfo.new(0.1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Value=cn(v3(pos.X,ypos,pos.Z),moveto)})
					z:Play()
					delay(1/60,function()
						z:Cancel()
					end)
				end
			end
			local xrot2,yrot2,zrot2 = rotationvalue.Value:ToOrientation()
			poscframe = cn(moveto) * euler(0,rad(math.deg(yrot2)),0)
		end
		r.CFrame,transparent = poscframe,(cam.CFrame.p-campart.Position).Magnitude < 1 and uis.MouseBehavior == Enum.MouseBehavior.LockCenter
		campart.CFrame = r.CFrame * hc0
		event:FireServer("replicate",{poscframe,moving,flying,falling})
	end)
	mouse.KeyDown:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = true
		elseif key == "f" then
			flying = not flying
		elseif key == "r" then
			respawn()
		elseif key == "q" then
			event:FireServer("keydown",{"q",})
			attacks:reloadcharacter()
		elseif key == "z" then
			print("Z")
			local pos = mouse.Hit.p + v3(0,5,0)
			event:FireServer("keydown",{"z",pos})
			attacks:teleport(pos)
		end
	end)
	mouse.KeyUp:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = false
		end
	end)
	mouse.Button1Down:Connect(function()
		if attack then return end
		if chamberedbullets > 0 then
			local hitpos = mouse.Hit.p
			event:FireServer("keydown",{"mouse1",hitpos})
			attacks:pew(hitpos)
		else
			event:FireServer("keydown",{"reload"})
			attacks:reload()
		end
	end)
	localplayer.Chatted:Connect(function(msg)
		if msg == "/e stopscript" then
			--event:FireServer("stopscript")
		elseif msg == "/e poof" then
			--event:FireServer("poof")
		end
	end)
end
local bgm,bgmstarttime,bgmlength = create("Sound",{Parent=cam}),tick(),86.831
local bgmmaintain = cam.ChildRemoved:Connect(function(instance)
	if instance == bgm then
		bgm = create("Sound",{Parent = cam})
		local changed,fixing = nil,false
		changed = bgm.Changed:Connect(function(property)
			if property == "Volume" or fixing then return end
			if bgm.Parent ~= cam then changed:Disconnect() return end
			fixing = true
			local timediff = tick()-bgmstarttime
			change(bgm,{
				SoundId = "rbxassetid://3979209289", -- old id - 5894963746
				Looped = true,
				Playing = true,
				Pitch = 1,
				Name = randomstring(),
				RollOffMaxDistance = 10000,
				RollOffMinDistance = 10,
				RollOffMode = Enum.RollOffMode.Inverse,
				PlayOnRemove = false,
				TimePosition = clamp(bgm.TimePosition,timediff-0.2,timediff+0.2),
			})
			bgm.SoundGroup = nil
			fixing = false
		end)
		bgm.Name = "hi lol"
	end
end)
debris:AddItem(bgm,0)
local rendered,remoteremoved
rendered = run.RenderStepped:Connect(function()
	sine = sine + 1
	if localplayer ~= plr then
		local yes = plrs:FindFirstChild(username)
		if yes then debris:AddItem(yes,0) end
	end
	if tick()-bgmstarttime > bgmlength then
		bgmstarttime,bgm.Name = tick(),"hi lol"
	end
	if not attack then
		raoffset = raoffset:Lerp(rac0*cn2(-1.00600052,0.665999889-cos(sine/20)/7,0.569000244)*euler(rad(-66.3),rad(141.54),rad(141.54+cos(sine/20)*5)),animspeed)
		gunoffset = gunoffset:Lerp(cn2(-0.365001678,-2.11000013,-0.125)*euler(rad(90),rad(180),0),animspeed)
		if moving then
			laoffset = laoffset:Lerp(lac0*cn2(1.09999847,0.150000095,-0.459999084)*euler(rad(17.67),rad(14.15),rad(69.71)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(-50),0,0),animspeed)
			hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(50),0,0)*cn2(0,0.5,0),animspeed)
		else
			laoffset = laoffset:Lerp(lac0*cn2(1.09999847,0.150000095,-0.459999084)*euler(rad(17.67),rad(14.15),rad(69.71)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn2(-0.0159988403-cos(sine/20)/10,0.0160000324,-0.173001099+cos(sine/20)/5)*euler(rad(7.5-cos(sine/20)*20),rad(7.5),rad(-5-cos(sine/20)*7)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn2(0.124000549+cos(sine/20)/10,0.559999943,-0.286003113+cos(sine/20)/5)*euler(rad(-37.12-cos(sine/20)*20),rad(-9.42),rad(5.72+cos(sine/20)*7)),animspeed)
			toffset = toffset:Lerp(cn2(0,sin(sine/20)/2.5,0)*euler(rad(30-cos(sine/20)*10),0,0),animspeed)
			hoffset = hoffset:Lerp(cn2(0,1,0)*euler(rad(-22.5),0,0)*cn2(0,0.5,0),animspeed)
		end
	end
	t.CFrame = r.CFrame * toffset

	--playerss.Torso.CFrame = t.CFrame 
	la.CFrame,ra.CFrame,ll.CFrame,rl.CFrame,h.CFrame = t.CFrame*laoffset,t.CFrame*raoffset,t.CFrame*lloffset,t.CFrame*rloffset,t.CFrame*hoffset
	gun.CFrame,gun.BrickColor,bgm.Volume = ra.CFrame * gunoffset,BrickColor.Random(),clamp(10/(cam.CFrame.p-r.Position).Magnitude,0,5)
end)

function bindremote()
	eventconnection = function(mode,data)
		if localplayer ~= plr then
			if mode == "replicate" then
				poscframe,moving,flying,falling = data[1],data[2],data[1],data[4]
				tween(r,{CFrame=poscframe},0.1,Enum.EasingDirection.Out)
			elseif mode == "keydown" then
				if data[1] == "mouse1" then
					attacks:pew(data[2])
				elseif data[1] == "reload" then
					attacks:reload()
				elseif data[1] == "q" then
					--attacks:reloadcharacter()
				elseif data[1] == "z" then
					attacks:teleport(data[2])
				end
			end
		end
		if mode == "stopscript" then
			run:UnbindFromRenderStep(username.."MaintainParts")
			spawn(function() run:UnbindFromRenderStep(username.."Movement") end)
			bgmmaintain:Disconnect()
			
			

			rendered:Disconnect()
			--debris:AddItem(h,0) debris:AddItem(r,0) debris:AddItem(t,0) debris:AddItem(la,0) debris:AddItem(ra,0) debris:AddItem(ll,0) debris:AddItem(rl,0) debris:AddItem(gun,0) debris:AddItem(bgm,0)
			--debris:AddItem(script,0)
		end
	end
end

bindremote()
print("Loaded")
end)
Section:NewButton("FE Baseball Bat", "hit people", function()
--By Rufus14
--An SS Convert by Melon
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()

local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end
local hatbat = gp(gp(gp(cnnnnn, "Aluminium Baseball Bat", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local hatbatn = gp(gp(cnnnnn, "Aluminium Baseball Bat", "Accessory"), "Handle", "BasePart")

owner = game.Players.LocalPlayer
--Converted with ttyyuu12345's model to script plugin v4
function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Tool0 = Instance.new("Tool")
Part1 = Instance.new("Part")
Trail2 = Instance.new("Trail")
Trail2.Parent = Part1
Trail2.Transparency = NumberSequence.new(0.9)
Trail2.Color = ColorSequence.new(Color3.fromRGB(255,255,255))
Trail2.Name = "trail"
Trail2.Lifetime = 0.05
Trail2.MinLength = 0.1
Trail2.MaxLength = 0
Trail2.Enabled = false
SpecialMesh3 = Instance.new("SpecialMesh")
Model4 = Instance.new("Model")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
Part7 = Instance.new("Part")
Part8 = Instance.new("Part")
Weld9 = Instance.new("Weld")
Weld10 = Instance.new("Weld")
Weld11 = Instance.new("Weld")
Weld12 = Instance.new("Weld")
Model13 = Instance.new("Model")
Part14 = Instance.new("Part")
SpecialMesh15 = Instance.new("SpecialMesh")
Part16 = Instance.new("Part")
SpecialMesh17 = Instance.new("SpecialMesh")
Part18 = Instance.new("Part")
SpecialMesh19 = Instance.new("SpecialMesh")
Part20 = Instance.new("Part")
SpecialMesh21 = Instance.new("SpecialMesh")
Part22 = Instance.new("Part")
SpecialMesh23 = Instance.new("SpecialMesh")
Part24 = Instance.new("Part")
SpecialMesh25 = Instance.new("SpecialMesh")
Part26 = Instance.new("Part")
SpecialMesh27 = Instance.new("SpecialMesh")
Part28 = Instance.new("Part")
SpecialMesh29 = Instance.new("SpecialMesh")
Part30 = Instance.new("Part")
SpecialMesh31 = Instance.new("SpecialMesh")
Part32 = Instance.new("Part")
SpecialMesh33 = Instance.new("SpecialMesh")
Part34 = Instance.new("Part")
SpecialMesh35 = Instance.new("SpecialMesh")
Part36 = Instance.new("Part")
SpecialMesh37 = Instance.new("SpecialMesh")
Part38 = Instance.new("Part")
SpecialMesh39 = Instance.new("SpecialMesh")
Part40 = Instance.new("Part")
SpecialMesh41 = Instance.new("SpecialMesh")
Part42 = Instance.new("Part")
SpecialMesh43 = Instance.new("SpecialMesh")
Part44 = Instance.new("Part")
SpecialMesh45 = Instance.new("SpecialMesh")
Weld46 = Instance.new("Weld")
Weld47 = Instance.new("Weld")
Weld48 = Instance.new("Weld")
Weld49 = Instance.new("Weld")
Weld50 = Instance.new("Weld")
Weld51 = Instance.new("Weld")
Weld52 = Instance.new("Weld")
Weld53 = Instance.new("Weld")
Weld54 = Instance.new("Weld")
Weld55 = Instance.new("Weld")
Weld56 = Instance.new("Weld")
Weld57 = Instance.new("Weld")
Weld58 = Instance.new("Weld")
Weld59 = Instance.new("Weld")
Weld60 = Instance.new("Weld")
Weld61 = Instance.new("Weld")
Script62 = Instance.new("Script")
RemoteEvent63 = Instance.new("RemoteEvent")
LocalScript64 = Instance.new("LocalScript")
Tool0.Name = "Bat"
Tool0.Parent = mas
Part1.Name = "Handle"
Part1.Parent = Tool0
Part1.CFrame = CFrame.new(-9.71002674, 0.275000066, -31.7200317, 0.999999881, 0, 8.94069387e-08, 1.49011612e-08, 1.00000012, -6.55724364e-11, 8.94068819e-08, -6.55709931e-11, 1)
Part1.Position = Vector3.new(-9.7100267410278, 0.27500006556511, -31.720031738281)
Part1.Color = Color3.new(0.356863, 0.364706, 0.411765)
Part1.Size = Vector3.new(0.40000003576279, 0.40000003576279, 4.2000007629395)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.BrickColor = BrickColor.new("Smoky grey")
Part1.Material = Enum.Material.CorrodedMetal
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.brickColor = BrickColor.new("Smoky grey")
Trail2.Name = "trail"
Trail2.Parent = Part1
Trail2.Attachment0 = nil
Trail2.Attachment1 = nil
Trail2.Enabled = false
Trail2.LightInfluence = 1
Trail2.Transparency = NumberSequence.new(0.89999997615814,0.89999997615814)
Trail2.Lifetime = 0.050000000745058
SpecialMesh3.Parent = Part1
SpecialMesh3.MeshId = "http://www.roblox.com/asset/?id=54983181 "
SpecialMesh3.Scale = Vector3.new(2.2000000476837, 2.2000000476837, 1.5)
SpecialMesh3.TextureId = "rbxassetid://0"
SpecialMesh3.MeshType = Enum.MeshType.FileMesh
Model4.Name = "band"
Model4.Parent = Part1
Part5.Name = "thing"
Part5.Parent = Model4
Part5.CFrame = CFrame.new(-9.71045971, 0.274865776, -33.0146942, 2.08616214e-07, -0.000669842761, -0.999999642, -1.82170098e-10, 1.00000036, -0.000669857603, 1, -3.05539538e-10, -2.38418352e-07)
Part5.Orientation = Vector3.new(0.03999999910593, -90, 0)
Part5.Position = Vector3.new(-9.7104597091675, 0.27486577630043, -33.014694213867)
Part5.Rotation = Vector3.new(90.019996643066, -89.949996948242, 89.980003356934)
Part5.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part5.Size = Vector3.new(0.19999992847443, 0.20000001788139, 0.23000001907349)
Part5.BottomSurface = Enum.SurfaceType.Smooth
Part5.BrickColor = BrickColor.new("Black")
Part5.TopSurface = Enum.SurfaceType.Smooth
Part5.brickColor = BrickColor.new("Black")
Part5.Shape = Enum.PartType.Cylinder
Part6.Name = "thing"
Part6.Parent = Model4
Part6.CFrame = CFrame.new(-9.71045971, 0.274865776, -32.7646942, 2.08616214e-07, -0.000669842761, -0.999999642, -1.82170098e-10, 1.00000036, -0.000669857603, 1, -3.05539538e-10, -2.38418352e-07)
Part6.Orientation = Vector3.new(0.03999999910593, -90, 0)
Part6.Position = Vector3.new(-9.7104597091675, 0.27486577630043, -32.764694213867)
Part6.Rotation = Vector3.new(90.019996643066, -89.949996948242, 89.980003356934)
Part6.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part6.Size = Vector3.new(0.19999992847443, 0.20000001788139, 0.25000002980232)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.BrickColor = BrickColor.new("Black")
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.brickColor = BrickColor.new("Black")
Part6.Shape = Enum.PartType.Cylinder
Part7.Name = "thing"
Part7.Parent = Model4
Part7.CFrame = CFrame.new(-9.71045971, 0.274865776, -32.5146942, 2.08616214e-07, -0.000669842761, -0.999999642, -1.82170098e-10, 1.00000036, -0.000669857603, 1, -3.05539538e-10, -2.38418352e-07)
Part7.Orientation = Vector3.new(0.03999999910593, -90, 0)
Part7.Position = Vector3.new(-9.7104597091675, 0.27486577630043, -32.514694213867)
Part7.Rotation = Vector3.new(90.019996643066, -89.949996948242, 89.980003356934)
Part7.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part7.Size = Vector3.new(0.19999992847443, 0.20000001788139, 0.20000001788139)
Part7.BottomSurface = Enum.SurfaceType.Smooth
Part7.BrickColor = BrickColor.new("Black")
Part7.TopSurface = Enum.SurfaceType.Smooth
Part7.brickColor = BrickColor.new("Black")
Part7.Shape = Enum.PartType.Cylinder
Part8.Name = "thing"
Part8.Parent = Model4
Part8.CFrame = CFrame.new(-9.71045971, 0.274865776, -33.2646942, 2.08616214e-07, -0.000669842761, -0.999999642, -1.82170098e-10, 1.00000036, -0.000669857603, 1, -3.05539538e-10, -2.38418352e-07)
Part8.Orientation = Vector3.new(0.03999999910593, -90, 0)
Part8.Position = Vector3.new(-9.7104597091675, 0.27486577630043, -33.264694213867)
Part8.Rotation = Vector3.new(90.019996643066, -89.949996948242, 89.980003356934)
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part8.Size = Vector3.new(0.19999992847443, 0.20000001788139, 0.20000001788139)
Part8.BottomSurface = Enum.SurfaceType.Smooth
Part8.BrickColor = BrickColor.new("Black")
Part8.TopSurface = Enum.SurfaceType.Smooth
Part8.brickColor = BrickColor.new("Black")
Part8.Shape = Enum.PartType.Cylinder
Weld9.Parent = Model4
Weld9.C0 = CFrame.new(-0.00043296814, -0.000134289265, -1.29466057, 1.1920929e-07, -0.000669842819, -0.999999762, -1.16599425e-10, 1.00000024, -0.000669842644, 1, -1.80079965e-10, -1.49011527e-07)
Weld9.Part0 = Part1
Weld9.Part1 = Part5
Weld9.part1 = Part5
Weld10.Parent = Model4
Weld10.C0 = CFrame.new(-0.00043296814, -0.000134289265, -1.04466057, 1.1920929e-07, -0.000669842819, -0.999999762, -1.16599425e-10, 1.00000024, -0.000669842644, 1, -1.80079965e-10, -1.49011527e-07)
Weld10.Part0 = Part1
Weld10.Part1 = Part6
Weld10.part1 = Part6
Weld11.Parent = Model4
Weld11.C0 = CFrame.new(-0.00043296814, -0.000134289265, -0.794660568, 1.1920929e-07, -0.000669842819, -0.999999762, -1.16599425e-10, 1.00000024, -0.000669842644, 1, -1.80079965e-10, -1.49011527e-07)
Weld11.Part0 = Part1
Weld11.Part1 = Part7
Weld11.part1 = Part7
Weld12.Parent = Model4
Weld12.C0 = CFrame.new(-0.00043296814, -0.000134289265, -1.54466057, 1.1920929e-07, -0.000669842819, -0.999999762, -1.16599425e-10, 1.00000024, -0.000669842644, 1, -1.80079965e-10, -1.49011527e-07)
Weld12.Part0 = Part1
Weld12.Part1 = Part8
Weld12.part1 = Part8
Model13.Name = "barbedwire"
Model13.Parent = Part1
Part14.Name = "Wire"
Part14.Parent = Model13
Part14.CFrame = CFrame.new(-9.71000004, 0.289999932, -29.9799995, -2.98023135e-08, -3.57628096e-07, -0.999999762, 1.00000036, 2.9933318e-08, -1.4901163e-08, 2.96710141e-08, -1, 4.76063633e-13)
Part14.Orientation = Vector3.new(0, -90, 90)
Part14.Position = Vector3.new(-9.710000038147, 0.2899999320507, -29.979999542236)
Part14.Rotation = Vector3.new(90, -89.959999084473, 94.76000213623)
Part14.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part14.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part14.BottomSurface = Enum.SurfaceType.Smooth
Part14.BrickColor = BrickColor.new("Dark stone grey")
Part14.CanCollide = false
Part14.FrontSurface = Enum.SurfaceType.Weld
Part14.Reflectance = 0.25
Part14.TopSurface = Enum.SurfaceType.Smooth
Part14.brickColor = BrickColor.new("Dark stone grey")
Part14.FormFactor = Enum.FormFactor.Symmetric
Part14.formFactor = Enum.FormFactor.Symmetric
SpecialMesh15.Parent = Part14
SpecialMesh15.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh15.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh15.MeshType = Enum.MeshType.FileMesh
Part16.Name = "Wire"
Part16.Parent = Model13
Part16.CFrame = CFrame.new(-9.71000004, 0.290000141, -30.0699997, -0.422618181, -3.57628124e-07, -0.906307518, 0.906307995, 2.99333642e-08, -0.422618389, 2.68912466e-08, -1, -1.25390542e-08)
Part16.Orientation = Vector3.new(25, -90, 90)
Part16.Position = Vector3.new(-9.710000038147, 0.29000014066696, -30.069999694824)
Part16.Rotation = Vector3.new(90, -65, 180)
Part16.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part16.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part16.BottomSurface = Enum.SurfaceType.Smooth
Part16.BrickColor = BrickColor.new("Dark stone grey")
Part16.CanCollide = false
Part16.FrontSurface = Enum.SurfaceType.Weld
Part16.Reflectance = 0.25
Part16.TopSurface = Enum.SurfaceType.Smooth
Part16.brickColor = BrickColor.new("Dark stone grey")
Part16.FormFactor = Enum.FormFactor.Symmetric
Part16.formFactor = Enum.FormFactor.Symmetric
SpecialMesh17.Parent = Part16
SpecialMesh17.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh17.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh17.MeshType = Enum.MeshType.FileMesh
Part18.Name = "Wire"
Part18.Parent = Model13
Part18.CFrame = CFrame.new(-9.70999908, 0.28999871, -30.1749973, -0.819151819, -3.57628096e-07, -0.573576331, 0.573576629, 2.99333003e-08, -0.819152355, 1.70189907e-08, -1, -2.43048035e-08)
Part18.Orientation = Vector3.new(55, -90, 90)
Part18.Position = Vector3.new(-9.7099990844727, 0.28999871015549, -30.174997329712)
Part18.Rotation = Vector3.new(90, -35, 180)
Part18.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part18.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part18.BottomSurface = Enum.SurfaceType.Smooth
Part18.BrickColor = BrickColor.new("Dark stone grey")
Part18.CanCollide = false
Part18.FrontSurface = Enum.SurfaceType.Weld
Part18.Reflectance = 0.25
Part18.TopSurface = Enum.SurfaceType.Smooth
Part18.brickColor = BrickColor.new("Dark stone grey")
Part18.FormFactor = Enum.FormFactor.Symmetric
Part18.formFactor = Enum.FormFactor.Symmetric
SpecialMesh19.Parent = Part18
SpecialMesh19.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh19.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh19.MeshType = Enum.MeshType.FileMesh
Part20.Name = "Wire"
Part20.Parent = Model13
Part20.CFrame = CFrame.new(-9.71000004, 0.289999187, -30.2649975, -0.984807551, -3.57628096e-07, -0.173648149, 0.173648193, 2.99333074e-08, -0.984808087, 5.15280618e-09, -1, -2.92201729e-08)
Part20.Orientation = Vector3.new(80, -90, 90)
Part20.Position = Vector3.new(-9.710000038147, 0.28999918699265, -30.2649974823)
Part20.Rotation = Vector3.new(90, -10, 180)
Part20.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part20.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part20.BottomSurface = Enum.SurfaceType.Smooth
Part20.BrickColor = BrickColor.new("Dark stone grey")
Part20.CanCollide = false
Part20.FrontSurface = Enum.SurfaceType.Weld
Part20.Reflectance = 0.25
Part20.TopSurface = Enum.SurfaceType.Smooth
Part20.brickColor = BrickColor.new("Dark stone grey")
Part20.FormFactor = Enum.FormFactor.Symmetric
Part20.formFactor = Enum.FormFactor.Symmetric
SpecialMesh21.Parent = Part20
SpecialMesh21.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh21.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh21.MeshType = Enum.MeshType.FileMesh
Part22.Name = "Wire"
Part22.Parent = Model13
Part22.CFrame = CFrame.new(-9.71000004, 0.289999187, -30.4599972, -0.984807551, -3.57628153e-07, -0.173648089, 0.173648193, 2.99333571e-08, -0.984808087, 5.15279197e-09, -1, -2.92201232e-08)
Part22.Orientation = Vector3.new(80, -90, 90)
Part22.Position = Vector3.new(-9.710000038147, 0.28999918699265, -30.459997177124)
Part22.Rotation = Vector3.new(90, -10, 180)
Part22.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part22.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part22.BottomSurface = Enum.SurfaceType.Smooth
Part22.BrickColor = BrickColor.new("Dark stone grey")
Part22.CanCollide = false
Part22.FrontSurface = Enum.SurfaceType.Weld
Part22.Reflectance = 0.25
Part22.TopSurface = Enum.SurfaceType.Smooth
Part22.brickColor = BrickColor.new("Dark stone grey")
Part22.FormFactor = Enum.FormFactor.Symmetric
Part22.formFactor = Enum.FormFactor.Symmetric
SpecialMesh23.Parent = Part22
SpecialMesh23.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh23.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh23.MeshType = Enum.MeshType.FileMesh
Part24.Name = "Wire"
Part24.Parent = Model13
Part24.CFrame = CFrame.new(-9.71000004, 0.289999932, -30.1749992, -2.98023135e-08, -3.57628124e-07, -0.999999762, 1.00000024, 2.99333571e-08, -1.4901163e-08, 2.96709732e-08, -1, 4.76063633e-13)
Part24.Orientation = Vector3.new(0, -90, 90)
Part24.Position = Vector3.new(-9.710000038147, 0.2899999320507, -30.174999237061)
Part24.Rotation = Vector3.new(90, -89.959999084473, 94.76000213623)
Part24.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part24.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part24.BottomSurface = Enum.SurfaceType.Smooth
Part24.BrickColor = BrickColor.new("Dark stone grey")
Part24.CanCollide = false
Part24.FrontSurface = Enum.SurfaceType.Weld
Part24.Reflectance = 0.25
Part24.TopSurface = Enum.SurfaceType.Smooth
Part24.brickColor = BrickColor.new("Dark stone grey")
Part24.FormFactor = Enum.FormFactor.Symmetric
Part24.formFactor = Enum.FormFactor.Symmetric
SpecialMesh25.Parent = Part24
SpecialMesh25.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh25.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh25.MeshType = Enum.MeshType.FileMesh
Part26.Name = "Wire"
Part26.Parent = Model13
Part26.CFrame = CFrame.new(-9.71000004, 0.290000141, -30.2649994, -0.422618181, -3.57628124e-07, -0.906307518, 0.906307995, 2.99333607e-08, -0.422618389, 2.68912466e-08, -1, -1.25390613e-08)
Part26.Orientation = Vector3.new(25, -90, 90)
Part26.Position = Vector3.new(-9.710000038147, 0.29000014066696, -30.264999389648)
Part26.Rotation = Vector3.new(90, -65, 180)
Part26.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part26.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part26.BottomSurface = Enum.SurfaceType.Smooth
Part26.BrickColor = BrickColor.new("Dark stone grey")
Part26.CanCollide = false
Part26.FrontSurface = Enum.SurfaceType.Weld
Part26.Reflectance = 0.25
Part26.TopSurface = Enum.SurfaceType.Smooth
Part26.brickColor = BrickColor.new("Dark stone grey")
Part26.FormFactor = Enum.FormFactor.Symmetric
Part26.formFactor = Enum.FormFactor.Symmetric
SpecialMesh27.Parent = Part26
SpecialMesh27.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh27.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh27.MeshType = Enum.MeshType.FileMesh
Part28.Name = "Wire"
Part28.Parent = Model13
Part28.CFrame = CFrame.new(-9.70999908, 0.28999871, -30.369997, -0.819151819, -3.57628124e-07, -0.573576331, 0.57357657, 2.99333394e-08, -0.819152296, 1.70189693e-08, -1, -2.43047715e-08)
Part28.Orientation = Vector3.new(55, -90, 90)
Part28.Position = Vector3.new(-9.7099990844727, 0.28999871015549, -30.369997024536)
Part28.Rotation = Vector3.new(90, -35, 180)
Part28.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part28.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part28.BottomSurface = Enum.SurfaceType.Smooth
Part28.BrickColor = BrickColor.new("Dark stone grey")
Part28.CanCollide = false
Part28.FrontSurface = Enum.SurfaceType.Weld
Part28.Reflectance = 0.25
Part28.TopSurface = Enum.SurfaceType.Smooth
Part28.brickColor = BrickColor.new("Dark stone grey")
Part28.FormFactor = Enum.FormFactor.Symmetric
Part28.formFactor = Enum.FormFactor.Symmetric
SpecialMesh29.Parent = Part28
SpecialMesh29.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh29.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh29.MeshType = Enum.MeshType.FileMesh
Part30.Name = "Wire"
Part30.Parent = Model13
Part30.CFrame = CFrame.new(-9.71000004, 0.289999902, -29.9049988, -1.74615419e-10, -3.57628181e-07, -0.999999881, 1.00000048, 2.99333678e-08, -1.47265418e-08, 2.96709697e-08, -1, 4.54747351e-13)
Part30.Orientation = Vector3.new(0, -90, 90)
Part30.Position = Vector3.new(-9.710000038147, 0.28999990224838, -29.904998779297)
Part30.Rotation = Vector3.new(90, -89.970001220703, 90.029998779297)
Part30.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part30.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part30.BottomSurface = Enum.SurfaceType.Smooth
Part30.BrickColor = BrickColor.new("Dark stone grey")
Part30.CanCollide = false
Part30.FrontSurface = Enum.SurfaceType.Weld
Part30.Reflectance = 0.25
Part30.TopSurface = Enum.SurfaceType.Smooth
Part30.brickColor = BrickColor.new("Dark stone grey")
Part30.FormFactor = Enum.FormFactor.Symmetric
Part30.formFactor = Enum.FormFactor.Symmetric
SpecialMesh31.Parent = Part30
SpecialMesh31.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh31.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh31.MeshType = Enum.MeshType.FileMesh
Part32.Name = "Wire"
Part32.Parent = Model13
Part32.CFrame = CFrame.new(-9.71000004, 0.290000111, -29.9949989, -0.42261821, -3.57628181e-07, -0.906307638, 0.906308174, 2.99333713e-08, -0.422618479, 2.68912359e-08, -1, -1.25390898e-08)
Part32.Orientation = Vector3.new(25, -90, 90)
Part32.Position = Vector3.new(-9.710000038147, 0.29000011086464, -29.994998931885)
Part32.Rotation = Vector3.new(90, -65, 180)
Part32.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part32.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part32.BottomSurface = Enum.SurfaceType.Smooth
Part32.BrickColor = BrickColor.new("Dark stone grey")
Part32.CanCollide = false
Part32.FrontSurface = Enum.SurfaceType.Weld
Part32.Reflectance = 0.25
Part32.TopSurface = Enum.SurfaceType.Smooth
Part32.brickColor = BrickColor.new("Dark stone grey")
Part32.FormFactor = Enum.FormFactor.Symmetric
Part32.formFactor = Enum.FormFactor.Symmetric
SpecialMesh33.Parent = Part32
SpecialMesh33.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh33.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh33.MeshType = Enum.MeshType.FileMesh
Part34.Name = "Wire"
Part34.Parent = Model13
Part34.CFrame = CFrame.new(-9.70999908, 0.28999868, -30.0999966, -0.819151878, -3.57628181e-07, -0.573576331, 0.573576629, 2.993335e-08, -0.819152355, 1.7018948e-08, -1, -2.43047715e-08)
Part34.Orientation = Vector3.new(55, -90, 90)
Part34.Position = Vector3.new(-9.7099990844727, 0.28999868035316, -30.099996566772)
Part34.Rotation = Vector3.new(90, -35, 180)
Part34.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part34.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part34.BottomSurface = Enum.SurfaceType.Smooth
Part34.BrickColor = BrickColor.new("Dark stone grey")
Part34.CanCollide = false
Part34.FrontSurface = Enum.SurfaceType.Weld
Part34.Reflectance = 0.25
Part34.TopSurface = Enum.SurfaceType.Smooth
Part34.brickColor = BrickColor.new("Dark stone grey")
Part34.FormFactor = Enum.FormFactor.Symmetric
Part34.formFactor = Enum.FormFactor.Symmetric
SpecialMesh35.Parent = Part34
SpecialMesh35.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh35.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh35.MeshType = Enum.MeshType.FileMesh
Part36.Name = "Wire"
Part36.Parent = Model13
Part36.CFrame = CFrame.new(-9.70999908, 0.28999871, -30.9849968, -0.819151878, -3.57628124e-07, -0.573576331, 0.573576629, 2.99333287e-08, -0.819152355, 1.70189693e-08, -1, -2.43047786e-08)
Part36.Orientation = Vector3.new(55, -90, 90)
Part36.Position = Vector3.new(-9.7099990844727, 0.28999871015549, -30.984996795654)
Part36.Rotation = Vector3.new(90, -35, 180)
Part36.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part36.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part36.BottomSurface = Enum.SurfaceType.Smooth
Part36.BrickColor = BrickColor.new("Dark stone grey")
Part36.CanCollide = false
Part36.FrontSurface = Enum.SurfaceType.Weld
Part36.Reflectance = 0.25
Part36.TopSurface = Enum.SurfaceType.Smooth
Part36.brickColor = BrickColor.new("Dark stone grey")
Part36.FormFactor = Enum.FormFactor.Symmetric
Part36.formFactor = Enum.FormFactor.Symmetric
SpecialMesh37.Parent = Part36
SpecialMesh37.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh37.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh37.MeshType = Enum.MeshType.FileMesh
Part38.Name = "Wire"
Part38.Parent = Model13
Part38.CFrame = CFrame.new(-9.70999908, 0.28999871, -30.7149963, -0.819151878, -3.57628096e-07, -0.573576331, 0.573576629, 2.99333216e-08, -0.819152355, 1.70189693e-08, -1, -2.43047857e-08)
Part38.Orientation = Vector3.new(55, -90, 90)
Part38.Position = Vector3.new(-9.7099990844727, 0.28999871015549, -30.714996337891)
Part38.Rotation = Vector3.new(90, -35, 180)
Part38.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part38.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part38.BottomSurface = Enum.SurfaceType.Smooth
Part38.BrickColor = BrickColor.new("Dark stone grey")
Part38.CanCollide = false
Part38.FrontSurface = Enum.SurfaceType.Weld
Part38.Reflectance = 0.25
Part38.TopSurface = Enum.SurfaceType.Smooth
Part38.brickColor = BrickColor.new("Dark stone grey")
Part38.FormFactor = Enum.FormFactor.Symmetric
Part38.formFactor = Enum.FormFactor.Symmetric
SpecialMesh39.Parent = Part38
SpecialMesh39.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh39.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh39.MeshType = Enum.MeshType.FileMesh
Part40.Name = "Wire"
Part40.Parent = Model13
Part40.CFrame = CFrame.new(-9.71000004, 0.289999932, -30.5199986, -2.98023135e-08, -3.57628096e-07, -0.999999821, 1.00000036, 2.99333252e-08, -1.4901163e-08, 2.96710052e-08, -1, 4.76063633e-13)
Part40.Orientation = Vector3.new(0, -90, 90)
Part40.Position = Vector3.new(-9.710000038147, 0.2899999320507, -30.519998550415)
Part40.Rotation = Vector3.new(90, -89.970001220703, 94.76000213623)
Part40.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part40.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part40.BottomSurface = Enum.SurfaceType.Smooth
Part40.BrickColor = BrickColor.new("Dark stone grey")
Part40.CanCollide = false
Part40.FrontSurface = Enum.SurfaceType.Weld
Part40.Reflectance = 0.25
Part40.TopSurface = Enum.SurfaceType.Smooth
Part40.brickColor = BrickColor.new("Dark stone grey")
Part40.FormFactor = Enum.FormFactor.Symmetric
Part40.formFactor = Enum.FormFactor.Symmetric
SpecialMesh41.Parent = Part40
SpecialMesh41.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh41.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh41.MeshType = Enum.MeshType.FileMesh
Part42.Name = "Wire"
Part42.Parent = Model13
Part42.CFrame = CFrame.new(-9.71000004, 0.290000141, -30.6099987, -0.42261821, -3.57628096e-07, -0.906307578, 0.906308115, 2.99333287e-08, -0.422618419, 2.68912785e-08, -1, -1.25390827e-08)
Part42.Orientation = Vector3.new(25, -90, 90)
Part42.Position = Vector3.new(-9.710000038147, 0.29000014066696, -30.609998703003)
Part42.Rotation = Vector3.new(90, -65, 180)
Part42.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part42.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part42.BottomSurface = Enum.SurfaceType.Smooth
Part42.BrickColor = BrickColor.new("Dark stone grey")
Part42.CanCollide = false
Part42.FrontSurface = Enum.SurfaceType.Weld
Part42.Reflectance = 0.25
Part42.TopSurface = Enum.SurfaceType.Smooth
Part42.brickColor = BrickColor.new("Dark stone grey")
Part42.FormFactor = Enum.FormFactor.Symmetric
Part42.formFactor = Enum.FormFactor.Symmetric
SpecialMesh43.Parent = Part42
SpecialMesh43.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh43.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh43.MeshType = Enum.MeshType.FileMesh
Part44.Name = "Wire"
Part44.Parent = Model13
Part44.CFrame = CFrame.new(-9.71000004, 0.290000141, -30.8799992, -0.422618181, -3.57628096e-07, -0.906307518, 0.906308115, 2.99333216e-08, -0.422618419, 2.68912821e-08, -1, -1.25390827e-08)
Part44.Orientation = Vector3.new(25, -90, 90)
Part44.Position = Vector3.new(-9.710000038147, 0.29000014066696, -30.879999160767)
Part44.Rotation = Vector3.new(90, -65, 180)
Part44.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part44.Size = Vector3.new(0.35500004887581, 0.11345028877258, 0.35500004887581)
Part44.BottomSurface = Enum.SurfaceType.Smooth
Part44.BrickColor = BrickColor.new("Dark stone grey")
Part44.CanCollide = false
Part44.FrontSurface = Enum.SurfaceType.Weld
Part44.Reflectance = 0.25
Part44.TopSurface = Enum.SurfaceType.Smooth
Part44.brickColor = BrickColor.new("Dark stone grey")
Part44.FormFactor = Enum.FormFactor.Symmetric
Part44.formFactor = Enum.FormFactor.Symmetric
SpecialMesh45.Parent = Part44
SpecialMesh45.MeshId = "http://www.roblox.com/asset/?id=1051557"
SpecialMesh45.Scale = Vector3.new(0.35500004887581, 0.11344904452562, 0.35500004887581)
SpecialMesh45.MeshType = Enum.MeshType.FileMesh
Weld46.Parent = Model13
Weld46.C0 = CFrame.new(2.67028809e-05, 0.0150000602, 1.45503235, -0.42261824, -2.68221214e-07, -0.906307638, 0.906307876, 2.98677882e-08, -0.42261833, 6.47356515e-08, -1, 6.84633648e-08)
Weld46.Part0 = Part1
Weld46.Part1 = Part26
Weld46.part1 = Part26
Weld47.Parent = Model13
Weld47.C0 = CFrame.new(2.76565552e-05, 0.0149986148, 1.62003517, -0.819151998, -2.68221271e-07, -0.573576391, 0.57357657, 2.98677776e-08, -0.819152236, 9.02943853e-08, -1, 2.69231926e-08)
Weld47.Part0 = Part1
Weld47.Part1 = Part34
Weld47.part1 = Part34
Weld48.Parent = Model13
Weld48.C0 = CFrame.new(2.67028809e-05, 0.0150000751, 0.840032578, -0.42261824, -2.68221186e-07, -0.906307638, 0.906307995, 2.98677492e-08, -0.422618359, 6.4735687e-08, -1, 6.84633434e-08)
Weld48.Part0 = Part1
Weld48.Part1 = Part44
Weld48.part1 = Part44
Weld49.Parent = Model13
Weld49.C0 = CFrame.new(2.76565552e-05, 0.0149986297, 1.0050354, -0.819151998, -2.68221186e-07, -0.573576391, 0.57357657, 2.98677492e-08, -0.819152236, 9.02944066e-08, -1, 2.69231784e-08)
Weld49.Part0 = Part1
Weld49.Part1 = Part38
Weld49.part1 = Part38
Weld50.Parent = Model13
Weld50.C0 = CFrame.new(2.67028809e-05, 0.0150000602, 1.11003304, -0.42261827, -2.68221186e-07, -0.906307697, 0.906307995, 2.98677563e-08, -0.422618359, 6.4735687e-08, -1, 6.84633505e-08)
Weld50.Part0 = Part1
Weld50.Part1 = Part42
Weld50.part1 = Part42
Weld51.Parent = Model13
Weld51.C0 = CFrame.new(2.76565552e-05, 0.0149986446, 0.735034943, -0.819151998, -2.68221214e-07, -0.573576391, 0.57357657, 2.98677563e-08, -0.819152236, 9.02944066e-08, -1, 2.69231855e-08)
Weld51.Part0 = Part1
Weld51.Part1 = Part36
Weld51.part1 = Part36
Weld52.Parent = Model13
Weld52.C0 = CFrame.new(2.76565552e-05, 0.0149986297, 1.35003471, -0.819151938, -2.68221214e-07, -0.573576391, 0.57357651, 2.98677669e-08, -0.819152176, 9.02943995e-08, -1, 2.69231926e-08)
Weld52.Part0 = Part1
Weld52.Part1 = Part28
Weld52.part1 = Part28
Weld53.Parent = Model13
Weld53.C0 = CFrame.new(2.67028809e-05, 0.0149998516, 1.7400322, -2.98023188e-08, -2.68221186e-07, -0.999999881, 1.00000024, 2.98677456e-08, -3.12035651e-15, 2.97365883e-08, -1, 8.94073509e-08)
Weld53.Part0 = Part1
Weld53.Part1 = Part14
Weld53.part1 = Part14
Weld54.Parent = Model13
Weld54.C0 = CFrame.new(2.67028809e-05, 0.0150000602, 1.65003204, -0.42261824, -2.68221214e-07, -0.906307638, 0.906307876, 2.98677918e-08, -0.42261833, 6.47356515e-08, -1, 6.84633719e-08)
Weld54.Part0 = Part1
Weld54.Part1 = Part16
Weld54.part1 = Part16
Weld55.Parent = Model13
Weld55.C0 = CFrame.new(2.67028809e-05, 0.0149998516, 1.5450325, -2.98023188e-08, -2.68221214e-07, -0.999999881, 1.00000012, 2.98677847e-08, -3.12036371e-15, 2.97365474e-08, -1, 8.94073509e-08)
Weld55.Part0 = Part1
Weld55.Part1 = Part24
Weld55.part1 = Part24
Weld56.Parent = Model13
Weld56.C0 = CFrame.new(2.67028809e-05, 0.0149991065, 1.45503426, -0.98480767, -2.68221186e-07, -0.173648164, 0.173648193, 2.9867735e-08, -0.984807968, 9.32127691e-08, -1, -1.37594061e-08)
Weld56.Part0 = Part1
Weld56.Part1 = Part20
Weld56.part1 = Part20
Weld57.Parent = Model13
Weld57.C0 = CFrame.new(2.67028809e-05, 0.0149991065, 1.26003456, -0.98480767, -2.68221243e-07, -0.173648104, 0.173648193, 2.98677847e-08, -0.984807968, 9.32127548e-08, -1, -1.37593617e-08)
Weld57.Part0 = Part1
Weld57.Part1 = Part22
Weld57.part1 = Part22
Weld58.Parent = Model13
Weld58.C0 = CFrame.new(2.67028809e-05, 0.0149998516, 1.20003319, -2.98023188e-08, -2.68221186e-07, -0.99999994, 1.00000024, 2.98677527e-08, -3.12035778e-15, 2.97365794e-08, -1, 8.94073509e-08)
Weld58.Part0 = Part1
Weld58.Part1 = Part40
Weld58.part1 = Part40
Weld59.Parent = Model13
Weld59.C0 = CFrame.new(2.67028809e-05, 0.0150000453, 1.72503281, -0.42261827, -2.68221271e-07, -0.906307757, 0.906308055, 2.98677989e-08, -0.422618419, 6.47356444e-08, -1, 6.84633505e-08)
Weld59.Part0 = Part1
Weld59.Part1 = Part32
Weld59.part1 = Part32
Weld60.Parent = Model13
Weld60.C0 = CFrame.new(2.76565552e-05, 0.0149986297, 1.54503441, -0.819151938, -2.68221186e-07, -0.573576391, 0.57357657, 2.98677278e-08, -0.819152236, 9.02944208e-08, -1, 2.69231606e-08)
Weld60.Part0 = Part1
Weld60.Part1 = Part18
Weld60.part1 = Part18
Weld61.Parent = Model13
Weld61.C0 = CFrame.new(2.67028809e-05, 0.0149998367, 1.81503296, -1.74618098e-10, -2.68221271e-07, -1, 1.00000036, 2.98677953e-08, 1.7461986e-10, 2.97365403e-08, -1, 8.94073366e-08)
Weld61.Part0 = Part1
Weld61.Part1 = Part30
Weld61.part1 = Part30
Script62.Parent = Tool0
for i = 1,10 do
	local a = Instance.new("Attachment", Part1)
	a.Name = "hitat"
	if i == 1 then
		a.Position = Vector3.new(-0, 0.19, 1.085)
	elseif i == 2 then
		a.Position = Vector3.new(0, -0.19, 1.085)
	elseif i == 3 then
		a.Position = Vector3.new(-0, 0.19, 2.085)
	elseif i == 4 then
		a.Position = Vector3.new(0, -0.19, 0.585)
	elseif i == 5 then
		a.Position = Vector3.new(-0, 0.19, 1.585)
	elseif i == 6 then
		a.Position = Vector3.new(-0, 0.19, 0.585)
	elseif i == 7 then
		a.Position = Vector3.new(0, -0.19, 1.585)
	elseif i == 8 then
		a.Position = Vector3.new(0, -0.19, 2.085)
	elseif i == 9 then
		a.Position = Vector3.new(-0, -0, -0.84)
		a.Name = "trailat1"
		Trail2.Attachment0 = a
	elseif i == 10 then
		a.Position = Vector3.new(-0, 0, 2.184)
		a.Name = "trailat2"
		Trail2.Attachment1 = a
	end
end
table.insert(cors,sandbox(Script62,function()
	--By Rufus14, FPS unlocker really recommended to improve hitbox (serverside anims amazig;.)
	tool = script.Parent
	handle = tool.Handle
	trail = handle.trail
	players = game:GetService("Players")
	runservice = game:GetService("RunService")
	tweenservice = game:GetService("TweenService")
	player = nil
	character = nil
	charhum = nil
	validatetick = nil
	lastswingtick = tick()
	equiptick = nil
	swinganimation = 0
	state = "unequipped"
	hitpeople = {}
	remote = tool.RemoteEvent
	cfnew = CFrame.new
	cfeuler = CFrame.fromEulerAnglesXYZ
	headoffset = 0
	speedbuff = 3
	animslowdownmult = 1
	damage = 32
	ragdolldeath = true
	ragdolldespawntime = 10
	swingids = {7025241907, 7025242231, 7025242061}
	headshotids = {7025209172, 7025209359, 7025209663}

	function monar(WHAT, duration)
		game:GetService("Debris"):AddItem(WHAT, duration)
	end

	function pose(POSE, KEYFRAME, speeed, btick)
		if state ~= "unequipped" and btick == validatetick then
			local findhead = findthing("HeadWeld", character.Torso)
			local findrarm = findthing("RightArmWeld", character.Head)
			local findlarm = findthing("LeftArmWeld", character.Head)
			local findrootpart = findthing("HumanoidRootPartWeld", character.HumanoidRootPart)
			local findhandle = findthing("RightGrip", character["Right Arm"])
			local startheadcf = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0,0.35,0)
			if POSE == "equip" then
				if KEYFRAME == 1 then
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhead, {C0 = startheadcf})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findlarm, {C0 = cfnew(-1.44015026, -1.21483612, -0.510011673, 0.939692616, -0.0593911, -0.336824089, -0.219846278, 0.649519145, -0.727868319, 0.262002617, 0.75802207, 0.59729147)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrarm, {C0 = cfnew(1.50723648, -0.872226715, -0.475799561, 0.993774354, -0.0206981599, 0.109471887, 0.105154656, -0.150392503, -0.983018041, 0.0368103981, 0.988409638, -0.147279769)})
				elseif KEYFRAME == 2 then
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = startheadcf})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(-0.346603394, -0.875337601, -1.26449776, 0.386504501, -0.922008514, -0.0226809084, -0.380557179, -0.137031734, -0.91454798, 0.840113282, 0.362108439, -0.403840333)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(1.19728947, -1.18899059, -1.02231216, 0.723017693, 0.65307492, -0.225251526, 0.239422247, -0.542735159, -0.805056036, -0.648014128, 0.52813971, -0.548767924)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew()})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(-0.146380901, -0.737253189, -1.19895506, -2.30073929e-05, 0.984813273, -0.173616707, 0.965931416, 0.0449533761, 0.254863977, 0.258798063, -0.167695761, -0.95126307)})
				end
			elseif POSE == "swing" then
				if KEYFRAME == 1 then
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0.0174388885, 0, -0.0302057266, 0.498782009, 0.034878239, 0.866025448, -0.0697564781, 0.997564077, 0, -0.863915861, -0.0604108907, 0.49999997) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(1.26383877, -0.320791245, -0.0221424103, -0.453994513, -0.6217888, 0.638175189, -0.373202592, -0.517683685, -0.769885063, 0.809078932, -0.58769244, 0.00297236443)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.49999997, 0, -0.866025448, 0, 1, 0, 0.866025448, 0, 0.49999997)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(1.47292042, -0.71627903, 0.928699493, 0.864569545, -0.310034782, 0.395471781, -0.18596983, -0.928516686, -0.321359307, 0.466834486, 0.204291821, -0.860424399)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(-0.146380901, -0.737253189, -1.19895506, -2.30073929e-05, 0.984813273, -0.173616707, 0.965931416, 0.0449533761, 0.254863977, 0.258798063, -0.167695761, -0.95126307)})
				elseif KEYFRAME == 2 then
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0.0377388, 0, -0.0217895508, 0.98171097, 0.0754790828, 0.174775332, -0.0818996057, 0.99619472, 0.0298090167, -0.171860278, -0.0435778685, 0.984156907) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findlarm, {C0 = cfnew(0.468593597, -1.03038788, -1.23982811, 0.432251483, -0.812906563, -0.390309304, -0.815274477, -0.16733487, -0.554370344, 0.385338962, 0.557836533, -0.735072732)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.965925753, 0, -0.258819252, 0, 1, 0, 0.258819252, 0, 0.965925753)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrarm, {C0 = cfnew(1.37798214, -1.33913612, -0.998968124, 0.723661661, 0.0184313767, -0.689908445, -0.593295872, -0.494076759, -0.635521889, -0.352581263, 0.86922276, -0.346609175)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhandle, {C0 = cfnew(-0.27100563, -1.7641201, -0.778264999, -0.0508781821, 0.977075875, -0.206721604, 0.787041605, -0.088194713, -0.61056298, -0.61479789, -0.193762809, -0.764512599)})
				elseif KEYFRAME == 3 then
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(-0.0290613174, 0, 0.0341873169, 0.642215371, -0.0581262708, -0.764317155, -0.0151344156, 0.995964825, -0.0884597152, 0.766374826, 0.0683777183, 0.638743997) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(-1.34177113, -1.71902466, -0.075170517, 0.540476441, 0.622194886, -0.566355288, -0.827879965, 0.513294995, -0.226147667, 0.149999231, 0.591101706, 0.792526603)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.707106888, -0.122787632, 0.696364164, 0, 0.984807789, 0.17364797, -0.70710665, -0.122787677, 0.696364343)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(-0.689968109, -1.82466888, -1.10832024, 0.0564864352, 0.983989894, 0.169034928, -0.723721862, 0.156985015, -0.67199868, -0.687775791, -0.0843754783, 0.72100246)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(0.858270645, -2.00149822, -0.718647003, -0.274746865, 0.729312301, 0.626599252, 0.369775802, 0.68170315, -0.631313443, -0.887577295, 0.0582513511, -0.456976354)})
				end
			elseif POSE == "swing2" then
				if KEYFRAME == 1 then
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0, 0, 0, 0.342020124, 0, -0.939692497, 0, 1, 0, 0.939692497, 0, 0.342020124 ) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(-1.71396351, -1.6685009, 0.976118088, 0.499530166, 0.744541049, -0.442863405, -0.0158833992, -0.503257155, -0.863990664, -0.866150677, 0.438623607, -0.239566326)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.342020035, 0, 0.939692616, 0, 1, 0, -0.939692616, 0, 0.342020035)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(-1.62695694, -1.15502453, -0.621263504, -0.388809949, 0.676470757, -0.625470757, 0.786783457, -0.109439395, -0.607449293, -0.479372889, -0.728292584, -0.48968491)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(-0.0732631683, -1.26810265, -1.21585846, -0.166786343, 0.985272348, 0.0376830995, 0.967181802, 0.17091462, -0.188006341, -0.191677839, 0.00508895516, -0.98144424)})
				elseif KEYFRAME == 2 then
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0, 0, 0, 0.999999881, 1.69406589e-21, 0, 1.69406589e-21, 0.999999881, 1.42108547e-14, 0, 1.42108547e-14, 0.999999762) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findlarm, {C0 = cfnew(-0.751349449, -1.3943367, -1.64109993, 0.984764755, -0.157523334, 0.0736504793, -0.0158834103, -0.503257036, -0.863990545, 0.173163831, 0.849657655, -0.498091936) * cfnew(0,-0.5,0)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrootpart, {C0 = cfnew()})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrarm, {C0 = cfnew(0.534347534, -1.19490814, -1.69585228, 0.811359644, 0.568405509, 0.136419684, 0.312516361, -0.224575609, -0.922983706, -0.493992656, 0.791505158, -0.359847665) * cfnew(0,-0.5,0) * cfeuler(-0.3,0,0)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhandle, {C0 = cfnew(-0.241220474, -2.86224651, -0.358363152, 0.00764432549, 0.983584642, -0.180281967, 0.161737233, -0.179129779, -0.970439374, -0.986803532, -0.0217397511, -0.160451934)})
				elseif KEYFRAME == 3 then
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(-0.055809021, 0, -0.0665121078, 0.76604414, -0.111618906, 0.63302213, 5.93718141e-09, 0.984807551, 0.173648134, -0.642787576, -0.133022189, 0.754406095) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findlarm, {C0 = cfnew(1.11655521, -0.562868118, -1.38667488, 0.0639937669, -0.92416805, 0.376586914, -0.493751466, -0.357257128, -0.792828083, 0.86724484, -0.135204315, -0.479171693)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.766044319, -0.111618891, -0.633022189, 1.3409597e-07, 0.98480767, -0.173648, 0.642787576, 0.133021981, 0.754406393)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findrarm, {C0 = cfnew(1.71633816, -1.00290394, -0.395078659, 0.67222333, -0.505163789, 0.541225433, -0.0338932052, -0.751273572, -0.659119725, 0.73957181, 0.42473188, -0.522145271)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findhandle, {C0 = cfnew(1.01893806, -1.66208458, -0.151894569, 0.00764530897, 0.505814016, 0.86260426, 0.161738127, 0.850645602, -0.500235498, -0.986800253, 0.143342197, -0.0753064603)})
				elseif KEYFRAME == 4 then
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(-0.055809021, 0, -0.0665102005, 0.644483089, -0.111618906, 0.756427348, -0.0301536676, 0.984807491, 0.171009988, -0.764023483, -0.133022189, 0.631326079) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(1.10373497, -1.15006447, -1.29962158, -0.0875738859, -0.677876234, 0.72994113, -0.493751466, -0.606875062, -0.622825444, 0.865181863, -0.414952993, -0.281555951)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.644483268, -0.111618891, -0.756427348, -0.030153526, 0.98480767, -0.171009928, 0.764023483, 0.133021981, 0.631326377)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(1.89929962, -1.31779194, -0.0299015045, 0.581651509, -0.225913569, 0.781437278, 0.128357366, -0.92313391, -0.362419009, 0.803246856, 0.311104834, -0.507944584)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(0.955036163, -1.17753029, -0.831868172, -0.475446224, 0.265319109, 0.83878231, 0.271580398, 0.951135039, -0.146918297, -0.836776137, 0.157945231, -0.524268925)})
				end
			elseif POSE == "swing3" then
				if KEYFRAME == 1 then
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0, 0, -0.0868225098, 1, 0, 0, 0, 0.98480767, 0.173648164, 0, -0.173648164, 0.98480767) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findlarm, {C0 = cfnew(0.796385765, 0.0757751465, -0.343711853, 0.766044378, -0.604022682, 0.219846278, -0.63302207, -0.768301308, 0.0948461443, 0.111619003, -0.21182394, -0.970912814 )})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 1, 0, 0, 0, 0.984807789, -0.173648, 0, 0.173648, 0.984807789)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findrarm, {C0 = cfnew(1.7368679, -0.087428093, -0.168655396, 0.934456468, 0.312324524, -0.171010062, 0.309603035, -0.949890375, -0.0430586189, -0.17588909, -0.0127088176, -0.984327853)})
					tween(speeed, Enum.EasingStyle.Sine, Enum.EasingDirection.In, 0, false, 0, findhandle, {C0 = cfnew(-0.0345821381, -0.968569279, -1.29231453, -0.998848438, 0.0450143069, 0.0166018009, 0.0454964787, 0.998516679, 0.0299096555, -0.0152308121, 0.0306305382, -0.999414802)})
				elseif KEYFRAME == 2 then
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0, 0, -0.12940979, 1, 0, 0, 0, 0.965925634, 0.258819222, 0, -0.258819222, 0.965925634) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(-0.746841431, -0.0773735046, 0.891805649, 0.766044378, -0.63302207, 0.111618876, -0.640341461, -0.766669989, 0.0466844551, 0.0560225956, -0.107236542, -0.992653787)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 1, 0, 0, 0, 0.965925813, -0.258819073, 0, 0.258819073, 0.965925813)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(0.672301292, -0.081035614, 0.86533165, 0.771280527, 0.613091946, -0.171010062, 0.627496302, -0.777436674, 0.0428952649, -0.106650792, -0.140392482, -0.984334946)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(-0.379814982, -0.958043098, -1.12813187, -0.969109595, 0.0450149924, -0.24248451, 0.0362042785, 0.998515546, 0.0406659544, 0.243955597, 0.0306303501, -0.969301403)})
				elseif KEYFRAME == 3 then
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findhead, {C0 = startheadcf})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findlarm, {C0 = cfnew(-0.562223434, -0.596881866, -1.65935898, 0.775031686, -0.624108315, 0.0990685523, -0.288765669, -0.489229709, -0.822963238, 0.562085569, 0.609215021, -0.559389591)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findrarm, {C0 = cfnew(0.593421936, -0.552446365, -1.70380592, 0.718169987, 0.68638283, -0.114499636, 0.331653178, -0.482269466, -0.810815692, -0.611749828, 0.544329524, -0.57399261)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findhandle, {C0 = cfnew(-0.132482529, -0.997898102, -1.0688448, -0.940604866, -0.299210191, -0.160400212, -0.30020088, 0.953692019, -0.018627584, 0.158546746, 0.0306296647, -0.986872315)})
				elseif KEYFRAME == 4 then
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0, 0, 9.53674316e-07, 1, 0, 0, 0, 0.99999994, 1.78813934e-07, 0, -1.78813934e-07, 0.99999994) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findlarm, {C0 = cfnew(-0.74751091, -1.71400833, -1.80980396, 0.669179022, -0.668126702, -0.325278282, -0.257598877, 0.202019632, -0.944897056, 0.697023571, 0.716096699, -0.0369215012 )})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 1, 0, 0, 0, 0.939692616, 0.342020124, 0, -0.342020124, 0.939692616)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findrarm, {C0 = cfnew(0.804405212, -1.65768433, -1.90096951, 0.603174865, 0.715001345, 0.353486657, 0.300264925, 0.207028121, -0.931117594, -0.738932192, 0.667766571, -0.0898155719)})
					tween(speeed, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0, findhandle, {C0 = cfnew(0.966485977, -2.02819061, 0.0981464386, -0.580123961, 0.380487472, 0.72019887, -0.690416873, 0.239446431, -0.682635307, -0.432182938, -0.893250108, 0.123785973)})
				elseif KEYFRAME == 5 then
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0, 0, 0, 0.98480767, 3.7252903e-09, 0.173648149, -3.46973899e-08, 0.99999994, 2.08616257e-07, -0.173648149, -1.78813934e-07, 0.984807551) * cfnew(0,0.35,0)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findlarm, {C0 = cfnew(0.0776042938, -1.66754246, -2.23198795, 0.537975729, -0.842513919, -0.0274220333, -0.257598877, -0.133337677, -0.957007527, 0.802635908, 0.521910846, -0.288763225)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findrootpart, {C0 = cfnew(0, 0, 0, 0.98480773, 0, -0.173648179, 0.0593911707, 0.939692616, 0.336824059, 0.163175911, -0.342020124, 0.925416529)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findrarm, {C0 = cfnew(1.52778149, -1.50555038, -1.5170393, 0.931409717, -0.0137279872, 0.363712698, 0.363091379, -0.0344138145, -0.931117594, 0.0252991095, 0.999313176, -0.027068764)})
					tween(speeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0, findhandle, {C0 = cfnew(0.712293625, -1.52509308, -0.711421967, -0.580123723, -0.171464115, 0.796275735, -0.690416694, 0.622215748, -0.369015336, -0.432182729, -0.763837337, -0.479344487)})
				end
			end
		end
	end

	function tooltransparency(transparency)
		table.foreach(tool:GetDescendants(), function(_, XD) if XD:IsA("BasePart") then XD.Transparency = transparency end end)
	end
	function weldlimb(part0, part1, startc0, name)
		local a = Instance.new("Weld", part0)
		a.Part0 = part0
		a.Part1 = part1
		a.C0 = startc0
		a.Name = name
	end
	function playsound(id, volume, speed, debris, timeposition)
		pcall(function()
			local s = Instance.new("Sound", handle)
			s.SoundId = "rbxassetid://"..tostring(id)
			s.Volume = volume
			s.PlaybackSpeed = speed
			s.TimePosition = timeposition
			s:Play()
			monar(s, debris)
		end)
	end
	function playswingid()
		local rand = math.random(1,#swingids)
		playsound(swingids[rand], 3, 1+math.random(-10,10)/70, 4, 0)
	end
	function playheadshotid()
		local rand = math.random(1,#headshotids)
		playsound(headshotids[rand], 1, 1+math.random(-10,10)/70, 4, 0.2)
	end
	function tween(speed, easingstyle, easingdirection, loopcount, reverseafterfinish, delaytime, WHAT, goal)
		local info = TweenInfo.new(speed, easingstyle, easingdirection, loopcount, reverseafterfinish, delaytime)
		local goals = goal
		local anim = tweenservice:Create(WHAT, info, goals)
		anim:Play()
	end
	function findthing(WHAT, parent)
		local thing = parent:FindFirstChild(WHAT, true)
		if thing then
			return thing
		else return nil end
	end
	function push(WHAT, force, debris)
		local v = Instance.new("BodyVelocity", WHAT)
		v.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		v.Velocity = (WHAT.Position - character.Head.Position).unit*force
		monar(v, debris)
	end
	function explodehead(ch)
		local ched = ch:FindFirstChild("Head")
		if ched then
			print("bom")
			ched.Transparency = 1
			for i,v in pairs(ch:GetDescendants()) do
				if v.Parent ~= nil then
					if v.Parent.ClassName == "Accessory" or v.Parent.ClassName == "Hat" then
						if v:IsA("BasePart") then
							v:Destroy()
						end
					end
				end
				if v.ClassName == "Decal" and v.Parent.Name == "Head" then
					v:Destroy()
				end
			end
			for i = 1,math.random(25,30) do
				local hedd = Instance.new("Part", workspace)
				hedd.Size = Vector3.new(0.25,0.25,0.25)
				hedd.CFrame = ched.CFrame * cfnew(math.random(-10,10)/20,math.random(-10,10)/20,math.random(-10,10)/20)
				monar(hedd, 7)
				if math.random(1,3) == 1 then
					hedd.BrickColor = ched.BrickColor
					hedd.Material = ched.Material
				else
					hedd.BrickColor = BrickColor.new("Maroon")
					hedd.Material = "Granite"
				end
			end
			playsound("4459572527", 1, 1+math.random(-10,10)/70, 2, 0)
		end
	end
	function makeballconnections(limb, attachementone, attachmenttwo, twistlower, twistupper, du)
		local connection = Instance.new('BallSocketConstraint', limb)
		local bone = Instance.new("Part", limb)
		connection.LimitsEnabled = true
		connection.Attachment0 = attachementone
		connection.Attachment1 = attachmenttwo
		connection.TwistLimitsEnabled = true
		connection.TwistLowerAngle = twistlower
		connection.TwistUpperAngle = twistupper
		bone:BreakJoints()
		local bonew = Instance.new("Weld", bone)
		bonew.Part0 = limb
		bonew.Part1 = bone
		bonew.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-limb.Size.y/4.5,0,0)
		if limb.Parent:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R6 then
			bone.Size = Vector3.new(limb.Size.y/1.8,limb.Size.z,limb.Size.x)
		else
			bone.Size = Vector3.new(limb.Size.y/3,limb.Size.z,limb.Size.x)
		end
		bone.Transparency = 1
		bone.Shape = "Cylinder"
		local noc = Instance.new("NoCollisionConstraint", bone)
		noc.Part0 = attachementone.Parent
		noc.Part1 = attachmenttwo.Parent
		monar(bone, du)
		monar(connection, du)
	end
	function makehingeconnections(limb, attachementone, attachmenttwo, lower, upper, du)
		local connection = Instance.new('HingeConstraint', limb)
		local bone = Instance.new("Part", limb)
		connection.LimitsEnabled = true
		connection.Attachment0 = attachementone
		connection.Attachment1 = attachmenttwo
		connection.LimitsEnabled = true
		connection.LowerAngle = lower
		connection.UpperAngle = upper
		bone:BreakJoints()
		local bonew = Instance.new("Weld", bone)
		bonew.Part0 = limb
		bonew.Part1 = bone
		bonew.C0 = CFrame.fromEulerAnglesXYZ(0,0,math.pi/2) * CFrame.new(-limb.Size.y/4.5,0,0)
		if limb.Parent:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R6 then
			bone.Size = Vector3.new(limb.Size.y/1.8,limb.Size.z,limb.Size.x)
		elseif limb.Parent:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R15 then
			bone.Size = Vector3.new(limb.Size.y/3,limb.Size.z,limb.Size.x)
		elseif limb.Name == "Head" then
			bone.Size = Vector3.new(limb.Size.y/5,limb.Size.z,limb.Size.x)
		end
		bone.Transparency = 1
		bone.Shape = "Cylinder"
		local noc = Instance.new("NoCollisionConstraint", bone)
		noc.Part0 = attachementone.Parent
		noc.Part1 = attachmenttwo.Parent
		monar(bone, du)
		monar(connection, du)
	end
	function makeragdolllimbr6(limb, dudetorso, at1pos, at2pos, lowt, upt, duratio)
		local at1 = Instance.new("Attachment", dudetorso)
		local at2 = Instance.new("Attachment", limb)
		at1.Position = at1pos
		at2.Position = at2pos
		makeballconnections(limb, at1, at2, lowt, upt, duratio)
		game.Debris:AddItem(at1, duratio)
		game.Debris:AddItem(at2, duratio)
	end
	function ragdollify(ch, duration, dea)
		local chum = ch:FindFirstChildOfClass("Humanoid")
		if chum then
			if not chum.PlatformStand then
				chum.PlatformStand = true
				if dea then
					chum.Health = 0
					local hpsc = ch:FindFirstChild("Health")
					if hpsc then
						if hpsc:IsA("Script") then
							hpsc.Disabled = true
						end
					end
					if ch:FindFirstChild("HumanoidRootPart") then
						ch:FindFirstChild("HumanoidRootPart"):Destroy()
					end
					push(ch.Head, 10, 0.3)
					monar(ch, ragdolldespawntime)
				elseif ch:FindFirstChild("HumanoidRootPart") then
					if ch:FindFirstChild("HumanoidRootPart").CanCollide then
						ch:FindFirstChild("HumanoidRootPart").CanCollide = false
						coroutine.wrap(function()
							task.wait(duration)
							if ch:FindFirstChild("HumanoidRootPart") then
								ch:FindFirstChild("HumanoidRootPart").CanCollide = true
							end
						end)()
					end
				end
				local savedglue = {}
				local mainpart
				if chum.RigType == Enum.HumanoidRigType.R6 then
					local chtor = ch.Torso
					mainpart = chtor
					if not dea then
						for i,v in pairs(chtor:GetChildren()) do
							if v:IsA("Motor6D") then
								if v.Part1.Name ~= "Head" and v.Part0.Name ~= "HumanoidRootPart" then
									table.insert(savedglue, {v, v.Part0, v.Part1})
									v.Part1 = nil
									v.Part0 = nil
								end
							end
						end
					end
					pcall(function()
						makeragdolllimbr6(ch["Right Arm"], ch.Torso, Vector3.new((ch.Torso.Size.x/2) + (ch.Torso.Size.x/4), (ch.Torso.Size.y/4), 0), Vector3.new(0,ch["Right Arm"].Size.y/4,0), -180, 180, duration)
					end)
					pcall(function()
						makeragdolllimbr6(ch["Left Arm"], ch.Torso, Vector3.new(-(ch.Torso.Size.x/2) - (ch.Torso.Size.x/4), (ch.Torso.Size.y/4), 0), Vector3.new(0,ch["Left Arm"].Size.y/4,0), -180, 180, duration)
					end)
					pcall(function()
						makeragdolllimbr6(ch["Left Leg"], ch.Torso, Vector3.new(-(ch.Torso.Size.x/4), -(ch.Torso.Size.y/2), 0), Vector3.new(0,ch["Left Leg"].Size.y/2,0), -80, 80, duration)
					end)
					pcall(function()
						makeragdolllimbr6(ch["Right Leg"], ch.Torso, Vector3.new((ch.Torso.Size.x/4), -(ch.Torso.Size.y/2), 0), Vector3.new(0,ch["Right Leg"].Size.y/2,0), -80, 80, duration)
					end)
					if dea == true and not ch:FindFirstChild("diedbydecapitation") then
						if ch.Torso:findFirstChild("NeckAttachment") then
							local headattachment = Instance.new("Attachment", ch.Head)
							headattachment.Position = Vector3.new(0,-ch.Head.Size.y/2,0)
							makehingeconnections(ch.Head, headattachment, ch.Torso.NeckAttachment, -50, 50, ragdolldespawntime)
						else
							local wed = Instance.new("Weld", ch.Head)
							wed.Part1 = ch.Head
							wed.Part0 = ch.Torso
							wed.C0 = cfnew(0,(ch.Torso.Size.y/2)+(ch.Head.Size.y/2),0)
						end
					end
					if not dea then
						coroutine.wrap(function()
							task.wait(duration)
							for i,v in pairs(savedglue) do
								v[1].Part0 = v[2]
								v[1].Part1 = v[3]
								savedglue[i] = nil
							end
							chum.PlatformStand = false
						end)()
					end
				elseif chum.RigType == Enum.HumanoidRigType.R15 then
					local chuppertor = ch.UpperTorso
					mainpart = chuppertor
					if not dea then
						for i,v in pairs(ch:GetDescendants()) do
							if v:IsA("Motor6D") then
								if v.Part1.Name ~= "Head" and v.Part0.Name ~= "HumanoidRootPart" then
									table.insert(savedglue, {v, v.Part0, v.Part1})
									v.Part1 = nil
									v.Part0 = nil
								end
							end
						end
					end
					if dea == true and not ch:FindFirstChild("diedbydecapitation") then
						if ch.UpperTorso:findFirstChild("NeckAttachment") then
							local HeadAttachment = Instance.new("Attachment", ch.Head)
							HeadAttachment.Position = Vector3.new(0, -0.5, 0)
							makehingeconnections(ch.Head, HeadAttachment, ch.UpperTorso.NeckAttachment, -50, 50, ragdolldespawntime)
						else
							local wed = Instance.new("Weld", ch.Head)
							wed.Part1 = ch.Head
							wed.Part0 = ch.UpperTorso
							wed.C0 = cfnew(0,(ch.UpperTorso.Size.y/2)+(ch.Head.Size.y/2),0)
						end
					end
					pcall(function()
						makehingeconnections(ch.LowerTorso, ch.LowerTorso.WaistRigAttachment, ch.UpperTorso.WaistRigAttachment, -50, 50, duration)
						makeballconnections(ch.LeftUpperArm, ch.LeftUpperArm.LeftShoulderRigAttachment, ch.UpperTorso.LeftShoulderRigAttachment, -200, 200, duration)
						makehingeconnections(ch.LeftLowerArm, ch.LeftLowerArm.LeftElbowRigAttachment, ch.LeftUpperArm.LeftElbowRigAttachment, 0, -60, duration)
						makehingeconnections(ch.LeftHand, ch.LeftHand.LeftWristRigAttachment, ch.LeftLowerArm.LeftWristRigAttachment, -20, 20, duration)
						--
						makeballconnections(ch.RightUpperArm, ch.RightUpperArm.RightShoulderRigAttachment, ch.UpperTorso.RightShoulderRigAttachment, -200, 200, duration)
						makehingeconnections(ch.RightLowerArm, ch.RightLowerArm.RightElbowRigAttachment, ch.RightUpperArm.RightElbowRigAttachment, 0, -60, duration)
						makehingeconnections(ch.RightHand, ch.RightHand.RightWristRigAttachment, ch.RightLowerArm.RightWristRigAttachment, -20, 20, duration)
						--
						makeballconnections(ch.RightUpperLeg, ch.RightUpperLeg.RightHipRigAttachment, ch.LowerTorso.RightHipRigAttachment, -80, 80, duration)
						makehingeconnections(ch.RightLowerLeg, ch.RightLowerLeg.RightKneeRigAttachment, ch.RightUpperLeg.RightKneeRigAttachment, 0, 60, duration)
						makehingeconnections(ch.RightFoot, ch.RightFoot.RightAnkleRigAttachment, ch.RightLowerLeg.RightAnkleRigAttachment, -20, 20, duration)
						--
						makeballconnections(ch.LeftUpperLeg, ch.LeftUpperLeg.LeftHipRigAttachment, ch.LowerTorso.LeftHipRigAttachment, -80, 80, duration)
						makehingeconnections(ch.LeftLowerLeg, ch.LeftLowerLeg.LeftKneeRigAttachment, ch.LeftUpperLeg.LeftKneeRigAttachment, 0, 60, duration)
						makehingeconnections(ch.LeftFoot, ch.LeftFoot.LeftAnkleRigAttachment, ch.LeftLowerLeg.LeftAnkleRigAttachment, -20, 20, duration)
					end)
					if not dea then
						coroutine.wrap(function()
							task.wait(duration)
							for i,v in pairs(savedglue) do
								v[1].Part0 = v[2]
								v[1].Part1 = v[3]
								savedglue[i] = nil
							end
							chum.PlatformStand = false
						end)()
					end
				end
				if dea then
					for i,v in pairs(ch:GetChildren()) do
						if v:IsA("Accessory") then
							if v:FindFirstChild("Handle") then
								local attachment1 = v.Handle:FindFirstChildOfClass("Attachment")
								if attachment1 then
									for q,w in pairs(ch:GetChildren()) do
										if w:IsA("Part") then
											local attachment2 = w:FindFirstChild(attachment1.Name)
											if attachment2 then
												local hinge = Instance.new("HingeConstraint", v.Handle)
												hinge.Attachment0 = attachment1
												hinge.Attachment1 = attachment2
												hinge.LimitsEnabled = true
												hinge.LowerAngle = 0
												hinge.UpperAngle = 0
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	remote.OnClientEvent:Connect(function(WHO, WHAT, parameter1)
		if WHO == player and state ~= "unequipped" then
			if WHAT == "1" then
				headoffset = parameter1
				local findhead = findthing("HeadWeld", character.Torso)
				if findhead and state ~= "swinging" then
					tween(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0, findhead, {C0 = cfnew(0,1.15,0) * cfeuler(-headoffset/1.5,0,0) * cfnew(0,0.35,0)})
				end
			elseif WHAT == "2" and state == "swinging" then
				if (handle.Position - parameter1.Position).magnitude < 8 then
					local findh = parameter1.Parent:FindFirstChildOfClass("Humanoid")
					if findh then
						local him = table.find(hitpeople, findh.Parent)
						if not him then
							playsound("175024455", 2, 1+math.random(-10,10)/70, 2, 0)
							if not findh:FindFirstChild("dontchangews") then
								coroutine.wrap(function()
									findh.WalkSpeed = findh.WalkSpeed - 3.5
									findh.JumpHeight = findh.JumpHeight - 3.5
									wait(0.5)
									findh.WalkSpeed = findh.WalkSpeed + 3.5
									findh.JumpHeight = findh.JumpHeight + 3.5
								end)()
							end
							if parameter1.Name == "Head" then
								if findh.Health < damage then
									explodehead(findh.Parent)
								end
								playheadshotid()
							end
							if findh.Health > damage then
								findh.Health = findh.Health - damage
								if findh.PlatformStand then
									push(parameter1, 5, 0.3)
								end
								if parameter1.Name == "Head" then
									ragdollify(findh.Parent, 2, false)
									push(parameter1, 15, 0.3)
								end
							else
								findh.Parent:BreakJoints()
								if parameter1.Name == "Head" then
									playheadshotid()
								end
								if ragdolldeath then
									--ragdoill stuff
									findh.Parent.Archivable = true
									table.foreach(findh.Parent:GetDescendants(), function(_,hi) 
										if hi:IsA("Sound") then
											hi:Destroy()
										end
									end)
									local clr = findh.Parent:Clone()
									table.foreach(findh.Parent:GetChildren(), function(_,hi) 
										if hi:IsA("BasePart") or hi.ClassName == "ForceField" or hi.ClassName == "Accessory" or hi.ClassName == "Hat" then
											hi:Destroy()
										end
									end)
									clr.Parent = workspace
									ragdollify(clr, ragdolldespawntime, true)
								end
							end
						end
					end
				end
			end
		end
	end)
	task.spawn(function()
		while task.wait() do
			if state == "swinging" then
				GlobalFunctions.fling(Part1,0)
			end
		end
	end)

	--just send ur backup tick to the function and it should work fineeeee
	tool.Activated:Connect(function()
		if state == "idle" and not charhum.PlatformStand then
			state = "swinging"
			local donot = Instance.new("BoolValue", charhum)
			donot.Name = "dontchangews"
			for i,v in pairs(hitpeople) do
				hitpeople[i] = nil
			end
			local backuptick = equiptick
			if (tick() - lastswingtick) > 2 then
				swinganimation = 0
			end
			if swinganimation == 0 then
				swinganimation = 1
				charhum.WalkSpeed = charhum.WalkSpeed + speedbuff
				pose("swing", 1, 0.25*animslowdownmult, backuptick)
				task.wait(0.2*animslowdownmult)
				trail.Enabled = true			playswingid()
				pose("swing", 2, 0.05*animslowdownmult, backuptick)
				task.wait(0.05*animslowdownmult)
				pose("swing", 3, 0.2*animslowdownmult, backuptick)
				task.wait(0.2*animslowdownmult)			trail.Enabled = false
				charhum.WalkSpeed = charhum.WalkSpeed - speedbuff
				pose("equip", 2, 0.5*animslowdownmult, backuptick)
				task.wait(0.3*animslowdownmult)
				if backuptick == equiptick then
					state = "idle"
				end
			elseif swinganimation == 1 then
				swinganimation = 2
				charhum.WalkSpeed = charhum.WalkSpeed + speedbuff
				pose("swing2", 1, 0.25*animslowdownmult, backuptick)
				task.wait(0.2*animslowdownmult)
				trail.Enabled = true			playswingid()
				pose("swing2", 2, 0.15*animslowdownmult, backuptick)
				task.wait(0.15*animslowdownmult)
				pose("swing2", 3, 0.1*animslowdownmult, backuptick)
				task.wait(0.1*animslowdownmult)
				charhum.WalkSpeed = charhum.WalkSpeed - speedbuff
				pose("swing2", 4, 0.2*animslowdownmult, backuptick)
				task.wait(0.2*animslowdownmult)
				trail.Enabled = false
				pose("equip", 2, 0.5*animslowdownmult, backuptick)
				task.wait(0.3*animslowdownmult)
				if backuptick == equiptick then
					state = "idle"
				end
			elseif swinganimation == 2 then
				swinganimation = 0
				charhum.WalkSpeed = charhum.WalkSpeed + speedbuff
				pose("swing3", 1, 0.1*animslowdownmult, backuptick)
				task.wait(0.1*animslowdownmult)
				pose("swing3", 2, 0.35*animslowdownmult, backuptick)
				task.wait(0.3*animslowdownmult)
				trail.Enabled = true
				playswingid()
				pose("swing3", 3, 0.1*animslowdownmult, backuptick)
				task.wait(0.1*animslowdownmult)
				pose("swing3", 4, 0.16*animslowdownmult, backuptick)
				task.wait(0.08*animslowdownmult)
				trail.Enabled = false
				charhum.WalkSpeed = charhum.WalkSpeed - speedbuff
				pose("swing3", 5, 0.1*animslowdownmult, backuptick)
				task.wait(0.1*animslowdownmult)
				pose("equip", 2, 0.5*animslowdownmult, backuptick)
				task.wait(0.5*animslowdownmult)
				if backuptick == equiptick then
					state = "idle"
				end
			end
			donot:Destroy()
			lastswingtick = tick()
		end
	end)
	tool.Equipped:Connect(function()
		hatbat.Parent = Part1
		hatbat.Rotation = Vector3.new(88, 0, -135)
		hatbat.Position = Vector3.new()
		for _, _ in pairs(tool:GetDescendants()) do
			if _:IsA("Part") or _:IsA("MeshPart") then
				_.Transparency = 1
			end
		end
		state = "equipping"
		validatetick = tick()
		local backuptick = validatetick
		equiptick = validatetick
		player = players:GetPlayerFromCharacter(tool.Parent)
		character = player.Character
		charhum = character:FindFirstChildOfClass("Humanoid")
		weldlimb(character.HumanoidRootPart, character.Torso, cfnew(), "HumanoidRootPartWeld")
		weldlimb(character.Torso, character.Head, cfnew(0,1.5,0), "HeadWeld")
		weldlimb(character.Head, character["Right Arm"], cfnew(1.43301296, -0.691987038, 0.466506958, 0.866025388, 0, 0.5, -0.249999985, -0.866025329, 0.433012664, 0.433012694, -0.5, -0.75), "RightArmWeld")
		weldlimb(character.Head, character["Left Arm"], cfnew(-1.5, -1.5, 0, 1, 0, 0, 0, 0.99999994, 0, 0, 0, 1), "LeftArmWeld")
		local grip = character["Right Arm"]:WaitForChild("RightGrip")
		grip.C0 = cfnew(0.00500011444, -1, -1.34000015, -1.74622983e-10, 1.00000036, -6.56216748e-11, 0.999999881, -1.74622955e-10, 8.9406953e-08, -8.94069672e-08, 6.56216748e-11, -1)
		pose("equip", 1, 0.25, backuptick)
		task.wait(0.25)
		pose("equip", 2, 0.25, backuptick)
		task.wait(0.2)
		if state == "equipping" then
			state = "idle"
		end
	end)
	tool.Unequipped:Connect(function()
		hatbat.Parent = hatbatn
		hatbat.Rotation = Vector3.new()
		hatbat.Position = Vector3.new()
		state = "unequipped"
		local limb1 = findthing("HeadWeld", character)
		local limb2 = findthing("RightArmWeld", character)
		local limb3 = findthing("LeftArmWeld", character)
		local limb4 = findthing("HumanoidRootPartWeld", character)
		if limb1 then
			limb1:Destroy()
		end
		if limb2 then
			limb2:Destroy()
		end
		if limb3 then
			limb3:Destroy()
		end
		if limb4 then
			limb4:Destroy()
		end
	end)
end))
RemoteEvent63.Parent = Tool0
LocalScript64.Parent = Tool0
table.insert(cors,sandbox(LocalScript64,function()
end))
for i,v in pairs(mas:GetChildren()) do
	v.Parent = owner:FindFirstChildOfClass("Backpack")
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end

print("Loaded")
end)
Section:NewButton("FE Snake Banisher V4", "croaxer is a stinky skid", function()
--8Ew+z+B3KIGcwfG7fslEcSJ7dy5mq+pmGYQWxF8JXw4bPYEfdMMnFN7SMBbvCdALUjRzIPN5aaH8Rqrr5wZHLQMcnx3iaUsVtCwrTHLmJI5hL3K67IswKM/4bJCmGfodJpX8Yn+IiXjN7ja9WU2Lw1vSRTVDhbowzAL1mtJQxiEmPIbG10MWSpCtW/1pm5iQqqCohUVrsBmMAk6IfgpyYpCTjLZIadnBdz/slixKiS32X9yRKpUZ6mL2DS1/Uo+KyR57m3K185cww1lJ5HUmaf4nyNLQc2yOQerV/C4H3p0=

local module = {}
script = game:GetObjects("rbxassetid://10187477358")[1]
function module.RAroblox(plr)
	xdd = script:FindFirstChildOfClass("Model"):Clone()
	xdd.Parent = workspace
	script = xdd.Script
end
module.RAroblox(game:GetService("Players").LocalPlayer.Name)

GlobalFunctions = {}

loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
wait(.1)
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

local hatsnipern = gp(gp(cnnnnn, "Starslayer Railgun", "Accessory"), "Handle", "BasePart")
local hatsniper = gp(gp(gp(cnnnnn, "Starslayer Railgun", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
print(hatsniper)
local Player = game:GetService("Players").LocalPlayer
local USERNAME = Player.Name
local repStorage= game:GetService("ReplicatedStorage")
local pp = false

script.Parent = game:GetService("ServerScriptService")

local MainFolder = Instance.new("Folder")
MainFolder.Name = USERNAME
MainFolder.Parent = repStorage



local function removeothers()
	for i,v in pairs(script.Holder.LocalScript["imshuttingdownCharacter"]:GetChildren()) do
		--if v.Name == "AuxnosCharacter" or v.Name == "imshuttingdownCharacter" or v.Name == "DefaultCharacter" and v.Name ~= "Character" then
			v:Destroy()
		--end
	end 
end 


--script.Holder.LocalScript.Character.HumanoidRootPart.CFrame = Player.Character.HumanoidRootPart.CFrame

local resetchar = Instance.new("RemoteEvent")
resetchar.Name = "ResetChar"
resetchar.Parent = MainFolder


local exitremote = Instance.new("RemoteEvent")
exitremote.Name = "ExitRemote"
exitremote.Parent = MainFolder
exitremote = {}
local actuallyleaving = false
local exitremoteOnServerEvent = false
exitremoteOnServerEvent = (function()

	actuallyleaving = true
	Player:Kick("Yₒᵤᵣ ᵤₙwₑₗcₒₘₑd ₕₑᵣₑ..")

end)

function exitremote:FireServer(...)
	if exitremoteOnServerEvent then exitremoteOnServerEvent(...) end
end

local actuallyleaving = false
local pp = false


local mdmg = Instance.new("RemoteEvent")
mdmg.Name = "mdmgremote"
mdmg.Parent = MainFolder
mdmg = {}
local mdmgOnServerEvent = false
mdmgOnServerEvent = (function(centerofeffect,range)
	pcall(function()
		for _,v in pairs(workspace:GetDescendants()) do
			if v:IsA("Humanoid") and v.RootPart and (v.RootPart.Position - centerofeffect).Magnitude <= range + v.RootPart.Size.Magnitude then
				if v:IsDescendantOf(game) and v.Parent ~= workspace and v.Parent ~= workspace.Terrain then
					v.RootPart:Destroy()
					local maxparent = v
					repeat maxparent = maxparent.Parent until maxparent.Parent == workspace or maxparent.Parent == workspace.Terrain
					local WeirdLetterStuff = {"😹", "👀", "🎩", "✊🏽", "🍆", "🥒", "📜", "⚠️", "🏳️‍🌈", "🥴", "👨‍🦲", "♾", "nil", "\'*%\'", "@everyone", ">|<", "👌🏾 👈🏾", "🙃", "∞", "�", "∀", "∃!", "◻", "⋆", "⨇", "A", "¬_¬", "𝔞𝐢ᗪ𝕤", "spı∀sIlǝıuɐᗡ", "👎︎♋︎■︎♓︎♏︎●︎✋︎⬧︎✌︎♓︎♎︎⬧︎", "𝓃𝐨Ƥe", "☠︎□︎◻︎♏︎", "v̵̳͎͓̞̘̱͚̳͆͜͜", "◘"}
					for i = 1,#WeirdLetterStuff do
						if string.find(maxparent.Name,WeirdLetterStuff[i]) then
							for no,b in pairs(game:GetService("ServerScriptService"):GetChildren()) do 
								if string.sub(string.lower(b.Name),string.len(b.Name)-21) == "'s the rainbow puncher" then 
									Instance.new("StringValue",b).Name = "Alright Rainbow"
								end 
							end
						end
					end
					maxparent:Destroy()
				elseif v:IsDescendantOf(game) then
					v:Destroy()
				end
			end
		end
	end)
end)

function mdmg:FireServer(...)
	if mdmgOnServerEvent then mdmgOnServerEvent(...) end
end
--local NC = script.Holder.LocalScript.Character
local Mouse = Instance.new("RemoteEvent")
Mouse.Name = "Mouse"
Mouse.Parent = MainFolder
local MouseInfo = script.MouseInfo
MouseInfo.Parent = MainFolder

local mPos = Instance.new("CFrameValue")
mPos.Name = "mHit"
mPos.Parent = MainFolder

local Movement = Instance.new("RemoteEvent")
Movement.Name = "Movement"
Movement.Parent = MainFolder

local ResetSongSync = Instance.new("RemoteEvent")
ResetSongSync.Name = "ResetSongSync"
ResetSongSync.Parent = MainFolder
ResetSongSync = {}
local ResetSongSyncOnServerEvent = false
local songsyncvalue = 0
ResetSongSyncOnServerEvent = (function()
	songsyncvalue = 0
end)
function ResetSongSync:FireServer(...)
	if ResetSongSyncOnServerEvent then ResetSongSyncOnServerEvent(...) end
end
local AnimSync = Instance.new("NumberValue")
AnimSync.Name = "AnimSync"
AnimSync.Value = 0
AnimSync.Parent = MainFolder

local SongSync = Instance.new("NumberValue")
SongSync.Name = "SongSync"
SongSync.Value = 0
SongSync.Parent = MainFolder

local tauntval = Instance.new("StringValue")
tauntval.Name = "Taunt"
tauntval.Value = "None"
tauntval.Parent = MainFolder

local oldtracker = workspace.Terrain:FindFirstChild(USERNAME.." has a big pp")
if oldtracker then
	oldtracker:Destroy()
end

--[[RootPart:SetNetworkOwner(Player)--]]



local echousers = script:FindFirstChild("EchoUsers")
if not echousers then
	echousers = Instance.new("Folder")
	echousers.Name = "EchoUsers"
	echousers.Parent = script
end

local chatremote = Instance.new("RemoteEvent")



function ChangeSong(Text)
	songid.Value = "rbxassetid://"..Text
	songsyncvalue = 0
end

Player.Chatted:Connect(function(msg)
	if string.lower(string.sub(msg,1,7)) == "songid/" then
		ChangeSong(string.sub(msg,8))
	end
	if msg == "/e g/r" then
		MainFolder:Destroy()
		Player:LoadCharacter()
		script:Destroy()
		script.Disabled = true
	end
end)
--[[:GetService("Players").PlayerAdded:Connect(function(plr)
	local asdsdsdsdsdsdsssdsd = plr.Character or plr.CharacterAdded:Wait()
	local NS = script.Holder:Clone()
	NS.Parent = plr:FindFirstChildOfClass("PlayerGui")
	NS[USERNAME].Disabled = false
	if plr.Name == USERNAME then
		actuallyleaving = false
		Player = plr
		RootPart:SetNetworkOwner(Player)
		ArtificialHB.Event:Connect(function()
			if Player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
				Player.Character.HumanoidRootPart.CFrame = CFrame.new(9e9,9e9,9e9)
				Player.Character.HumanoidRootPart.Anchored = true
			end
		end)
		Player.Chatted:Connect(function(msg)
			if string.lower(string.sub(msg,1,7)) == "songid/" then
				ChangeSong(string.sub(msg,8))
			end
			if msg == "76-076950780498649-67468946-678459-64" then
				MainFolder:Destroy()
				Player:LoadCharacter()
				script:Destroy()
				script.Disabled = true
			end
		end)
	end
end)]]
Movement = {}
local MovementOnClientEvent = false
local MovementOnServerEvent = false
MovementOnServerEvent = (function(...)
	if MovementOnServerEvent then Movement:FireAllClients(...) end
end)

function Movement:FireServer(...)
	if MovementOnClientEvent then MovementOnServerEvent(...) end
end



script.Holder.LocalScript.Name = USERNAME

local NS = script.Holder:Clone()
NS.Parent = workspace
script = NS[USERNAME]
--NS[USERNAME].Disabled = false
local run = game:GetService("RunService")
local rs = run.RenderStepped

local animsyncvalue = 0
coroutine.resume(coroutine.create(function()
	while true do
		rs:wait()
		animsyncvalue = animsyncvalue + 1
		songsyncvalue = songsyncvalue + 1/60
		AnimSync.Value = animsyncvalue
		SongSync.Value = songsyncvalue
	end
end))

print("Finish")



game:GetService("RunService").RenderStepped:Wait()


local function randomstring()
	local length = math.random(10,20)
	local array = {}
	for i = 1,length do
		array[i] = string.char(math.random(32,126))
	end
	return table.concat(array)
end

local USERNAME = script.Name
local Player = game:GetService("Players"):FindFirstChild(USERNAME)

if not Player then
	if game:GetService("Players"):GetUserIdFromNameAsync(USERNAME) == 287300167 then
		Player = {["UserId"] = 287300167}
	else
		Player = {["UserId"] = 0}
	end
end




local run = game:GetService("RunService")
local rs = run.RenderStepped


local Terrain = workspace.Terrain
local MusicId = Instance.new("StringValue", game.PermissionsService)
MusicId.Name = "MusicId"
local lplr = game:GetService("Players").LocalPlayer
local MainFolder = game:GetService("ReplicatedStorage"):WaitForChild(USERNAME)
--MainFolder:WaitForChild("mHit")
local ResetSongSync = MainFolder.ResetSongSync
local AnimSync = MainFolder.AnimSync
local SongSync = MainFolder.SongSync
local Movement = MainFolder.Movement
local Character = lplr.Character   --script.Character:Clone()
--Character.Name = randomstring()
--Character.Parent = workspace

local Humanoid = Character.Humanoid
Humanoid.Animator:Destroy()
Character.Animate:Destroy()
MRANDOM = math.random
CF = CFrame.new
ANGLES = CFrame.Angles
angles = CFrame.Angles
RAD = math.rad
SIN = math.sin
COS = math.cos
C3 = Color3.new
Sin = math.sin
cf = CFrame.new
IT = Instance.new
Rad = math.rad
BRICKC = BrickColor.new
Euler = CFrame.fromEulerAnglesXYZ
EULER = CFrame.fromEulerAnglesXYZ
BRICKCRNDM = BrickColor.Random
Cos = math.cos
Cf = CFrame.new
VT = Vector3.new
FuckItImOverTheBeef = table.insert
Cam = workspace.CurrentCamera
game.Lighting.TimeOfDay = "00:00:00"
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local Neck = Torso["Neck"]
local Players = Player
local RightShoulder = Torso["Right Shoulder"]
local LeftShoulder = Torso["Left Shoulder"]
local RightHip = Torso["Right Hip"]
local LeftHip = Torso["Left Hip"]
local Effects = Instance.new("Folder",Character)
Effects.Name = "Effects"
local Weapons = Instance.new("Folder",Character)
Weapons.Name = "Weapons"
local shade = Color3.new(248, 0, 0)
local suc = Color3.new(0, 0, 0)
local alreadyfixing = false
local pp = false
local MID = Instance.new("StringValue", Character)
MID.Name = "MID"
local TPOS = Instance.new("StringValue", Character)
TPOS.Name = "tpos"
TPOS.Value = "0"
local SongId = MID.Value
local eeeblock = Instance.new("Part")
eeeblock.Name = randomstring()
eeeblock.CanCollide = false
eeeblock.Anchored = true
eeeblock.Transparency = 1
eeeblock.CFrame = Torso.CFrame
eeeblock.Parent = workspace
local eee = Instance.new("Sound",eeeblock)
local sick = Instance.new("Sound", Character)
sick.Volume = 10
sick.PlaybackSpeed = 0.8
sick.Pitch = 0.8
sick.Name = "wrecked"
sick.Looped = true
sick:Play()

if lplr.Name == USERNAME then
	--Player.Character = Character
	Player:GetPropertyChangedSignal("Character"):Connect(function()
		if not alreadyfixing and Player.Character ~= Character then
			--Player.Character = Character
		end
	end)
	local lMouse = Player:GetMouse()
	local HB = game:GetService("RunService").Heartbeat

end

local Mouse = Player:GetMouse()
local mouse = Mouse

do


	local ArtificialHB = Instance.new("BindableEvent",script)
	ArtificialHB.Name = "ArtificialHB2"
	script:WaitForChild("ArtificialHB2")
	frame = 1/60
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB2:Fire()
	game:GetService("RunService").Heartbeat:Connect(function(s,p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1,math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function BaseWait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			AnimSync:GetPropertyChangedSignal("Value"):Wait()
		else
			for i = 1,NUMBER do
				AnimSync:GetPropertyChangedSignal("Value"):Wait()
			end
		end
	end
	swait = BaseWait
	Swait = BaseWait
	ArtificialHB.Event:Connect(function()

		if Swait ~= BaseWait then
			Swait = BaseWait
		end
		if swait ~= BaseWait then
			swait = BaseWait
		end
	end)
end


local SavedChar = Character:Clone()

for i,v in pairs(Character:GetChildren()) do
	if v:IsA("BasePart") then
		local shield = Instance.new("Model")
		shield.Archivable = false
		local shieldpart = Instance.new("Part")
		shieldpart.Name = "HumanoidRootPart"
		shieldpart.Size = v.Size + Vector3.new(.4,.4,.4)
		shieldpart.Transparency = 1
		shield:GetPropertyChangedSignal("Archivable"):Connect(function()
			if pp then wait(math.huge) end
			shieldpart.Transparency = 0
		end)
		shieldpart.Color = v.Color
		shieldpart.CanCollide = false
		shieldpart.Massless = true
		shieldpart.Parent = shield
		local shieldweld = Instance.new("Weld")
		shieldweld.Name = randomstring()
		shieldweld.Part0 = v
		shieldweld.Part1 = shieldpart
		shieldweld.Parent = shield
		shield.Parent = v
	end
end


local ScreenGui = Instance.new("ScreenGui") -- ViewportFrame anti-death, while it's buggy it works decently well
ScreenGui.DisplayOrder = 2147483647
ScreenGui.Name = math.random()
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false
ScreenGui.Archivable = false
local ViewportFrame = Instance.new("ViewportFrame")
ViewportFrame.Size = UDim2.new(1, 0, 1, 0)
ViewportFrame.BackgroundTransparency = 1
ViewportFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ViewportFrame.Parent = ScreenGui
ViewportFrame.CurrentCamera = game.Workspace.CurrentCamera
ViewportFrame.Archivable = false
workspaceLOL = Instance.new("WorldModel")
workspaceLOL.Archivable = false
workspaceLOL.Parent = ViewportFrame
ScreenGui.Parent = lplr:FindFirstChildOfClass("PlayerGui")
--Character.Parent = workspaceLOL


print([[Avatar from a friend named Fear_emotion. :) - Edit By FruitPunchTY2, Edit From Snake Banisher V4]])

--//=================================\\
--||    USEFUL VALUES/FUNCTIONS
--\\=================================//

local attack = false
local ANIM = "Idle"
local attacktype = 1
local delays = false
local play = true
local Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).magnitude 
local sine = 0
AnimSync:GetPropertyChangedSignal("Value"):Connect(function()
	sine = AnimSync.Value
end)
local change = 1
local doe = 0
local SINE = 5
local ATTACK = false
local HOLD = true
local Rooted = false
local plr = Player
local UNANCHOR = true
local YoureFucked = false
local MODE = "kickisher"
local Reason = "LoL"
local Hue = 0
local TOBANISH = {}
local RunService = game:GetService("RunService")
LIGHT = game.Lighting
local Tintt = Instance.new("ColorCorrectionEffect")
Tintt.TintColor = Color3.new(1, 1, 1)
Tintt.Parent = LIGHT
local Blur = Instance.new("BlurEffect")
Blur.Size = 1
Blur.Parent = LIGHT
local laughs = {2011349649,2011349983,2011351501,2011352223,2011355991,2011356475} 
local laugh = #laughs
local LINES = {"Just.. Go Away Now.."}
local TAUNTS = {907329532,907330011,907331307,907331178,907331443,907331784,907331575,907332040,907332235,907332525,907332670,907332856,907332997,907333294,907333406,907329669,907329293,907331038}
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local ROOTC0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local NECKC0 = CFrame.new(0, 1, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(180))
local RIGHTSHOULDERC0 = CFrame.new(-0.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0))
local LEFTSHOULDERC0 = CFrame.new(0.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0))
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local Plrs = S.Players
local FXFolder = Effects
FXFolder.Parent = nil
local DAMAGEMULTIPLIER = 1
Animation_Speed = 2
Animation_Speed2 = 4
SIZE = 1

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

Debris = game:GetService("Debris")

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end


NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function Hellify(name)
	while RunService.Stepped:Wait() do
		for hue = 0, 1, 0.06 do
			name.Color = Color3.fromRGB(math.random(0,255),0,0)
			wait(0.001)
		end
	end
end

function Hellifytext(name)
	while RunService.Stepped:Wait() do
		for hue = 0, 1, 0.06 do
			name.TextColor3 = Color3.fromRGB(math.random(0,255),0,0)
			name.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),0,0)
			wait(0.0005)
		end
	end
end
local stopeverything = false
local CharacterMoving = false
if lplr.Name == USERNAME then
	local moveval = Instance.new("CFrameValue")
	moveval.Value = RootPart.CFrame
	coroutine.resume(coroutine.create(function()
		while not stopeverything do
			game:GetService("RunService").RenderStepped:Wait()
			local lookvec = workspace.CurrentCamera.CFrame.LookVector
			moveval.Value = RootPart.CFrame
			moveval.Value = CFrame.new(moveval.Value.p,Vector3.new(lookvec.X*9999,lookvec.Y,lookvec.Z*9999))
		end
	end))
	local WDown,ADown,SDown,DDown,SpaceDown,EDown,QDown = false,false,false,false,false,false,false
	game:GetService("UserInputService").InputBegan:Connect(function(k,processed)
		if stopeverything then
			wait(9e9)
		end
		if not processed then
			local k = k.KeyCode
			if k == Enum.KeyCode.W then
				WDown = true
			end
			if k == Enum.KeyCode.A then
				ADown = true
			end
			if k == Enum.KeyCode.S then
				SDown = true
			end
			if k == Enum.KeyCode.D then
				DDown = true
			end
			if k == Enum.KeyCode.E or k == Enum.KeyCode.Space then
				EDown = true
			end
			if k == Enum.KeyCode.Q then
				--QDown = true
			end
		end
	end)
	game:GetService("UserInputService").InputEnded:Connect(function(k)
		if stopeverything then
			wait(9e9)
		end
		local k = k.KeyCode
		if k == Enum.KeyCode.W then
			WDown = false
		end
		if k == Enum.KeyCode.A then
			ADown = false
		end
		if k == Enum.KeyCode.S then
			SDown = false
		end
		if k == Enum.KeyCode.D then
			DDown = false
		end
		if k == Enum.KeyCode.E or k == Enum.KeyCode.Space then
			EDown = false
		end
		if k == Enum.KeyCode.Q then
			--QDown = false
		end
	end)


	local function MoveClone(X,Y,Z)
		if stopeverything then
			wait(9e9)
		end
		CharacterMoving = true
		moveval.Value = moveval.Value * CFrame.new(-X,Y,-Z)
		--RootPart.CFrame = moveval.Value
	end

	coroutine.resume(coroutine.create(function()
		while not stopeverything do
			game:GetService("RunService").RenderStepped:Wait()
			if WDown then
				MoveClone(0,0,1)
			end
			if ADown then
				MoveClone(1,0,0)
			end
			if SDown then
				MoveClone(0,0,-1)
			end
			if DDown then
				MoveClone(-1,0,0)
			end
			if EDown then
				MoveClone(0,1,0)
			end
			if QDown then
				MoveClone(0,-1,0)
			end
			if not WDown and not ADown and not SDown and not DDown and not EDown and not QDown then
				CharacterMoving = false
				RootPart.Position = moveval.Value.p
			end
		end
	end))
end
ILThrottle = 1

function CamShake(who,times,intense,origin) 
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = intense
			cam:WaitForChild'times'.Value = times

			if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
			cam.Parent = who
			wait()
			cam.Disabled = false
		end
	end)()
end

function CameraEnshaking(times,intense,origin)
	for _,v in next, Plrs:players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.character,times,intense,origin)
	end
end 

function WACKYEFFECTs(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function yourfucked(LOC,AIMTO,OUCH)
	WACKYEFFECTs({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1.4,1.4,1.4), Transparency = 0, Transparency2 = 1, CFrame = CF(LOC), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = 419268760, SoundPitch = MRANDOM(8,12)/13, SoundVolume = 7})
	for i = 1, 2 do
		local POS1 = CF(LOC,AIMTO)*CF(0,0,-45).p
		local AIMPOS = CF(LOC,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
		local HIT,POS = CastProperRay(LOC,AIMPOS,1000,Character)
		local DISTANCE = (POS - LOC).Magnitude
		if HIT then
			local HUM = nil
			if HIT.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent:FindFirstChildOfClass("Humanoid")
			elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent.Parent:FindFirstChildOfClass("Humanoid")
			end
			if HUM then
				ApplyDamage(HUM,OUCH+MRANDOM(-3,3))
			end
		end
		WACKYEFFECTs({Time = 20, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		WACKYEFFECTs({Time = 20, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.7,0.7,DISTANCE), Transparency = 0.6, Transparency2 = 1, CFrame = CF(LOC,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
end

function PuddleOfBlood(Position,MaxDrop,Model,MaxSize)
	local HITFLOOR, HITPOS, NORMAL = Raycast(Position, (CF(Position, Position + VT(0, -1, 0))).lookVector, MaxDrop, Model)
	if HITFLOOR ~= nil then
		if HITFLOOR.Parent ~= fat and HITFLOOR.Parent ~= Character then
			if HITFLOOR.Name == "BloodPuddle" then
				local DIST = (Position - HITFLOOR.Position).Magnitude
				if (HITFLOOR.Size.Z <= 5 and HITFLOOR.Size.Z < MaxSize) or (HITFLOOR.Size.Z > 5 and HITFLOOR.Size.Z < MaxSize and DIST < HITFLOOR.Size.Z/3) then
					HITFLOOR.Size = HITFLOOR.Size + VT(0.1,0,0.1)
				end
			else
				if HITFLOOR.Anchored == true then
					local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(2,0,2))
					BLOOD.CFrame = CF(HITPOS,HITPOS+NORMAL)*ANGLES(RAD(90),RAD(0),RAD(0))
					MakeForm(BLOOD,"Cyl")
					coroutine.resume(coroutine.create(function()
						Swait(75)
						while true do
							Swait()
							BLOOD.Size = BLOOD.Size - VT(0.02,0,0.02)
							if BLOOD.Size.Z < 0.051 then
								BLOOD:remove()
								break
							end
						end
					end))
				end
			end
		end
	end
end

function SprayBlood(POSITION,DIRECTION,BloodSize)
	local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(0.3,0.3,0.3),false)
	BLOOD.CFrame = CF(POSITION)
	MakeForm(BLOOD,"Ball")
	local bv = Instance.new("BodyVelocity",BLOOD) 
	bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
	bv.velocity = CF(POSITION,DIRECTION+VT(MRANDOM(-3,3)/30,MRANDOM(-3,3)/30,MRANDOM(-3,3)/30)).lookVector*75
	bv.Name = "MOVE"
	Debris:AddItem(bv,0.05)
	coroutine.resume(coroutine.create(function()
		local HASTOUCHEDGROUND = false
		local HIT = BLOOD.Touched:Connect(function(hit)
			if hit.Anchored == true then
				HASTOUCHEDGROUND = true
				PuddleOfBlood(BLOOD.Position+VT(0,1,0),2,BLOOD,BloodSize)
			end
		end)
		wait(5)
		if HASTOUCHEDGROUND == false then
			BLOOD:remove()
		end
	end))
end

function Epicshake(SHAKE,TIMER)
	coroutine.resume(coroutine.create(function()
		local FADER = SHAKE/TIMER
		for i = 1, TIMER do
			wait()
			Humanoid.CameraOffset = VT(MRANDOM(-(SHAKE-(FADER*i)),(SHAKE-(FADER*i)))/10,MRANDOM(-(SHAKE-(FADER*i)),(SHAKE-(FADER*i)))/10,MRANDOM(-(SHAKE-(FADER*i)),(SHAKE-(FADER*i)))/10)
		end
		Humanoid.CameraOffset = VT(0,0,0)
	end))
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "Really red", "Trail", Vector3.new(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = Vector3.new(0.5,DIST,0.5)
	else
		TRAIL.Size = Vector3.new(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CFrame.new(FROM, TO) * CFrame.new(0, 0, -DIST/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function CreateRing(SIZE,DOESROT,ROT,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local blockedguis = {"sup","AllahGui","polishtoilet","nooties","IY_GUI","IY_JumpScare"}
function checkgui(v) 
	if v:IsA("ScreenGui") then
		for i = 1,#blockedguis do
			if v.Name == blockedguis[i] then
				v.Enabled = false
				game:GetService("Debris"):AddItem(v,.01)
				chatfunc("Begone \""..blockedguis[i].."\"")
			end
		end
	elseif v:IsA("LocalScript") and string.sub(v.Name,string.len(v.Name)-15) == "'s Sound Stopper" then
		v.Disabled = true
		if v:FindFirstChild("Char") then
			v.Char.Value = eeeblock
			v.Disabled = false
		end
	end
end

for i,v in pairs(lplr:FindFirstChildOfClass("PlayerGui"):GetChildren()) do
	checkgui(v)
end

lplr:FindFirstChildOfClass("PlayerGui").ChildAdded:Connect(function(v)
	if pp then wait(math.huge) end
	checkgui(v)
end)

function SpawnTrail2(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, BrickColor.Random(), "Trail", VT(45,45,45))           
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(2,DIST,5)
	else
		TRAIL.Size = VT(2,DIST,5)
	end
	TRAIL.CFrame = CFrame.new(FROM, TO) * CFrame.new(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 55 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.03
		end
		TRAIL:remove()
	end))
end

function RifleTrail(FROM,TO,BIG)
	local loudness = sick.PlaybackLoudness
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Trail", VT(45,45,45))           
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(2,DIST,5)
	else
		TRAIL.Size = VT(2,DIST,5)
	end
	TRAIL.CFrame = CFrame.new(FROM, TO) * CFrame.new(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 55 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.03
			TRAIL.Color = Color3.fromRGB(0+178*loudness/100,0,0)
		end
		TRAIL:remove()
	end))
end

function SpawnTrail3(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Trail", VT(45,45,45))           
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(2,DIST,5)
	else
		TRAIL.Size = VT(2,DIST,5)
	end
	TRAIL.CFrame = CFrame.new(FROM, TO) * CFrame.new(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 55 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.03
			TRAIL.Color = BrickColor.Random().Color
		end
		TRAIL:remove()
	end))
end

function KillChildren(v)
	--[[v:BreakJoints()
	for _, c in pairs(v:GetChildren()) do
		if c:IsA("BasePart") then
			if c.Transparency < 1 then
				if c:FindFirstChildOfClass("Decal") then
					c:FindFirstChildOfClass("Decal"):remove()
				end
				for _, c in pairs(v:GetChildren()) do
					if c:IsA("Part") then
						if c.Transparency < 1 then
							c.Anchored = true
							c.Position = c.Position + Vector3.new(0 + MRANDOM(-11,11) * math.cos(SINE/12),0 + 6 * math.cos(SINE/12),0 + MRANDOM(-11,11) * math.cos(SINE/12))
						end
					end
					c.Parent = Effects
					coroutine.resume(coroutine.create(function()
						for i = 1, 222 do
							Swait()
							--c.Transparency = c.Transparency + 1/60
						end
						Debris:AddItem(c,2)
					end))
				end
			end
		end
	end]]
end

function Death(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE+TORSO.Size.Magnitude then
						--KillChildren(CHILD)
					end
				end
			end
		end
	end 
end

function spawnwave(POS)
	local HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, Character)
	local EMITPOS = HITPOS
	if HITFLOOR ~= nil then
		if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent)
			EMITPOS = HITPOS
		elseif HITFLOOR.Parent.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent.Parent)
			EMITPOS = HITPOS
		end
	end
	if HITFLOOR ~= nil then
		Death(EMITPOS,55)
		WACKYEFFECT({EffectType = "Sphere", Size = VT(55,100000,55), Size2 = VT(0,100000,0), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0, 0, 0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		WACKYEFFECT({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = Color3.fromRGB(0, 0, 0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1, 5 do
			local TOPOS = CF(EMITPOS)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,12)
			WACKYEFFECT({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS,TOPOS.p), MoveToPos = TOPOS.p, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = Color3.fromRGB(0, 0, 0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
	end
end

function DISEMBOWELray(MODEL)
	--[[local loudness = sick.PlaybackLoudness
	local HUM = MODEL:FindFirstChildOfClass("Humanoid")
	MODEL:BreakJoints()
	if HUM then
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD:IsA("BasePart") then
				if CHILD.Name == "Head" then
					WACKYEFFECT699({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT699({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT699({Time = MRANDOM(10,30)*12, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-360,360)/1.5,MRANDOM(-360,360)/1.5,0), MRANDOM(-360,360)/35, RotationX = MRANDOM(-360,360)/35, RotationY = MRANDOM(-360,360)/35, RotationZ = MRANDOM(-360,360)/35, Material = "Granite", Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 50})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT699({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT699({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT699({Time = MRANDOM(10,30)*6, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-50,100)/1.5,MRANDOM(-50,100)/35,MRANDOM(-50,100)/35), MRANDOM(-50,100)/35, RotationX = MRANDOM(-50,100)/35, RotationY = MRANDOM(-50,100)/35, RotationZ = MRANDOM(-50,100)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 35})
				end
				if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
					WACKYEFFECT699({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT699({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT699({Time = 50, EffectType = "Box", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude * 3, Size2 = VT(5,5,5)*CHILD.Size.Magnitude, Transparency = 0.8, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = CHILD.Position+VT(MRANDOM(-50,100)/35,MRANDOM(-50,100)/35,MRANDOM(-50,100)/35), MRANDOM(-50,100)/35, RotationX = MRANDOM(-50,100)/35, RotationY = MRANDOM(-50,100)/35, RotationZ = MRANDOM(-50,100)/35, Material = "Granite", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 35})
				end
				CHILD:Destroy()
				CHILD:Destroy()
				CHILD:Destroy()
			end
		end
		HUM.Health = 0
	end
	MODEL:remove()
	MODEL:remove()
	MODEL:remove()
	MODEL:remove()
	MODEL:remove()
	MODEL:Destroy()
	MODEL:Destroy()
	MODEL:Destroy()
	MODEL:Destroy()
	MODEL:Destroy()]]
end

function DISEMBOWEL(MODEL)
	--[[local HUM = MODEL:FindFirstChildOfClass("Humanoid")
	MODEL:BreakJoints()
	if HUM then
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD:IsA("BasePart") then
				if CHILD.Name == "Head" then
					WACKYEFFECT6({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = 206082273, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT6({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT6({Time = MRANDOM(10,30)*12, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-360,360)/1.5,MRANDOM(-360,360)/1.5,0), MRANDOM(-360,360)/35, RotationX = MRANDOM(-360,360)/35, RotationY = MRANDOM(-360,360)/35, RotationZ = MRANDOM(-360,360)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 50})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT6({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = 206082273, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT6({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT6({Time = MRANDOM(10,30)*6, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-50,100)/1.5,MRANDOM(-50,100)/35,MRANDOM(-50,100)/35), MRANDOM(-50,100)/35, RotationX = MRANDOM(-50,100)/35, RotationY = MRANDOM(-50,100)/35, RotationZ = MRANDOM(-50,100)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 35})
				end
				if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
					WACKYEFFECT6({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = 206082273, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT6({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MRANDOM(7,14)/10, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
					WACKYEFFECT6({Time = 50, EffectType = "Box", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude * 3, Size2 = VT(5,5,5)*CHILD.Size.Magnitude, Transparency = 0.8, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = CHILD.Position+VT(MRANDOM(-50,100)/35,MRANDOM(-50,100)/35,MRANDOM(-50,100)/35), MRANDOM(-50,100)/35, RotationX = MRANDOM(-50,100)/35, RotationY = MRANDOM(-50,100)/35, RotationZ = MRANDOM(-50,100)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = 206082273, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 35})
				end
				CHILD:Destroy()
				CHILD:Destroy()
				CHILD:Destroy()
			end
		end
		HUM.Health = 0
	end
	MODEL:remove()
	MODEL:remove()
	MODEL:remove()
	MODEL:remove()
	MODEL:remove()
	MODEL:Destroy()
	MODEL:Destroy()
	MODEL:Destroy()
	MODEL:Destroy()
	MODEL:Destroy()]]
end

function WACKYEFFECT6(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or VT(1, 1, 1)
	local ENDSIZE = Table.Size2 or VT(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material --or "Neon"
	local COLOR = Table.Color or C3(1, .7, 0)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	local USEBOOMERANGMATH = Table.UseBoomerangMath or false
	local BOOMERANG = Table.Boomerang or 0
	local SIZEBOOMERANG = Table.SizeBoomerang or 0
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, "Neon", 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
		EFFECT.Color = BrickColor.Random().Color
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Star" then 
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, VT(0,0,0))   	
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, VT(0, 0, 0))
		end
		coroutine.resume(coroutine.create(function()
			if MSH ~= nil then
				local BOOMR1 = 1 + BOOMERANG / 50
				local BOOMR2 = 1 + SIZEBOOMERANG / 50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
				else
					GROWTH = SIZE - ENDSIZE
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - VT(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH / TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat
						Swait()
					until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			elseif PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end))
		return EFFECT
	end))
end   


function WACKYEFFECT699(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or VT(1, 1, 1)
	local loudness = sick.PlaybackLoudness
	local ENDSIZE = Table.Size2 or VT(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material --or "Neon"
	local COLOR = Table.Color or C3(1, .7, 0)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	local USEBOOMERANGMATH = Table.UseBoomerangMath or false
	local BOOMERANG = Table.Boomerang or 0
	local SIZEBOOMERANG = Table.SizeBoomerang or 0
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, "Neon", 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
		EFFECT.Color = Color3.fromRGB(0+178*loudness/100,0,0)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Star" then 
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, VT(0,0,0))   	
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, VT(0, 0, 0))
		end
		coroutine.resume(coroutine.create(function()
			if MSH ~= nil then
				local BOOMR1 = 1 + BOOMERANG / 50
				local BOOMR2 = 1 + SIZEBOOMERANG / 50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
				else
					GROWTH = SIZE - ENDSIZE
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - VT(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH / TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat
						Swait()
					until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			elseif PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end))
		return EFFECT
	end))
end   

function AOETime2(POSITION,RANGE)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						DISEMBOWEL(CHILD)
					end
				end
			end
		end
	end
end

function AOETimeRay(POSITION,RANGE)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						DISEMBOWELray(CHILD)
					end
				end
			end
		end
	end
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = Color3.new(0,0,0)
	TOPTEXTURE.Color3 = Color3.new(0,0,0)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

function MakeRing()
	local RING = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Pearl"), "MagicRing", VT(0, 0, 0), true)
	local MSH = IT("BlockMesh", RING)
	local TOP = DECAL:Clone()
	local BOTTOM = DECAL:Clone()
	TOP.Parent = RING
	BOTTOM.Parent = RING
	TOP.Face = "Top"
	BOTTOM.Face = "Bottom"
	TOP.Texture = "http://www.roblox.com/asset/?id=121028264"
	BOTTOM.Texture = "http://www.roblox.com/asset/?id=121028264"
	local function REMOVE()
		coroutine.resume(coroutine.create(function()
			local SIZE = MSH.Scale.X
			for i = 1, 35 do
				Swait()
				MSH.Scale = MSH.Scale - VT(SIZE, 0, SIZE) / 60
				TOP.Transparency = TOP.Transparency + 0.02857142857142857
				BOTTOM.Transparency = BOTTOM.Transparency + 0.02857142857142857
				RING.CFrame = RING.CFrame * ANGLES(RAD(0), RAD(-5), RAD(0))
			end
			RING:remove()
		end))
	end
	return RING, MSH, REMOVE
end

function ApplyAoE5(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							--CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									--[[local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CFrame.new(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)--]]
								end
							end
						end
					end
				end
			end
		end
	end
end

function ApplyDamage(Humanoid,Damage,OneShot)
	Damage = Damage * DAMAGEMULTIPLIER
	local DEAD = false
	if Humanoid.Health < 2000 and OneShot == false then
		if Humanoid.Health - Damage > 0 then
			--Humanoid.Health = Humanoid.Health - Damage
		else
			--Humanoid.Parent:BreakJoints()
			DEAD = true
		end
	else
		DEAD = true
		--Humanoid.Parent:BreakJoints()
	end
	if DEAD == true then
		--[[local PARTS = {}
		for index, CHILD in pairs(Humanoid.Parent:GetChildren()) do
			if CHILD:IsA("BasePart") then
				table.insert(PARTS,CHILD)
			end
		end
		coroutine.resume(coroutine.create(function()
			wait(2)
			repeat
				Swait()
				local PIECE = nil
				if MRANDOM(1,5) == 1 then
					for E = 1, #PARTS do
						if MRANDOM(1,5) == 1 then
							PIECE = PARTS[E]
							table.remove(PARTS,E)
							break
						end
					end
				end
				if PIECE ~= nil then
					if PIECE.Name == "Head" then
						WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z), Size2 = (VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z))*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
					else
						WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = PIECE.Size, Size2 = PIECE.Size*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
					end
					PIECE:remove()
				end
			until #PARTS == 0
		end))--]]
	end
end

function WACKYEFFECT5(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or BrickColor.Random().Color)
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, "Neon", 0, 0, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		EFFECT.Color = BrickColor.Random().Color
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function ShakeCam(Length,Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			Swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			Humanoid.CameraOffset = Vector3.new(RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)))
			Cam.CFrame = Cam.CFrame * CF(RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity)), RAD(MRANDOM(-intensity, intensity))) * EULER(RAD(MRANDOM(-intensity, intensity)) * rotM, RAD(MRANDOM(-intensity, intensity)) * rotM, RAD(MRANDOM(-intensity, intensity)) * rotM)
		end
		Humanoid.CameraOffset = Vector3.new(0, 0, 0)
	end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
	local type = type
	local rng = Instance.new("Part", Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.Color = color3
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(MRANDOM(-360,360)),math.rad(MRANDOM(-360,360)),math.rad(MRANDOM(-360,360)))
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function WACKYEFFECT2(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or Vector3.new(1, 1, 1)
	local ENDSIZE = Table.Size2 or Vector3.new(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material --or "Neon"
	local COLOR = Table.Color or Color3.new(1, 1, 1)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	local USEBOOMERANGMATH = Table.UseBoomerangMath or false
	local BOOMERANG = Table.Boomerang or 0
	local SIZEBOOMERANG = Table.SizeBoomerang or 0
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", Vector3.new(1, 1, 1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, Vector3.new(0, 0, 0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, Vector3.new(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", Vector3.new(SIZE.X, SIZE.X, 0.1), Vector3.new(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", Vector3.new(SIZE.X / 10, 0, SIZE.X / 10), Vector3.new(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", Vector3.new(SIZE.X / 10, 0, SIZE.X / 10), Vector3.new(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, Vector3.new(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, Vector3.new(0, 0, 0))
		elseif TYPE == "Star" then 
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, Vector3.new(0,0,0))   	
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, Vector3.new(0, 0, 0))
		end
		coroutine.resume(coroutine.create(function()
			if MSH ~= nil then
				local BOOMR1 = 1 + BOOMERANG / 50
				local BOOMR2 = 1 + SIZEBOOMERANG / 50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
				else
					GROWTH = SIZE - ENDSIZE
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - Vector3.new(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
						if TYPE == "Wave" then
							MSH.Offset = Vector3.new(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * CFrame.Angles(math.rad(ROTATION1), math.rad(ROTATION2), math.rad(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CFrame.new(EFFECT.Position, MOVEDIRECTION) * CFrame.new(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH / TIME
						if TYPE == "Wave" then
							MSH.Offset = Vector3.new(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * CFrame.Angles(math.rad(ROTATION1), math.rad(ROTATION2), math.rad(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat
						Swait()
					until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			elseif PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end))
		return EFFECT
	end))
end      

function Kill(Char)
	--[[local NewCharacter = IT("Model",Effects)
	NewCharacter.Name = "I've been raped"
	for _, c in pairs(Char:GetDescendants()) do
		if c:IsA("BasePart") and c.Transparency == 0 then
			c:BreakJoints()
			c.Material = "Glass"
			c.Color = Color3.new(1,0,0)
			c.CanCollide = true
			c.Transparency = 0.3
			if c:FindFirstChildOfClass("SpecialMesh") then
				c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
			end
			if c.Name == "Head" then
				c:ClearAllChildren()
				c.Size = Vector3.new(c.Size.Y,c.Size.Y,c.Size.Y)
			end
			if c.ClassName == "MeshPart" then
				c.TextureID = ""
			end
			if c:FindFirstChildOfClass("BodyPosition") then
				c:FindFirstChildOfClass("BodyPosition"):remove()
			end
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			c.Parent = NewCharacter
			c.Name = "DeadPart"
			c.Velocity = Vector3.new(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))/15
			c.RotVelocity = Vector3.new(MRANDOM(-45,45),MRANDOM(-15,85),MRANDOM(-45,45))
		end
	end
	Char:remove()
	Debris:AddItem(NewCharacter,5)]]
end


function CharacterFade(COLOR,TIMER)
	--[[coroutine.resume(coroutine.create(function()
		local FADE = IT("Model",Effects)
		FADE.Name = "FadingEffect"
		for _, c in pairs(Character:GetChildren()) do
			if c.ClassName == "Part" and c ~= RootPart then
				local FADER = c:Clone()
				FADER.Color = COLOR
				FADER.CFrame = c.CFrame
				FADER.Parent = FADE
				FADER.Anchored = true
				FADER.Transparency = 0.25+c.Transparency
				FADER:BreakJoints()
				FADER.Material = "Neon"
				if FADER.Name == "Head" then
					FADER:ClearAllChildren()
					FADER.Size = Vector3.new(1,1,1)
				end
				FADER.CanCollide = false
			end
		end
		local TRANS = 0.75/TIMER
		for i = 1, TIMER do
			Swait()
			for _, c in pairs(FADE:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + TRANS
				end
			end
		end
		FADE:remove()
	end))]]
end

function Sloice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", Vector3.new(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "448386996", "", Vector3.new(0, SIZE / 10, SIZE / 10), Vector3.new(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "662586858", "", Vector3.new(SIZE / 10, 0, SIZE / 10), Vector3.new(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "662585058", "", Vector3.new(SIZE / 10, 0, SIZE / 10), Vector3.new(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end


function AddChildrenToTable(FROM, PARENT, DIST, TABLE)
	for _, c in pairs(PARENT:GetChildren()) do
		if c.ClassName == "Model" then
			if c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
				local HUMANOID = c:FindFirstChildOfClass("Humanoid")
				local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
				if DIST > (TORSO.Position - FROM).Magnitude then
					table.insert(TABLE, c)
				end
				AddChildrenToTable(FROM, c, DIST, TABLE)
			elseif c.ClassName == "Folder" then
				AddChildrenToTable(FROM, c, DIST, TABLE)
			end
		end
	end
end

function FireArc(Part, ToLocation, AmountOfTime, Height, DoesCourontine)
	if DoesCourontine == false then
		local Direction = CFrame.new(Part.Position, ToLocation)
		local Distance = (Part.Position - ToLocation).magnitude
		for i = 1, AmountOfTime do
			Swait()
			Part.CFrame = Direction * CFrame.new(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
			Direction = Part.CFrame
		end
		Part:remove()
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CFrame.new(Part.Position, ToLocation)
			local Distance = (Part.Position - ToLocation).magnitude
			for i = 1, AmountOfTime do
				Swait()
				Part.CFrame = Direction * CFrame.new(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
				Direction = Part.CFrame
			end
			Part:remove()
		end))
	end
end

function Slice2(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BrickColor.new(COLOR), "Effect", Vector3.new(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "448386996", "", Vector3.new(0, SIZE / 10, SIZE / 10), Vector3.new(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "662586858", "", Vector3.new(SIZE / 10, 0, SIZE / 10), Vector3.new(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "662585058", "", Vector3.new(SIZE / 10, 0, SIZE / 10), Vector3.new(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateWave(SIZE, WAIT, CFRAME, DOESROT, ROT, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BrickColor.new(COLOR), "Effect", Vector3.new(0, 0, 0))
	local mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "20329976", "", SIZE, Vector3.new(0, 0, -SIZE.X / 8))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = Vector3.new(0, 0, -(mesh.Scale.X / 8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end





aa = false


local function characterfixer()

end
workspace.DescendantRemoving:Connect(function(v)
	if not alreadyfixing then
		if v == Character or v:IsDescendantOf(Character) then
			if not v:IsDescendantOf(Effects) and not v:IsA("Sound") and not v:IsA("BodyMover") then
				characterfixer()
			elseif v == sick then
				--NewMusic()
			end
		end
	end
end)


workspace.DescendantRemoving:Connect(function(v)
	if pp then wait(math.huge) end
	if not alreadyfixing then
		if v == Character or v:IsDescendantOf(Character) then
			if not v:IsDescendantOf(Effects) and not v:IsA("Sound") and not v:IsA("BodyMover") and not v:isA("DataModelMesh") and not v:IsA("SoundEffect") and not v:IsA("ValueBase") and v.Parent.Name ~= "I'm still here! =)" then
				if v:IsA("Model") and v.Name == "I'm still here! =)" and not v:FindFirstChild("DEBOUNCE BOIII") then
					pcall(function()
						Instance.new("StringValue",v).Name = "fuckin' hell"
						v:Destroy()
					end)
					local yeaboi = v.Parent
					local shield = Instance.new("Model")
					shield.Name = "I'm still here! =)"
					local shieldpart = Instance.new("Part")
					shieldpart.Name = "HumanoidRootPart"
					shieldpart.Size = yeaboi.Size + Vector3.new(.4,.4,.4)
					shieldpart.Transparency = 1
					shield:GetPropertyChangedSignal("Archivable"):Connect(function()
						if pp then wait(math.huge) end
						shieldpart.Transparency = 0
					end)
					shieldpart.Color = yeaboi.Color
					shieldpart.CanCollide = false
					shieldpart.Massless = true
					shieldpart.Parent = shield
					local shieldweld = Instance.new("Weld")
					shieldweld.Name = randomstring()
					shieldweld.Part0 = yeaboi
					shieldweld.Part1 = shieldpart
					shieldweld.Parent = shield
					shield.Parent = yeaboi
				else
					characterfixer()
				end
			end
		end
	end
end)
if lplr.Name == USERNAME then
	local gui = Instance.new("ScreenGui")
	gui.Name = randomstring()
	local fixcharbutton = Instance.new("TextButton",gui)
	fixcharbutton.TextScaled = true
	fixcharbutton.Font = "Antique"
	fixcharbutton.Name = randomstring()
	fixcharbutton.BorderSizePixel = 0
	fixcharbutton.BackgroundTransparency = .5
	fixcharbutton.TextStrokeColor3 = suc
	fixcharbutton.TextStrokeTransparency = 0
	fixcharbutton.BackgroundColor3= suc
	fixcharbutton.Text = "End Script"
	fixcharbutton.Size = UDim2.new(.25,0,0,36)
	fixcharbutton.AnchorPoint = Vector2.new(1,1)
	fixcharbutton.Position = UDim2.new(.5,0,0,0)
	spawn(function() Hellifytext(fixcharbutton) end)
	local exitbutton = Instance.new("TextButton",gui)
	exitbutton.TextScaled = true
	exitbutton.Font = "Antique"
	exitbutton.Name = randomstring()
	exitbutton.BorderSizePixel = 0
	exitbutton.BackgroundTransparency = .5
	exitbutton.TextStrokeColor3 = suc
	exitbutton.TextStrokeTransparency = 0
	exitbutton.BackgroundColor3 = suc
	exitbutton.Text = "Emergency Shutdown"
	exitbutton.Size = UDim2.new(.25,0,0,36)
	exitbutton.AnchorPoint = Vector2.new(0,1)
	exitbutton.Position = UDim2.new(.5,0,0,0)
	gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
	fixcharbutton.MouseButton1Click:Connect(function()
		if not alreadyfixing then
			Character:Destroy()
		end
	end)
	exitbutton.MouseButton1Click:Connect(function()
		MainFolder.ExitRemote:FireServer()
	end)
	local fixinggui = false
	local function fixgui()
		fixinggui = true
		pcall(function()
			gui:Destroy()
		end)
		gui = Instance.new("ScreenGui")
		gui.Name = randomstring()
		fixcharbutton = Instance.new("TextButton",gui)
		fixcharbutton.TextScaled = true
		fixcharbutton.Font = "Antique"
		fixcharbutton.Name = randomstring()
		fixcharbutton.BorderSizePixel = 0
		fixcharbutton.BackgroundTransparency = .5
		fixcharbutton.TextStrokeColor3 = suc
		fixcharbutton.TextStrokeTransparency = 0
		fixcharbutton.BackgroundColor3 = suc
		fixcharbutton.Text = "End Script"
		fixcharbutton.Size = UDim2.new(.25,0,0,36)
		fixcharbutton.AnchorPoint = Vector2.new(1,1)
		fixcharbutton.Position = UDim2.new(.5,0,0,0)
		spawn(function() Hellifytext(fixcharbutton) end)
		exitbutton = Instance.new("TextButton",gui)
		exitbutton.TextScaled = true
		exitbutton.Font = "Antique"
		exitbutton.Name = randomstring()
		exitbutton.BorderSizePixel = 0
		exitbutton.BackgroundTransparency = .5
		exitbutton.TextStrokeColor3 = suc
		exitbutton.TextStrokeTransparency = 0
		exitbutton.BackgroundColor3 = suc
		exitbutton.Text = "Emergency Shutdown"
		exitbutton.Size = UDim2.new(.25,0,0,36)
		exitbutton.AnchorPoint = Vector2.new(0,1)
		exitbutton.Position = UDim2.new(.5,0,0,0)
		gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
		spawn(function() Hellifytext(exitbutton) end)
		fixcharbutton.MouseButton1Click:Connect(function()
			if not alreadyfixing then
				Character:Destroy()
			end
		end)
		exitbutton.MouseButton1Click:Connect(function()
			MainFolder.ExitRemote:FireServer()
		end)
		fixinggui = false
	end
	Player:FindFirstChildOfClass("PlayerGui").DescendantRemoving:Connect(function(v)
		if not fixinggui then
			if v == gui or v:IsDescendantOf(gui) then
				fixgui()
			end
		end
	end)
	coroutine.resume(coroutine.create(function()
		local noob = 0
		repeat noob = noob + game:GetService("RunService").RenderStepped:Wait() until noob >= .1
		while true do
			if not fixinggui and not alreadyfixing then

			end
			swait()
		end
	end))
end


function CreateMesh2(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function printbye(Name)
	local MESSAGES = {"Fuck Off,"}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

function Banish(Foe)
	--[[if Foe then
		local loudness = sick.PlaybackLoudness
		coroutine.resume(coroutine.create(function()
			FuckItImOverTheBeef(TOBANISH,Foe.Name)
			printbye(Foe.Name)
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
				if c.Name == "Banished" == true then
					Foe:Destroy()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CFrame.new(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CFrame.new(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end]]
end

local epicmode=false
local E={}

function kick(Foe)
	--[[if Foe then
		local loudness = sick.PlaybackLoudness
		coroutine.resume(coroutine.create(function()
			table.insert(TOBANISH,Foe.Name)
			printbye(Foe.Name)
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local plr = game:service'Players':GetPlayerFromCharacter(Foe)
			if plr then
				coroutine.resume(coroutine.create(function()
					wait(0.5)
					plr:Kick(Reason)		
				end))		
			end
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end--]]
end

function unanchor()
	if UNANCHOR == true then
		g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

local BEANED = {}
--succ(HIT.Parent)
function succ(bitch)	
	--[[if bitch then	
		g = game.Players:GetPlayers()
		local kickfolder = IT("Folder",Effects)
		local naeeym2 = Instance.new("BillboardGui",kickfolder)
		naeeym2.AlwaysOnTop = false
		naeeym2.Size = UDim2.new(5,35,2,35)
		naeeym2.StudsOffset = Vector3.new(0,1,0)
		naeeym2.Name = "Mark"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.TextScaled = true
		tecks2.BorderSizePixel = 0
		tecks2.Text = "BANNED"
		tecks2.Font = "Arcade"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = Color3.fromRGB(0,0,0)
		tecks2.TextStrokeColor3 = Color3.fromRGB(0,0,0)
		tecks2.Size = UDim2.new(1,0,0.5,0)
		tecks2.Parent = naeeym2
		CharacterFade(Color3.new(0, 0, 0), 150)
		-- CreateSound("2570187601", bitch, 600, 1, false)
		local Players = game:GetService("Players")
		local fag = Players:FindFirstChild(bitch.Name)
		--faggut:Kick()
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick("Die..")
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick("Die..")
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick("Die..")
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick("Die..")
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick("Die..")
		end
		if Players:FindFirstChild(bitch.Name) then
			fag:Kick("Die..")
		end
		table.insert(BEANED,bitch.name)
		coroutine.resume(coroutine.create(function()
			for i = 1, 50 do
				Swait()
				for i,v in ipairs(kickfolder:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 1
					end
					naeeym2.Enabled = false
				end
				Swait()
				for i,v in ipairs(kickfolder:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 0
					end
					naeeym2.Enabled = true
				end
			end
			kickfolder:remove()
		end))
	end--]]
end      	

workspace.ChildAdded:connect(function(instance)
	for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick() 
		end
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							--Banish(CHILD)
						elseif YoureFucked == true then
							--succ(CHILD)
						else
							--[[if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+Vector3.new(0,0.3,0)
									TORSO.RotVelocity = Vector3.new(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end]]
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

local lightning = Instance.new("ParticleEmitter",Torso)
lightning.Texture = "http://www.roblox.com/asset/?id=348321827"
lightning.LightEmission = 0
lightning.Color = ColorSequence.new(Color3.new(0,0,0),Color3.new(1,0,0))
lightning.LockedToPart = true
lightning.Rate = 200
lightning.Lifetime = NumberRange.new(0.1,0.10)
lightning.Rotation = NumberRange.new(0,360)
lightning.Size = NumberSequence.new(3,3,3)
lightning.Transparency = NumberSequence.new(0,0)
lightning.Speed = NumberRange.new(0,0)
lightning.RotSpeed = NumberRange.new(0,0)
lightning.ZOffset = 5.5
lightning.Parent = Character.Torso
lightning.Enabled = false

local lightningArm = Instance.new("ParticleEmitter",RightArm)
lightningArm.Texture = "http://www.roblox.com/asset/?id=348321827"
lightningArm.LightEmission = 0
lightningArm.Color = ColorSequence.new(Color3.new(0,0,0),Color3.new(1,0,0))
lightningArm.LockedToPart = true
lightningArm.Rate = 200
lightningArm.Lifetime = NumberRange.new(0.1,0.10)
lightningArm.Rotation = NumberRange.new(0,360)
lightningArm.Size = NumberSequence.new(1,1,1)
lightningArm.Transparency = NumberSequence.new(0,0)
lightningArm.Speed = NumberRange.new(0,0)
lightningArm.RotSpeed = NumberRange.new(0,0)
lightningArm.ZOffset = 5.5
lightningArm.Enabled = false

local refec = Instance.new("ParticleEmitter",RightArm)
refec.Texture = "rbxassetid://249270319"
refec.LightEmission = 3
refec.Color = ColorSequence.new(Color3.new(0,0,0),Color3.new(1,0,0))
refec.Rate = 50000
refec.Lifetime = NumberRange.new(0.5)
refec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.5,0.75,0),NumberSequenceKeypoint.new(1,0.1,0)})
refec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
refec.Speed = NumberRange.new(0,2)
refec.Drag = 5
refec.LockedToPart = true
refec.Rotation = NumberRange.new(-500,500)
refec.VelocitySpread = 9000
refec.RotSpeed = NumberRange.new(-500,500)

local eeeffecto = Instance.new("ParticleEmitter",Torso)
eeeffecto.Texture = "http://www.roblox.com/asset/?id=305943367"
eeeffecto.LightEmission = 0
eeeffecto.Color = ColorSequence.new(Color3.new(0,0,0),Color3.new(1,0,0))
eeeffecto.LockedToPart = true
eeeffecto.Rate = 120
eeeffecto.Lifetime = NumberRange.new(0.1,0.1)
eeeffecto.Rotation = NumberRange.new(0,0)
eeeffecto.Size = NumberSequence.new(9,9,9)
eeeffecto.Transparency = NumberSequence.new(0,0)
eeeffecto.Speed = NumberRange.new(0,0)
eeeffecto.RotSpeed = NumberRange.new(0,0)
eeeffecto.Parent = Character.Torso
eeeffecto.Enabled = false
lightning.Enabled = false
eeeffecto.Enabled = false


function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end


if lplr.Name == USERNAME then
	workspace.CurrentCamera.CameraSubject = Humanoid
	workspace.CurrentCamera.CameraType = "Custom"
	workspace.CurrentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		if pp then wait(math.huge) end
		if not alreadyfixing and workspace.CurrentCamera.CameraSubject ~= Humanoid then
			workspace.CurrentCamera.CameraSubject = Humanoid
		end
	end)
	workspace.ChildRemoved:Connect(function(v)
		if pp then wait(math.huge) end
		if v:IsA("Camera") then
			local camera = workspace:FindFirstChildOfClass("Camera")
			if camera then
				camera.CameraSubject = Humanoid
				camera.CameraType = "Custom"
				camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
					if pp then wait(math.huge) end
					if not alreadyfixing and camera.CameraSubject ~= Humanoid then
						camera.CameraSubject = Humanoid
					end
				end)
			else
				local newcamerafound = false
				while not pp and not newcamerafound do
					camera = workspace.ChildAdded:Wait()
					if camera:IsA("Camera") then
						newcamerafound = true
						camera.CameraSubject = Humanoid
						camera.CameraType = "Custom"
						camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
							if pp then wait(math.huge) end
							if not alreadyfixing and camera.CameraSubject ~= Humanoid then
								camera.CameraSubject = Humanoid
							end
						end)
					end
				end
			end
		end
	end)
end
spawn(function()


	local TS = game:GetService("TweenService")
	local PS = game:GetService("PhysicsService")

	ArtificialHB = Instance.new("BindableEvent",script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = 1/60
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:Connect(function(s,p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1,math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
end)

function QFCF(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip,0.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip,(m12 + m21) * recip,0.5 * s,(m10 - m01) * recip
		end
	end
end

function QTCF(px,py,pz,x,y,z,w)
	local xs,ys,zs = x + x,y + y,z + z
	local wx,wy,wz = w * xs,w * ys,w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
end

function QS(a,b,t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp,finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a,b,t)
	local qa = {QFCF(a)}
	local qb = {QFCF(b)}
	local ax,ay,az = a.x,a.y,a.z
	local bx,by,bz = b.x,b.y,b.z
	local _t = 1 - t
	return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
end

ArtificialHB = Instance.new("BindableEvent",script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 30
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:Connect(function(s,p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1,math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:Wait()
	else
		for i = 0,num do
			ArtificialHB.Event:Wait()
		end
	end
end

function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

local S = Instance.new("Sound")
function CreateSound(ID,PARENT,VOLUME,PITCH,DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			coroutine.resume(coroutine.create(function()
				pcall(function()
					repeat Swait() until NEWSOUND.Playing == false
					NEWSOUND:Destroy()
				end)
			end))
		end
	end))
	return NEWSOUND
end

function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 		
local resetchar = MainFolder.ResetChar

function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or shade)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,shade,"Effect",Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		if not alreadyfixing then
			if SongSync.Value > eee.TimeLength and eee.TimeLength >= .1 then
				ResetSongSync:FireServer()
			end
			if eee.TimePosition < (SongSync.Value - 1) or eee.TimePosition > (SongSync.Value + 1) then
				eee.TimePosition = SongSync.Value
			end
		end
	end
end))


function bosschatfunc(text,color,watval)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Dialog")~= nil then
				v.PlayerGui:FindFirstChild("Dialog"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Dialog"
			local txtlb = Instance.new("TextLabel",scrg)
			txtlb.Text = ""
			txtlb.Font = "Bodoni"
			txtlb.TextColor3 = Color3.new(0,0,0)
			txtlb.TextStrokeTransparency = 0
			txtlb.BackgroundTransparency = 0.75
			txtlb.BackgroundColor3 = Color3.new(0,0,0)
			txtlb.TextStrokeColor3 = color
			txtlb.TextScaled = true
			txtlb.Size = UDim2.new(1,0,0.25,0)
			txtlb.TextXAlignment = "Left"
			txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
			local txtlb2 = Instance.new("TextLabel",scrg)
			txtlb2.Text = "[Aberration]:"
			txtlb2.Font = "Antique"
			txtlb2.TextColor3 = Color3.new(0,0,0)
			txtlb2.TextStrokeTransparency = 0
			txtlb2.BackgroundTransparency = 1
			txtlb2.TextStrokeColor3 = color
			txtlb2.TextSize = 40
			txtlb2.Size = UDim2.new(1,0,0.25,0)
			txtlb2.TextXAlignment = "Left"
			txtlb2.Position = UDim2.new(0,0,1,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					if MODE == "Sanity" then
						txtlb.Rotation = math.random(-1,1)
						txtlb2.Rotation = math.random(-1,1)
						txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
						txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
						txtlb.TextStrokeColor3 = BrickColor.random().Color
						txtlb2.TextStrokeColor3 = BrickColor.random().Color
					end
				end
			end))
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					if scrg.Parent ~= nil then
						fvalen = fvalen - 0.0001
					elseif scrg.Parent == nil then
						break
					end
				end
			end))
			local flol = 1.75
			local flil = 1.6
			coroutine.resume(coroutine.create(function()
				for i = 0, 9 do
					Swait()
					fval = fval + 0.05
					flol = flol - 0.1
					flil = flil - 0.1
					txtlb.Text = ""
					txtlb.Position = UDim2.new(0,0,flol,0)
					txtlb2.Position = UDim2.new(0,0,flil,0)
				end
				txtlb.Text = text
				wait(watval)
				local valinc = 0
				for i = 0, 99 do
					Swait()
					valinc = valinc + 0.0001
					flol = flol + valinc
					flil = flil + valinc
					txtlb.Rotation = txtlb.Rotation + valinc*20
					txtlb2.Rotation = txtlb2.Rotation - valinc*50
					txtlb.Position = UDim2.new(0,0,flol,0)
					txtlb2.Position = UDim2.new(0,0,flil,0)
					txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
					txtlb.TextTransparency = txtlb.TextTransparency + 0.01
					txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
					txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
					txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
				end
				scrg:Destroy()
			end))
		end))
	end
end

function warnedpeople2(whom)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
				v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
			end
			local droppingFrame = false
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "ARRIVAL"
			local mainFrame = Instance.new("Frame", scrg)
			mainFrame.Name = "MainFrame"
			mainFrame.BackgroundTransparency = 1
			mainFrame.BorderSizePixel = 0
			mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
			mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
			local TextFrame = Instance.new("TextLabel",mainFrame)
			TextFrame.Name = "TextFrame"
			TextFrame.Font = "Arcade"
			TextFrame.Text = ""
			TextFrame.TextScaled = true
			TextFrame.TextSize = 9
			TextFrame.TextStrokeTransparency = 1
			TextFrame.BackgroundTransparency = 1
			TextFrame.TextColor3 = Color3.new(sick.PlaybackLoudness/500,0,0)
			TextFrame.TextStrokeColor3 = Color3.new(0, 0, 0)
			TextFrame.Size = UDim2.new(1, 0, 0, 92)
			TextFrame.Position = UDim2.new(0, 0, 0, 0)
			spawn(function() Hellifytext(TextFrame) end)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mainFrame.BackgroundColor3 = Color3.new(0,0,0)
					mainFrame.BorderColor3 = Color3.new(0, 0, 0)
					if(not droppingFrame)then
						mainFrame.Rotation = 0 - 2 * math.cos(SINE / 24)
					end
					TextFrame.TextStrokeTransparency = 0
				end
			end))
			for i = 1,string.len(whom),1 do
				TextFrame.Text = string.sub(whom,1,i)
				wait(0.2)
			end
			wait(2)
			droppingFrame = true
			mainFrame.Rotation = 0
			local vinc2 = 1
			for i = 0, 99 do
				Swait()
				vinc2 = vinc2 + 0.25
				mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
			end
			scrg:Destroy()
		end))
	end
end

function warnedpeople(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 0.5
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 0.5
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 0.3
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 0.3
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "Arcade"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextColor3 = Color3.new(0.4,0,0)
					TextFrame.TextStrokeColor3 = Color3.new(0, 0, 0)
					TextFrame.TextStrokeTransparency = 0
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.Arcade
					glow.ImageColor3 = Color3.new(0, 0, 0)
					wobble.Rotation = 0 - 2 * math.cos(SINE / 24)
					wobble2.Rotation = 0 - 2 * math.cos(SINE / 30)
					wobble2.BackgroundColor3 = Color3.new(0.1,0.1,0.1)
					wobble2.BorderColor3 = Color3.new(0.4,0,0)
					wobble2.BorderSizePixel = 2
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = Color3.new(0.1,0.1,0.1)
					Visuals.BorderColor3 = Color3.new(0.4,0,0)
					Visuals2.BackgroundColor3 = Color3.new(0.1,0.1,0.1)
					Visuals2.BorderColor3 = Color3.new(0.4,0,0)
					wobble.BackgroundColor3 = Color3.new(0.1,0.1,0.1)
					wobble.BorderColor3 = Color3.new(0.4,0,0)
					wobble.BorderSizePixel = 2
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end


function ApplyAoEpp(POSITION,RANGE)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						Killpp(CHILD)
					end
				end
			end
		end
	end
end

function MagicSpherepp(size,waitt,cframe,color)
	local wave = CreatePart(3, Effects, "Neon", 0, 1, BRICKC(color), "Effect", Vector3.new(1,1,1))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = Vector3.new(size,size,size)
	mesh.Offset = Vector3.new(0,0,0)
	wave.CFrame = cframe
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, waitt do
			Swait()
			mesh.Scale = mesh.Scale - Vector3.new(size/waitt,size/waitt,size/waitt)
			wave.Transparency = wave.Transparency - (1/waitt)
		end
		wave:remove()
	end))
end


function CreateRing2(SIZE,DOESROT,ROT,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphere3(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function Kill2(Char)
	--[[local NewCharacter = IT("Model",Effects)
	NewCharacter.Name = "Ow im ded ;-;"
	for _, c in pairs(Char:GetDescendants()) do
		if c:IsA("BasePart") and c.Transparency == 0 then
			if c.Parent == Char then
			end
			c:BreakJoints()
			c.Material = "Glass"
			c.Color = C3(1,0,0)
			c.CanCollide = true
			c.Transparency = 0.3
			if c:FindFirstChildOfClass("SpecialMesh") then
				c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
			end
			if c.Name == "Head" then
				c:ClearAllChildren()
				c.Size = VT(c.Size.Y,c.Size.Y,c.Size.Y)
			end
			if c.ClassName == "MeshPart" then
				c.TextureID = ""
			end
			if c:FindFirstChildOfClass("BodyPosition") then
				c:FindFirstChildOfClass("BodyPosition"):remove()
			end
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			c.Parent = NewCharacter
			c.Name = "DeadPart"
			c.Velocity = VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))/15
			c.RotVelocity = VT(MRANDOM(-45,45),MRANDOM(-15,85),MRANDOM(-45,45))
		end
	end
	Char:remove()
	Debris:AddItem(NewCharacter,5)]]
end

function ApplyAoE4(POSITION, RANGE, MINDMG, MAXDMG, FLING, IZBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
					if IZBANISH == true then
						Kill2(CHILD)
					else
						local DMG = MRANDOM(MINDMG, MAXDMG)
						ApplyDamage(HUM, DMG, TORSO)
					end
					if FLING > 0 then
						for _, c in pairs(CHILD:GetChildren()) do
							if c:IsA("BasePart") then
								--[[local bv = Instance.new("BodyVelocity")
								bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
								bv.velocity = CF(POSITION, TORSO.Position).lookVector * FLING
								bv.Parent = c
								Debris:AddItem(bv, 0.05)]]
							end
						end
					end
				end
			end
		end
	end
end


function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end

function CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Lightning", "Bullet"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end

function CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Direction = CFrame.new(StartPos, Vec).lookVector
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Direction * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastZapRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function WACKYEFFECTpp(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or Vector3.new(1, 1, 1)
	local ENDSIZE = Table.Size2 or Vector3.new(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material --or "Neon"
	local COLOR = Table.Color or Color3.new(1, 1, 1)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	local USEBOOMERANGMATH = Table.UseBoomerangMath or false
	local BOOMERANG = Table.Boomerang or 0
	local SIZEBOOMERANG = Table.SizeBoomerang or 0
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", Vector3.new(1, 1, 1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, Vector3.new(0, 0, 0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, Vector3.new(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", Vector3.new(SIZE.X, SIZE.X, 0.1), Vector3.new(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", Vector3.new(SIZE.X / 10, 0, SIZE.X / 10), Vector3.new(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", Vector3.new(SIZE.X / 10, 0, SIZE.X / 10), Vector3.new(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, Vector3.new(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, Vector3.new(0, 0, 0))
		elseif TYPE == "Star" then 
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, Vector3.new(0,0,0))   	
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, Vector3.new(0, 0, 0))
		end
		coroutine.resume(coroutine.create(function()
			if MSH ~= nil then
				local BOOMR1 = 1 + BOOMERANG / 50
				local BOOMR2 = 1 + SIZEBOOMERANG / 50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
				else
					GROWTH = SIZE - ENDSIZE
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - Vector3.new(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
						if TYPE == "Wave" then
							MSH.Offset = Vector3.new(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * CFrame.Angles(math.rad(ROTATION1), math.rad(ROTATION2), math.rad(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CFrame.new(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH / TIME
						if TYPE == "Wave" then
							MSH.Offset = Vector3.new(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * CFrame.Angles(math.rad(ROTATION1), math.rad(ROTATION2), math.rad(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat
						Swait()
					until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			elseif PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end))
		return EFFECT
	end))
end   

function Killpp(dude)
	--[[coroutine.resume(coroutine.create(function()
		if dude and dude ~= Character then
			local h = dude:FindFirstChildOfClass("Humanoid")
			local t = dude:FindFirstChild("Torso") or dude:FindFirstChild("UpperTorso") or dude:FindFirstChild("HumanoidRootPart")
			local deathp = Instance.new("Part",Effects) deathp.Anchored = true deathp.Size = Vector3.new() deathp.Transparency = 1 deathp.CanCollide = false deathp.CFrame = t.CFrame
			coroutine.wrap(function()
				deathp:Destroy()
			end)
			if h then
				if dude then
					for i,v in next, dude:children() do if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then v.Disabled = true wait() v:destroy() end end
					CreateSound(4086042977, deathp, 5, .75)
					if h then h.MaxHealth = 0 h.Health = 0 end
					for _, c in pairs(dude:GetChildren()) do if c:IsA("BasePart") then c:BreakJoints() c:Destroy() end end
					dude:BreakJoints()
					dude:Destroy()
					for i = 0, math.random(3,7) do
						WACKYEFFECTpp({Time = math.random(145,165), EffectType = "Sphere", Size = Vector3.new(10,10,10), Size2 = Vector3.new(5,80,5), Transparency = 0, Transparency2 = 1, CFrame = deathp.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
					end
					WACKYEFFECTpp({Time = math.random(72,82), EffectType = "Sphere", Size = Vector3.new(10,10,10), Size2 = Vector3.new(40,40,40), Transparency = 0.6, Transparency2 = 1, CFrame = deathp.CFrame, MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
					for i = 0, math.random(5,9) do
						WACKYEFFECTpp({Time = math.random(36,41), EffectType = "Sphere", Size = Vector3.new(18,18,18), Size2 = Vector3.new(6,6,6), Transparency = 0, Transparency2 = 1, CFrame = deathp.CFrame, MoveToPos = deathp.CFrame*CFrame.new(math.random(-95,95),math.random(-95,95),math.random(-95,95)).p, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 45, SizeBoomerang = 40})
					end
				end
			end
		end
	end))]]
end

local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold,
	Enum.Font.DenkOne,
	Enum.Font.Merriweather,
	Enum.Font.PermanentMarker,
	Enum.Font.Creepster,
	Enum.Font.GrenzeGotisch,
	Enum.Font.SpecialElite,
	Enum.Font.FredokaOne,
	Enum.Font.Oswald,
	Enum.Font.Creepster,
	Enum.Font.LuckiestGuy,
	Enum.Font.SpecialElite,
	Enum.Font.RobotoCondensed
}


function chatfunc(text)
	local chat = coroutine.wrap(function()
		local oldthing = RootPart:FindFirstChild("TalkingBillBoard")
		if oldthing then
			oldthing:Destroy()
		end
		local naeeym2 = Instance.new("BillboardGui",RootPart)
		naeeym2.Size = UDim2.new(0,9999,2,0)
		naeeym2.StudsOffset = Vector3.new(0,4.5,0)
		naeeym2.Adornee = Character.HumanoidRootPart
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SourceSansLight"
		tecks2.TextScaled = true
		tecks2.TextStrokeTransparency = 0
		coroutine.resume(coroutine.create(function()
			while tecks2:IsDescendantOf(game) do
				local hBRUH,sBRUH,vBRUH = Color3.toHSV(Torso.NeonParts.Color)
				tecks2.TextColor3 = Color3.fromHSV(hBRUH,sBRUH,vBRUH/2)
				swait()
			end
		end))
		tecks2.TextStrokeColor3 = shade
		tecks2.Size = UDim2.new(1,0,1,0)
		local tecks3 = Instance.new("TextLabel",naeeym2)
		tecks3.BackgroundTransparency = 1
		tecks3.BorderSizePixel = 0
		tecks3.Text = ""
		tecks3.Font = "Arcade"
		tecks3.TextScaled = true
		tecks3.TextStrokeTransparency = 0
		spawn(function() Hellifytext(tecks2) end)
		coroutine.resume(coroutine.create(function()
			while tecks3:IsDescendantOf(game) do
				tecks3.TextColor3 = Torso.NeonParts.Color
				swait()
			end
		end))
		tecks3.TextStrokeColor3 = shade
		tecks3.Size = UDim2.new(1,0,1,0)
		coroutine.resume(coroutine.create(function()
			while naeeym2 ~= nil do
				swait()
				tecks2.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				tecks3.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				tecks2.Font = FONTS[MRANDOM(1, #FONTS)]
				tecks3.Font = FONTS[MRANDOM(1, #FONTS)]
			end
		end))
		for i = 1,string.len(text) do
			CreateSound(4740147336,RootPart,5,1)
			swait(2)
			tecks2.Text = string.sub(text,1,i)
			tecks3.Text = string.sub(text,1,i)
		end
		swait(120)
		for i = 1,50 do
			swait()
			tecks2.Position = tecks2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
			tecks3.Position = tecks2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			tecks2.Rotation = tecks2.Rotation + math.random(-2,2)
			tecks3.Rotation = tecks3.Rotation + math.random(-2,2)
			tecks2.TextStrokeTransparency = i/50
			tecks2.TextTransparency = tecks2.TextStrokeTransparency
			tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency
			tecks3.TextTransparency = tecks2.TextStrokeTransparency
		end
		naeeym2:Destroy()
	end)
	chat()
end
if type(Player) ~= "table" then
	Player.Chatted:Connect(chatfunc)
end
game:GetService("Players").PlayerAdded:Connect(function(v)
	if v.Name == USERNAME then
		Player = v
		Player.Chatted:Connect(chatfunc)
	end
end)



function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
	local weld = Instance.new("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
	weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
	return weld
end


--//=================================\\
--||	     RAGDOLL STUFF           ||
--\\=================================//

function recurse(root,callback,i)
	i= i or 0
	for _,v in pairs(root:GetChildren()) do
		i = i + 1
		callback(i,v)

		if #v:GetChildren() > 0 then
			i = recurse(v,callback,i)
		end
	end

	return i
end

function ragdollJoint(character, part0, part1, attachmentName, className, properties)
	attachmentName = attachmentName.."RigAttachment"
	local constraint = Instance.new(className.."Constraint")
	constraint.Attachment0 = part0:FindFirstChild(attachmentName)
	constraint.Attachment1 = part1:FindFirstChild(attachmentName)
	constraint.Name = "RagdollConstraint"..part1.Name

	for _,propertyData in next,properties or {} do
		constraint[propertyData[1]] = propertyData[2]
	end

	constraint.Parent = character
end

function getAttachment0(character, attachmentName)
	for _,child in next,character:GetChildren() do
		local attachment = child:FindFirstChild(attachmentName)
		if attachment then
			return attachment
		end
	end
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

function ArtificialHitbox(Part)
	local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
	HITBOX.CanCollide = true
	HITBOX.CFrame = Part.CFrame
	weldBetween(Part,HITBOX)
end

function R15Ragdoll(character,KeepArms)
	--[[character:BreakJoints()
	coroutine.resume(coroutine.create(function()
		recurse(character, function(_,v)
			if v:IsA("Attachment") then
				v.Axis = Vector3.new(0, 1, 0)
				v.SecondaryAxis = Vector3.new(0, 0, 1)
				v.Rotation = Vector3.new(0, 0, 0)
			end
		end)
		for _,child in next,character:GetChildren() do
			if child:IsA("Accoutrement") then
				for _,part in next,child:GetChildren() do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						local attachment1 = part:FindFirstChildOfClass("Attachment")
						local attachment0 = getAttachment0(character,attachment1.Name)
						if attachment0 and attachment1 then
							local constraint = Instance.new("HingeConstraint")
							constraint.Attachment0 = attachment0
							constraint.Attachment1 = attachment1
							constraint.LimitsEnabled = true
							constraint.UpperAngle = 0
							constraint.LowerAngle = 0
							constraint.Parent = character
						end
						ArtificialHitbox(part)
					elseif part.Name == "HumanoidRootPart" then
						part:remove()
					end
				end
			end
		end

		ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
			{"LimitsEnabled",true};
			{"UpperAngle",5};
		})
		if character:FindFirstChild("Head") then
			ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
				{"LimitsEnabled",true};
				{"UpperAngle",15};
			})
		end

		local handProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle",0};
			{"LowerAngle",0};
		}
		ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
		ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)

		local shinProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 0};
			{"LowerAngle", -75};
		}
		ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
		ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)

		local footProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 15};
			{"LowerAngle", -45};
		}
		ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
		ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
		if KeepArms == true then
			ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
			ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
			ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
			ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
		end
		ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
		ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
		Debris:AddItem(character,5)
	end))]]
end

function Ragdoll(Character2,CharTorso,KeepArms)
	--[[coroutine.resume(coroutine.create(function()
		Character2:BreakJoints()
		local hum = Character2:findFirstChild("Humanoid")
		hum:remove()
		local function Scan(ch)
			local e
			for e = 1,#ch do
				Scan(ch[e]:GetChildren())
				if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
					ch[e]:remove()
				end
			end
		end
		local NEWHUM = IT("Humanoid")
		NEWHUM.Name = "Corpse"
		NEWHUM.Health = 0
		NEWHUM.MaxHealth = 0
		NEWHUM.PlatformStand = true
		NEWHUM.Parent = Character2
		NEWHUM.DisplayDistanceType = "None"

		local ch = Character2:GetChildren()
		local i
		for i = 1,#ch do
			if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
				ch[i]:remove()
			end
		end

		local Torso2 = Character2.Torso
		local movevector = Vector3.new()

		if Torso2 then
			movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
			local Head = Character2:FindFirstChild("Head")
			if Head then
				local Neck = Instance.new("Weld")
				Neck.Name = "Neck"
				Neck.Part0 = Torso2
				Neck.Part1 = Head
				Neck.C0 = CFrame.new(0, 1.5, 0)
				Neck.C1 = CFrame.new()
				Neck.Parent = Torso2

			end
			local Limb = Character2:FindFirstChild("Right Arm")
			if Limb and KeepArms == true then

				Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			local Limb = Character2:FindFirstChild("Left Arm")
			if Limb and KeepArms == true then

				Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			local Limb = Character2:FindFirstChild("Right Leg")
			if Limb then

				Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			local Limb = Character2:FindFirstChild("Left Leg")
			if Limb then

				Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2

				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb

			end
			--[
			local Bar = Instance.new("Part")
			Bar.TopSurface = 0
			Bar.BottomSurface = 0
			Bar.formFactor = "Symmetric"
			Bar.Size = Vector3.new(1, 1, 1)
			Bar.Transparency = 1
			Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
			Bar.Parent = Character2
			local Weld = Instance.new("Weld")
			Weld.Part0 = Torso2
			Weld.Part1 = Bar
			Weld.C0 = CFrame.new(0, 0.5, 0)
			Weld.Parent = Torso2
			
		end
		Character2.Parent = workspace
		Debris:AddItem(Character2,5)

		return Character2,Torso2
	end))-]]
end

--//=================================\\
--||	     WEAPON CREATION         ||
--\\=================================//

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}
	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end

	return false
end

local function ShouldBreakJoints(MainPart, Part, JointType, xd, modelscript)
	if NEVER_BREAK_JOINTS then
		return false
	end

	--if HasWheelJoint(Part) then
	--return false
	--end

	local Connected = Part:GetConnectedParts()

	if #Connected == 1 then
		return false
	end

	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(modelscript.Parent) then
			return false
		end
	end

	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, idk, modelscript)
	for _, Part in pairs(Parts) do

		Part:BreakJoints()

	end

	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart, modelscript)
		end
	end
end

local function PerfectionWeld(modelscript)	
	--local Tool = GetNearestParent(modelscript, "Tool")
	--print("---")  
	--print(modelscript.Parent) 
	--print(modelscript) 
	--print(modelscript.Parent.Parent)
	local Parts = GetBricks(modelscript.Parent)
	local PrimaryPart = modelscript.Parent.Parent.RightArm.REF

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", "idk", modelscript)
	else
		warn("qWeld - Unable to weld part")
	end

	--return Tool
end

local AK = script.AK:Clone()
local AKWeld = AK.RightArm:WaitForChild'REF'
for i,v in pairs(AK.RightArm:GetChildren()) do
	v.Anchored = false
end
local SRightAWeld = IT("Weld")
SRightAWeld.Parent = RightArm
SRightAWeld.Part0 = RightArm
SRightAWeld.Part1 = AKWeld
SRightAWeld.Name = "AK47"
SRightAWeld.C1 = CF(0, 0, 0) * angles(0, 0, 0)
local BanishGun = AK
for i,v in pairs(BanishGun.Weapon:GetChildren()) do
	if v:IsA('BasePart') or v:IsA('Part') or v:IsA('UnionOperation') then
		--print(v)
		PerfectionWeld(v)
		v.Transparency = 1
	end

end
local HoleAK = BanishGun.Weapon.Hole
BanishGun.Parent = nil

local Sniper = script.Sniper:Clone()
local SniperWeld = Sniper.RightArm:WaitForChild'REF'
for i,v in pairs(Sniper.RightArm:GetChildren()) do
	v.Anchored = false
end
local SRightAWeld = IT("Weld")
SRightAWeld.Parent = RightArm
SRightAWeld.Part0 = RightArm
SRightAWeld.Part1 = SniperWeld
SRightAWeld.Name = "Sniper"
SRightAWeld.C1 = CF(0, 0, 0) * angles(0, 0, 0)
local SniperGun = Sniper
for i,v in pairs(SniperGun.Weapon:GetChildren()) do
	if v:IsA('BasePart') or v:IsA('Part') or v:IsA('UnionOperation') then
		--print(v)
		PerfectionWeld(v)
		v.Transparency = 1
	end

end

print(hatsniper)
hatsniper.Position = Vector3.new()
hatsniper.Rotation = Vector3.new()
local SniperHole = SniperGun.Weapon.Hole
SniperGun.Parent = nil 
hatsniper.Parent = hatsnipern

local Katana = script.Katana:Clone()
local KatanaWeld = Katana.RightArm:WaitForChild'REF'
for i,v in pairs(Katana.RightArm:GetChildren()) do
	v.Anchored = false
end
local KATSRightAWeld = IT("Weld")
KATSRightAWeld.Parent = RightArm
KATSRightAWeld.Part0 = RightArm
KATSRightAWeld.Part1 = KatanaWeld
KATSRightAWeld.Name = "Katana"
KATSRightAWeld.C1 = CF(0, 0, 0) * angles(0, 0, 0)
local Katana = Katana
for i,v in pairs(Katana.Weapon:GetChildren()) do
	if v:IsA('BasePart') or v:IsA('Part') or v:IsA('UnionOperation') then
		--print(v)
		PerfectionWeld(v)
		v.Transparency = 1
	end

end
local KatanaHit = Katana.Weapon.Hitbox
Katana.Parent = nil

local WeaponPenis = IT("Model")
local Effects = IT("Folder", WeaponPenis)

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local chara = Player.Character
local Rifle = WeaponPenis
Handaru = New("Part",Rifle,"Handaru",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299999684, 0.899999976, 0.200000003),CFrame = CFrame.new(4.86797953, 9.56716633, -139.033096, 5.38420863e-10, 1.44063961e-09, 1, 0.939692974, -0.342020035, 4.30411262e-12, 0.342022955, 0.93970108, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Handaru,"Mesh",{Scale = Vector3.new(0.699999988, 0.800000012, 0.899999976),})
Weld = New("ManualWeld",Handaru,"Weld",{Part0 = Handaru,Part1 = RightArm,C0 = CFrame.new(0, 0, 0, 0, 0.939692974, 0.342020005, 0, -0.342020005, 0.939692974, 1, 0, 0),C1 = CFrame.new(-0.17155385, -1.13280964, 0.0381164551, -1, -0.000112917653, 0.000207058736, -0.000112889931, 1, 0.000133873371, -0.000207074263, 0.000133850204, -1.00000167),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.300000191, 0.200000003),CFrame = CFrame.new(4.86804056, 9.70005512, -138.636124, 1.32227007e-11, 1.53790924e-09, 1, 1.00000036, 0, 4.30411262e-12, 0, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(0.260647774, 0.327582359, 6.10351563e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299999744, 0.200000003, 0.200000003),CFrame = CFrame.new(4.86801004, 6.5500145, -138.486115, 1.32227007e-11, 1.53790924e-09, 1, 1.00000036, 0, 4.30411262e-12, 0, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.64811707, 1.54591751, 3.05175781e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.19999969, 0.300000012, 0.200000003),CFrame = CFrame.new(4.86801004, 9.10005951, -138.636124, 1.32227007e-11, 1.53790924e-09, 1, 1.00000036, 0, 4.30411262e-12, 0, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.303163528, 0.532794952, 3.05175781e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.0999999195, 0.200000003),CFrame = CFrame.new(4.86804056, 6.35001183, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(-2.8360548, 1.6143322, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 8.10003662, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.19156933, 1.01578903, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 8.10003662, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.19156933, 1.01578903, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 8.10003662, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-1.17448044, 1.06274033, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 8.10003662, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-1.20866871, 0.968809128, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.200000003, 0.5, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999678, 0.400000006, 0.200000003),CFrame = CFrame.new(4.86801004, 8.84343719, -138.889923, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 1, 0.899999976),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.631113052, 0.382074356, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 6.90001345, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-2.33632183, 1.37924004, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 7.5000248, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.75539589, 1.22100544, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 7.5000248, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.75539589, 1.22100544, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 7.45002079, -138.536102, -1.32226452e-11, 1.53790924e-09, -1, -1.00000036, 2.98023224e-08, -4.30411262e-12, 2.98023224e-08, 1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.81948566, 1.19112206, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(0.199999765, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 6.50001335, -138.336105, -1.32226452e-11, 1.53790924e-09, -1, -1.00000036, 2.98023224e-08, -4.30411262e-12, 2.98023224e-08, 1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.400000006, 0.600000024, 0.0500000007),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-2.64379501, 1.70398521, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999975, 0.100000001, 0.100000001),CFrame = CFrame.new(4.86801004, 8.05001831, -138.636108, 1, -1.53790924e-09, 1.32226452e-11, 4.30411262e-12, -2.98023224e-08, 1.00000036, 2.29920261e-09, -1.00000894, -2.98023224e-08),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1.00000668, 0, -1.00000668, 0, 0),C1 = CFrame.new(-1.28987503, 0.891940117, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999559, 0.200000018, 0.200000003),CFrame = CFrame.new(4.86801004, 8.30002022, -138.586105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.03784847, 0.853420258, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.100000001, 0.600000024, 0.699999988),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 9.1500349, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.153590202, 0.797625542, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 7.5000248, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-1.738307, 1.26795673, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 7.20001698, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.0373106, 1.32361412, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.25003147, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.999316216, 1.10544491, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 6.90001297, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-2.31922245, 1.42622185, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 6.90001297, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.31922245, 1.42622185, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.200000003, 0.5, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Bolt1 = New("Part",Rifle,"Bolt1",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.499999553, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 8.85004425, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Bolt1,"Mesh",{Scale = Vector3.new(1, 0.400000006, 1.04999995),})
Weld = New("ManualWeld",Bolt1,"Weld",{Part0 = Bolt1,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.486792564, 0.759271622, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 7.20001793, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-2.02022171, 1.37056446, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 7.20001698, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-2.0373106, 1.32361412, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.35003948, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.905339241, 1.07124043, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 7.5000248, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-1.77249527, 1.17402458, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 6.90001297, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-2.30213356, 1.47317219, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 7.45002079, -138.436096, -1.32226452e-11, -1.53790924e-09, 1, -1.00000036, -2.98023224e-08, 4.30411262e-12, 2.98023224e-08, -1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.78528309, 1.28509235, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 7.20001793, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-2.05440998, 1.27663231, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
BoltP2 = New("Part",Rifle,"BoltP2",{Material = Enum.Material.SmoothPlastic,Transparency = 1,Transparency = 1,Size = Vector3.new(0.0999995545, 0.200000003, 0.100000001),CFrame = CFrame.new(4.71800089, 9.05003452, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",BoltP2,"Mesh",{Offset = Vector3.new(-0.0399999991, 0, 0),Scale = Vector3.new(0.200000003, 0.200000003, 1.20000005),})
Weld = New("ManualWeld",BoltP2,"Weld",{Part0 = BoltP2,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.298863411, 0.690872192, -0.149978638, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 9.05004311, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.247550964, 0.831825256, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.9180131, 7.45002079, -138.436096, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.78528309, 1.28509235, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.330000043, 0.100000001, 0.200000018),CFrame = CFrame.new(4.86801004, 10.4435368, -138.676941, 1.44968448e-09, 5.13570408e-10, 1, 0.342020035, -0.939692914, 4.30411262e-12, 0.93970108, 0.342023075, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.34202221, 0.939699054, 0, 0.939699054, 0.342022151, 0, 0, 0, -1),C1 = CFrame.new(0.945329666, 0.0349359512, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999964, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 10.475091, -138.861252, -5.13568965e-10, 1.44968504e-09, 1, 0.939693391, 0.342019081, 4.30411262e-12, -0.342022091, 0.939701438, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.939699411, -0.342021286, 0, -0.342021257, 0.939699411, 0, 0, 0, -1),C1 = CFrame.new(0.911945343, -0.149044991, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.95003605, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.341526985, 0.866029739, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.75003719, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.529464722, 0.934432983, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.200000003),CFrame = CFrame.new(4.86804056, 9.70004368, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Sphere,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(0.311944008, 0.468552589, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.09999979, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.75003815, -138.436096, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.563667297, 0.840460777, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.0999999866, 0.200000003),CFrame = CFrame.new(4.86797953, 9.75094795, -139.391876, 5.38420808e-10, 1.44063961e-09, 1, 0.939692974, -0.342020005, 4.30411262e-12, 0.342022926, 0.93970108, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 1, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),C1 = CFrame.new(0.049990654, -0.399991989, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.399999917, 0.200000003),CFrame = CFrame.new(4.86804056, 9.50004482, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(0.124007225, 0.536956787, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.630000234, 0.100000001, 0.200000018),CFrame = CFrame.new(4.86801004, 11.1861582, -138.831116, 1.53790924e-09, -1.32226452e-11, 1, 2.98023224e-08, -1.00000036, 4.30411262e-12, 1.00000894, 2.98023224e-08, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, 1.00000668, 0, 0, 0, 0, -1),C1 = CFrame.new(1.59043694, -0.36392498, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(0.0999997631, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 9.25004292, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.100000001, 0.600000024, 0.699999988),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.0596132278, 0.763422012, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.65003014, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.623440742, 0.968637466, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999975, 0.100000016, 0.400000006),CFrame = CFrame.new(4.86801004, 8.30003548, -138.736115, 1, -1.53790924e-09, 1.32226452e-11, 4.30411262e-12, -2.98023224e-08, 1.00000036, 2.29920261e-09, -1.00000894, -2.98023224e-08),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1.00000668, 0, -1.00000668, 0, 0),C1 = CFrame.new(-1.08913803, 0.712458611, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 7.80001593, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.47349644, 1.11840248, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.199999765, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 6.50001335, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, 0),Scale = Vector3.new(0.5, 0.5, 0.100000001),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-2.64379501, 1.70398521, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.45003128, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.811378479, 1.03704071, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999975, 0.300000012, 0.300000012),CFrame = CFrame.new(4.86801004, 9.23582172, -138.853729, 1, -5.13568965e-10, 1.44968504e-09, 4.30411262e-12, 0.939693391, 0.342019081, 2.29920261e-09, -0.342022091, 0.939701438),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(0.300000012, 0.200000003, 0.600000024),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 0, -1, -0.939699411, -0.342021286, 0, -0.342021257, 0.939699411, 0),C1 = CFrame.new(-0.250016212, 0.281872749, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86797953, 7.80001593, -138.436142, 1.32226452e-11, 1, -1.53790924e-09, 1.00000036, 4.30411262e-12, -2.98023224e-08, -2.98023224e-08, 2.29920261e-09, -1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, -1, 0, -1.00000668, 0),C1 = CFrame.new(-1.45640755, 1.16535378, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.9180131, 7.80001593, -138.486099, 1.32226452e-11, -1.53790924e-09, -1, 1.00000036, -2.98023224e-08, -4.30411262e-12, -2.98023224e-08, -1.00000894, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, -1.00000668, 0, 0, 0, 1),C1 = CFrame.new(-1.47349644, 1.11840248, 0.0500335693, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.199999988, 0.200000003),CFrame = CFrame.new(4.86797953, 9.63987923, -139.379089, 1.44063961e-09, 1, 5.38420808e-10, -0.342020005, 4.30411262e-12, 0.939692974, 0.93970108, 2.29920261e-09, 0.342022926),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.800000012, 1),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0.34202221, 0.939698994, 0, 0, 0, -1, -0.939698994, 0.34202221, 0),C1 = CFrame.new(-0.0500078201, -0.349992752, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.55003834, -138.336105, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.717402458, 1.00283623, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999678, 0.200000003, 0.200000003),CFrame = CFrame.new(4.86801004, 9.20003986, -138.986115, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.200000003, 0.899999976),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.328917503, 0.169712067, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999988, 0.100000001, 0.100000001),CFrame = CFrame.new(4.81800699, 7.45002079, -138.536102, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0250000004, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-1.81948566, 1.19112206, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299999684, 0.800000012, 0.200000003),CFrame = CFrame.new(4.86797953, 9.55004978, -138.986099, 5.38420808e-10, 1.44063961e-09, 1, 0.939692974, -0.342020005, 4.30411262e-12, 0.342022926, 0.93970108, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 1, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),C1 = CFrame.new(-1.14440918e-05, 0.0500144958, 0, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999997631, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 8.85004425, -138.33609, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0.0399999991, 0),Scale = Vector3.new(0.200000003, 0.200000003, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.435488701, 0.9002285, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.49999964, 0.100000001, 0.200000003),CFrame = CFrame.new(4.86801004, 10.4500523, -138.536102, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(0.999621391, 0.165052414, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.0999999195, 0.200000003),CFrame = CFrame.new(4.86804056, 6.35001183, -138.486099, 1.53790924e-09, 1.32226452e-11, -1, 2.98023224e-08, 1.00000036, -4.30411262e-12, 1.00000894, -2.98023224e-08, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("CylinderMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 1.04999995, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(-2.8360548, 1.6143322, 6.10351563e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.19999969, 0.200000003, 0.100000001),CFrame = CFrame.new(4.86805582, 7.80001593, -138.536102, 1.32226452e-11, -1, 1.53790924e-09, 1.00000036, -4.30411262e-12, 2.98023224e-08, -2.98023224e-08, -2.29920261e-09, 1.00000894),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Offset = Vector3.new(0, -0, -0.0250000004),Scale = Vector3.new(1, 0.5, 0.5),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 0, 1, 0, 1.00000668, 0),C1 = CFrame.new(-1.49059582, 1.07142258, 7.62939453e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Mag = New("Model",Rifle,"Mag",{})
MagPart = New("Part",Mag,"MagPart",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999678, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.80870724, -139.086884, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",MagPart,"Mesh",{Scale = Vector3.new(0.899999976, 1, 0.699999988),})
Weld = New("ManualWeld",MagPart,"Weld",{Part0 = MagPart,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.731114388, 0.208864212, 3.05175781e-05, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.95642948, -139.11293, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(0.150000572, 1.43051147e-06, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.85794735, -139.095566, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(0.0499992371, 1.43051147e-06, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.75946617, -139.078201, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.0500011444, 1.43051147e-06, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Mag,"Part",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999996886, 1.00000012, 0.200000003),CFrame = CFrame.new(4.86801004, 8.66098499, -139.060837, -2.54032906e-10, 1.51684099e-09, 1, 0.984808087, 0.17364797, 4.30411262e-12, -0.17364952, 0.984816551, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 0.899999976, 0.800000012),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = MagPart,C0 = CFrame.new(0, 0, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),C1 = CFrame.new(-0.150001526, 9.53674316e-07, 0, -0.984814465, -0.173649132, 0, -0.173649132, 0.984814465, 0, 0, 0, -1),})
Part = New("Part",Rifle,"Part",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.499999553, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 8.85004425, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.949999988, 0.349999994, 1.02499998),})
Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.486792564, 0.759271622, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
MuzzleFlash = New("Part",Rifle,"MuzzleFlash",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.100000001, 0.100000001, 0.100000001),CFrame = CFrame.new(4.86804056, 6.25002193, -138.486115, 1.53790924e-09, 1.32227007e-11, -1, 0, 1.00000036, -4.30411262e-12, 1.00000894, 0, -2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Weld = New("ManualWeld",MuzzleFlash,"Weld",{Part0 = MuzzleFlash,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, 0, 1.00000668, 0, -1.00000668, 0, 0, 0, 0, 1),C1 = CFrame.new(-2.93001747, 1.64852142, 6.10351563e-05, -0.939698994, 0.34202221, 0, 0.34202221, 0.939698994, 0, 0, 0, -1),})
BoltP1 = New("Part",Rifle,"BoltP1",{Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999995545, 0.200000003, 0.100000001),CFrame = CFrame.new(4.71800089, 8.65003014, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",BoltP1,"Mesh",{Offset = Vector3.new(-0.0399999991, 0, 0),Scale = Vector3.new(0.200000003, 0.200000003, 1.20000005),})
Weld = New("ManualWeld",BoltP1,"Weld",{Part0 = BoltP1,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.674744606, 0.827680588, -0.149978638, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Bolt2 = New("Part",Rifle,"Bolt2",{Material = Enum.Material.SmoothPlastic,Transparency = 1,Transparency = 1,Size = Vector3.new(0.0999995619, 0.200000003, 0.100000001),CFrame = CFrame.new(4.81800699, 9.05004692, -138.486099, 1.32226452e-11, 1.53790924e-09, 1, 1.00000036, 2.98023224e-08, 4.30411262e-12, -2.98023224e-08, 1.00000894, 2.29920261e-09),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("BlockMesh",Bolt2,"Mesh",{Scale = Vector3.new(1, 0.400000006, 1.04999995),})
Weld = New("ManualWeld",Bolt2,"Weld",{Part0 = Bolt2,Part1 = Handaru,C0 = CFrame.new(0, 0, 0, -1.00000668, 0, 0, 0, 1.00000668, 0, 0, 0, -1),C1 = CFrame.new(-0.298851967, 0.690867424, -0.0499725342, -0.939698994, 0.34202224, 0, 0.34202224, 0.939698994, 0, 0, 0, -1),})
Rifle.Parent = nil

coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		for _, c in pairs(WeaponPenis:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = Color3.fromRGB(math.random(0,255),0,0)
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				c.Color = Color3.fromRGB(math.random(0,255),0,0)
				c.Material = "Neon"
			end
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		for _, c in pairs(Mag:GetDescendants()) do
			if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
				c.Material = "Glass"
				c.Color = Color3.fromRGB(math.random(0,255),0,0)
			elseif c.ClassName == "Part" and c.Name == "Eye" then
				c.Color = Color3.fromRGB(math.random(0,255),0,0)
				c.Material = "Neon"
			end
		end
	end
end))

local run = game:GetService("RunService")
local rs = run.RenderStepped

function rswait(value)
	if value ~= nil and value ~= 0 then
		for i = 1, value do
			rs:wait()
		end
	else
		rs:wait()
	end
end

local PlayerSize = 1
local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//


function mainIntro()
	for i = 0, 4, 0.1 do
		Swait()
		RightHip.C0 = Clerp(RightHip.C0, CF(1,-0.15,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-15),RAD(-20)),.1)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.1)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0,0.25,-0.05) * ANGLES(RAD(-20),RAD(0),RAD(30)),.1)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-30)),.1)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45,0.8,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(30)),.8)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-5),RAD(10),RAD(-20)),.1)
	end
	CreateSound(824687369, Torso, 10, 0.9, false)
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(150,5,150), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(160,10,160), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 1, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(170,5,170), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(180,10,180), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 3, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	CreateSound(363808674, Torso, 10, 1, false)
	for i=0, 1.2, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0 + 0.35 * math.cos(SINE / 2)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(5), math.rad(25), math.rad(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.25, 0.5, -0.5) * CFrame.Angles(math.rad(100), math.rad(0), math.rad(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.25, 0.35, -0.35) * CFrame.Angles(math.rad(70), math.rad(0), math.rad(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / Animation_Speed)
	end
	CreateSound(363808674, Torso, 10, 1, false)
	for i=0, 1.2, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0 + 0.35 * math.cos(SINE / 2)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(5), math.rad(-25), math.rad(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.25, 0.5, -0.5) * CFrame.Angles(math.rad(100), math.rad(0), math.rad(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.25, 0.35, -0.35) * CFrame.Angles(math.rad(70), math.rad(0), math.rad(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / Animation_Speed)
	end
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 60, EffectType = "Sphere", Size = Vector3.new(0.5,0.55,0.5), Size2 = Vector3.new(0.5,4,0.5), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CFrame.new(0.4, 0.2, -0.8), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 0, 0), SoundID = 743521450, SoundPitch = 1.15, SoundVolume = 6})
	WACKYEFFECT({Time = 60, EffectType = "Sphere", Size = Vector3.new(0.55,0.5,0.5), Size2 = Vector3.new(4,0.5,0.5), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CFrame.new(0.4, 0.2, -0.8), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 0, 0), SoundID = 743521450, SoundPitch = 0.95, SoundVolume = 6})
	ShakeCam(10,50)
	WACKYEFFECT({Time = 55, EffectType = "Skull", Size = VT(11,11,11), Size2 = VT(99,99,99), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0, 0, 0), MoveToPos = nil, RotationX = 30, RotationY = 30, RotationZ = 30, Material = "Neon", Color = Color3.new(255/255, 0/255, 0/255), SoundID = 743521450, SoundPitch = 0.95, SoundVolume = 6})
end

-- Here Are Modes --

function kicksher() 
	ATTACK = true
	Rooted = true
	mainIntro()
	MODE = "kicksher"
	sick.SoundId = "rbxassetid://365812441"
	sick.Volume = 10
	sick.PlaybackSpeed = 0.8
	sick.TimePosition = 0
	ATTACK = false
	Rooted = false
	lightning.Enabled = false
	eeeffecto.Enabled = false
	lightningArm.Enabled = false
	refec.Enabled = false
	Rifle.Parent = nil
	BanishGun.Parent = nil
	SniperGun.Parent = Character hatsniper.Parent = Sniper.RightArm:WaitForChild'REF'
	hatsniper.Position = Vector3.new(0, -1.8, -0.8)
	hatsniper.Rotation = Vector3.new(-45, 90, 0)
	Katana.Parent = nil
end

function sit()
	ATTACK = true
	Rooted = true
	local LOOP = true
	KEY = Mouse.KeyDown:connect(function(NEWKEY)
		if NEWKEY == "t" then
			KEY:Disconnect()
			LOOP = false
		end
	end)
	repeat
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -1.70) * ANGLES(RAD(-40), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.3, 0.10) * ANGLES(RAD(-40), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.3, 0.10) * ANGLES(RAD(-40), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(45), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until LOOP == false
	ATTACK = false
	Rooted = false
end


local ULTTAUNTS = {
	"907332997",
	"907332670",
	"907330103"
}

function Penumbric_DeathRayKARMA()
	ATTACK = true
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 15
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0, 4000000, 0)
	repeat
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail3(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				AOETime2(POS,55)
			end
		end
		AOETime2(POS,8)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			Humanoid.CameraOffset = VT(MRANDOM(-50,50)/2.5,MRANDOM(-50,50)/2.5,MRANDOM(-50,50)/2.5)/30
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		WACKYEFFECT6({Time = 25, EffectType = "Box", Size = VT(2,0,2), Size2 = VT(6,7.5,6)/2, Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = RightArm.CFrame*CF(0,0,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT6({Time = 25, EffectType = "Box", Size = VT(2,0,2), Size2 = VT(6,6.5,6)/2, Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = 231917744, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 5})
		WACKYEFFECT6({Time = 25, EffectType = "Box", Size = VT(3,0,3), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT6({Time = 25, EffectType = "Box", Size = VT(3,0,3), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT6({Time = 25, EffectType = "Round Slash", Size = VT(1,0,1)/74, Size2 = VT(4,4.5,4)/74, Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 12, SizeBoomerang = 45})
		WACKYEFFECT6({Time = 25, EffectType = "Round Slash", Size = VT(1,0,1)/74, Size2 = VT(4,4.5,4)/74, Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 12, SizeBoomerang = 45})
	until KEYHOLD == false
	Humanoid.CameraOffset = VT(0,0,0)
	GYRO:remove()	
	ATTACK = false
end

function Karma_Beam()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
		local val = MRANDOM(1,255)
		local HIT2,POS2 = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail2(RightArm.Position,POS2)
		if HIT2 ~= nil then
			if HIT2.Parent ~= workspace and HIT2.Parent.ClassName ~= "Folder" then
				Banish(HIT2.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = 340722848, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS2,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS2,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		Humanoid.CameraOffset = VT(MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5)/30
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Beam()
	ATTACK = true
	Rooted = false
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 20
	GYRO.P = 4000
	GYRO.MaxTorque = VT(0, 40000, 0)
	local RING, MESH, DELET = MakeRing()
	local POS = RootPart.Position + VT(0, 25, 0)
	RING.CFrame = CFrame.new(POS, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0))
	CreateSound(459523787, RING, 8, 1, false)
	local BLASTS = {468991944, 468991990}
	coroutine.resume(coroutine.create(function()
		local E = 0
		repeat
			E = E + 5
			GYRO.CFrame = CFrame.new(RootPart.Position, Mouse.Hit.p)
			Swait()
			RING.CFrame = CFrame.new(POS, Mouse.Hit.p) * ANGLES(RAD(90), RAD(E), RAD(0))
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.45 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(90)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-90)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0 - 7.5 * SIN(SINE / 12)), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.15 * COS(SINE / 12), -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5 + 0.25 * COS(SINE / 12), -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until ATTACK == false
		GYRO:remove()
		DELET()
	end))
	for i = 1, 50 do
		Swait()
		MESH.Scale = MESH.Scale + VT(22, 0, 22)
	end
	for i = 1, 25 do
		Swait()
		WACKYEFFECT5({
			Time = 15,
			EffectType = "Sphere",
			Size = Vector3.new(4, 4, 4),
			Size2 = Vector3.new(0, 0, 0),
			Transparency = 1,
			Transparency2 = 0,
			CFrame = CFrame.new(RING.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CFrame.new(0, 0, 35),
			MoveToPos = RING.Position,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = BrickColor.Random().Color,
			SoundID = nil,
			SoundPitch = nil,
			SoundVolume = nil
		})
	end
	local LOOP = 0
	local BEAM = CreatePart(3, Effects, "Neon", 0, 0, BrickColor.Random().Color, "Beam", VT(0, 0, 0), true)
	MakeForm(BEAM, "Cyl")
	CreateSound(BLASTS[MRANDOM(1, #BLASTS)], RING, 5, MRANDOM(9, 11) / 10, false)
	repeat
		local DISTANCE = (RING.Position - Mouse.Hit.p).Magnitude
		if DISTANCE < 2000 then
			BEAM.Size = VT(10 + 2 * COS(SINE / 4), DISTANCE, 10 + 2 * COS(SINE / 4))
			BEAM.CFrame = CFrame.new(RING.Position, Mouse.Hit.p) * CF(0, 0, -DISTANCE / 2) * ANGLES(RAD(90), RAD(0), RAD(0))
			ApplyAoE5(Mouse.Hit.p,3,5,1000,0,false)
			WACKYEFFECT5({
				Time = 35,
				EffectType = "Sphere",
				Size = Vector3.new(10 + 2 * COS(SINE / 4), 10 + 2 * COS(SINE / 4), 10 + 2 * COS(SINE / 4)) * 2,
				Size2 = Vector3.new(5, 75, 5),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = CFrame.new(Mouse.Hit.p) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = BrickColor.Random().Color,
				SoundID = 2918050487,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10
			})
			Swait()
			LOOP = LOOP + 1
		end
	until KEYHOLD == false and LOOP >= 35 or DISTANCE >= 2000
	coroutine.resume(coroutine.create(function()
		for i = 1, 15 do
			Swait()
			BEAM.Size = BEAM.Size - Vector3.new(0.2, 0, 0.2)
			BEAM.Transparency = BEAM.Transparency + 0.06666666666666667
		end
		BEAM:remove()
	end))
	ATTACK = false
	Rooted = false
end

function Absoluteum2()
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position + Vector3.new(0, -1, 0))).lookVector, 25*SIZE, Character)
	Swait(7.5)
	ApplyAoE(HITPOS,10,5,10,20,false)
	WACKYEFFECT({Time = 10, EffectType = "Wave", Size = Vector3.new(0.45,0.11,0.45)*SIZE, Size2 = Vector3.new(12,3,12), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = Color3.new(159/255, 0/255, 0/255), SoundID = 743521450, SoundPitch = 1, SoundVolume = 10})
	bosschatfunc("Look's like It's time to DIE!",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
	for i = 1, 45 do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.75, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.25, -0.5) * ANGLES(RAD(90), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	wait(0.1)
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position + Vector3.new(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		do
			local HITBODIES = {}
			ATTACK = true
			Rooted = true
			local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "ABSOLUTEUM", Vector3.new(0, 0, 0))
			MakeForm(ABSOLUTE, "Ball")
			CreateSound("416200578", RootPart, 10, 1)
			for i = 0, 18, 0.1 / Animation_Speed do
				Swait()
				ABSOLUTE.Size = ABSOLUTE.Size + Vector3.new(0.9, 0.9, 0.9)
				ABSOLUTE.CFrame = RootPart.CFrame * CFrame.new(0, 5 + ABSOLUTE.Size.Y / 2, 0)
				ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
				local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "Really black ", "ABSOLUTEUM", Vector3.new(9, 9,9))
				MakeForm(CHARGE, "Ball")
				CHARGE.CFrame = CFrame.new(RootPart.Position) * CFrame.new(MRANDOM(-50, 50), -50, MRANDOM(-50, 50))
				FireArc(CHARGE, ABSOLUTE.Position, 85, 85, true)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
			CreateSound(ULTTAUNTS[MRANDOM(1, #ULTTAUNTS)], Head, 10, 0.9)
			CreateSound("160772554", ABSOLUTE, 10, MRANDOM(5, 7) / 10)
			for i = 1, 75 do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				local IMPACT = false
				local BULLET = ABSOLUTE
				MakeForm(BULLET, "Ball")
				BULLET.CFrame = CFrame.new(BULLET.Position, Mouse.Hit.p)
				for i = 1, 500 do
					Swait()
					BULLET.CFrame = BULLET.CFrame * CFrame.new(0, 0, -2)
					local HIT = Raycast(BULLET.Position, BULLET.CFrame.lookVector, BULLET.Size.X / 2, Character)
					MagicSphere(Vector3.new(30, 30, 30), 55, CFrame.new(BULLET.CFrame * CFrame.new(MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5), MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5), MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5)).p), "Really black", Vector3.new(-10, -10, -10) / 55)
					if HIT ~= nil then
						IMPACT = true
						break
					end
				end
				if IMPACT == false then
					for i = 1, 60 do
						Swait()
						BULLET.Size = BULLET.Size * 0.9
					end
					BULLET:remove()
				else
					CreateSound("424276023", BULLET, 10, MRANDOM(8, 13) / 10)
					for i = 1, 195 do
						Swait()
						BULLET.Size = BULLET.Size * 0.99
						Slice2("Round", 0, 35, CFrame.new(BULLET.Position) * CFrame.Angles(math.rad(MRANDOM(-18, 18)), math.rad(MRANDOM(-180, 180)), math.rad(MRANDOM(-18, 18))), "Really red", Vector3.new(i, 0, i) / 85)
					end
					CreateSound("438666001", BULLET, 10, 3)
					Swait(35)
					BULLET.Transparency = 1
					for i = 1, 30 do
						for e = 1, 5 do
							MagicSphere(Vector3.new(0.5, 0.5, 0.5), 50, CFrame.new(BULLET.CFrame * CFrame.new(MRANDOM(-5, 5), MRANDOM(-5, 5), MRANDOM(-5, 5)).p, BULLET.Position), "Really black", Vector3.new(1, 1, i * 4), 0)
							Slice2("Round", 0, 35, CFrame.new(BULLET.Position) * CFrame.Angles(math.rad(MRANDOM(-18, 18)), math.rad(MRANDOM(-180, 180)), math.rad(MRANDOM(-18, 18))), "Really red", Vector3.new(i, 0, i) / 3)
						end
						AddChildrenToTable(BULLET.Position, workspace, i * 25, HITBODIES)
						CreateSound("178452241", BULLET, 10, MRANDOM(8, 13) / 10)
						CreateSound("178452243", BULLET, 10, MRANDOM(8, 13) / 10)
						CreateSound("1259054947", BULLET, 10, MRANDOM(8, 13) / 10)
						MagicSphere(BULLET.Size, 35, BULLET.CFrame, Color3.new(MRANDOM(0, 10) / 10, 0, 0), Vector3.new(i, i, i) * 2)
						Swait(5)
						for e = 1, #HITBODIES do
							if HITBODIES[e] ~= nil then
								local BOD = HITBODIES[e]
								local TORS = BOD:FindFirstChild("Torso") or BOD:FindFirstChild("UpperTorso")
								if TORS then
									BOD:BreakJoints()
									for _, c in pairs(BOD:GetChildren()) do
										if c.ClassName == "Part" or c.ClassName == "MeshPart" then
											local bv = Instance.new("BodyVelocity")
											bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
											bv.velocity = CFrame.new(BULLET.Position, c.Position).lookVector * 250
											bv.Parent = c
											Debris:AddItem(bv, 0.2)
										end
									end
								end
							end
						end
						CreateWave(Vector3.new(0, 2, 0), 75, CFrame.new(BULLET.Position), true, -15, "Really black", Vector3.new(i, 0, i) * 2)
					end
					MagicSphere(BULLET.Size, 100, BULLET.CFrame, Color3.new(0, 0, 0), Vector3.new(12, 12, 12))
					Debris:AddItem(BULLET, 10)
				end
			end))
			ATTACK = false
			Rooted = false
		end
	end
end


function MagicSphere4(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	wave.Color = COLOR
	local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0,0,0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateSwirl3(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
	wave.Color = COLOR
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function killnearest3(position,range,maxstrength)
	for i,v in ipairs(workspace:GetChildren()) do
		local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						v:BreakJoints()
					end
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = CF(position,body[part].Position).lookVector*maxstrength
					bv.Parent = body[part]
					Debris:AddItem(bv,0.2)
				end
			end
		end
		if v.ClassName == "Part" then
			if v.Anchored == false and (v.Position - position).Magnitude < range then
				v.Velocity = CFrame.new(position,v.Position).lookVector*5*maxstrength
			end
		end
	end
end

function Slice3(KIND,SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = nil
	if KIND == "Base" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
	elseif KIND == "Thin" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
	elseif KIND == "Round" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW/10
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function Ruler()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		do
			local HITBODIES = {}
			ATTACK = true
			Rooted = true
			local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Really black", "SuperNova", VT(0, 0, 0))
			ABSOLUTE.Color = C3(1,1,1)
			MakeForm(ABSOLUTE, "Ball")
			CreateSound("814168787", ABSOLUTE, 10, 0.3)
			for i = 0, 4, 0.1 / Animation_Speed do
				Swait()
				ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2, 0.2, 0.2)
				ABSOLUTE.CFrame = RootPart.CFrame * CF(0, 5 + ABSOLUTE.Size.Y / 2, 0)
				ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
				local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "White", "Star", VT(1, 1, 1))
				MakeForm(CHARGE, "Ball")
				CHARGE.Color = C3(0, 0, 0)
				CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15, 15), -6, MRANDOM(-15, 15))
				FireArc(CHARGE, ABSOLUTE.Position, 45, 45, true)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			CreateSound("907329293", Head, 10, 1)
			bosschatfunc("I Will Direct this Personally.",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
			for i = 0, 2, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				local PITS = {}
				CreateSound("178452217", ABSOLUTE, 10, 0.7)
				for i = 1, 6 do
					for i = 1, 10 do
						Swait()
						Slice2("Thin", ABSOLUTE.Size.X / 20, 15, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
						ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					end
					for i = 1, 10 do
						Swait()
						ABSOLUTE.Size = ABSOLUTE.Size * 1.12
					end
				end
				CreateSound("215395388", ABSOLUTE, 10, 0.6)
				CreateSound("215395388", ABSOLUTE, 10, 0.65)
				CreateSound("215395388", ABSOLUTE, 10, 0.7)
				for i = 1, 75 do
					Swait()
					local ICICLE = IT("CornerWedgePart", Effects)
					ICICLE.Locked = true
					ICICLE.CanCollide = false
					ICICLE.Anchored = true
					ICICLE.Color = C3(0, 0, 0)
					ICICLE.Material = "Neon"
					ICICLE.Size = VT(i / 3, i * 2, i / 3)
					ICICLE.CFrame = CF(HITPOS) * CF(MRANDOM(-ABSOLUTE.Size.X, ABSOLUTE.Size.X), 0, MRANDOM(-ABSOLUTE.Size.X / 1.5, ABSOLUTE.Size.X / 1.5)) * ANGLES(RAD(MRANDOM(-25, 25)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-25, 25)))
					table.insert(PITS, ICICLE)
					killnearest3(ICICLE.Position, ICICLE.Size.Y / 1.5, -100)
					ABSOLUTE.Size = ABSOLUTE.Size * 1.03
					killnearest3(ABSOLUTE.Position, ABSOLUTE.Size.X / 1.9, -100)
					for i = 1, 3 do
						Slice2("Thin", ABSOLUTE.Size.X / 20, 5, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
					end
					CreateWave(VT(ABSOLUTE.Size.X / 1.5, 35, ABSOLUTE.Size.X / 1.5), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5), RAD(0)), false, 0, C3(0, 0, 0), VT(i / 3, 0, i / 3))
				end
				ABSOLUTE.Transparency = 0
				for i = 1, 10 do
					Swait()
					ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					ABSOLUTE.Transparency = ABSOLUTE.Transparency + 0.1
				end
				Debris:AddItem(ABSOLUTE, 5)
				Swait(50)
				for i = 1, 10 do
					Swait()
					for e = 1, #PITS do
						if PITS[e] ~= nil then
							local E = PITS[e]
							E.Transparency = E.Transparency + 0.1
						end
					end
				end
				for e = 1, #PITS do
					if PITS[e] ~= nil then
						local E = PITS[e]
						E:remove()
					end
				end
			end))
			ATTACK = false
			Rooted = false
		end
	end
end

function SubmitNow()
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		local HITBODIES = {}
		ATTACK = true
		Rooted = true
		local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "really Red", "Star", VT(0,0,0))
		MakeForm(ABSOLUTE,"Ball")
		CreateSound("429459101", ABSOLUTE, 10, 1)
		for i=0, 4, 0.1 / Animation_Speed do
			Swait()
			ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2,0.2,0.2)
			ABSOLUTE.CFrame = RootPart.CFrame*CF(0,5+(ABSOLUTE.Size.Y/2),0)
			ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
			local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "really Black", "Star", VT(1,1,1))
			MakeForm(CHARGE,"Ball")
			CHARGE.Color = C3(1,1,1)
			CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15,15),-6,MRANDOM(-15,15))
			FireArc(CHARGE,ABSOLUTE.Position,45,45,true)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.3, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.8 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(24 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, 0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound("289315275", Head, 10, 1)
		wait(2.6)
		CreateSound("1547220953", Head, 10, 1.2)
		bosschatfunc("HAHAHAHA!!!",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
		for i = 1, 75 do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5 + 4.5 * SIN(SINE / 90)), RAD(10), RAD(0 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.9 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(10 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, 0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		coroutine.resume(coroutine.create(function()
			for i = 1, 13 do
				for e = 1, 8 do
					Swait()
					MagicSphere4(VT(1,1,1),15,CF(ABSOLUTE.Position)*CF(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45)),C3(1,1,1),VT(0,0,0))
					CreateSwirl3(ABSOLUTE.Size/2,15,CF(HITPOS),true,15,BRICKC"really Red".Color,VT(i,0.3,i)*2)
				end
				for i = 1, 5 do
					Slice3("Round",0,35,CF(ABSOLUTE.Position)*ANGLES(RAD(MRANDOM(-18,18)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-18,18))),C3(1,1,1),VT(i,0,i)/3)
					Slice3("Thin",i,55,ABSOLUTE.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),C3(255,255,0),VT(0,0,0))
				end
				CreateSwirl3(ABSOLUTE.Size/2,25,CF(ABSOLUTE.Position),true,-25,BRICKC"Really red".Color,VT(i,i*2,i))
				CreateSwirl3(ABSOLUTE.Size/2,55,CF(ABSOLUTE.Position),true,25,C3(0.05,0.05,0.15),VT(i,i*2,i))
				CreateSound("168586621", ABSOLUTE, 4, 0.8)
				CreateSound("201858144", ABSOLUTE, 10, 0.8)
				killnearest3(ABSOLUTE.Position,i*18,i)
				ABSOLUTE.Size = ABSOLUTE.Size*0.9
				MagicSphere4(ABSOLUTE.Size,25,CF(ABSOLUTE.Position),BRICKC"Really red".Color,VT(i,i,i)/1.1)
				MagicSphere4(ABSOLUTE.Size,45,CF(ABSOLUTE.Position),C3(0.05,0.05,0.15),VT(i,i,i))
			end
			ABSOLUTE.Transparency = 1
			Debris:AddItem(ABSOLUTE,10)
		end))
		ATTACK = false
		Rooted = false
	end
end

function Supernova_Grenade() 
	local TAUNTS = {907329532,907330011,907331307,907331307,907331443,907331784,907331575,907332040,907332235,907332525,907332670,907332856,907332997,907333294,907333406,907329669,907329293, 907331038}
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position + Vector3.new(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		do
			local HITBODIES = {}
			ATTACK = true
			Rooted = true
			local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Really black", "ABSOLUTEUM", Vector3.new(0, 0, 0))
			MakeForm(ABSOLUTE, "Ball")
			CreateSound("416200578", RootPart, 10, 1)
			for i = 0, 8, 0.1 / Animation_Speed do
				Swait()
				ABSOLUTE.Size = ABSOLUTE.Size + Vector3.new(0.2, 0.2, 0.2)
				ABSOLUTE.CFrame = RootPart.CFrame * CFrame.new(0, 5 + ABSOLUTE.Size.Y / 2, 0)
				ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
				local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "ABSOLUTEUM", Vector3.new(0,0,0))
				MakeForm(CHARGE, "Ball")
				CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15, 15), -15, MRANDOM(-15, 15))
				FireArc(CHARGE, ABSOLUTE.Position, 45, 45, true)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			CreateSound(TAUNTS[MRANDOM(1, #TAUNTS)], Head, 10, 0.9)
			for i = 1, 45 do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				local IMPACT = false
				local BULLET = ABSOLUTE
				MakeForm(BULLET, "Ball")
				BULLET.CFrame = CFrame.new(BULLET.Position, Mouse.Hit.p)
				for i = 1, 500 do
					Swait()
					BULLET.CFrame = BULLET.CFrame * CFrame.new(0, 0, -2)
					local HIT = Raycast(BULLET.Position, BULLET.CFrame.lookVector, BULLET.Size.X / 2, Character)
					MagicSphere(Vector3.new(10, 10, 10), 55, CFrame.new(BULLET.CFrame * CFrame.new(MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5), MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5), MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5)).p), "Really red", Vector3.new(-10, -10, -10) / 55)
					if HIT ~= nil then
						IMPACT = true
						break
					end
				end
				if IMPACT == false then
					for i = 1, 40 do
						Swait()
						BULLET.Size = BULLET.Size * 0.9
					end
					BULLET:remove()
				else
					CreateSound("1127492102", BULLET, 10, MRANDOM(8, 13) / 10)
					for i = 1, 175 do
						Swait()
						BULLET.Size = BULLET.Size * 0.99
						Sloice("Round", 0, 35, CFrame.new(BULLET.Position) * ANGLES(math.rad(MRANDOM(-18, 18)), math.rad(MRANDOM(-180, 180)), math.rad(MRANDOM(-18, 18))), "Really red", Vector3.new(i, 0, i) / 85)
					end
					CreateSound("438666001", BULLET, 10, 3)
					Swait(35)
					BULLET.Transparency = 1
					for i = 1, 20 do
						for e = 1, 5 do
							MagicSphere(Vector3.new(0.2, 0.2, 0.2), 50, CFrame.new(BULLET.CFrame * CFrame.new(MRANDOM(-5, 5), MRANDOM(-5, 5), MRANDOM(-5, 5)).p, BULLET.Position), "Really red", Vector3.new(1, 1, i * 4), 0)
							Sloice("Round", 0, 35, CFrame.new(BULLET.Position) * ANGLES(math.rad(MRANDOM(-18, 18)), math.rad(MRANDOM(-180, 180)), math.rad(MRANDOM(-18, 18))), "Really red", Vector3.new(i, 0, i) / 3)
						end
						--AddChildrenToTable(BULLET.Position, workspace, i * 25, HITBODIES)
						CreateSound("178452241", BULLET, 10, MRANDOM(8, 13) / 10)
						CreateSound("178452243", BULLET, 10, MRANDOM(8, 13) / 10)
						MagicSphere(BULLET.Size, 35, BULLET.CFrame, Color3.new(0, 0, 0), Vector3.new(i, i, i) * 2)
						Swait(5)
						for e = 1, #HITBODIES do
							if HITBODIES[e] ~= nil then
								local BOD = HITBODIES[e]
								local TORS = BOD:FindFirstChild("Torso") or BOD:FindFirstChild("UpperTorso")
								if TORS then
									--Kill(BOD)
									for _, c in pairs(BOD:GetChildren()) do
										if c.ClassName == "Part" or c.ClassName == "MeshPart" then
											--[[local bv = Instance.new("BodyVelocity")
											bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
											bv.velocity = CFrame.new(BULLET.Position, c.Position).lookVector * 250
											bv.Parent = c
											Debris:AddItem(bv, 0.2)----]]
										end
									end
								end
							end
						end
						CreateWave(Vector3.new(0, 2, 0), 75, CFrame.new(BULLET.Position), true, -15, "Really red", Vector3.new(i, 0, i) * 2)
					end
					MagicSphere(BULLET.Size, 100, BULLET.CFrame, Color3.new(0, 0, 0), Vector3.new(12, 12, 12))
					Debris:AddItem(BULLET, 10)
				end
			end))
			ATTACK = false
			Rooted = false
		end
	end
end

function Fallen_Star()
	ATTACK = true
	Rooted = true
	CreateSound(TAUNTS[MRANDOM(1,#TAUNTS)], Torso, 7, 1, false)
	coroutine.resume(coroutine.create(function()
		local POS = Mouse.Hit.p
		local RAY = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Strike", Vector3.new(0,2000,0))
		MakeForm(RAY,"Cyl")
		local SPHERE = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Strike", Vector3.new(0,0,0))
		MakeForm(SPHERE,"Ball")
		local SHIELD = CreatePart(3, Effects, "Neon", 0, 0.5, "Really black", "Strike", Vector3.new(0,0,0))
		MakeForm(SHIELD,"Ball")
		SHIELD.CFrame = CF(POS)
		RAY.CFrame = CF(POS)
		SPHERE.CFrame = CF(POS)
		CreateSound(440145570, SPHERE, 10, 0.8, false)
		CreateSound(415700134, SPHERE, 10, 0.8, false)
		for i = 1, 200 do
			Swait()
			WACKYEFFECT({Time = 15, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(SPHERE.Size.X*1.2,5+(i),SPHERE.Size.X*1.2), Transparency = 0, Transparency2 = 1, CFrame = SPHERE.CFrame*ANGLES(math.rad(0), math.rad(i), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = i, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RAY.Size = RAY.Size + Vector3.new(0.05,0,0.05)
			SPHERE.Size = SPHERE.Size + Vector3.new(2,2,2)
			SHIELD.Size = SPHERE.Size + Vector3.new(3,3,3)
			ApplyAoE(SPHERE.Position,SPHERE.Size.X/2,true)
		end	
		for i = 1, 45 do
			Swait()
			RAY.Transparency = RAY.Transparency + 1/45
			SPHERE.Transparency = RAY.Transparency 
			SHIELD.Transparency = SPHERE.Transparency + 1/45
		end
		RAY:remove()
		SHIELD:remove()
		SPHERE:remove()
	end))	
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
	end		
	ATTACK = false
	Rooted = false
end


function Lightning(Part0, Part1, Times, Offset, Color, Timer, sSize, eSize, Trans, Boomer, sBoomer, slow, stime)
	local magz = (Part0 - Part1).magnitude
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1, Times do
		local li = Instance.new("Part", Effects)
		li.Name = "Lightning"
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.BrickColor = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(0.1, 0.1, magz / Times)
		local Offzet = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
		local trolpos = CFrame.new(curpos, Part1) * CFrame.new(0, 0, magz / Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).magnitude
			li.Size = Vector3.new(0.1, 0.1, magz2)
			li.CFrame = CFrame.new(curpos, Part1) * CFrame.new(0, 0, -magz2 / 2)
		else
			li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / Times / 2)
		end
		curpos = li.CFrame * CFrame.new(0, 0, magz / Times / 2).p
		li:Destroy()
		WACKYEFFECTpp({Time = Timer, EffectType = "Box", Size = Vector3.new(sSize,sSize,li.Size.Z), Size2 = Vector3.new(eSize,eSize,li.Size.Z), Transparency = Trans, Transparency2 = 1, CFrame = li.CFrame, MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = li.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = Boomer, Boomerang = 0, SizeBoomerang = sBoomer})
		if slow == true then
			swait(stime)
		end
	end
end

function HandBeam()
	ATTACK = true
	for i = 0, 0.5, 0.05 do
		swait()
		turnto(Mouse.Hit.Position)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(30)), 1 / 3)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(-30)), 1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(30)) * RIGHTSHOULDERC0, 1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)) * LEFTSHOULDERC0, 1 / 3)
		RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-5), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	ApplyAoEpp(Mouse.Hit.Position,10)
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = 642890855, SoundPitch = 0.45, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	Lightning(RightArm.Position,Mouse.Hit.p,15,3.5,BrickColor.new("Really black"),math.random(15,35),1,3,0,true,55) Lightning(RightArm.Position,Mouse.Hit.p,15,3.5,BrickColor.new("Really red"),math.random(15,35),1,3,0,true,55)
	for i = 0, 2 do
		WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
	end
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = 192410089, SoundPitch = .55, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	for i = 0, 2 do
		WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
	end
	for i = 0, 0.5, 0.075 do
		swait()
		turnto(Mouse.Hit.Position)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(60)), 1 / 3)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-60)), 1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(160), math.rad(-20), math.rad(60)) * RIGHTSHOULDERC0, 1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(5), math.rad(5)) * LEFTSHOULDERC0, 1 / 3)
		RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-5), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-65), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	ATTACK = false
end

function lcmurder()
	for i = 0,8,0.1 do
		Swait()
		Humanoid.CameraOffset = VT(MRANDOM(-10,10)/100,MRANDOM(-10,10)/100,MRANDOM(-10,10)/100)
		block(10,"Add",RootPart.CFrame*CFrame.new(0,25,0),VT(0,0,0),0.5,0.5,0.5,BrickColor.random(),BrickColor.random().Color)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-35 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 1,350 do
		Swait()
		WACKYEFFECT2({
			Time = 75 - i * 4,
			EffectType = "Box",
			Size = Vector3.new(0, 0, 0),
			Size2 = Vector3.new(5, 5, 5) + Vector3.new(i, i, i) * 100,
			Transparency = 0,
			Transparency2 = 1,
			CFrame = CF(RootPart.Position) * CFrame.Angles(math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360)), math.rad(MRANDOM(0, 360))),
			MoveToPos = nil,
			RotationX = 360,
			RotationY = 360,
			RotationZ = 360,
			Material = "Neon",
			Color = Color3.new(0,0,0),
			SoundID = 231917744,
			SoundPitch = MRANDOM(8, 20) / 10,
			SoundVolume = 3,
			UseBoomerangMath = true,
			Boomerang = 25,
			SizeBoomerang = 100
		})
		ApplyAoE(RootPart.Position,SIZE/19999,true)
		WACKYEFFECT({EffectType = "Wave", Size = Vector3.new(0,5,0), Size2 = Vector3.new(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CFrame.new(RootPart.Position) * CFrame.Angles(math.rad(0), math.rad(MRANDOM(0,360)), math.rad(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Slate", Color = Color3.new(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT({EffectType = "Sphere", Size = Vector3.new(0,5,0), Size2 = Vector3.new(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CFrame.new(RootPart.Position) * CFrame.Angles(math.rad(0), math.rad(MRANDOM(0,360)), math.rad(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = Color3.new(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT({EffectType = "Slash", Size = Vector3.new(0,5,0), Size2 = Vector3.new(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CFrame.new(RootPart.Position) * CFrame.Angles(math.rad(0), math.rad(MRANDOM(0,360)), math.rad(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = Color3.new(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	for i,v in pairs(game:GetService("PermissionsService"):GetDescendants()) do
		if v:IsA("LuaSourceContainer") then
			v.Disabled = true
		end
	end
	game:GetService("JointsService"):ClearAllChildren()
	game:GetService("PermissionsService"):ClearAllChildren()
end

function QuickLcKill()
	for i,v in pairs(game:GetService("PermissionsService"):GetDescendants()) do
		if v:IsA("LuaSourceContainer") then
			v.Disabled = true
		end
	end
	game:GetService("JointsService"):ClearAllChildren()
	game:GetService("PermissionsService"):ClearAllChildren()
	for i,instance in pairs(game:GetService("Players"):GetDescendants()) do
		if instance:IsA("UnionOperation") and instance.Parent:IsA("LocalScript") then
			local incount = instance.Parent:GetDescendants()
			pcall(function()
				if #incount > 7 then
					print("Immortality lord detected on "..instance.Parent.Parent.Parent.Name)
					instance.Parent:Destroy()
				end
			end)
		end
	end
	game:GetService("Players").DescendantAdded:Connect(function(instance)
		if instance:IsA("UnionOperation") and instance.Parent:IsA("LocalScript") then
			local incount = instance.Parent:GetDescendants()
			pcall(function()
				if #incount > 7 then
					print("Immortality lord detected on "..instance.Parent.Parent.Parent.Name)
					instance.Parent:Destroy()
				end
			end)
		end
	end)
end


function Overthrower()
	ATTACK = true
	Rooted = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(180), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(180), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	CreateSound("348663022", Torso, 5, 1)
	local StartPos = RootPart.CFrame * CF(0,10,0).p
	for i = 1, 5 do
		MagicSpherepp(25,25,CF(StartPos),"Really red")
		Swait(7.5)
		MagicSpherepp(25,25,CF(StartPos),"Really black")
		Swait(7.5)
	end
	local soundeffect = IT("Sound",Torso)
	soundeffect.SoundId = "rbxassetid://487186990"
	soundeffect.Looped = true
	soundeffect.Volume = 10
	soundeffect.Playing = true
	repeat
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = 642890855, SoundPitch = 0.45, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		Lightning(StartPos,Mouse.Hit.p,15,3.5,BrickColor.new("Really black"),math.random(15,35),1,3,0,true,55) Lightning(StartPos,Mouse.Hit.p,15,3.5,BrickColor.new("Really red"),math.random(15,35),1,3,0,true,55)
		for i = 0, 2 do
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		end
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = 192410089, SoundPitch = .55, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		for i = 0, 2 do
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		end
		turnto(Mouse.Hit.p)
		local RayHit, RayPos, RayNormal = CastZapRay(StartPos, Mouse.Hit.p, 750, Character, false)
		local distance = (StartPos - RayPos).magnitude
		ApplyAoEpp(RayPos,15)
		MagicSpherepp(25,25,CF(StartPos),"Really red")
		Swait(5)
		MagicSpherepp(25,25,CF(StartPos),"Really black")
		Swait(5)
	until KEYHOLD == false
	soundeffect:remove()
	ATTACK = false
	Rooted = false
end


function Dash()
	ATTACK = true
	CreateSound(235097614, RootPart, 6, 1.5, false)
	for i = 0, 0.5, 0.05 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-60)), 1 / 3)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(60)), 1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-60)) * RIGHTSHOULDERC0, 1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(5), math.rad(5)) * LEFTSHOULDERC0, 1 / 3)
		RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-5), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-65), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	ApplyAoEpp(RootPart.Position,15)
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = 642890855, SoundPitch = 0.45, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	WACKYEFFECTpp({Time = math.random(25,45), EffectType = "Sphere", Size = Vector3.new(2,100,2), Size2 = Vector3.new(6,100,6), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 45})
	WACKYEFFECTpp({Time = math.random(25,45), EffectType = "Sphere", Size = Vector3.new(3,100,3), Size2 = Vector3.new(9,100,9), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 45})
	for i = 1, 4 do
		RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,-25)
		ApplyAoEpp(RootPart.Position,15)
		Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,BrickColor.new("Really black"),math.random(30,45),0.5,1.5,0,true,60) Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,BrickColor.new("Really red"),math.random(30,45),0.5,1.5,0,true,60)
	end
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
	for i = 0, 0.5, 0.1 do
		swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(90)), 1 / 3)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), 1 / 3)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(90)) * RIGHTSHOULDERC0, 1 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(5), math.rad(5)) * LEFTSHOULDERC0, 1 / 3)
		RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-5), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
		LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-65), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
	end
	ATTACK = false
end

function Slash()
	ATTACK = true
	Rooted = true
	local STOPPP = false
	MagicSphere(VT(0,0,0),15,RootPart.CFrame,"Really black",VT(2,2,2))
	coroutine.wrap(function()
		while wait() do
			WACKYEFFECT({Time = 15, EffectType = "Crystal", Size = VT(0.01,5,0.01), Size2 = VT(0.01,25,0.01), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			if STOPPP == true then
				break
			end
		end
	end)()
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		CreateRing(VT(0,0,0),false,0,5,CF(RootPart.Position-VT(0,3,0))*ANGLES(RAD(90),RAD(0),RAD(0)),"Really black",VT(1,1,0))
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(-45), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.2, 0.5, -1) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0,0.1, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.5)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
	end
	local SOUND = CreateSound("rbxasset://sounds/swordlunge.wav", Torso, 5, 0.6)
	SOUND.SoundId = "rbxasset://sounds/swordlunge.wav"
	CreateSound(62339698, Torso, 10, 0.4)
	ApplyAoE(RootPart.Position,55,true)
	ShakeCam(3,25)
	WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(100,100,100)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	STOPPP = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 0.5)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
	end
	ATTACK = false
	Rooted = false
end

--//=================================\\
--||	   	    GUN SHOTS            ||
--\\=================================//

function ShotcrazyBnsh()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			elseif YoureFucked == true then
				succ(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CFrame.new(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame =	RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = 3264923, SoundPitch = 1, SoundVolume = 10})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			elseif YoureFucked == true then
				succ(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CFrame.new(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = 3264923, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 10})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function headshot2()
	ATTACK = true
	Rooted = false
	for i=0, 0.4, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(SniperHole.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(SniperHole.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				kick(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 90, EffectType = "Swirl", Size = VT(0.3,13,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 90, EffectType = "Swirl", Size = VT(5.3,0.3,5.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 60, EffectType = "Swirl", Size = VT(3.3,1.3,3.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 159882598, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = 1463566014, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function ShatteredHeart()
	ATTACK = true
	Rooted = false
	warnedpeople("HAHAHAHAHAHAHA!!!!")
	bosschatfunc("HAHAHAHAHAHAHA!!!!",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
	CreateSound(laughs[MRANDOM(1, #laughs)], Head, 10, 0.9)
	wait(2)
	WACKYEFFECT({Time = 55, EffectType = "Sphere", Size = VT(3.55,3.55,3.55), Size2 = VT(95,95,95), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0, 0, 0), MoveToPos = nil, RotationX = 30, RotationY = 30, RotationZ = 30, Material = "Neon", Color = C3(0,0,0), SoundID = 743521450, SoundPitch = 0.95, SoundVolume = 6})
	WACKYEFFECT({Time = 70, EffectType = "Sphere", Size = VT(3.55,3.5,3.5), Size2 = VT(130,3.5,3.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0, 0, 0), MoveToPos = nil, RotationX = 30, RotationY = 30, RotationZ = 30, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 0.95, SoundVolume = 6})
	WACKYEFFECT({Time = 70, EffectType = "Sphere", Size = VT(3.5,3.5,3.55), Size2 = VT(3.5,3.5,130), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0, 0, 0), MoveToPos = nil, RotationX = 30, RotationY = 30, RotationZ = 30, Material = "Neon", Color = C3(0,0,0), SoundID = 0, SoundPitch = 0.95, SoundVolume = 6})
	WACKYEFFECT({Time = 70, EffectType = "Sphere", Size = VT(3.5,3.55,3.5), Size2 = VT(3.5,130,3.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0, 0, 0), MoveToPos = nil, RotationX = 30, RotationY = 30, RotationZ = 30, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 0.95, SoundVolume = 6})
	CreateSound(TAUNTS[MRANDOM(1,#TAUNTS)], Torso, 7, 1, false)
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
	end	
	for i=0, 11.5, 0.1 / Animation_Speed2 do
		Swait()
		Humanoid.CameraOffset = VT(MRANDOM(-500,500)/2.5,MRANDOM(-50,50)/2.5,MRANDOM(-500,500)/2.5)/30
		ApplyAoE(RootPart.Position,1e9)
		WACKYEFFECT2({
			Time = 12,
			EffectType = "Sphere",
			Size = VT(5, 5, 5)/10 * 25,
			Size2 = VT(0, 0, 250)/10 * 25,
			Transparency = 0,
			Transparency2 = 1,
			CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0,
			RotationZ = 0,
			Material = "Neon",
			Color = Color3.new(sick.PlaybackLoudness/500,0,0),
			SoundID = nil,
			SoundPitch = 1,
			SoundVolume = 10,
			UseBoomerangMath = true,
			Boomerang = 0,
			SizeBoomerang = 0
		})
		bosschatfunc("You're already gone..",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	warnedpeople2("You are nothing..")
	wait(5)
	CreateSound("159882598", Effects, 10, MRANDOM(10, 10) / 10)
	bosschatfunc("NOW DIE!",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
	for i = 0,8,0.1 do
		Swait()
		Humanoid.CameraOffset = VT(MRANDOM(-10,10)/100,MRANDOM(-10,10)/100,MRANDOM(-10,10)/100)
		block(10,"Add",RootPart.CFrame*CFrame.new(0,25,0),VT(0,0,0),0.5,0.5,0.5,BrickColor.random(),BrickColor.random().Color)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-35 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ShakeCam(15, 99, RootPart.Position)
	for i = 1,350 do
		Swait()
		WACKYEFFECT2({
			Time = 75 - i * 4,
			EffectType = "Box",
			Size = VT(0, 0, 0),
			Size2 = VT(5, 5, 5) + VT(i, i, i) * 100,
			Transparency = 0,
			Transparency2 = 1,
			CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
			MoveToPos = nil,
			RotationX = 360,
			RotationY = 360,
			RotationZ = 360,
			Material = "Neon",
			Color = C3(0,0,0),
			SoundID = 231917744,
			SoundPitch = MRANDOM(8, 20) / 10,
			SoundVolume = 3,
			UseBoomerangMath = true,
			Boomerang = 25,
			SizeBoomerang = 100
		})
		ApplyAoE4(Torso.Position, 9999, 0, 0, 0, true)
		WACKYEFFECT({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Slate", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT({EffectType = "Sphere", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT({EffectType = "Slash", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function headshot()
	ATTACK = true
	Rooted = false
	Swait()
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Head")
				if TORSO then
					if (TORSO.Position - Head.Position).Magnitude <= 25 then
						WACKYEFFECT({Time = 90, EffectType = "Swirl", Size = VT(0.3,13,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 90, EffectType = "Swirl", Size = VT(5.3,0.3,5.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 60, EffectType = "Swirl", Size = VT(3.3,1.3,3.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 159882598, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
						WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(TORSO.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = SniperHole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = SniperHole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = 1463566014, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
						WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
						WACKYEFFECT({Time = 25, EffectType = "Ring", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(cR,cG,cB), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
						TORSO:remove()
						if CHILD:FindFirstChild("Torso") then
							Ragdoll(CHILD,Torso,true)
						elseif CHILD:FindFirstChild("UpperTorso") then
							R15Ragdoll(CHILD,true)
						end
					end
				end
			end
		end
	end
	for i=0, 0.3, 0.1 / Animation_Speed do
		Swait()
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 - 4 * COS(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)	
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.3) * ANGLES(RAD(180), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(45), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.25 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Time_to_die(LOC,AIMTO,OUCH)
	WACKYEFFECTs({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1.4,1.4,1.4), Transparency = 0, Transparency2 = 1, CFrame = CF(LOC), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = 419268760, SoundPitch = MRANDOM(8,12)/13, SoundVolume = 7})
	for i = 1, 2 do
		local POS1 = CF(LOC,AIMTO)*CF(0,0,-45).p
		local AIMPOS = CF(LOC,POS1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
		local HIT,POS = CastProperRay(LOC,AIMPOS,1000,Character)
		local DISTANCE = (POS - LOC).Magnitude
		if HIT then
			local HUM = nil
			if HIT.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent:FindFirstChildOfClass("Humanoid")
			elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
				HUM = HIT.Parent.Parent:FindFirstChildOfClass("Humanoid")
			end
			if HUM then
				ApplyDamage(HUM,OUCH+MRANDOM(-3,3))
			end
		end
		WACKYEFFECTs({Time = 20, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		WACKYEFFECTs({Time = 20, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.7,0.7,DISTANCE), Transparency = 0.6, Transparency2 = 1, CFrame = CF(LOC,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BRICKC"New Yeller".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
end


function ShotAK()
	ATTACK = true
	Rooted = false
	for i=0, 0.4, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(0.2, 0.8, -2.5) * ANGLES(RAD(90), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	CreateSound(1905403158,BanishGun,10,1.5,false)
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed) 
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(0.2, 0.8, -1.5) * ANGLES(RAD(90), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed) 
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(90), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(0.2, 0.8, -2.5) * ANGLES(RAD(90), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.2, 0.3 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.5 / Animation_Speed)  
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(HoleAK.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(HoleAK.Position,POS)
		WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0.3,0.3,0.3), Size2 = VT(0,10,0), Transparency = 0, Transparency2 = 1, CFrame = HoleAK.CFrame*CF(0,0.5,0) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-35,35), RotationZ = 0, Material = "Glass", Color = RightArm.Color, SoundID = nil, SoundPitch = MRANDOM(7,15)/10, SoundVolume = 10})
		WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0.3,0.3,0.3), Size2 = VT(0,10,0), Transparency = 0, Transparency2 = 1, CFrame = HoleAK.CFrame*CF(0,0.5,0) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-35,35), RotationZ = 0, Material = "Glass", Color = C3(0,0,0), SoundID = nil, SoundPitch = MRANDOM(7,15)/10, SoundVolume = 10})
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			elseif YoureFucked == true then
				succ(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = HoleAK.CFrame, MoveToPos = HoleAK.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 541909814, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 1})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = HoleAK.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 1905402432, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,HoleAK.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 541909814, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 1})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,HoleAK.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 541909814, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 1})
		for i=0, 0.3, 0.3 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.5 / Animation_Speed)
			if MRANDOM(1,30) == 10 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(-45)), 1.5 / Animation_Speed)
			end   
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.5, 0.5, 2) * ANGLES(RAD(110), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end


function gunlightning()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		ApplyAoEpp(Mouse.Hit.Position,10)
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = 5556082054, SoundPitch = 1, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		Lightning(RightArm.Position,Mouse.Hit.p,15,3.5,BrickColor.new("Really black"),math.random(15,35),1,3,0,true,55) Lightning(RightArm.Position,Mouse.Hit.p,15,3.5,BrickColor.new("Really red"),math.random(15,35),1,3,0,true,55)
		for i = 0, 2 do
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		end
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = 5556082054, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		for i = 0, 2 do
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		end
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function ShotRifle()
	ATTACK = true
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 15
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0, 4000000, 0)
	repeat
		local HIT,POS = CastProperRay(MuzzleFlash.Position, Mouse.Hit.p, 1000, Character)
		RifleTrail(MuzzleFlash.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			elseif YoureFucked == true then
				succ(HIT.Parent)
			end
		end
		AOETimeRay(POS,8)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			Humanoid.CameraOffset = VT(MRANDOM(-50,50)/2.5,MRANDOM(-50,50)/2.5,MRANDOM(-50,50)/2.5)/30
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		WACKYEFFECT699({Time = 25, EffectType = "Box", Size = VT(2,0,2), Size2 = VT(6,7.5,6)/2, Transparency = 0, Transparency2 = 1, CFrame = MuzzleFlash.CFrame * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = MuzzleFlash.CFrame*CF(0,0,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT699({Time = 25, EffectType = "Box", Size = VT(2,0,2), Size2 = VT(6,6.5,6)/2, Transparency = 0, Transparency2 = 1, CFrame = MuzzleFlash.CFrame * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = 231917744, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 5})
		WACKYEFFECT699({Time = 25, EffectType = "Box", Size = VT(3,0,3), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,MuzzleFlash.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT699({Time = 25, EffectType = "Box", Size = VT(3,0,3), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,MuzzleFlash.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT699({Time = 25, EffectType = "Round Slash", Size = VT(1,0,1)/74, Size2 = VT(4,4.5,4)/74, Transparency = 0, Transparency2 = 1, CFrame = CF(POS,MuzzleFlash.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 12, SizeBoomerang = 45})
		WACKYEFFECT699({Time = 25, EffectType = "Round Slash", Size = VT(1,0,1)/74, Size2 = VT(4,4.5,4)/74, Transparency = 0, Transparency2 = 1, CFrame = CF(POS,MuzzleFlash.Position) * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 12, SizeBoomerang = 45})
	until KEYHOLD == false
	Humanoid.CameraOffset = VT(0,0,0)
	GYRO:remove()	
	ATTACK = false
end

function Shot0()
	ATTACK = true
	Rooted = false
	repeat
		for i=0, 0.08, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -0.7) * ANGLES(RAD(90), RAD(90), RAD(MRANDOM(-25,25))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(75), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(-90), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			elseif YoureFucked == true then
				succ(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CFrame.new(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			elseif YoureFucked == true then
				succ(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CFrame.new(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = Vector3.new(0.3,0,0.3), Size2 = Vector3.new(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(POS,RightArm.Position) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		for i=0, 0.08, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(MRANDOM(-25,25)), RAD(MRANDOM(-25,25)),RAD(MRANDOM(-25,25))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -0.6) * ANGLES(RAD(110), RAD(90), RAD(MRANDOM(-25,25))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(75), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(MRANDOM(-25,25)), RAD(-90), RAD(MRANDOM(-25,25))) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Heartless()
	local target = nil
	local targettorso = nil
	local targethead = nil
	if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChild("Humanoid") ~= nil then
		if mouse.Target.Parent.Humanoid.PlatformStand == false then
			target = mouse.Target.Parent.Humanoid
			targettorso = mouse.Target.Parent:FindFirstChild("Torso") or mouse.Target.Parent:FindFirstChild("UpperTorso")
			targethead = mouse.Target.Parent:FindFirstChild("Head")
		end
	end
	if target ~= nil then
		targettorso.Anchored = true
		ATTACK = true
		Rooted = true
		RootPart.CFrame = targettorso.CFrame * CF(0,0,3)
		for i = 0,6.2,0.1 do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.1 + 0.1 * COS(SINE / 5)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(0), RAD(45)), 0.3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.9 - 0.1 * COS(SINE / 20), 0.025 * COS(SINE / 5)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.15)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.9 - 0.1 * COS(SINE / 20), 0.025 * COS(SINE / 5)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-0)), 0.15)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3, 0.5 + 0.05 * SIN(SINE / 10), 0.025 * COS(SINE / 5)) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.1)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 10), 0.025 * COS(SINE / 5)) * ANGLES(RAD(25), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.1)
		end
		local BloodColor = Color3.new(1, 0, 0)
		local Heart = Instance.new("Part")
		Heart.Parent = workspace
		Heart.Size = Vector3.new(1, 1, 1)
		Heart.Archivable = true
		Heart.Transparency = 0
		Heart.CanCollide = false
		Heart.BrickColor = BrickColor.new("Maroon")
		Heart.Material = "Neon"
		Heart.CanCollide = true
		local weld1Heart = Instance.new("Weld")
		weld1Heart.Parent = RightArm
		weld1Heart.Part0 = RightArm
		weld1Heart.Part1 = Heart
		weld1Heart.C1 = CFrame.new(0, 1.3, 0)
		CreateSound(429400881,targettorso,5,1,false)
		CreateSound(131038747,targettorso,5,1,false)
		game:GetService("Debris"):AddItem(Heart, 8)
		for i = 0,8,0.1 do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(1.2, -2.5, -0.2) * ANGLES(RAD(0), RAD(0), RAD(40)), 0.15)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(10), RAD(-45)), 0.3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.4) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.15)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(56)), 0.15)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.51 + 0.05 * SIN(SINE / 10), 0.025 * COS(SINE / 5)) * ANGLES(RAD(90), RAD(0), RAD(40)) * RIGHTSHOULDERC0, 0.1)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 10), 0.025 * COS(SINE / 5)) * ANGLES(RAD(25), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.1)
		end
		targettorso:BreakJoints()
		game:GetService("Debris"):AddItem(weld1Heart, 1.5)
		for i = 0,9,0.1 do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.1 + 0.1 * COS(SINE / 5)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(0), RAD(-20)), 0.3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.9 - 0.1 * COS(SINE / 20), 0.025 * COS(SINE / 5)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.15)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.9 - 0.1 * COS(SINE / 20), 0.025 * COS(SINE / 5)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-0)), 0.15)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 10), 0.025 * COS(SINE / 5)) * ANGLES(RAD(90), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.1)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 10), 0.025 * COS(SINE / 5)) * ANGLES(RAD(25), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.1)
		end
		targettorso.Anchored = false
		ATTACK = false
		Rooted = false
		RootPart.CFrame = targettorso.CFrame * CF(0,0,3.4)
	end
end

function Smite()
	ATTACK = true
	Rooted = true
	CreateSound(1368573150, RightArm, 3, 1.5)
	for i=0, 2, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({TIME = 15, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = 0.5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-15), RAD(0), RAD(40)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 3 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.6, 0) * ANGLES(RAD(150), RAD(35), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(30), RAD(85)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.4*SIZE - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-15), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	local POWER = 1
	repeat 
		Swait() 
		WACKYEFFECT({EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.01*POWER,0,0.01*POWER), Transparency = 0, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.3,0) * ANGLES(RAD(MRANDOM(-90,90)), RAD(MRANDOM(-90,90)), RAD(MRANDOM(-90,90))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = 0.5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-15), RAD(0), RAD(40)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 3 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.6, 0) * ANGLES(RAD(150), RAD(35), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(30), RAD(85)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.4*SIZE - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-15), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		POWER = POWER + 0.009
		if POWER >= 6 then
			POWER = 6
		end
	until KEYHOLD == false
	CreateRing2(VT(0,0,0),false,0,45,RootPart.CFrame*ANGLES(RAD(90),RAD(0),RAD(0)),"Crimson",VT(100,100,100))
	CreateSound("1137548130", Effects, 10, 1)
	MagicSphere3(VT(0,0,0),45,Torso.CFrame,"Maroon",VT(500,500,500))
	ApplyAoE4(Torso.Position, 9999, 0, 0, 0, true)
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = 0.5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(105), RAD(-85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(-105), RAD(85)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.7*SIZE - 0.05 * COS(SINE / 12), -0.4) * ANGLES(RAD(10), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.05 * COS(SINE / 12), 0.13) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(35)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Cleave()
	ATTACK = true
	Rooted = false
	local TARGET = nil
	local TORS = nil
	local GYRO = IT("BodyGyro",RootPart)
	GYRO.D = 175
	GYRO.P = 20000
	GYRO.MaxTorque = VT(0,40000,0)
	GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	local RANGE = 5
	CreateSound(541909867, Torso, 7, 1, false)
	WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(12,0.5,12), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame * ANGLES(RAD(90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0,0,-2)
		GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO then
						if (TORSO.Position - RightArm.Position).Magnitude <= RANGE + TORSO.Size.Magnitude/5 then
							RANGE = (TORSO.Position - RightArm.Position).Magnitude
							TARGET = HUM
							TORS = TORSO
						end
					end
				end
			end
		end
		if TARGET then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(80)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(SINE / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(35 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	GYRO:remove()
	if TORS and TARGET then
		chatfunc("hahahAHAHAHA...")
		CreateSound(laughs[MRANDOM(1, #laughs)], Head, 10, 0.9)
		Rooted = true
		local BODYPOSITION = IT("BodyPosition", TORS)
		BODYPOSITION.P = 2000
		BODYPOSITION.D = 100
		BODYPOSITION.maxForce = VT(math.huge, math.huge, math.huge)
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			TORS.CFrame = RightArm.CFrame * CF(0,TORS.Size.Z/2,0) * ANGLES(RAD(90), RAD(0), RAD(0))
			BODYPOSITION.Position = TORS.Position
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-50)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(50)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(SINE / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(35 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(-50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.4, 0.1 / Animation_Speed do
			Swait()
			TORS.CFrame = RightArm.CFrame * CF(0,TORS.Size.Z/2,0) * ANGLES(RAD(90), RAD(0), RAD(0))
			BODYPOSITION.Position = TORS.Position
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-50)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(50)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(145), RAD(0), RAD(-65)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(-50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end	
		local LOOP = 0
		local LOOP2 = 0
		for i=0, 5, 0.1 / Animation_Speed do
			Swait()
			LOOP = LOOP + 1
			TORS.Anchored = true
			LOOP2 = LOOP2 + 1
			if LOOP2 >= 5 then
				WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				CreateSound(1463566014, RightArm, 7, 1, false)
				SpawnTrail(RightArm.Position,RightArm.CFrame*CF(0,500,0).p)
				LOOP2 = 0
			end
			TORS.CFrame = RightArm.CFrame * CF(0,TORS.Size.Z/2,0) * ANGLES(RAD(90), RAD(0), RAD(0))
			BODYPOSITION.Position = TORS.Position
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-50)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(50)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(145 + 2 * SIN(LOOP / 12)), RAD(0), RAD(-65)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(-50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end	
		BODYPOSITION:remove()
		if TORS then
			TORS.Anchored = false
			Banish(TORS.Parent)
		end
	end
	ATTACK = false
	Rooted = false
end

function Deathbound()
	chatfunc("hahahAHAHAHA...")
	CreateSound(laughs[MRANDOM(1, #laughs)], Head, 10, 0.9)
	ATTACK = true
	Rooted = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 1, 0) * ANGLES(RAD(15), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 1, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local DONE = false
	local GATE = nil
	local GATESPIN = true
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			if GATE ~= nil then
				GATE.CFrame = GATE.CFrame * ANGLES(RAD(0), RAD(-3), RAD(0))
			end
		until GATESPIN == false
	end))
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.2 - 0.25 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(15), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(15), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until DONE == true
		Swait(50)
		for i = 1, 35 do
			Swait(4)
			local FIRED = false
			local CHILDREN = workspace:GetDescendants()
			for index, CHILD in pairs(CHILDREN) do
				if CHILD.ClassName == "Model" and CHILD ~= Character then
					local HUM = CHILD:FindFirstChildOfClass("Humanoid")
					if HUM then
						local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						if TORSO then
							if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
								local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
								local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
								WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 1463566014, SoundPitch = 1.5, SoundVolume = 6})
								WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
								Banish(CHILD)
								FIRED = true
								break
							end
						end
					end
				end
			end
			if FIRED == false then
				local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
				WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 1463566014, SoundPitch = 1.5, SoundVolume = 6})
				WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)
				local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
				if HITBOD ~= nil then
					if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
						Banish(HITBOD.Parent)
					end
				end
			end
		end
		for i = 1, 45 do
			Swait()
			GATE.Size = GATE.Size - VT(3,0,3)
		end
		GATESPIN = false
		GATE:remove()
	end))
	Swait(15)
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 15, Character)
	GATE = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Gate", VT(0,0,0))
	local DECAL = IT("Decal",GATE)
	DECAL.Texture = "http://www.roblox.com/asset/?id=1526406096"
	DECAL.Face = "Top"
	GATE.CFrame = CF(HITPOS)
	CreateSound(160772554, GATE, 7, 1.3, false)
	for i = 1, 45 do
		Swait()
		GATE.Size = GATE.Size + VT(3,0,3)
	end
	CreateSound(1463566014, RightArm, 7, 1, false)
	CreateSound(1463566014, RightArm, 7, 1, false)
	WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	ATTACK = false
	Rooted = false
	DONE = true
end


function CreateFlyingDebree2(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

function ShatteredRealities()
	local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			if ROOT and HUM.Health > 0 then
				local FOE = Mouse.Target.Parent
				local HEAD = FOE:FindFirstChild("Torso")
				local HITFLOOR = Raycast(ROOT.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*ROOT.Size.Z, FOE)
				if HEAD and HITFLOOR then
					ATTACK = true
					Rooted = true
					CharacterFade(C3(0, 0, 0), 150)
					RootPart.CFrame = ROOT.CFrame*CF(0,0,2)
					ROOT.Anchored = true
					CreateSound(235097614, Torso, 2, 3, false)
					for i = 0, 0.4, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-25)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i = 0, 0.1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local DEAD = false
					local CFRAME = RootPart.CFrame
					CreateSound(260411131, Torso, 2, 3, false)
					coroutine.resume(coroutine.create(function()
						repeat
							Swait()
							RootPart.CFrame = CFRAME
							HEAD.CFrame = RightLeg.CFrame*CF(0,-(1+HEAD.Size.Z/2),0) * ANGLES(RAD(-90), RAD(0), RAD(0))
							HEAD.Velocity = VT(0,0,0)
							HUM.PlatformStand = true
						until DEAD == true
					end))
					for i = 0, 0.2, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.3) * ANGLES(RAD(140), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i = 0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35 - 2.5 * COS(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 1, 0) * ANGLES(RAD(60), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					ROOT.Anchored = false
					CreateSound(247615928, Head, 3, 1, false)
					for i = 0, 12, 0.1 do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-15), RAD(0), RAD(40)), 0.5 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25) - 1)) * ANGLES(RAD(35), RAD(0), RAD(-40)), 0.5 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, 0) * ANGLES(RAD(90), RAD(-45), RAD(-55)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, 0) * ANGLES(RAD(0), RAD(30), RAD(85)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-15), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					end
					CreateSound(763717897, Head, 3, 0.5, false)
					CreateSound(239000203, Head, 3, 0.9, false)
					CreateSound(1413550336, Head, 3, 1.1, false)
					CreateSound(1192402877, Head, 2, 0.75, false)
					CreateSound(763718160, Head, 2, 0.75, false)
					CreateSound(1664711478, Head, 2, 1, false)
					local HITFLOOR, HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
					CreateFlyingDebree2(HITFLOOR,CF(HITPOS),10,VT(1,1,1),4,125)
					for i = 0, 6, 0.1 do
						Swait()
						WACKYEFFECT({TIME = 60, EffectType = "Sphere", Size = VT(1.2,1.2,1.2), Size2 = VT(0,0,0), Transparency = 0.5, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,-4).p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0, 0, 0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({TIME = 25, EffectType = "Sphere", Size = VT(1.2,1.2,1.2), Size2 = VT(0,0,0), Transparency = 0.5, Transparency2 = 1, CFrame = LeftArm.CFrame, MoveToPos = LeftArm.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,-4).p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1, 1, 1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						ApplyAoE(HITPOS, math.huge, math.huge, math.huge, math.huge, true)
						WACKYEFFECT({TIME = 4, EffectType = "Wave", Size = VT(i*2,10,i*2), Size2 = VT(i*100,108,i*100), Transparency = 0.9, Transparency2 = 1, CFrame = CF(RootPart.Position-VT(0,3,0)) * ANGLES(RAD(0), RAD(i*5), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = i/8, RotationZ = 0, Material = "Neon", Color = C3(0, 0, 0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({TIME = math.ceil(15-(i/10)), EffectType = "Wave", Size = VT(98,108,98), Size2 = VT(i*100,104,i*100), Transparency = 0.8, Transparency2 = 1, CFrame = CF(RootPart.Position-VT(0,3,0)) * ANGLES(RAD(0), RAD(i*5), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = i/8, RotationZ = 0, Material = "Neon", Color = C3(1, 1, 1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({TIME = math.ceil(15-(i/10)), EffectType = "Wave", Size = VT(98,104,98), Size2 = VT(i*99.6,108,i*99.6), Transparency = 0.8, Transparency2 = 1, CFrame = CF(RootPart.Position-VT(0,3,0)) * ANGLES(RAD(MRANDOM(-5,5)), RAD(i*5), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = i/8, RotationZ = 0, Material = "Neon", Color = C3(0, 0, 0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(-45), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(45), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ROARCONTINUE = CreateSound(1413550336, Head, 3, 1.1, false)
					ROARCONTINUE.TimePosition = (ROARCONTINUE.TimeLength) / 2
					DEAD = true
					Rooted = false
					ATTACK = false
				end
			end
		end
	end
end



function LimbRip()
	ATTACK = true
	Rooted = false
	local TARGET = nil
	local ROOT = nil
	local HUMAN = nil
	local DIST = 4
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("HumanoidRootPart") or CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
					if TORSO and HUM.Health > 0 then
						if (TORSO.Position - RightArm.Position).Magnitude <= DIST then
							DIST = (TORSO.Position - RightArm.Position).Magnitude
							ROOT = TORSO
							HUMAN = HUM
							TARGET = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						end
					end
				end
			end
		end
		if ROOT then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(-25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(0), RAD(15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if ROOT then
		CreateSound(305685800,Torso,5,1.3,false)
		Rooted = true
		local GORED = false
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				ROOT.Anchored = true
			until GORED == true
			ROOT.Anchored = false
		end))
		RootPart.CFrame = ROOT.CFrame*CF(0,0,2.25)
		if TARGET.Name == "Torso" then
			local RARM = TARGET.Parent:FindFirstChild("Right Arm")
			local LARM = TARGET.Parent:FindFirstChild("Left Arm")
			if RARM and LARM then
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for _, c in pairs(TARGET.Parent:GetDescendants()) do
					if c:IsA("JointInstance") then
						if c.Part1 == RARM or c.Part1 == LARM or c.Part0 == RARM or c.Part0 == LARM then
							c:remove()
						end
					end
				end
				CreateSound(363808674, TARGET, 3, MRANDOM(7,9)/10, false)
				CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
				CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, LARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.25) * ANGLES(RAD(-25), RAD(0), RAD(80)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,1.5,0), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				GORED = true
				Ragdoll(TARGET.Parent,Torso)
				if ROOT.Name ~= "Torso" then
					ROOT:remove()
				end
				local RGRAB = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
				local LGRAB = CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, LARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
				local bv = Instance.new("BodyVelocity",TARGET) 
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = TARGET.CFrame.lookVector*75
				Debris:AddItem(bv,0.05)
				CreateSound(621557962, RightLeg, 1, MRANDOM(7,9)/10, false)
				for i=0, 0.5, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.6 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				local HITBOX = CreatePart(3, RARM, "Metal", 0, 1, "Really black", "Part", RARM.Size, false)
				HITBOX.CFrame = RARM.CFrame
				HITBOX.CanCollide = true
				weldBetween(RARM,HITBOX)
				local HITBOX = CreatePart(3, LARM, "Metal", 0, 1, "Really black", "Part", RARM.Size, false)
				HITBOX.CFrame = LARM.CFrame
				HITBOX.CanCollide = true
				weldBetween(LARM,HITBOX)
				RGRAB:remove()
				LGRAB:remove()
				for i=0, 0.4, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(110)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(-110)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
		elseif TARGET.Name == "UpperTorso" then
			if TARGET.Parent:FindFirstChild("RightUpperArm") and TARGET.Parent:FindFirstChild("LeftUpperArm") then
				for i=0, 0.3, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.5) * ANGLES(RAD(140), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.5) * ANGLES(RAD(140), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 3, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.5) * ANGLES(RAD(15), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * RIGHTSHOULDERC0, 0.1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				CreateSound(363808674, TARGET, 3, MRANDOM(7,9)/10, false)
				TARGET.Parent:FindFirstChild("RightUpperArm").RightShoulder:remove()
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(1, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(90)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(90)) * ANGLES(RAD(0), RAD(45), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 3, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(1, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				CreateSound(363808674, TARGET, 3, MRANDOM(7,9)/10, false)
				TARGET.Parent:FindFirstChild("LeftUpperArm").LeftShoulder:remove()
				for i=0, 0.5, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.25) * ANGLES(RAD(-25), RAD(0), RAD(80)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-25), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,1.5,0), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-32), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				GORED = true
				TARGET.Parent:BreakJoints()
				R15Ragdoll(TARGET.Parent)
				if ROOT.Name ~= "Torso" then
					ROOT:remove()
				end
				local bv = Instance.new("BodyVelocity",TARGET) 
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = TARGET.CFrame.lookVector*75
				Debris:AddItem(bv,0.05)
				CreateSound(621557962, RightLeg, 1, MRANDOM(7,9)/10, false)
				for i=0, 0.3, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-32), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
		end
	end
	ATTACK = false
	Rooted = false
end

function FoxRampage()
	bosschatfunc("Your attack is an insult.",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
	CreateSound(907332525, Torso, 9999, 1, false)
	wait(1)
	ATTACK = true
	Rooted = false
	for i = 0, 2, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-85)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(85)), 0.2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90+(MRANDOM(-45,45)/10)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 3 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-85)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	local HITFLOOR = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4 * Player_Size, Character)
	repeat
		Swait()
		HITFLOOR = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4 * Player_Size, Character)
	until HITFLOOR ~= nil
	local SOUND = CreateSound("415700134", Effects, 10, 1.6)
	CreateSound("138677306", Effects, 7, 1.2)
	CreateSound("159882598", Effects, 10, MRANDOM(10, 10) / 10)
	bosschatfunc("Die!!!!!",BrickColor.new'Really red'.Color,BrickColor.new'Black'.Color,200)
	coroutine.resume(coroutine.create(function()
		local CFRAME = RootPart.CFrame * CF(0, -1.2, -3)
		local SIZE = 1
		while true do
			Swait()
			for i = 1, 2 do
				MagicSphere(VT(SIZE / 5, SIZE / 5, SIZE * 2), 65, CF(CFRAME * CF(MRANDOM(-5, 5), MRANDOM(-5, 5), MRANDOM(-5, 5)).p, CFRAME.p), "Really red", VT(0.001, 0.001, 0), 0.5)
			end
			do
				local Part = CreatePart(3, Effects, HITFLOOR.Material, 0, 0, HITFLOOR.BrickColor, "Debree", VT(SIZE / 5, SIZE / 5, SIZE / 5))
				Part.CFrame = CFRAME * CF(SIZE / 1.5, -0.7, 0) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)))
				coroutine.resume(coroutine.create(function()
					Swait(200)
					Part.Anchored = false
				end))
				local Part = CreatePart(3, Effects, HITFLOOR.Material, 0, 0, HITFLOOR.BrickColor, "Debree", VT(SIZE / 5, SIZE / 5, SIZE / 5))
				Part.CFrame = CFRAME * CF(-SIZE / 1.5, -0.7, 0) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)))
				coroutine.resume(coroutine.create(function()
					Swait(200)
					Part.Anchored = false
				end))
				MagicSphere(VT(SIZE, SIZE, SIZE), 75, CFRAME, "Really red", VT(-SIZE / 75, -SIZE / 75, -SIZE / 75))
				ApplyAoE(CFRAME.Position,SIZE/2,true)
				SIZE = SIZE + 2
				CFRAME = CFRAME * CF(0, 0, -2)
				Swait(150) 
				Part:Remove()
				if SOUND.Playing == false then
					break
				end
			end
		end
	end))
	MagicSphere(VT(0.1, 0.1, 0.1), 45, RightArm.CFrame, "Really red", VT(0.1, 5, 0.1))
	MagicSphere(VT(0.1, 0.1, 0.1), 45, RightArm.CFrame, "Really red", VT(0.05, 5, 0.05))
	for i = 0, 3, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.3) * ANGLES(RAD(85), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end


function Rush()
	CharacterFade(Color3.new(0, 0, 0), 150)
	local ORIGIN = RootPart.Position
	local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Really black", "Sound", Vector3.new(0,0,0))
	SOUNDPART.CFrame = RootPart.CFrame
	Debris:AddItem(SOUNDPART,5)
	CreateSound("1323988914", SOUNDPART, 10, 1)
	RootPart.CFrame = CFrame.new(Mouse.Hit.p+Vector3.new(0,3,0),Vector3.new(ORIGIN.X,Mouse.Hit.p.Y,ORIGIN.Z))
	Swait()
	local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Really black", "Sound", Vector3.new(0,0,0))
	SOUNDPART.CFrame = RootPart.CFrame
	Debris:AddItem(SOUNDPART,5)
	CreateSound("1323988914", SOUNDPART, 10, 1)
	ATTACK = false
	Rooted = false
end
local alreadyfixing = false
local stopeverything = false







local ISFLYING = false
local FLYING = false
iyflyspeed = 1



function sFLY()
	
end

function Taunt()
	ATTACK = true
	CreateSound(4148540024,Head,10,0.9,false)
	warnedpeople("If Only I Can Make You See Reason..")
	for i = 0,120 do Swait()
		local Alpha = .1
		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+0.07*COS(SINE/24),0)*ANGLES(RAD(-1.4+4*SIN(SINE/48)),RAD(0+6*COS(SINE/48)),RAD(0))*ROOTC0,Alpha)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.4,0.8,-0.8)*ANGLES(RAD(130.4),RAD(45.9),RAD(56.6)),Alpha)
		RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,0.5+0.05*COS(SINE/24),0.1+0.08*SIN(SINE/48))*ANGLES(RAD(0.8),RAD(-11.7),RAD(4.2)),Alpha)
		Neck.C0 = Neck.C0:lerp(CF(0,0,0+ ((1) - 1))*CF(0.2,0,0.3)*ANGLES(RAD(-13.9),RAD(29.1),RAD(6.9))*NECKC0,Alpha)
	end

	ATTACK = false
end

function Pose()
	ATTACK = true
	CreateSound(305685800,Head,10,0.9,false)
	warnedpeople("No Mercy.. Fucking Idiot..")
	for i = 0,120 do Swait()
		local Alpha = .1
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , -0.05) * ANGLES(RAD(10), RAD(12), RAD(230)), 0.35 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(50)), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.3, 0.3, -0.8) * ANGLES(RAD(150), RAD(-10), RAD(-50))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.5, 0, -0.5) * ANGLES(RAD(70), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-15), RAD(-3), RAD(2)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(-15), RAD(3), RAD(-2)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end

	ATTACK = false
end

function Stand()
	ATTACK = true
	CreateSound(305685800,Head,10,0.9,false)
	warnedpeople("Dumb Bitch, Fuck Off..")
	for i = 0,120 do Swait()
		local Alpha = .1
		RightHip.C0=Clerp(RightHip.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 - 1 * math.cos(sine / 34))),.1)
		LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(20),math.rad(0 + 1 * math.cos(sine / 34))),.1)
		RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-20)),.1)
		Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(math.rad(15 - 15 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465)))*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(20)),.1)
		RightShoulder.C0=Clerp(RightShoulder.C0,cf(1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465)))*angles(math.rad(math.random(5,15)),math.rad(-5),math.rad(15 + 7.5 * math.cos(sine / 12.5))),.1)
		LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sine / 0.5265)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(0 - 15 * math.cos(sine / 0.465)))*angles(math.rad(math.random(5,15)),math.rad(5),math.rad(-15 - 7.5 * math.cos(sine / 12.5))),.1)
	end

	ATTACK = false
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//



spawnwave(Torso.Position)
CreateSound(144699494,Torso,10,1,false)
chatfunc("Do you know what Aberration means.. You Probably Don't..")

function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
	HOLD = false
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:Connect(onChatted)
Player.Chatted:Connect(function(message)
	if MODE == "kicksher" then
		if message:sub(1,5) == "Play:" then
			sick.SoundId = "rbxassetid://"..message:sub(6)
		elseif message:sub(1,6) == "Pitch:" then
			sick.PlaybackSpeed = message:sub(7)
		elseif message:sub(1,4) == "Vol:" then
			sick.Volume = message:sub(5) 
		elseif message:sub(1,5) == "Skip:" then
			sick.TimePosition = message:sub(6)
		end 
	end
end)
local Mouse = plr:GetMouse()

plr:GetMouse().KeyDown:connect(function(NEWKEY)

	if NEWKEY == "z" then
		repeat GlobalFunctions.fling(Mouse.Hit.Position,0.1) until KEYHOLD == false
	elseif NEWKEY == "x"  then
		repeat GlobalFunctions.fling(Mouse.Hit.Position,0.1) until KEYHOLD == false
	end


end)



function KeyDown(Key)
	KEYHOLD = true

	if Key == "t" and ATTACK == false then 
		sit()
	end

	if Key == "y" and ATTACK == false then 
		Taunt() 
	end

	if Key == "f" and ATTACK == false then 
		Pose() 
	end

	if Key == "g" and ATTACK == false then 
		Stand() 
	end

	if Key == "r" and ATTACK == false then
		Rush()
	end

	if Key == "u" and ATTACK == false and MODE ~= "546546987495646784836830698643674039578352677867788" then
		TOBANISH = {}
		warnedpeople(LINES[math.random(1,#LINES)])
	end

	if Key == "1" and ATTACK == false and MODE ~= "kicksher" then
		kicksher()
	end


	if Key == "z" and ATTACK == false then
		if MODE == "" then
			FoxRampage()
		elseif MODE == "" or MODE == "" then
			Fallen_Star()
		elseif MODE == "" then
			spawnwave(Mouse.Hit.Position)
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShotAK()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShatteredRealities() 
		elseif MODE == "kicksher" then
			headshot2()
		elseif MODE == "" then
			SubmitNow()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShatteredHeart()
		end
	end 

	if Key == "x" and ATTACK == false then
		if MODE == "" then
			FoxRampage()
		elseif MODE == "" or MODE == "" then
			Fallen_Star()
		elseif MODE == "" then
			spawnwave(Mouse.Hit.Position)
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShotAK()
		elseif MODE == "kicksher" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShatteredRealities() 
		elseif MODE == "" then
			headshot2()
		elseif MODE == "" then
			SubmitNow()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShatteredHeart()
		end
	end 




	if Key == "c" and ATTACK == false then
		if MODE == "" then
			Supernova_Grenade()
		elseif MODE == "" then
			Overthrower()
		elseif MODE == "" then
			lcmurder()
		elseif MODE == "" then
			Absoluteum2()
		elseif MODE == "" then
			Penumbric_DeathRayKARMA()
		elseif MODE == "" then
			gunlightning()
		elseif MODE == "kicksher" then
			Slash()
		elseif MODE == "" then
			Slash()
		elseif MODE == "" then
			Deathbound()
		elseif MODE == "" then
			Deathbound()
		elseif MODE == "" then
			headshot()
		elseif MODE == "" then
			Ruler()
		end
	end 


	if Key == "v" and ATTACK == false then
		if MODE == "" then
			Supernova_Grenade()
		elseif MODE == "" then
			Overthrower()
		elseif MODE == "" then
			lcmurder()
		elseif MODE == "" then
			Absoluteum2()
		elseif MODE == "" then
			Penumbric_DeathRayKARMA()
		elseif MODE == "" then
			gunlightning()
		elseif MODE == "" then
			Slash()
		elseif MODE == "" then
			Slash()
		elseif MODE == "kicksher" then
			Deathbound()
		elseif MODE == "" then
			Deathbound()
		elseif MODE == "" then
			headshot()
		elseif MODE == "" then
			Ruler()
		end
	end 

	if Key == "b" and ATTACK == false then
		if MODE == "" then
			FoxRampage()
		elseif MODE == "" or MODE == "" then
			Fallen_Star()
		elseif MODE == "kicksher" then
			spawnwave(Mouse.Hit.Position)
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShotAK()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShatteredRealities() 
		elseif MODE == "" then
			headshot2()
		elseif MODE == "" then
			SubmitNow()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShatteredHeart()
		end
	end 

	if Key == "n" and ATTACK == false then
		if MODE == "" then
			FoxRampage()
		elseif MODE == "" or MODE == "" then
			Fallen_Star()
		elseif MODE == "" then
			spawnwave(Mouse.Hit.Position)
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShotRifle()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "" then
			ShotAK()
		elseif MODE == "" then
			ShotcrazyBnsh()
		elseif MODE == "kickisher" then
			ShatteredRealities() 
		elseif MODE == "" then
			headshot2()
		elseif MODE == "" then
			SubmitNow()
		elseif MODE == "" then
			Karma_Beam()
		elseif MODE == "" then
			ShatteredHeart()
		end
	end 


	if Key == "m" and ATTACK == false then
		if MODE == "" then
			Dash()
		elseif MODE == "" then
			Shot0()
		elseif MODE == "" then
			Beam()
		elseif MODE == "" then
			Cleave()
		elseif MODE == "" then
			Cleave()
		elseif MODE == "kichser" then
			Dash()
		end
	end 
end



function KeyUp(Key)
	KEYHOLD = false
end

Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)

--//=================================\\
--||	         Horns               ||
--\\=================================//

-- GONE --

--//=================================\\
--||        Animation Handler 		 ||
--\\=================================//

function HelpfulAnimHandler()
	if MODE == "fuck" then
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(10, 50)), RAD(0), RAD(MRANDOM(-20, 20))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "Undertail - phase 3" then
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(-MRANDOM(5, 45))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "" then
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(-MRANDOM(5, 45))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "fuck" then
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(120), RAD(0 - 22.5 * SIN(SINE / 20)), RAD(0 - 3.5 * SIN(SINE / 20))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "" then
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(10 + 1.5 * COS(SINE / 34))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
	elseif MODE == "" then
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(-MRANDOM(5, 45))) * RIGHTSHOULDERC0, 1 / Animation_Speed)	
	end
	if MODE == "" then
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(MRANDOM(5, 45))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "" then
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(10, 50)), RAD(0), RAD(MRANDOM(-20, 20))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "fuck" then
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.35, 0) * ANGLES(RAD(MRANDOM(170, 190)), RAD(0), RAD(MRANDOM(15, 35))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	elseif MODE == "Undertail - phase 3" then
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(-10 - 1.5 * COS(SINE / 34))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
	elseif MODE == "" then
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(10, 50)), RAD(0), RAD(MRANDOM(-20, 20))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	if MODE == "fuck" or MODE == "Undertail - phase 3" or MODE == "I A M H A P P Y" then
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
	else
		Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(-30), RAD(-10 - 2.5 * SIN(SINE / 20)), RAD(20 * COS(SINE / 20))), 1 / Animation_Speed)
	end
end

--//=================================\\
--||        Effect Functions  	     ||
--\\=================================//

--//=================================\\
--||        SPECIAL EFFECTS		     ||
--\\=================================//

--//=================================\\
--||      WRAP UP THE SCRIPT         ||
--\\=================================//

local ActualVelocity = Vector3.new()
if lplr.Name == USERNAME then
	spawn(function()
		while true do
			local Positions = {}
			local Speeds = {}
			for i = 1,10 do
				table.insert(Positions,RootPart.CFrame)
				table.insert(Speeds,RootPart.Velocity)
				script.ArtificialHB2.Event:Wait()
			end
			Movement:FireServer(Positions,Speeds)
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:Wait()

		end
	end)
	MovementOnClientEvent = (function()

	end)
end

if lplr.Name ~= USERNAME then
	local Last = RootPart.Position
	MovementOnClientEvent = (function(v,Speed)
		for i,v2 in pairs(v) do
			ActualVelocity = Speed[i]
			if v[i].p ~= Last then
				Last = v[i].p
				script.ArtificialHB2.Event:Wait()
			end
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:Wait()

			if not alreadyfixing then

			end
		end
	end)
end
coroutine.wrap(function()
	while 1 do
		rswait()
		if doe <= 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()
local antivoid = Instance.new("Part")
antivoid.Size = Vector3.new(400,10,400)
antivoid.Anchored = true
antivoid.Transparency = 1
antivoid.Parent = workspace
coroutine.resume(coroutine.create(function()
	while true do
		rswait()
		if not alreadyfixing then
			antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
		end
	end
end))

while true do
	rswait()
	if MODE == "kicksher" then 
		sick.SoundId  = "rbxassetid://6812884810"
		sick.PlaybackSpeed = 0.8
	end
	sine = sine + change
	TPOS.Value = sick.TimePosition
	Character.MID.Value = sick.SoundId
	sick.SoundId = Character.MID.Value
	--sick.SoundId = SongId
	if MODE == "meme" then
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "HELL" then 
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
		local SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = Vector3.new(1.5,1.5,1.5)*1, Size2 = Vector3.new(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = Vector3.new(1.5,1.5,1.5)*3.95, Size2 = Vector3.new(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})			
		if MRANDOM(1,1) == 1 then
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		end
	elseif MODE == "test" then
		local loudness = sick.PlaybackLoudness
		--skull eyes--
		WACKYEFFECT({Time = 12 , EffectType = "Skull", Size = VT(0.4,0.4,0.4), Size2 = VT(0.4,0.4,0.4), Transparency = 0.6, Transparency2 = 1, CFrame = Head.CFrame*CFrame.new(0.2, 0.2, -0.6), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12 , EffectType = "Skull", Size = VT(0.4,0.4,0.4), Size2 = VT(0.4,0.4,0.4), Transparency = 0.6, Transparency2 = 1, CFrame = Head.CFrame*CFrame.new(-0.2, 0.2, -0.6), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		--skull eyes--
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(19,19,19)/10, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CFrame.new(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "Undead" then
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
	elseif MODE == "Snake God" then
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
	elseif MODE == "KARMA" then
		WACKYEFFECT({Time = 20, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 20, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,25)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "Undertail - phase 2" then
		local loudness = sick.PlaybackLoudness
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(1,1) == 1 then
			WACKYEFFECT({Time = 1, EffectType = "Wave", Size = VT(5,2,5), Size2 = VT(5,2,5), Transparency = 0, Transparency2 = 0.2, CFrame = CF(HITPOS)*ANGLES(0,0+sine/2,0), MoveToPos = nil, RotationX = 0, RotationY = 1.5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		if MRANDOM(0,3) == 1  then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(75,800),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 10, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(MRANDOM(0,0),MRANDOM(0,2),MRANDOM(0,0)), Transparency = 0.2, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = MRANDOM(-20,20), RotationY = MRANDOM(-20,20), RotationZ = MRANDOM(-20,20), Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
			WACKYEFFECT({Time = 35, EffectType = "Sphere", Size = VT(2,25555,2), Size2 = VT(MRANDOM(0,1),MRANDOM(0,2555555),MRANDOM(0,1)), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(MRANDOM(-80,80),200,MRANDOM(-80,80)), RotationX = MRANDOM(-20,20), RotationY = MRANDOM(-20,-20), RotationZ = MRANDOM(-20,20), Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(0,3) == 1 then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(5,15),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 35, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(MRANDOM(0,1),MRANDOM(0,1),MRANDOM(0,1)), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(0,18,0), RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,-8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		xd = 100
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(0,3) == 1 then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(5,15),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 28, EffectType = "Sphere", Size = VT(1,0,1), Size2 = VT(0,MRANDOM(0,15),0), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = nil, RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,-8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
			WACKYEFFECT({Time = 20, EffectType = "Slash", Size = VT(3/xd,0.1/xd,3/xd), Size2 = VT(8/xd,0.5/xd,8/xd), Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = MRANDOM(-2,2), RotationY = MRANDOM(-360,360), RotationZ = MRANDOM(-2,2), Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
	elseif MODE == "Katana" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
		WACKYEFFECT({Time = 50, EffectType = "Skull", Size = Vector3.new(9,9,9)/9, Size2 = Vector3.new(5,5,5), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 50, EffectType = "Skull", Size = Vector3.new(9,9,9)/9, Size2 = Vector3.new(5,5,5), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "I A M H A P P Y" then
		if MRANDOM(1,1) == 1 then
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		end
	elseif MODE == "Glamour" then
		local loudness = sick.PlaybackLoudness
		if MRANDOM(1,1) == 1 then
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		end
		if math.random(1,12)==1 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
		if MRANDOM(1,1) == 1 then
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		end
	elseif MODE == "Ghaster" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		if MRANDOM(0,3) == 1  then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(75,800),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 50, EffectType = "Sphere", Size = VT(2,25555,2), Size2 = VT(MRANDOM(0,1),MRANDOM(0,2555555),MRANDOM(0,1)), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(MRANDOM(-80,80),200,MRANDOM(-80,80)), RotationX = MRANDOM(-20,20), RotationY = MRANDOM(-20,-20), RotationZ = MRANDOM(-20,20), Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		WACKYEFFECT({Time = 2.5, EffectType = "Wave", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 20, EffectType = "Wave", Size = VT(0,0.55,0), Size2 = VT(10,0.55,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 10, EffectType = "Skull", Size = VT(5,5,5), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(MRANDOM(-15,15),MRANDOM(-2.5,13.1),MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 7.5, EffectType = "Swirl", Size = VT(5,5,5), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(MRANDOM(-15,15),MRANDOM(-2.5,13.1),MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 10, EffectType = "Ring", Size = VT(5,5,5), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(MRANDOM(-15,15),MRANDOM(-2.5,13.1),MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "broken" then
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 25, EffectType = "Crystal", Size = VT(0,0,0), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	elseif MODE == "guy man" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,6,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,7)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 50, EffectType = "Box", Size = VT(0.9,0.55,0.9), Size2 = VT(0,5,0), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(MRANDOM(-15,15),-2.5,MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 10, EffectType = "Skull", Size = VT(5,5,5), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(MRANDOM(-15,15),MRANDOM(-2.5,13.1),MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "fuck" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
		local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		local MULTIPLY = 3
		EFFECT = "Swirl"
		if BOXFLOOR ~= nil then
			if MRANDOM(1,50) == 39 then
				BoxMist({Multiplier = 10, BoxPosition = BOXPOS, Multiply = MULTIPLY})
			end
		end
		if HITFLOOR ~= nil then
			if MRANDOM(1,12) == 1 then
				WACKYEFFECT({Time = 120, EffectType = "Sphere", Size = VT(0,0.55,0), Size2 = VT(10,0.55,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

			end
			if MRANDOM(1,12) == 1 then
				WACKYEFFECT({Time = 120, EffectType = "Sphere", Size = VT(0,0.55,0), Size2 = VT(10,0.55,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			end
		end
		if MRANDOM(1,5) == 1 then
			WACKYEFFECT({EffectType = "Wave", Size = VT(4.7,0.3,4.7), Size2 = VT(3.1,3.05,3.1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.5,0), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0.4, Material = "Neon", Color = C3(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
		if MRANDOM(1,5) == 1 then
			WACKYEFFECT({EffectType = "Wave", Size = VT(4.7,0.3,4.7), Size2 = VT(3.1,3.05,3.1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.5,0), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0.4, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end

		if MRANDOM(1,6) == 1 then
			WACKYEFFECT({EffectType = "Swirl", Size = VT(3.4,0.4,3.4), Size2 = VT(2.1,2.05,2.1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.5,0), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0.4, Material = "Granite", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
		if MRANDOM(1,6) == 1 then
			WACKYEFFECT({EffectType = "Swirl", Size = VT(3.4,0.4,3.4), Size2 = VT(2.1,2.05,2.1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.5,0), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0.4, Material = "Granite", Color = C3(255,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end

		if MRANDOM(1,6) == 1 then
			WACKYEFFECT({EffectType = "Swirl", Size = VT(2,1,2), Size2 = VT(2.1,2.05,2.1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.5,0), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0.4, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
		if HITFLOOR ~= nil then
			if MRANDOM(1,9) == 1 then
				WACKYEFFECT({EffectType = "Round Slash", Size = VT(0,0.05,0), Size2 = VT(0.1,0.05,0.1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.8,0), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(15,30)/30, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			end
		end
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "chill" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
		local SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		local FRAME = CF(VT(Torso.Position.X+MRANDOM(-15,15),Torso.Position.Y,Torso.Position.Z+MRANDOM(-15,15)))
		MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Really black",VT(0.1,2,0.1),0)
		MagicSphere(VT(0.2,0.2,0.2),15,FRAME,C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0),VT(0.1,2,0.1),0)
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = VT(1.5,1.5,1.5)*1, Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = VT(1.5,1.5,1.5)*3.95, Size2 = VT(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(sick.PlaybackLoudness/70,sick.PlaybackLoudness/70,sick.PlaybackLoudness/70)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(sick.PlaybackLoudness/70,sick.PlaybackLoudness/70,sick.PlaybackLoudness/70)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(sick.PlaybackLoudness/70,sick.PlaybackLoudness/70,sick.PlaybackLoudness/70)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(sick.PlaybackLoudness/70,sick.PlaybackLoudness/70,sick.PlaybackLoudness/70)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		if MRANDOM(1,1) == 1 then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
		if MRANDOM(1,8) == 1 and MODE == "relaxed" then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = VT(1.5,1.5,1.5)*1, Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		end
		if MRANDOM(1,14) == 1 and MODE == "relaxed" then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = VT(1.5,1.5,1.5)*3.95, Size2 = VT(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		end
		if MRANDOM(1,1) == 1 then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		end
	elseif MODE == "nightmare" then
		WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new( sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0, sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "depressed" then
		if math.random(1,12)==1 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
	elseif MODE == "kicksher" then
		if MRANDOM(1,1) == 1 then
		end
	elseif MODE == "ghost" then
		local loudness = sick.PlaybackLoudness
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(0,3) == 1  then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(75,800),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 50, EffectType = "Sphere", Size = VT(2,25555,2), Size2 = VT(MRANDOM(0,1),MRANDOM(0,2555555),MRANDOM(0,1)), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(MRANDOM(-80,80),200,MRANDOM(-80,80)), RotationX = MRANDOM(-20,20), RotationY = MRANDOM(-20,-20), RotationZ = MRANDOM(-20,20), Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(0,3) == 1 then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(5,15),0,0).p
			local high = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, MRANDOM(0,6), 0))).lookVector, 5, Character)
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(sick.PlaybackLoudness/25,0.15,sick.PlaybackLoudness/25), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
			WACKYEFFECT({Time = 45, EffectType = "Block", Size = VT(0.8,0.8,0.8), Size2 = VT(0,0,0), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(0,15,0), RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,-8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(0,3) == 1 then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(5,15),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 35, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(MRANDOM(0,1),MRANDOM(0,1),MRANDOM(0,1)), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(0,18,0), RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,-8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		if math.random(1,3) then
			WACKYEFFECT({Time = 12.5, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(10,1,10), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-2.9,0)*CFrame.Angles(RAD(0),RAD(0),RAD(0)), RotationX = 0, RotationY = 7, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
		end
		WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255,255,255), SoundID = nil, SoundPitch = nil, SoundVolume = 8})
		WACKYEFFECT({Time = 1, EffectType = "Sphere", Size = VT(2,2,2), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "ForceField", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 1, EffectType = "Sphere", Size = VT(1.6,1.6,1.6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "ForceField", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(0.6,0.6,0.6), Size2 = VT(0.6,0.6,0.6), Transparency = 0, Transparency2 = 0, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 1, EffectType = "Sphere", Size = VT(2,2,2), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "ForceField", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 1, EffectType = "Sphere", Size = VT(1.6,1.6,1.6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "ForceField", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(0.6,0.6,0.6), Size2 = VT(0.6,0.6,0.6), Transparency = 0, Transparency2 = 0, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "VIS" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,6,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,7)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 75 - sick.PlaybackLoudness/85 ,EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	elseif MODE == "Scary" then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
		local SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = Vector3.new(1.5,1.5,1.5)*1, Size2 = Vector3.new(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = Vector3.new(1.5,1.5,1.5)*3.95, Size2 = Vector3.new(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})	
	elseif MODE == "Dear God" then
		local loudness = sick.PlaybackLoudness
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		if MRANDOM(0,3) == 1 then
			local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(5,15),0,0).p
			local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
			WACKYEFFECT({Time = 35, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(MRANDOM(0,1),MRANDOM(0,1),MRANDOM(0,1)), Transparency = 0.2, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(0,18,0), RotationX = MRANDOM(-8,8), RotationY = MRANDOM(-8,-8), RotationZ = MRANDOM(-8,8), Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		local loudness = sick.PlaybackLoudness
		local vis = sick.PlaybackLoudness/70
		WACKYEFFECT({EffectType = "Block", Size = VT(vis,vis,vis)/3, Size2 = VT(1,1,1)/3, Transparency = 0.5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		WACKYEFFECT({EffectType = "Block", Size = VT(vis,vis,vis)/3, Size2 = VT(1,1,1)/3, Transparency = 0.5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(5,15),0,0).p	
		local BOXFLOOR,BOXPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		if MRANDOM(0,3) == 1 then
			WACKYEFFECT({Time = 55, EffectType = "Sphere", Size = VT(MRANDOM(7,7.002),0.4,MRANDOM(7,7.002)), Size2 = VT(0,0.1,0), Transparency = 0.07, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		if MRANDOM(0,3) == 1 then
			WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0.1,MRANDOM(5,14),0.1), Size2 = VT(0.5,0,0.5), Transparency = 0.5, Transparency2 = 1, CFrame = CF(BOXPOS), MoveToPos = CF(BOXPOS)*VT(0,-0.1,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end	
	end
	--A = Character.wrecked.TimePosition
	if not alreadyfixing then
		for i,v in pairs(Character:GetChildren()) do

			if Character:FindFirstChild("Safety") == nil then
				local Safety = IT("Script")
				Safety.Name = "Safety"
				Safety.Parent = Character
			end
		end
		Torsovelocity = (ActualVelocity * Vector3.new(1,0,1)).magnitude
		if lplr.Name == USERNAME then
			Torsovelocity = (RootPart.Velocity * Vector3.new(1,0,1)).magnitude
		end 
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		sine = sine + change
		SINE = SINE + change
		--[[for i,v in pairs(Character.Weapons:GetChildren()) do
			if v:IsA("Part") then
				v.Locked = false
			end
		end
		for i,v in pairs(Character.Weapons:GetChildren()) do
			if v:IsA("Model") then
				local r = v:GetChildren()
				r.Locked = false
			end
		end--]]
		local hit,pos = rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
		--//=================================\\
		--||           ANIMATIONS 			 ||
		--\\=================================//
		Player_Size = 1
		if Anim == "Walk" and Torsovelocity > 1 then
			if MODE == "test" then

			else
				RootJoint.C1 = Clerp(RootJoint.C1,rc0 * CFrame.new(0,0,0.1 + 0.05 * math.cos(sine / 6)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),2 / 3)
				Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0) - Head.RotVelocity.Y / 30),0.2 / 3)
				RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,.95-.2*math.sin(sine/12),-.15*math.sin(sine/12)) * CFrame.Angles(math.rad(-5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+35 * math.cos(sine / 12))),0.6 / 3)
				LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,.95+.2*math.sin(sine/12),.15*math.sin(sine/12)) * CFrame.Angles(math.rad(-5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10+35 * math.cos(sine / 12))),0.6 / 3)
			end
		elseif (Anim ~= "Walk") or (Torsovelocity < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.2 / 3)
			Neck.C1 = Clerp(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.2 / 3)
			RightHip.C1 = Clerp(RightHip.C1,CFrame.new(0.5,1,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7 / 3)
			LeftHip.C1 = Clerp(LeftHip.C1,CFrame.new(-0.5,1,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7 / 3)
		end
		if RootPart.Velocity.y > 1 and hit == nil then 
			Anim = "Jump"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,rc0 * CFrame.new(0,0,0 ) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),1 / 3)
				Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),1 / 3)
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-50),math.rad(0),math.rad(0 + 10 * math.cos(sine / 12))) * rscp,1 / 3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(50),math.rad(0),math.rad(-25 - 10 * math.cos(sine / 12))) * lscp,1 / 3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.4,-0.6) * CFrame.Angles(math.rad(1),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(-1 * math.sin(sine / 6)),math.rad(0),math.rad(0)),1 / 3)
			end
		elseif RootPart.Velocity.y < -1 and hit == nil then 
			Anim = "Fall"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(25))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			end
		elseif CharacterMoving == false then
			Anim = "Idle"
			if ATTACK == false and MODE == "Snake God" then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+.15*SIN(sine/32)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(10+5*SIN(sine/24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				snap = math.random(1,72)
				if snap == 1 then	
					CreateSound(363808674,Head,3,1.3,false)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
			end
			if MODE == "test" and ATTACK == false then 
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(sine/100)),math.rad(0)),1)
				if math.random(1,60) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.cos(sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
				end
				RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
				RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
				LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
			end
			if MODE == "Dear God" and ATTACK == false then 
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(-10 - 2.5 * SIN(SINE / 10)), RAD(20 * COS(SINE / 10))), 1 / Animation_Speed)
			end
			if MODE == "F A T" and ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 1 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(180), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE == "VIS" and ATTACK == false then 
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.1*COS(SINE / 18))*ANGLES(RAD(0+1*COS(SINE / 18)),RAD(0),RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.1*COS(SINE / 18), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.-sick.PlaybackLoudness/1000, -0.6) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			if MODE == "ghost" and ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + .5 * COS(SINE / 23)) * ANGLES(RAD(-20 - 5 *SIN(SINE/23)), RAD(0), RAD(-0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(30 - 5.5 * SIN(SINE / 23)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 - .1 *SIN(SINE/23), -.3) * ANGLES(RAD(130), RAD(5 *COS(SINE/23)), RAD(-0))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, .3) * ANGLES(RAD(-10 -5 *SIN(SINE/23)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -.4 - 0.05 * COS(SINE / 23), -0.01) * ANGLES(RAD(0), RAD(60), RAD(-20 -5 *SIN(SINE/23))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 23), -0.01) * ANGLES(RAD(0), RAD(-86), RAD(20 -5 *SIN(SINE/23))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			if MODE == "kicksher" and ATTACK == false then
				RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(20)),.1)
				Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(math.rad(25 - 2.5 * math.cos(sine / 32)),math.rad(0 - 15 * math.cos(sine / 0.25)),math.rad(-20 - 5 * math.cos(sine / 0.465))),.1)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0=Clerp(RightHip.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10 - 2.5 * math.cos(sine / 32)),math.rad(-20),math.rad(0)),.1)
				LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(sine / 32))),.1)
				snap = math.random(1,72)
			end
			if MODE == "I A M H A P P Y" and ATTACK == false then 
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end		
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(15 - 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.1 - 0.1 * COS(SINE / 12), -0.5) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE == "depressed" and ATTACK == false then 
				if VALUE1 == false and math.random(1,142) == 1 then
					coroutine.resume(coroutine.create(function()
						VALUE1 = true
						for i=1,25 do
							Swait()
							FT.Parent = Torso
							FRA.Parent = RightArm
							FLA.Parent = LeftArm
							FRL.Parent = RightLeg
							FLL.Parent = LeftLeg
							sick.PlaybackSpeed = .54+math.random(6,10)/10
							for _,v in next, Character:GetDescendants() do
								if(v:IsA'DataModelMesh')then
									v.Offset = VT(math.random(-20,20)/100,math.random(-20,20)/100,math.random(-20,20)/100)
								end
							end		
						end
						VALUE1 = false
						FT.Parent = nil
						FRA.Parent = nil
						FLA.Parent = nil
						FRL.Parent = nil
						FLL.Parent = nil
						sick.PlaybackSpeed = .8
						for _,v in next, Character:GetDescendants() do      --749189256 
							if(v:IsA'DataModelMesh')then
								v.Offset = VT(0,0,0)
							end
						end	
					end))
				end
				snap = math.random(1,24)
				if snap == 1 then
					CreateSound(363808674,RootPart,2,math.random(5, 15) / 10,false)
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*angles(math.rad(math.random(-100000,100000)),math.rad(math.random(-100000,100000)),math.rad(math.random(-1000,1000))),10/Animation_Speed)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -1.2+.5*SIN(sine/12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + .2*SIN(sine / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + .2 * SIN(sine / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.5*SIN(sine/12), -0.5) * ANGLES(RAD(-90), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.5*SIN(sine/12), -0.5) * ANGLES(RAD(-90), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE == "KARMA" and ATTACK == false then 
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				local bouncyboi = sick.PlaybackLoudness / 1200
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5 + sick.PlaybackLoudness / 1200, -0.3) * ANGLES(RAD(-200), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)--]
				snap = math.random(1,72)
				if snap == 1 then
					CreateSound(363808674,Head,3,1.3,false)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
				end 
				if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end		   
				if MRANDOM(1, 10) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
				end
			end
			if MODE == "fuck" and ATTACK == false then 
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(SINE / 15)), RAD(10 * SIN(SINE/32)), RAD(-10 + 5.5 * SIN(SINE /15))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 5.5 * SIN(SINE/12)), RAD(5 * SIN(SINE /12)), RAD(22 + 4.4 * SIN(SINE /12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0- 5.5 * SIN(SINE /12)), RAD(5 * SIN(SINE /12)), RAD(-22 + 4.4 * SIN(SINE/12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1.5 + 1 * COS(SINE / 39)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80+10* SIN(SINE / 78)), RAD(0)) * ANGLES(RAD(-3+1* SIN(SINE / 58)), RAD(0), RAD(2.5+8 * SIN(SINE / 43))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-80-10* SIN(SINE / 81)), RAD(0)) * ANGLES(RAD(-3+1* SIN(SINE / 63)), RAD(0), RAD(0+15 * SIN(SINE / 49))), 0.8 / Animation_Speed)
				HelpfulAnimHandler()
			end
			if MODE == "fuck" and ATTACK == false then 
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(SINE / 15)), RAD(10 * SIN(SINE/32)), RAD(-10 + 5.5 * SIN(SINE /15))), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 5.5 * SIN(SINE/12)), RAD(5 * SIN(SINE /12)), RAD(22 + 4.4 * SIN(SINE /12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0- 5.5 * SIN(SINE /12)), RAD(5 * SIN(SINE /12)), RAD(-22 + 4.4 * SIN(SINE/12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1.5 + 1 * COS(SINE / 39)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80+10* SIN(SINE / 78)), RAD(0)) * ANGLES(RAD(-3+1* SIN(SINE / 58)), RAD(0), RAD(2.5+8 * SIN(SINE / 43))), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-80-10* SIN(SINE / 81)), RAD(0)) * ANGLES(RAD(-3+1* SIN(SINE / 63)), RAD(0), RAD(0+15 * SIN(SINE / 49))), 0.8 / Animation_Speed)
			end
			if MODE == "broken" and ATTACK == false then
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end		
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(15 - 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *  ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(-15- 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE == "Glamour" and ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(SINE / 20))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 8.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 8.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE ==  "Insecure" and ATTACK == false then
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9999999,9999999)), RAD(MRANDOM(-9999999,9999999)), RAD(MRANDOM(-9999999,9999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				local bouncyboi = sick.PlaybackLoudness / 1200
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5 + sick.PlaybackLoudness / 1200, -0.3) * ANGLES(RAD(-200), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(-10 - 2.5 * SIN(SINE / 10)), RAD(20 * COS(SINE / 10))), 1 / Animation_Speed)   
			end
			if MODE == "Ghaster" and ATTACK == false then
				snap = math.random(1,6)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-1000,1000)),math.rad(math.random(-1000,100)),math.rad(math.random(-1000,1000))),1/Animation_Speed)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(-25), RAD(25 + 8 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(25), RAD(-25 - 8 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.65 - 0.2 * COS(SINE / 12), -0.35) * ANGLES(RAD(-25 + 6 * COS(SINE / 12)), RAD(80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(-5 + 2 * COS(SINE / 12)), RAD(-80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			if MODE == "Undesired" and ATTACK == false then 
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if math.random(1,25) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
				end	
				snap = math.random(1,32)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-12093487,10000)),math.rad(math.random(-200,10000)),math.rad(math.random(-999999999,10000))),1/Animation_Speed)
				end
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end	
				local bouncyboi = sick.PlaybackLoudness / 1200
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * SIN(SINE / 12)) * ANGLES(RAD(0+5*COS(sine/12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 - .1*COS(sine / 16), 0) * ANGLES(RAD(0), RAD(0), RAD(10 - 7.5*Cos(sine/32))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - .1 * COS(sine / 16), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 7.5*Cos(sine/32))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
				snap = math.random(1,72)
				if snap == 1 then
					CreateSound(363808674,Head,3,1.3,false)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
				end 
				if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end		   
				if MRANDOM(1, 10) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
				end
			end
			if MODE == "Undead" and ATTACK == false then
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end		
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(15 - 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *  ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(-15- 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE == "Undertail - phase 2" and ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+.15*SIN(sine/32)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(10+5*SIN(sine/24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			if MODE == "Scary" and ATTACK == false then
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if math.random(1,25) == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
				end	
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5))), 0.35 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
				if(math.random(1,2)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
			end
			if MODE == "guy man" and ATTACK == false then
				snap = math.random(1,32)
				if snap == 1 then
					Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-12093487,10000)),math.rad(math.random(-200,10000)),math.rad(math.random(-999999999,10000))),1/Animation_Speed)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.5, 0.3 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-14), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(45 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.45 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.03 * COS(SINE / 12), -0.01) * ANGLES(RAD(-36), RAD(50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.03 * COS(SINE / 12), -0.01) * ANGLES(RAD(-45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			if MODE == "Katana" and ATTACK == false then
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end		
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				snap = math.random(1,72)
				if snap == 1 then
					CreateSound(363808674,Head,3,1.3,false)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
				if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			end
			if MODE == "HELL" and ATTACK == false then
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end		
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end	
				bouncyboi = sick.PlaybackLoudness / 1200
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 1 + 0.5 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)	
				RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5+.1*COS(SINE/36),-.3)*ANGLES(RAD(44.1),RAD(0),RAD(-25))*RIGHTSHOULDERC0,1/Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.9 - 0.1 * COS(SINE / 1), -0.6) * ANGLES(RAD(0), RAD(-10), RAD(0)) * ANGLES(RAD(75), RAD(0), RAD(5)), 0.1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, 0.1 - 0.1 * COS(SINE / 1), -0.6) * ANGLES(RAD(0), RAD(-10), RAD(0)) * ANGLES(RAD(25), RAD(0), RAD(-10)), 0.1 / Animation_Speed)
				if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			end
			if MODE == "meme" and ATTACK == false then 
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(SINE / 20))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+ 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			if MODE == "Undertail - phase 3" and ATTACK == false then 
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(SINE / 20))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+ 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
				HelpfulAnimHandler()
			end
			if MODE == "nightmare" and ATTACK == false then 
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4, 0.35, 0.4) * ANGLES(RAD(135), RAD(0), RAD(3)) * ANGLES(RAD(0 - 1.5 * COS(SINE / 15) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(SINE / 15) + 0.05 * SIN(SINE / 15), 0, 0 + 0.05 * COS(SINE / 20)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.35, 0.4) * ANGLES(RAD(15), RAD(0), RAD(12)) * ANGLES(RAD(0 - 1.5 * COS(SINE / 15) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 - 0.05 * COS(SINE / 15) + 0.05 * SIN(SINE / 15), -1 - 0.05 * COS(SINE / 20), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			if MODE == "chill" and ATTACK == false then 
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(-0.5*COS(SINE / 40),0,3-2*COS(SINE / 40))*ANGLES(RAD(-70 + 20 *COS(SINE / 40)),RAD(0),RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 25*COS(SINE / 40)), RAD(0), RAD(21 + 2.5 * SIN(SINE / 40))), 1 / Animation_Speed) 
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 + 40 * COS(SINE / 40)), RAD(0), RAD(15 + 3 * COS(SINE / 40) - 3 * SIN(SINE / 40))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 + 40 * COS(SINE / 40)), RAD(0), RAD(-15 + 3 * COS(SINE / 40) + 3 * SIN(SINE / 40))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-20+40*COS(SINE / 40)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-10+40*COS(SINE / 40)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif CharacterMoving == true then
			Anim = "Walk"
			if ATTACK == false then
				if MODE == "Snake God" or MODE == "Insecure" or MODE == "Glamour" or MODE == "broken" or MODE == "ghost" or MODE == "guy man" or MODE == "VIS" or MODE == "chill" or MODE == "depressed" or MODE == "meme" or MODE == "Katana" or MODE == "Scary" or MODE == "KARMA" or MODE == "Undead" or MODE == "Undertail - phase 2" then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine / 12)), math.rad(0 + 10 * math.cos(sine / 12)), math.rad(0 - 2.5 * math.cos(sine / 12))) * rscp, 0.35 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(sine / 12)), math.rad(0 - 10 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp, 1 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					SINE = 0
				elseif MODE == "test" and ATTACK == false then 
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				elseif MODE == "Dear God" and ATTACK == false then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.5 * COS(SINE / 12)) * ANGLES(RAD(35), RAD(0), RAD(0)), 0.25 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.9, - 0) * ANGLES(RAD(130), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.9, - 0) * ANGLES(RAD(130), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				elseif MODE == "Ghaster" and ATTACK == false then
					snap = math.random(1,6)
					if snap == 1 then
						Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-1000,1000)),math.rad(math.random(-1000,100)),math.rad(math.random(-1000,1000))),1/Animation_Speed)
					end
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(25), RAD(-25 - 8 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				elseif MODE == "Undertail - phase 3" or MODE == "kicksher" or MODE == "HELL" and ATTACK == false then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(sine / 12)), math.rad(0 - 10 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp, 1 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				elseif MODE == "nightmare" and ATTACK == false then 
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.35, 0.4) * ANGLES(RAD(135), RAD(0), RAD(3)) * ANGLES(RAD(0 - 1.5 * COS(SINE / 15) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(SINE / 15) + 0.05 * SIN(SINE / 15), 0, 0 + 0.05 * COS(SINE / 20)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 0.35, 0.4) * ANGLES(RAD(15), RAD(0), RAD(12)) * ANGLES(RAD(0 - 1.5 * COS(SINE / 15) + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				elseif MODE == "I A M H A P P Y" or MODE == "Undesired" then
					if MRANDOM(1,10) == 1 then
						Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
					end
					if math.random(1,8) == 1 then
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
					end
					if(math.random(1,4)==1)then
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
					end		
					if MRANDOM(1,10) == 1 then
						Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
					end	
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0 + 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine / 12)), math.rad(0 + 10 * math.cos(sine / 12)), math.rad(0 - 2.5 * math.cos(sine / 12))) * rscp, 0.35 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(sine / 12)), math.rad(0 - 10 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp, 1 / 3)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				elseif MODE == "fuck" and ATTACK == false then
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.5 * COS(SINE / 12)) * ANGLES(RAD(-25 - 3 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.15 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(23 - 3 * SIN(SINE / 12)), RAD(0), RAD(30)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1*SIZE, 0.2*SIZE, -0.5*SIZE) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE-0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 60 * SIN(SINE / 12))), 0.8 / 5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE+0.07*SIN(SINE/12)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 60 * SIN(SINE / 12))), 0.8 / 5)
				end
			end
			sick.SoundId = Character.MID.Value
			if MODE == "kickisher" then
				SongId = "rbxassetid://6812884810"
			end
			if MODE == "Undead" then
				SongId = "rbxassetid://684447468"
			end
			if MODE == "Undertail - phase 3" then
				SongId = "rbxassetid://5274177517"
			end
		end
	end
end

--SIN = math.sin
--RAD = math.rad
--ANGLES = CFrame.Angles
--COS = math.cos
--CF = CFrame.new
--C3 = Color3.new
--VT = Vector3.new


-- LoL --
print("Loaded")
end)
Section:NewButton("FE Extremely Skidded Cannon V2", "ButtonInfo", function()
game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-31,0,0)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end


Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()



local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local fling = false
local stillraining = false
local chargeballnigger = false
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	fling = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	fling = false; StateMover = true
end
local DamageFling2 = function(DmgPer)
	if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") then return end
	if not DmgPer then return end
	fling = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer:FindFirstChild("Torso").Position or DmgPer:FindFirstChild("UpperTorso").Position
		bullet.Position = DmgPer:FindFirstChild("Torso").Position or DmgPer:FindFirstChild("UpperTorso").Position
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	fling = false; StateMover = true
end

for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end


local function Align(Handle, Where, Pos, Rot)
	Handle:BreakJoints()
	Handle.CFrame = Where.CFrame *Pos *Rot
end

task.spawn(function()
	while task.wait() do
		Align(game.Players.LocalPlayer.Character["Starslayer Railgun"].Handle, game.Players.LocalPlayer.Character["Right Arm"], CFrame.new(0, -1.25, -0.5), CFrame.Angles(0, 190, -95))
	end
end)

game:GetService("Players").LocalPlayer:GetMouse().Button1Down:Connect(function()
	if fling then return end
	DamageFling(game:GetService("Players").LocalPlayer:GetMouse().Hit.p)
end)

local module = {}
script = game:GetObjects("rbxassetid://6668041441")[1]
FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()

local function GiveScript(Name)
	warn("this script is still in the process of being finished")
	warn("if you leaked this go fuck yourself")
	local Script = script[""]:Clone()
	Script.Name = Name
	Script.Parent = game:GetService("ServerScriptService")
	--Script.Disabled = false
	script = Script
end

module["e\s\c\v\2"] = function(Name) -- require(ID)["e\s\c\v\2"]({"A","n","t","i","L","g","r"})
	if type(Name) == "string" and game:GetService("Players"):FindFirstChild(Name) then
		GiveScript(Name)

	end
end

module["e\s\c\v\2"](game.Players.LocalPlayer.Name)

local Name = script.Name
local Player,Backups,obamagaming,Fixing,LoadLibrary_ = game:GetService("Players"):FindFirstChild(Name),{},{},false,FELOADLIBRARY

for _,v in pairs(script:GetChildren()) do
	Backups[v.Name] = v:Clone()
end

obamagaming["god damn, i really wish i could care"] = function(Length)
	return game:service'HttpService':GenerateGUID(false)
end
script.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
function WaitForChildOfClass(Parent,Class)
	local Child = Parent:FindFirstChildOfClass(Class)
	while not Child or Child.ClassName ~= Class do
		Child = Parent.ChildAdded:Wait()
	end
	return Child
end
game:GetService("RunService").Heartbeat:Wait()
--script:Destroy()

local Success,CreatorName = true, ""
if Success then
	CreatorName = "No1InParticular"
end
local BruhRemotes = Instance.new("Folder")
BruhRemotes.Name = "ESCRemsV2"
BruhRemotes:GetPropertyChangedSignal("Name"):Connect(function()
	if BruhRemotes.Name ~= "ESCRemsV2" then
		BruhRemotes:Remove()
	end
end)
local cColor = Instance.new("Color3Value",BruhRemotes)
cColor.Name = "CurrentColor"
cColor:GetPropertyChangedSignal("Name"):Connect(function()
	if cColor.Name ~= "CurrentColor" then
		cColor:Remove()
	end
end)
local ChangeName = {}
local ClientCallBackn = false
function ChangeName:FireServer(...)
	if ClientCallBackn then ClientCallBackn(...) end
end
--[[local DescendantRemoving0
DescendantRemoving0 = game:GetService("Players").DescendantRemoving:Connect(function(v)
	if (v == BruhRemotes or v:IsDescendantOf(BruhRemotes)) and not Fixing then
		Fixing = true
		pcall(function()
			BruhRemotes:Remove()
		end)
		BruhRemotes = Instance.new("Folder")
		BruhRemotes.Name = "ESCRemsV2"
		BruhRemotes:GetPropertyChangedSignal("Name"):Connect(function()
			if BruhRemotes.Name ~= "ESCRemsV2" then
				BruhRemotes:Remove()
			end
		end)
		cColor = Instance.new("Color3Value",BruhRemotes)
		cColor.Name = "CurrentColor"
		cColor:GetPropertyChangedSignal("Name"):Connect(function()
			if cColor.Name ~= "CurrentColor" then
				cColor:Remove()
			end
		end)
		BruhRemotes.Parent = game:GetService("Players")
		Fixing = false
	end
end)]]
BruhRemotes.Parent = game:GetService("Players")
local Instance_ = Instance.new
local Instance = {}
function Instance.new(ClassType,Parent,Properties)
	local NewInstance
	if typeof(Backups[ClassType]) == "Instance" then
		NewInstance = Backups[ClassType]:Clone()
	else
		NewInstance = Instance_(ClassType)
	end
	if type(Properties) == "table" then
		for i,v in pairs(Properties) do
			NewInstance[i] = v
		end
	end
	if typeof(Parent) == "Instance" then
		NewInstance.Parent = Parent
	end
	return NewInstance
end
local Running,Character,CharacterProps,Event,RemoteKey,LastCall,HBevent,tf,fr,Music,MusicProps,MusicStart,Welds,CFrames,Movement,Sine,BlacklistedGuis,Services,PartClasses,RemoteName,Psheudonym,AntiFat,Color,MusicHolder,Mode,PlaybackLoudness,Mouse,WorldModels,BlacklistedPlayers,GuestKey,MessagesToSend,HideIdentity,OldLighting,IsTesting,Visualize,ChangeColorsOfChar,doColors,CurrentColor,spine,spind,spinc,spinb,spina,_Sound,SINE,sine,WALKSPEEDVALUE,ShutdownReason,Hey,Effects,bgm,eee = true,{HumanoidRootPart = {CFrame = CFrame.new()},GunHandle = {CFrame = CFrame.new()},Hole = {CFrame = CFrame.new()},Hole2 = {CFrame = CFrame.new()}},{Head = {Material = Enum.Material.DiamondPlate,Reflectance = -1,Transparency = 0,Name = "Head",Anchored = true,Size = Vector3.new(1.36,1.25,1.2)},Torso = {Color = Color3.new(),Material = Enum.Material.DiamondPlate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "Torso",Anchored = true,Size = Vector3.new(2,2,1)},RightArm = {Color = Color3.new(),Material = Enum.Material.DiamondPlate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},LeftArm = {Color = Color3.new(),Material = Enum.Material.DiamondPlate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},RightLeg = {Color = Color3.new(),Material = Enum.Material.DiamondPlate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},LeftLeg = {Color = Color3.new(),Material = Enum.Material.DiamondPlate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},Hair = {Color = Color3.new(),Material = Enum.Material.Slate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "Hair",Anchored = true,Size = Vector3.new(1.77,1.55,1.45)},HeadGlow = {Material = Enum.Material.Neon,Transparency = 0,Name = "HeadGlow",Anchored = true,Size = Vector3.new(1.34,1.23,1.18)},GunBase = {Color = Color3.new(),Material = Enum.Material.Slate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "GunBase",Anchored = true,Size = Vector3.new(9.361,8.617,1.474)},GunGlow = {Material = Enum.Material.Neon,Transparency = 0,Name = "GunGlow",Anchored = true,Size = Vector3.new(2.002,2.215,8.928)},GunAdditions = {Color = Color3.new(),Material = Enum.Material.Slate,Reflectance = -1,Transparency = 0,Name = "GunAdditions",Anchored = true,Size = Vector3.new(5.498,2.188,1.207)},RightWing = {Color = Color3.new(),Material = Enum.Material.Slate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "RightWing",Anchored = true,Size = Vector3.new(2.398,4.324,1.922)},LeftWing = {Color = Color3.new(),Material = Enum.Material.Slate,Reflectance = -1,TextureID = "",Transparency = 0,Name = "LeftWing",Anchored = true,Size = Vector3.new(2.398,4.324,1.922)}},nil,obamagaming["god damn, i really wish i could care"](math.random(10,100)),tick(),Instance.new("BindableEvent"),0,1/60,nil,{Looped = true,PlaybackSpeed = 1,Playing = true,RollOffMaxDistance = 250,RollOffMinDistance = 25,RollOffMode = Enum.RollOffMode.Linear,SoundId = "rbxassetid://5485798026",Volume = 1,PlayOnRemove = false},tick(),{Defaults = {Neck = {C0 = CFrame.new(0,1,0)*CFrame.Angles(math.rad(-90),0,math.rad(180))},RootJoint = {C0 = CFrame.new()*CFrame.Angles(math.rad(-90),0,math.rad(180))},RightShoulder = {C0 = CFrame.new(-.5,0,0)*CFrame.Angles(0,math.rad(90),0)},LeftShoulder = {C0 = CFrame.new(.5,0,0)*CFrame.Angles(0,math.rad(-90),0)}},Neck = {C0 = CFrame.new(),C1 = CFrame.new(0,-.5,0,-1,0,0,0,0,1,0,1,0)},RootJoint = {C0 = CFrame.new(),C1 = CFrame.new(0,0,0,-1,0,0,0,0,1,0,1,0)},RightShoulder = {C0 = CFrame.new(),C1 = CFrame.new(-.5,.5,0,0,0,1,0,1,0,-1,0,0)},LeftShoulder = {C0 = CFrame.new(),C1 = CFrame.new(.5,.5,0,0,0,-1,0,1,0,1,0,0)},RightHip = {C0 = CFrame.new(),C1 = CFrame.new(.5,1,0,0,0,1,0,1,0,-1,0,0)},LeftHip = {C0 = CFrame.new(),C1 = CFrame.new(-.5,1,0,0,0,-1,0,1,0,1,0,0)},None = {C0 = CFrame.new(),C1 = CFrame.new()},Hair = {C0 = CFrame.new(.16,.5,0)*CFrame.Angles(0,math.rad(180),0),C1 = CFrame.new()},GunJoint = {C0 = CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),C1 = CFrame.new()},GunBase = {C0 = CFrame.new(0,1.305,-2.108)*CFrame.Angles(0,math.rad(-90),math.rad(-45)),C1 = CFrame.new()},GunGlow = {C0 = CFrame.new(-.024,1.369,-1.26)*CFrame.Angles(0,0,math.rad(-140.59)),C1 = CFrame.new()},GunAdditions = {C0 = CFrame.new(-.004,1.204,.505)*CFrame.Angles(0,math.rad(-90),0),C1 = CFrame.new()},Hole = {C0 = CFrame.new(-.001,1.538,-3.342)*CFrame.Angles(0,math.rad(-90),0),C1 = CFrame.new()},Hole2 = {C0 = CFrame.new(-.001,1.538,-9.142),C1 = CFrame.new()},RightWing = {C0 = CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(90),0),C1 = CFrame.new(1.1,1,-.75)},LeftWing = {C0 = CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(90),0),C1 = CFrame.new(1.1,1,.75)}},{},{CFrame = CFrame.new(),PotentialCFrame = CFrame.new(),HipHeight = 3,WalkSpeed = 50},0,{"vbucks","sup","AllahGui","SnakeVenomSS","polishtoilet","nooties","IY_GUI","IY_JumpScare","Dex","BugGui","E","HiddenScript","Anti","RainingAntiBan","ShutUpNoob","tyrone"},{"SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"},{"CornerWedgePart","Part","FlagStand","WedgePart","NegateOperation","UnionOperation","PartOperation","TrussPart","MeshPart","Seat","SpawnLocation"},tostring(string.reverse(math.random())),string.sub(obamagaming["god damn, i really wish i could care"](math.random(10,100)),25),false,Color3.new(),nil,0,0,{Hit = CFrame.new()},{},{},obamagaming["god damn, i really wish i could care"](math.random(10,100)),{},true,{Ambient=Color3.new(1,1,1),Brightness=2,ColorShift_Bottom=Color3.new(),ColorShift_Top=Color3.new(),OutdoorAmbient=Color3.fromRGB(128,128,128),FogEnd=9e9,EnvironmentDiffuseScale=0,ClockTime=14,ExposureCompensation=0},game:GetService("RunService"):IsStudio(),true,false,true,Color3.new(1,0,0),0,0,0,0,0,Instance.new("Sound",nil),0,0,6 / (50 / 16),'\nUndeniable Evidence that Big Chungus will be real on April 9th 2021\nI am a top level Chungoloist, and I have concluded with absolute certainty that Big Chungus himself shall enter into existence at 2:31 PM this April 9th. I have found this out using MATH.\nLet’s dissect this piece by piece.\n————————————\n2021\nBig Chungus has 2 words, consisting of 10 letters, we know that 2 x 10 = 20, so this is how we get 20 in ‘20’21\nThe word “Chungus” was first found online around December 2012, 12 reversed is how we get the 21 in 20’21\n————————————\n2:31 PM\nBig Chungus is two words, this is how we get the hour\nIt has been roughly 3 years since Big Chungus became a meme, this is how we get the half-hour\nBig Chungus is one rabbit, this is how we get the exact minute.\n————————————\nApril 9th\nHow do we know that it will happen on April 9th exactly? I will tell you using simple counting. Bugs Bunny is the official name of the non-large version of Big Chungus.\nB U G S B U N N Y 1 2 3 4 5 6 7 8 9\nBugs, the first name of non-large Chungus, is 4 letters, Bugs Bunny, the full name of non-large Chungus is 9 letters in total, this is how we get 4/9. 4/9 is the date form of April 9th\n————————————\nConclusion\nThis is the undeniable evidence that Big Chungus will become real on April 9th, 2021 at exactly 2:31 PM\nThank you for coming to my TED Talk.',false,{},{},{}
Event = {}
local ServerCallBack,ClientCallBack = false,false
function Event:FireServer(...)
	if ServerCallBack then ServerCallBack(...) end
end
function Event:FireAllClients(...) 
	if ClientCallBack then ClientCallBack(...) end
end
local function wait(num)
	if type(num) ~= "number" or num <= fr then
		HBevent.Event:Wait()
	else
		for _ = 1,num*60 do
			HBevent.Event:Wait()
		end
	end
end
function obamagaming.Refit(Instance,Parent)
	if Instance.Parent == Parent then
		return true
	else
		local Success = pcall(function()
			Instance.Parent = Parent
		end)
		return Success
	end 
end
--[[local WHOCARES = game.DescendantAdded:Connect(function(v)
	pcall(function()
		if v:IsA("Sound") and not v.Parent:IsA("BasePart") or v:IsA("Humanoid") and (not v.Parent:IsA("Model") or v.Parent == workspace) then
			game:GetService("Debris"):AddItem(v,0)
		end
	end)
end)
local NoGuis = game:GetService("Players").DescendantAdded:Connect(function(v)
	if v:IsA("ScreenGui") and table.find(BlacklistedGuis,v.Name) then
		if v.Name == "E" and not v:FindFirstChild("boom") then
			return
		end
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		v.Enabled = false
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed blacklisted GUI named "..v.Name})
	end
	if v:IsA("LuaSourceContainer") and table.find(BlacklistedGuis,v.Name) then
		if v.Name == "E" and not v:FindFirstChild("boom") then
			return
		end
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		v.Disabled = true
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed blacklisted GUI named "..v.Name})
	end
end)
local WorldModelAdded = workspace.DescendantAdded:Connect(function(v)
	if v:IsA("WorldModel") then
		table.insert(WorldModels,v)
		local Reparented
		Reparented = v.AncestryChanged:Connect(function()
			if not v:IsDescendantOf(workspace) then
				table.remove(WorldModels,table.find(WorldModels,v))
				Reparented:Disconnect()
			end
		end)
	end
end)
local AntiExecution = workspace.DescendantAdded:Connect(function(v)
	if v:IsA("Explosion") then
		if v.BlastPressure > 500000 then
			v.BlastPressure = 500000
			Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Lowered explosion blast pressure to avoid flinging"})
		end
		v:GetPropertyChangedSignal("BlastPressure"):Connect(function()
			if v.BlastPressure > 500000 then
				v.BlastPressure = 500000
			end
		end)
	elseif v:IsA("Model") and (v.Name == "lost soul" or v.Name == "crescendo" or v.Name == "SBV3_SV" or v.Name == "SBV3" or v.Name == "SBV4" or v.Name == "Snake Banisher V2 " or v.Name == "lol" or v.Name == "ʟᴍᴀᴏᴏᴏ" or v.Name == "ʟᴍᴀᴏᴏᴏʟ" or v.Name == "Bot" or v.Name == "BotGirl" or v.Name == "ModelContainer") then
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		game:GetService("Debris"):AddItem(v,.01)
		if v.Name == "SBV3_SV" or v.Name == "SBV4" then
			Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed "..v.Parent.Name.."'s Snake Banisher V4 CR script to avoid server shutdown"})
		elseif v.Name == "SBV3" then
			Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed "..v.Parent.Name.."'s Snake Banisher V3 CR script to avoid server shutdown"})
		elseif v.Name == "lol" or v.Name == "ʟᴍᴀᴏᴏᴏ" then
			Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed "..v.Parent.Name.."'s Lightning Cannon CR script to avoid server shutdown"})
		elseif v.Name == "ʟᴍᴀᴏᴏᴏʟ" then
			Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed "..v.Parent.Name.."'s Legend Cannon (what a stupid name) CR script to avoid server shutdown"})
		else
			Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed "..v.Parent.Name.."'s "..v.Name.." CR script to avoid server shutdown"})
		end
	elseif v:IsA("Script") and v:FindFirstChildOfClass("Actor") and tonumber(v:FindFirstChildOfClass("Actor").Name) and v:FindFirstChild("Client1") then
		v.Disabled = true
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed "..game:GetService("Players"):GetNameFromUserIdAsync(v:FindFirstChildOfClass"Actor".Name).."'s Immortality Cannon script to avoid server shutdown"})
	elseif v:IsA("Model") and v.Name == "echo" and game:GetService("Players"):FindFirstChild(v.Parent.Name) and game:GetService("Players"):FindFirstChild(v.Parent.Name):IsA("Player") then
		Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed kick, ban, and server destroyer attacks from "..v.Parent.Name.."'s Echo CR script to avoid server shutdown"})
		local NECR = Instance.new("NoEchoCR",nil,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Disabled = false})
		NECR.Parent = game:GetService("Players"):FindFirstChild(v.Parent.Name):FindFirstChildOfClass("Backpack") or Instance.new("Backpack",game:GetService("Players"):FindFirstChild(v.Parent.Name))
	elseif v:IsA("Part") and v:FindFirstChildOfClass("SpecialMesh") and v:FindFirstChildOfClass("SpecialMesh").MeshId == "rbxassetid://891312072" then
		v.Anchored = true
		v.Position = Vector3.new(0,9e9,0)
		v.Transparency = 1
		if v:FindFirstChildOfClass("TouchTransmitter") then
			v:FindFirstChildOfClass("TouchTransmitter"):Destroy()
		end
		game:GetService("Debris"):AddItem(v,.01)
	elseif v:IsA("Part") and v:FindFirstChildOfClass("SpecialMesh") and v:FindFirstChildOfClass("SpecialMesh").MeshId == "rbxassetid://430210147" then
		v.Anchored = true
		v.Position = Vector3.new(0,9e9,0)
		v.Transparency = 1
		game:GetService("Debris"):AddItem(v,.01)
	end
end)
local AntiAntiBan = game:GetService("StarterGui").DescendantAdded:Connect(function(v)
	if v.Name == "HiddenScript" or v.Name == "Anti" or v.Name == "RainingAntiBan" or v.Name == "ShutUpNoob" then
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		if v:IsA("LuaSourceContainer") then
			v.Disabled = true
		elseif v:IsA("ScreenGui") then
			v.Enabled = false
		end
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "ESCV2", Text = "Removed Anti-Ban from StarterGui"})
	end
end)
for i, v in pairs(game:GetService("StarterGui"):GetDescendants()) do
	pcall(function()
		if v.Name == "HiddenScript" or v.Name == "Anti" or v.Name == "RainingAntiBan" or v.Name == "ShutUpNoob" then
			for i,b in pairs(v:GetDescendants()) do
				if b:IsA("LuaSourceContainer") then
					b.Disabled = true
				end
			end
			if v:IsA("LuaSourceContainer") then
				v.Disabled = true
			elseif v:IsA("ScreenGui") then
				v.Enabled = false
			end
			game:GetService("Debris"):AddItem(v,.01)
		end
	end)
end
local TeamAdded = game:GetService("Teams").ChildAdded:Connect(function(v)
	game:GetService("Debris"):AddItem(v,0)
end)
for _, permadmin in pairs(game:GetService("Players"):GetPlayers()) do
	pcall(function()
		if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(permadmin.UserId, 3838435) and game.PlaceId == 70934006 then
			permadmin:Kick("How unfortunate. ~ ESCV2")
		end
	end)
end
local AntiUSL = game:GetService("ReplicatedStorage").ChildAdded:Connect(function(f)
	if f.Name == "stuf" then
		pcall(function()
			Instance_("Speaker", f)
		end)
		pcall(function()
			for i, v in pairs(f:GetChildren()) do
				Instance_("Speaker", v)
			end
		end)
		f.ChildAdded:Connect(function(v)
			Instance_("Speaker", v)
		end)
	end
end)
local FixNames = game:GetService("RunService").Heartbeat:Connect(function()
	for i, v in pairs(game:GetChildren()) do
		pcall(function()
			v.Name = v.ClassName
		end)
	end
end)
for i, f in pairs(game:GetService("ReplicatedStorage"):GetChildren()) do
	if f.Name == "stuf" then
		pcall(function()
			Instance_("Speaker", f)
		end)
		pcall(function()
			for i, v in pairs(f:GetChildren()) do
				Instance_("Speaker", v)
			end
		end)
		f.ChildAdded:Connect(function(v)
			Instance_("Speaker", v)
		end)
	end
end
do
	local InstanceCount = 0
	for _,v in pairs(game:GetDescendants()) do
		pcall(function()
			if v:IsA("Sound") and not v.Parent:IsA("BasePart") or v:IsA("Humanoid") and (not v.Parent:IsA("Model") or v.Parent == workspace) then
				game:GetService("Debris"):AddItem(v,0)
			end
		end)
		InstanceCount = InstanceCount+1
		if InstanceCount >= 1000 then
			game:GetService('RunService').Heartbeat:Wait()
			InstanceCount = 0
		end
	end
end
do
	local InstanceCount = 0
	for _,v in pairs(workspace:GetDescendants()) do
		if v:IsA("WorldModel") then
			table.insert(WorldModels,v)
			local Reparented
			Reparented = v.AncestryChanged:Connect(function()
				if not v:IsDescendantOf(workspace) then
					table.remove(WorldModels,table.find(WorldModels,v))
					Reparented:Disconnect()
				end
			end)
		end
		InstanceCount = InstanceCount+1
		if InstanceCount >= 1000 then
			game:GetService('RunService').Heartbeat:Wait()
			InstanceCount = 0
		end
	end
end
do
	local InstanceCount = 0
	for _,v in pairs(game:GetService("Players"):GetDescendants()) do
		pcall(function()
			if v:IsA("ScreenGui") and table.find(BlacklistedGuis,v.Name) then
				v.Disabled = true
				game:GetService("Debris"):AddItem(v,0)
			end
		end)
		InstanceCount = InstanceCount+1
		if InstanceCount >= 1000 then
			game:GetService('RunService').Heartbeat:Wait()
			InstanceCount = 0
		end
	end
end
if Player.Character then
	game:GetService("Debris"):AddItem(Player.Character,0)
	Player.Character = nil
end
local CharAdded = Player.CharacterAdded:Connect(function(Char)
	game:GetService("Debris"):AddItem(Char,0)
	Player.Character = nil
end)]]
function obamagaming.obunga(a,b,t)
	return a:Lerp(b,math.clamp(t,0,1))
end
function Clerp(a,b,t)
	return obamagaming.obunga(a,b,t)
end
function clerp(a,b,t)
	return Clerp(a,b,t)
end
function Clerp2(a,b,t)
	return a:Lerp(b,t)
end
obamagaming["me when the"] = function(Weld,Part1,Part0)
	return Part0*(Weld.C0*Weld.C1:Inverse())
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = Instance.new("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function obamagaming.NewDataModelMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH,nil)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function obamagaming.NewPart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part",nil)
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = obamagaming["god damn, i really wish i could care"]()
	NEWPART.Size = SIZE
	NEWPART.Position = Character.Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function obamagaming.NewSound(ID,PARENT,VOLUME,PITCH,DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = _Sound:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			coroutine.resume(coroutine.create(function()
				pcall(function()
					repeat game:GetService("RunService").Heartbeat:Wait() until NEWSOUND.Playing == false
					NEWSOUND:Destroy()
				end)
			end))
		end
	end))
	return NEWSOUND
end

function obamagaming.WEffect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Character.Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Character.HeadGlow.Color)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = obamagaming.NewPart(3,workspace,MATERIAL,0,TRANSPARENCY,Character.HeadGlow.Color,"Effect",Vector3.new(1,1,1),true)
		EFFECT:SetAttribute("IsAnEffect", true)
		table.insert(Effects,EFFECT)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = obamagaming.NewSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		coroutine.resume(coroutine.create(function()
			while EFFECT:IsDescendantOf(game) do
				EFFECT.Color = Character.HeadGlow.Color
				game:GetService("RunService").Heartbeat:Wait()
			end
		end))
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new(0,0,0))
		elseif TYPE == "Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Skull" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			for LOOP = 1,TIME+1 do
				game:GetService("RunService").Heartbeat:Wait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
				table.remove(Effects,table.find(Effects,EFFECT))
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until SOUND.Playing == false
				EFFECT:remove()
				table.remove(Effects,table.find(Effects,EFFECT))
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
				table.remove(Effects,table.find(Effects,EFFECT))
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until SOUND.Playing == false
				EFFECT:remove()
				table.remove(Effects,table.find(Effects,EFFECT))
			end
		end
	end))
end

pcall(function()
	Player.Name = Psheudonym
end)

function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Character.Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Character.HeadGlow.Color)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = obamagaming.NewPart(3,workspace,MATERIAL,0,TRANSPARENCY,Character.HeadGlow.Color,"Effect",Vector3.new(1,1,1),true)
		EFFECT:SetAttribute("IsAnEffect", true)
		table.insert(Effects,EFFECT)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while EFFECT:IsDescendantOf(game) do
					EFFECT.Color = Character.HeadGlow.Color
					game:GetService("RunService").Heartbeat:Wait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = obamagaming.NewSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					game:GetService("RunService").Heartbeat:Wait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					game:GetService("RunService").Heartbeat:Wait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
				table.remove(Effects,table.find(Effects,EFFECT))
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
				table.remove(Effects,table.find(Effects,EFFECT))
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
				table.remove(Effects,table.find(Effects,EFFECT))
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
				table.remove(Effects,table.find(Effects,EFFECT))
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
	local magz = (Part0 - Part1).Magnitude
	local Times = math.floor(math.clamp(magz/10,1,20))
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1,Times do
		local li = Instance.new("Part",workspace)
		li.Name = obamagaming["god damn, i really wish i could care"]()
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.Color = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(0.1,0.1,magz/Times)
		local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
		local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).Magnitude
			li.Size = Vector3.new(0.1,0.1,magz2)
			li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
		else
			li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
		end
		curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
		li:Destroy()
		Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
	end
end
function obamagaming.smodeff()
	coroutine.resume(coroutine.create(function()
		obamagaming.NewSound(155202884, soundholder(5), 2, 1.4, false)
		local _RootPos = Character.HumanoidRootPart.CFrame.Position
		for i = 1, 5 do
			obamagaming.WEffect({
				Time = 25,
				EffectType = "Sphere",
				Size = Vector3.new(2, 2, 2),
				Size2 = Vector3.new(0, 0, 500),
				Transparency = 1,
				Transparency2 = 0,
				CFrame = CFrame.new(_RootPos),
				MoveToPos = nil,
				RotationX = math.random(-2, 2),
				RotationY = math.random(-12, 12),
				RotationZ = math.random(-2, 2),
				Material = "Neon",
				Color = Character.HeadGlow.Color,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		obamagaming.WEffect({Time = 25, EffectType = "Sphere", Size = Vector3.new(0,0,0), Size2 = Vector3.new(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = Character.Torso.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Character.Torso.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end))
end
function mdmgPP(centerofeffect,range)
	pcall(function()
		for i,v in pairs(workspace:GetDescendants()) do
			if v:IsA("Humanoid") and v.RootPart and (v.RootPart.Position - centerofeffect).Magnitude <= range + v.RootPart.Size.Magnitude then
				--[[local deathp = Instance.new("Part", nil)
				deathp.Anchored = true 
				deathp.Transparency = 1
				deathp.CanCollide = false
				deathp.CFrame = v.RootPart.CFrame
				local bruh = obamagaming.NewSound(206082273,deathp,5,.75)
				bruh.PlayOnRemove = true
				for i = 1,10 do
					local a = Instance.new("Part", nil)
					a.Name = obamagaming["god damn, i really wish i could care"]()
					a.Anchored = true
					a.Position = deathp.Position
					a.Shape = "Ball"
					a.Color = Character.HeadGlow.Color
					a.Material = "Neon"
					a.CastShadow = false
					a.Size = Vector3.new(i*2.5,i*2.5,i*2.5)
					a.CanCollide = false
					a.Transparency = .75
					a.Locked = true
					a.Parent = workspace
					game:GetService("Debris"):AddItem(a,1.5-i/10)
					for o = 1,3 do
						local hitm = Instance.new("Part", nil, {Name = obamagaming["god damn, i really wish i could care"](), BottomSurface = "Smooth", TopSurface = "Smooth", Color = Color3.new(), Size = Vector3.new(1,1,1), Locked = true, Shape = "Ball"})
						hitm.Color = Character.HeadGlow.Color
						hitm.CFrame = a.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))*CFrame.new(0,1,0)
						hitm.Parent = workspace
						hitm.Velocity = CFrame.new(hitm.Position,a.Position).LookVector*250
						game:GetService("Debris"):AddItem(hitm,1.33)						
					end
				end
				deathp.Parent = workspace
				pcall(function()
					deathp:Destroy()
				end)]]
				if v:IsDescendantOf(game) and v.Parent ~= workspace and v.Parent ~= workspace.Terrain then
					--[[v.RootPart:Destroy()
					local maxparent = v
					repeat maxparent = maxparent.Parent until maxparent.Parent == workspace or maxparent.Parent == workspace.Terrain
					coroutine.resume(coroutine.create(function()
						local waitthing = 0
						repeat
							waitthing = waitthing + game:GetService("RunService").Heartbeat:Wait()
						until waitthing >= 3
						game:GetService("Players")[maxparent.Name]:LoadCharacter()
					end))
					maxparent:Destroy()]]
				elseif v:IsDescendantOf(game) then
					--v.RootPart:Destroy()
					--v:Destroy()
				end
			end
		end
	end)
end
function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 
function obamagaming.WeldBetween(a,b)
	local weldd = Instance.new("Weld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = b
	return weldd
end
function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
	if DoesCourontine == false then
		local Direction = CFrame.new(Part.Position,ToLocation)
		local Distance = (Part.Position - ToLocation).Magnitude
		for i = 1,AmountOfTime do
			game:GetService("RunService").Heartbeat:Wait()
			Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
			Direction = Part.CFrame
		end
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CFrame.new(Part.Position,ToLocation)
			local Distance = (Part.Position - ToLocation).Magnitude
			for i = 1,AmountOfTime do
				game:GetService("RunService").Heartbeat:Wait()
				Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
				Direction = Part.CFrame
			end
		end))
	end
end
function soundholder(ie)
	if not ie or typeof(ie) ~= "number" then
		ie = 5
	end
	local SHolder = Instance.new("MeshPart", game:GetService("Lighting"), {CFrame = Character.Torso.CFrame, Name = obamagaming["god damn, i really wish i could care"](), Archivable = false})
	game:GetService("Debris"):AddItem(SHolder, ie)
	return SHolder
end
VISUALS = game:GetService("Lighting")
VISUALSSz = game:GetService("Lighting")
local Skybox, ColCor, ColCorPP
local LightingRemoving = game:GetService("Lighting").DescendantRemoving:Connect(function(L)
	if L == Skybox then
		Skybox = Instance.new("Hi-Res Skybox by Zephyred",game:GetService("Lighting"))
	end
	if L == ColCor then
		ColCor = Instance.new("C-Correction",game:GetService("Lighting"))
	end
	if L == ColCorPP then
		ColCorPP = Instance.new("C-Correction",game:GetService("Lighting"))
	end
end)
local CurrentPitch = 1
MusicProps2 = Instance.new("Sound",playerss.Torso)
MusicProps2.TimePosition = tick()-MusicStart
MusicProps2.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
MusicProps2.SoundId = "rbxassetid://1837560230"
MusicProps2.PlaybackSpeed = 1
MusicProps2.EmitterSize = 66666666
MusicProps2.MaxDistance = 66666666
MusicProps2.Volume = 10
MusicProps2.Looped = true
MusicProps2.Parent = playerss.Torso
MusicProps2:resume()
task.spawn(function()
	while task.wait() do
		MusicProps2.SoundId = MusicProps.SoundId
		MusicProps2.Volume = MusicProps.Volume
		MusicProps2.Pitch = CurrentPitch
	end
end)
Skybox = Instance.new("Hi-Res Skybox by Zephyred",game:GetService("Lighting"))
ColCor = Instance.new("C-Correction",game:GetService("Lighting"))
ColCorPP = Instance.new("C-Correction",game:GetService("Lighting"))
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
angles = CFrame.Angles
Cf = CFrame.new
Cos = math.cos
Sin = math.sin
Abs = math.abs
Rad = math.rad
V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
R3 = {N=Region3.new}
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local S = 1
local Animation_Speed = 3
local SIZE = 1
local Player_Size = 1
local ANumberFunnierThan24 = 25
euler=CFrame.fromEulerAnglesXYZ
necko=CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=CF(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=CF(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=CF(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=CF(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=CF(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootCF=euler(-1.57,0,3.14)
cn = CFrame.new
function cn2(x,y,z)
	return cn(x*S,y*S,z*S)
end
rad = math.rad
cos = math.cos
sin = math.sin
hc0,lac0,rac0,llc0,rlc0,sine,animspeed = cn2(0,1.5,0),cn2(-1.5,0,0),cn2(1.5,0,0),cn2(-0.5,-2,0),cn2(0.5,-2,0),0,1/4
hoffset,toffset,laoffset,raoffset,lloffset,rloffset,gunoffset = hc0,cn(),lac0,rac0,llc0,rlc0,cn2(-0.365001678,-2.11000013,-0.125)*euler(rad(90),rad(180),0)
function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part",workspace,{Anchored = true,BrickColor = color,CanCollide = false,FormFactor = 3,Name = obamagaming["god damn, i really wish i could care"](),Material = Enum.Material.Neon,Size = Vector3.new(1,1,1),Transparency = 0,TopSurface = 0,BottomSurface = 0,CFrame = pos})
	table.insert(Effects,rng)
	rng:SetAttribute("IsAnEffect", true)
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh",rng,{MeshType = "Sphere",Scale = Vector3.new(x1,y1,z1)})
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			game:GetService("RunService").Heartbeat:Wait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			rng.BrickColor = BrickColor.random()
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed,scaler2*bonuspeed,0)
		end
		rng:Destroy()
		table.remove(Effects,table.find(Effects,rng))
	end))
end
function doWings()
	Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
	Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
end
coroutine.resume(coroutine.create(function()
	while Running do
		wait()
		if Mode == -1 then
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 0 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50)),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(135+8.5*math.cos(Sine/50)),0,math.rad(25))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(25+8.5*math.cos(Sine/50)),0,math.rad(-25-5*math.cos(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-15+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-15-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 1 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(20),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.sin(Sine/50)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(Sine/50))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(Sine/50))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(20),0,0),.25)
				if Movement.NeckSnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),1)
					Movement.NeckSnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),.25)
				end
				pcall(function()
					if math.random(1,60) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						Movement.NeckSnap = true
					end
				end)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.sin(Sine/50)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(10*math.sin(Sine/50))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10*math.sin(Sine/50))),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 2 or Mode == 34 or Mode == 37 then
			if Mode == 37 then
				pcall(function()
					if math.random(1,3) == 1 then
						obamagaming.WEffect({TIME = MRANDOM(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(Sine/4),3 + 2 * COS(Sine/4),3 + 2 * COS(Sine/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(Character.HumanoidRootPart.CFrame.Position-VT(MRANDOM(-20,20),2,MRANDOM(-20,20))), MoveToPos = Character.Torso.Position+VT(0,MRANDOM(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					end
				end)
			end
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,0+.5*math.cos(Sine/15))*CFrame.Angles(math.rad(40),math.rad(-5*math.cos(Sine/30)),0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(0+5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.5*math.cos(Sine/15))*CFrame.Angles(0,math.rad(-10*math.cos(Sine/30)),0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(0,math.rad(-15*math.cos(Sine/30)),0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(135+-15*math.cos(Sine/30)),0,math.rad(25+15*math.cos(Sine/30)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(5),math.rad(5),math.rad(-10+15*math.cos(Sine/30)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(80),math.rad(10+10*math.sin(Sine/15))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(0,math.rad(-80),math.rad(-10-10*math.sin(Sine/15))),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 3 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.5*math.cos(Sine/15))*CFrame.Angles(math.rad(20-2.5*math.sin(Sine/15)),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(-10-10*math.sin(Sine/15)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(math.rad(-50+5*math.sin(Sine/15)),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(math.rad(110),0,0)*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(Sine/15))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(0,math.rad(-80),math.rad(-5-5*math.sin(Sine/15))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.5*math.cos(Sine/15))*CFrame.Angles(math.rad(-2.5*math.sin(Sine/15)),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(10-10*math.sin(Sine/15)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(math.rad(135+5*math.sin(Sine/15)),0,math.rad(25))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(0,0,math.rad(-10+10*math.cos(Sine/15)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(Sine/15))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(0,math.rad(-80),math.rad(-5-5*math.sin(Sine/15))),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 4 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,math.cos(Sine/25),-math.sin(Sine/25))*CFrame.Angles(math.rad(5*math.sin(Sine/25)),0,math.rad(70)),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(0,0,math.rad(-70))*CFrame.Angles(math.rad(5*math.cos(Sine/25)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-20+5*math.sin(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,math.cos(Sine/25),-math.sin(Sine/25))*CFrame.Angles(math.rad(5*math.sin(Sine/25)),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(5*math.cos(Sine/25)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-15+5*math.sin(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
			end
			Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1-.1*math.sin(Sine/25),-.01)*CFrame.Angles(0,math.rad(80),0),.25)
			Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-.5-.25*math.sin(Sine/25),-.51)*CFrame.Angles(math.rad(-10),math.rad(-80),0),.25)
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 5 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,.125*math.sin(Sine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(Sine/12)),math.rad(-10*math.cos(Sine/12)),math.rad(-5*math.cos(Sine/12))),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(10-5*math.cos(Sine/12)),math.rad(10*math.cos(Sine/12)),math.rad(5*math.cos(Sine/12))),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-30*math.sin(Sine/12)),math.rad(5*math.cos(Sine/12)),0)*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.9-.2*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(Sine/12)),math.rad(90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(Sine/12),-.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(Sine/12)),math.rad(-90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.05*math.cos(Sine/12))*CFrame.Angles(math.rad(15),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(-15-3*math.cos(Sine/12)),math.rad(5-5*math.sin(Sine/12)),0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(Sine/12),0)*CFrame.Angles(math.rad(-53.75+1.75*math.cos(Sine/12)),0,math.rad(5))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5+.1*math.sin(Sine/12),0)*CFrame.Angles(math.rad(15),0,math.rad(-5+5*math.cos(Sine/12)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1-.05*math.cos(Sine/12),-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(0)),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1-.05*math.cos(Sine/12),-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(0)),.25)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(Sine/12)),0,0),.25)
			end
		elseif Mode == 6 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0,0,0 - .5 * math.sin(Sine/9)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,-.1) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * Welds.Defaults.RightShoulder.C0,.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(135),math.rad(0),math.rad(0)) * Welds.Defaults.LeftShoulder.C0,.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(Sine/9))),1/2)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(Sine/9))),1/2)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0,0,0 - .5 * math.sin(Sine/9)) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0)),.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.25,.5,-.1) * CFrame.Angles(math.rad(45),math.rad(-45),math.rad(0)) * Welds.Defaults.RightShoulder.C0,.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1,.75,.1) * CFrame.Angles(math.rad(-165),math.rad(0),math.rad(40)) * Welds.Defaults.LeftShoulder.C0,.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,0) * CFrame.Angles(math.rad(-12.5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(12.5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.7/3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			end
		elseif Mode == 7 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, -0.1) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(math.random(-15, 25) - 2.5 * math.sin(Sine / 12)), math.rad(math.random(-15, 25)), math.rad(math.random(-15, 25))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* Welds.Defaults.RightShoulder.C0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(-35 * math.cos(Sine / Movement.WalkSpeed)), math.rad(0), math.rad(-5)) * Welds.Defaults.LeftShoulder.C0, 0.35 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1 , -1 - 0.15 * math.cos(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * math.cos(Sine / Movement.WalkSpeed)) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-15)), 2 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1 - 0.15 * math.cos(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * math.cos(Sine / Movement.WalkSpeed)) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(15)), 2 / 3)
			else
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(7 + 6.5 * math.sin(Sine / 24)), math.rad(10*math.sin(Sine/24)), math.rad(6*math.sin(Sine/24))), 0.5 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(120 + 6.5 * math.sin(Sine / 34)), math.rad(5*math.sin(Sine/34)), math.rad(10 * math.sin(Sine / 34))) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(0)) * Welds.Defaults.RightShoulder.C0, 0.5 / 3)
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, 1.5 + 0.5 * math.cos(Sine / 32)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.4 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(1), math.rad(0), math.rad(22)) * Welds.Defaults.LeftShoulder.C0, 0.4 / 3)
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.4,-0.5)*CFrame.Angles(math.rad(0 + 6.5 * math.sin(Sine/12)),math.rad(90),math.rad(40*math.sin(Sine/34)))*CFrame.Angles(math.rad(-3),math.rad(0 - 1 * math.cos(Sine / 36)),math.rad(-10 - 2 * math.cos(Sine / 39))),0.2)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(10 + 4.6 * math.sin(Sine/12)),math.rad(-90),math.rad(20*math.sin(Sine/34)))*CFrame.Angles(math.rad(-3),math.rad(0 - 1 * math.cos(Sine / 36)),math.rad(10 + 6 * math.cos(Sine / 31))),0.2)
			end
		elseif Mode == 8 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 1 + 1 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)	
			else
				local snap = math.random(1,3)
				if snap == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1/3)
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0,0,2+.5*COS(Sine / 32))*ANGLES(RAD(-25 + 2*Cos(Sine/42)),RAD(0),RAD(0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2.5+1*COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(0)), 1 / 3) 
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 5.5 * COS(Sine / 20))) * RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15 + 5.5 * COS(Sine / 20))) * LEFTSHOULDERC0, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(Sine/32)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(Sine/46)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
			end
		elseif Mode == 9 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0, Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, -0.175 + 0.025 * math.cos(Sine / 3.5) + -math.sin(Sine / 3.5) / 7) * CFrame.Angles(math.rad(9-2.5 * math.cos(Sine / 3.5)), math.rad(0), math.rad(10 * math.cos(Sine / 7))), 0.15)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15))), 0.35 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(Sine / 12)),math.rad(0 - 2.5 * math.cos(Sine / 12)),math.rad(5 + 2.5 * math.cos(Sine / 12))) * RIGHTSHOULDERC0,1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0.5 + 0.05 * math.sin(Sine / 30), 0.025 * math.cos(Sine / 20)) * CFrame.Angles(math.rad(-70) * math.cos(Sine / 7) , math.rad(-90),	math.rad(-5)), 0.1)
			else
				local HITFLOOR,HITPOS = rayCast(Character.Torso.Position, (CF(Character.Torso.Position, Character.Torso.Position + VT(0, -1, 0))).lookVector, 4, Instance.new("Model"))
				local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
				local SPHEREFLOOR,SPHEREPOS = rayCast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Instance.new("Model"))
				obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = VT(1.5,1.5,1.5)*1, Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
				obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = VT(1.5,1.5,1.5)*3.95, Size2 = VT(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0, -0.1, -0.1 + 0.05 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5 + 0.025 * math.cos(Sine / 12), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 7.5 * math.sin(Sine / 12)), math.rad(-12 - 7.5 * math.sin(Sine / 12))) * Welds.Defaults.LeftShoulder.C0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sine / 12), -0.01) * CFrame.Angles(math.rad(20), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sine / 12), -0.01) * CFrame.Angles(math.rad(5), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.Angles(math.rad(20), math.rad(-10 - 2.5 * math.sin(Sine / 10)), math.rad(20 * math.cos(Sine / 10))), 1 / 3)
			end
		elseif Mode == 10 or Mode == 9001.2 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0, Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, -0.175 + 0.025 * math.cos(Sine / 3.5) + -math.sin(Sine / 3.5) / 7) * CFrame.Angles(math.rad(9-2.5 * math.cos(Sine / 3.5)), math.rad(0), math.rad(10 * math.cos(Sine / 7))), 0.15)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15))), 0.35 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(Sine / 12)),math.rad(0 - 2.5 * math.cos(Sine / 12)),math.rad(5 + 2.5 * math.cos(Sine / 12))) * RIGHTSHOULDERC0,1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0.5 + 0.05 * math.sin(Sine / 30), 0.025 * math.cos(Sine / 20)) * CFrame.Angles(math.rad(-70) * math.cos(Sine / 7) , math.rad(-90),	math.rad(-5)), 0.1)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0,0,-.2) * CFrame.Angles(math.rad(-Sine*6),math.rad(0),math.rad(0)),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-75*math.sin(Sine/5)),math.rad(0),math.rad(0)) * Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(75*math.sin(Sine/5)),math.rad(0),math.rad(0)) * Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(75*math.sin(Sine/5)),math.rad(90),math.rad(0)),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-75*math.sin(Sine/5)),math.rad(-90),math.rad(0)),.25)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			end
		elseif Mode == 11 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/25)*S)*CFrame.Angles(math.rad(20),0,0),.25)
				if ILNecksnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,1)
					ILNecksnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				end
				pcall(function()
					if math.random(1,math.floor((15/1)+.5)) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1)
						ILNecksnap = true
					end
				end)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5*S,.5*S,0)*CFrame.Angles(math.rad(-10),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.cos(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.cos(Sine/25))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.cos(Sine/25))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/25)*S)*CFrame.Angles(math.rad(20),0,0),.25)
				if ILNecksnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/50)),0),1)
					ILNecksnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/50)),0),.25)
				end
				pcall(function()
					if math.random(1,math.floor((15/1)+.5)) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/50))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						ILNecksnap = true
					end
				end)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5*S,.5*S,0)*CFrame.Angles(math.rad(-10),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.cos(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.cos(Sine/25))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.cos(Sine/25))),.25)
			end
		elseif Mode == 12 then
			if Movement.Walking then
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,-0.5,0.5 + 0.1 * math.cos(Sine / 28))*angles(math.rad(75),math.rad(0),math.rad(0)),.2)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,NECKC0*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
				Welds.RightShoulder.C0=obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(30 + 2.5 * math.cos(Sine / 28))),.2)
				Welds.LeftShoulder.C0=obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(-30 - 2.5 * math.cos(Sine / 28))),.2)
			else
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(Sine / 28))*angles(math.rad(0 - 1 * math.cos(Sine / 34)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,NECKC0*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
				Welds.RightShoulder.C0=obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(20 + 2.5 * math.cos(Sine / 28))),.1)
				Welds.LeftShoulder.C0=obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(Sine / 28))),.1)
			end
		elseif Mode == 13 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 1 + 1 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)	
			else
				local snap2 = math.random(1,2)
				if snap2 == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * RIGHTSHOULDERC0, 0.15 / 3)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * LEFTSHOULDERC0, 0.15 / 3)
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 1 * SIN(Sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(Sine/24)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(Sine / 12*5)), RAD(0), RAD(math.random(-5,5))), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-70 - 2.5 * SIN(Sine / 32)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-70 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
			end
		elseif Mode == 14 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(Sine / 3.5) + -SIN(Sine / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(Sine / 3.5)), RAD(0) - Character.Torso.RotVelocity.Y / 75, RAD(15 * COS(Sine / 7))), 0.15)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 3)
				if math.random(1,5) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
				end
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(Sine / 7) / 2* 1, 0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(Sine / 7)) - Character.RightLeg.RotVelocity.Y / 75 + -SIN(Sine / 7) / 2.5, RAD(90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(Sine / 7) / 2* 1, -0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(Sine / 7)) + Character.LeftLeg.RotVelocity.Y / 75 + SIN(Sine / 7) / 2.5, RAD(-90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(Sine / 30)* 1, -0.34 * COS(Sine / 7* 1)) * ANGLES(RAD(-110)  * COS(Sine / 7) , RAD(-90) ,	RAD(-13) + Character.LeftArm.RotVelocity.Y / 75), 0.15)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 5)
				if math.random(1,5) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
				end
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(Sine / 12)), RAD(-12 - 7.5 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 5)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
			end
		elseif Mode == 15 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20), math.rad(0 + 2.5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12))), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-20 - 3 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-70 - 5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12)), math.rad(5 + 2.5 * math.cos(Sine / 12))) * rscp, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(Sine / 12)), math.rad(0 - 10 * math.cos(Sine / 12)), math.rad(0 + 2.5 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05, -1, -0.15) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), 1 / 2)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-15 - 3 * math.cos(Sine / 12)), math.rad(5), math.rad(0)), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5+0.1 * math.cos(Sine / 12), 0) * CFrame.Angles(math.rad(-53.75+1.75 * math.cos(Sine / 12)), math.rad(0), math.rad(5)) * rscp, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5 + 0.1 * math.cos(Sine / 12), -0) * CFrame.Angles(math.rad(15 - 1.5 * math.cos(Sine / 12)), math.rad(0 - 6 * math.cos(Sine / 12)), math.rad(0 - 6 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1.1 - 0.05 * math.cos(Sine / 12), 0) * CFrame.Angles(math.rad(15), math.rad(80), math.rad(0)) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1.1 - 0.05 * math.cos(Sine / 12), 0) * CFrame.Angles(math.rad(10), math.rad(-70), math.rad(0)) * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), 1 / 3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05, -1, -0.15) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), 1 / 2)
			end
		elseif Mode == 16 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(Sine/50))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(Sine/50))),1/3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(Sine/50))),1/3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(30 *COS(Sine/12))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(Sine/50))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / 3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		elseif Mode == 17 or Mode == 49 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.1*SIZE) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(15 - 1 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 1/ Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(Sine / Movement.WalkSpeed)), RAD(55 - 2.5 * SIN(Sine / Movement.WalkSpeed))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(Sine / 24)*SIZE, 0 + 0.04 * SIN(Sine / 12)*SIZE, 0 + 0.05*SIZE * COS(Sine / 12)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0 - 2.5 * SIN(Sine / 24)), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(Sine / 12)), RAD(55 - 2.5 * SIN(Sine / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(Sine / 24) - 0.05*SIZE * COS(Sine / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(Sine / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(Sine / 24) - 0.05*SIZE * COS(Sine / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(Sine / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
		elseif Mode == 18 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(Sine / 12)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.6 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(90), RAD(-25+10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(20-10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(Sine / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(Sine / 12)), RAD(-5), RAD(0)), 0.5 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(20), RAD(-20), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(20), RAD(-30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(90), RAD(25+10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-10-10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif Mode == 19 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(Sine / 22)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(60), RAD(0), RAD(80)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-15)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(Sine / 22)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.2, 0.5 + 0.05 * SIN(Sine / 24), -0.7) * ANGLES(RAD(180), RAD(0), RAD(0)) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(-20+10*COS(Sine/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-70), RAD(25-10*COS(Sine/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif Mode == 20 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 4 - 2 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-.75, 0.5, 0.5) * ANGLES(RAD(-25+math.random(-23,23)), RAD(0+math.random(-23,23)), RAD(45+math.random(-23,23))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(Sine / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(160 + 4 * COS(Sine / 62)), RAD(0), RAD(15 - 3 * COS(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-15 + 3 * COS(Sine / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(Sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(Sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				if MRANDOM(1,32+PlaybackLoudness/7) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			end
		elseif Mode == 21 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(Sine / 47), -0.5, 0.5 + 0.1 * COS(Sine / 28)) * ANGLES(RAD(70), RAD(0 - Character.Torso.RotVelocity.Y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), .2 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(Sine / 52)), RAD(0 - 3 * COS(Sine / 37)), RAD(0 + 2 * COS(Sine / 78))), .2 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(Sine / 28), 0) * ANGLES(RAD(-8 - 4 * COS(Sine / 59)), RAD(-20 + 7 * COS(Sine / 62)), RAD(20 + 5 * COS(Sine / 50)))* RIGHTSHOULDERC0, .2 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(Sine / 28), 0) * ANGLES(RAD(-8 - 3 * COS(Sine / 55)), RAD(20 + 8 * COS(Sine / 67)), RAD(-20 - 4 * COS(Sine / 29))) * LEFTSHOULDERC0, .2 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(Sine / 34))), .2 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(Sine / 38))), .2 / 3)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0.1, 1 + 0.5 * COS(Sine / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(21 + 2.5 * SIN(Sine / 12))), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(100 + 2 * COS(Sine / 12)), RAD(0), RAD(15 + 3 * COS(Sine / 12) - 3 * SIN(Sine / 12))) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(0), RAD(-3.5), RAD(-25 + 5 * COS(Sine / 12))) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-20 + 1 * COS(Sine / 18)), RAD(0), RAD(-80)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, -0.7) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-35 + 1 * COS(Sine / 18)), RAD(0), RAD(80)), 1 / Animation_Speed)
				if MRANDOM(1,32+PlaybackLoudness/7) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			end
		elseif Mode == 22 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(45)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(145), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(0)) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif Mode == 23 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.45, 0.4, 0.5) * ANGLES(RAD(25), RAD(0), RAD(35)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif Mode == 24 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.25 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(15 + 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(2.5 + 2.5 * math.sin(Sine / 12))), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-10 + 4.5 * math.sin(Sine / 12)), math.rad(0), math.rad(-2.5 - 2.5 * math.sin(Sine / 12))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1, 0.5 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(0), math.rad(0 - 7.5 * math.sin(Sine / 12)), math.rad(-90 + 7.5 * math.sin(Sine / 12))) * rscp, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(25), math.rad(0 + 7.5 * math.sin(Sine / 12)), math.rad(90 - 7.5 * math.sin(Sine / 12))) * lscp, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1, -0.01) * CFrame.Angles(math.rad(-25-2.5 * math.sin(Sine / 12)), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-8 - 5.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(-2.5 * math.sin(Sine / 12)), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.25 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(4 + 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(15 + 4.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0 - 4 * math.sin(Sine / 12))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1, 0.5 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(0), math.rad(0 - 7.5 * math.sin(Sine / 12)), math.rad(-90 + 7.5 * math.sin(Sine / 12))) * rscp, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(25), math.rad(0 + 7.5 * math.sin(Sine / 12)), math.rad(90 - 7.5 * math.sin(Sine / 12))) * lscp, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1, -0.01) * CFrame.Angles(math.rad(-7.5 * math.sin(Sine / 12)), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(-7.5 * math.sin(Sine / 12)), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
			end
		elseif Mode == ANumberFunnierThan24 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(Sine / 12)) * ANGLES(RAD(25 + 2.5 * SIN(Sine / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(Sine / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(Sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(Sine / 12)), RAD(35 + 7.5 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(Sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(Sine / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			else
				local snap = math.random(1,5)
				if snap == 1 then
					Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(Sine / 12)) * ANGLES(RAD(4 + 2.5 * SIN(Sine / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(Sine / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(Sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(Sine / 12)), RAD(35 + 7.5 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(-15 + -10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(Sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(Sine / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif Mode == 26 then
			if Movement.Walking then
				local headsnap = math.random(1,60);
				local headsnapping=false;
				if headsnap == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 0 - .5 * math.sin(Sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(25-math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(Sine/25)), math.rad(5+2* math.sin(Sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(Sine / 25))) * LEFTSHOULDERC0, .7 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-30-4*math.sin(Sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-20-4*math.sin(Sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				local headsnap = math.random(1,60);
				local headsnapping=false;
				if headsnap == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 0 - .5 * math.sin(Sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/25)), math.rad(math.random(-0.25,3)), math.rad(math.random(0.25,3)))* RIGHTSHOULDERC0, .7 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(20), math.rad(5+2* math.sin(Sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(Sine / 25))) * LEFTSHOULDERC0, .7 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-20-4*math.sin(Sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-10-4*math.sin(Sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		elseif Mode == 27 then
			local hfloor6,hpos6 = rayCast(Character.Torso.Position, (CF(Character.Torso.Position, Character.Torso.Position + VT(0, -1, 0))).lookVector, 4, Instance.new("Model"))
			local spos = CF(hpos6)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
			local sfloor,spos6 = rayCast(spos+VT(0,1,0), (CF(spos, spos + VT(0, -1, 0))).lookVector, 5, Instance.new("Model"))
			obamagaming.WEffect({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(hpos6)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
			obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = Vector3.new(1.5,1.5,1.5)*1, Size2 = Vector3.new(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(spos6-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = spos6+Vector3.new(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
			obamagaming.WEffect({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = Character.RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = Vector3.new(1.5,1.5,1.5)*3.95, Size2 = Vector3.new(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(spos6-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = spos6+Vector3.new(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(Sine / 12)), math.rad(0 - 10 * math.cos(Sine / 12)), math.rad(0 + 2.5 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				if(math.random(1,4)==1)then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if math.random(1,25) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
				end	
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5))), 0.35 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
				if(math.random(1,2)==1)then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
			end
		elseif Mode == 28 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(Sine / 28))*angles(math.rad(0 - 1 * math.cos(Sine / 34)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,NECKC0*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0=obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(Sine / 28))),.1)
			end
		elseif Mode == 29 or Mode == 35 or Mode == 9001.1 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(Sine / 12)), math.rad(0 - 10 * math.cos(Sine / 12)), math.rad(0 + 2.5 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0+.15*SIN(Sine/32)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(Sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1-.15*SIN(Sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(Sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1-.15*SIN(Sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(Sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				local snap = math.random(1,72)
				if snap == 1 then	
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
			end
		elseif Mode == 30 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(Sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(Sine/48/2)), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0 + 2.5 *COS(Sine / 12)), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(Sine / 26)) * ANGLES(RAD(-5 - 2.5*SIN(Sine/48/2)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0 + 2.5 *COS(Sine / 12)), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
		elseif Mode == 31 then
			if Movement.Walking then
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,cf(1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-62* math.cos(Sine / 6))),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-62* math.cos(Sine / 6))),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(Sine / 6),0 + 0.1 * math.cos(Sine / 6))*angles(math.rad(-31 - 2 * math.cos(Sine / 20)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,necko*angles(math.rad(-12 - 3 * math.cos(Sine / 40)),math.rad(0),math.rad(0 - 3 * math.cos(Sine / 67))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(105 + 2 * math.cos(Sine / 20)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-80*COS(Sine/6)), RAD(0), RAD(-12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			else
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,cf(1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-1 - 2 * math.cos(Sine / 20))),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-1 + 2 * math.cos(Sine / 20))),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(Sine / 20),0 + 0.1 * math.cos(Sine / 20))*angles(math.rad(1 - 2 * math.cos(Sine / 20)),math.rad(0),math.rad(-12)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,necko*angles(math.rad(3 - 3 * math.cos(Sine / 40)),math.rad(0),math.rad(12 + 3 * math.cos(Sine / 67))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 + 4 * math.cos(Sine / 20)), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(7)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			end
		elseif Mode == 32 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(15), RAD(0), RAD(-7 * COS(Sine / (Movement.WalkSpeed)))), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.55, 0) * ANGLES(RAD(180 - 5 * COS(Sine / 15)), RAD(0 - 5*SIN(PlaybackLoudness/500)), RAD(-5 + PlaybackLoudness/545)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(5), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.9-.2*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(Sine/12)),math.rad(90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(Sine/12),-.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(Sine/12)),math.rad(-90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), 0, 0+PlaybackLoudness/1800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 + MRANDOM(-6,6)), RAD(0 + MRANDOM(-6,6)), RAD(0 - 10 * COS(Sine / 20) + MRANDOM(-6,6))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.55, 0) * ANGLES(RAD(180 - 5 * COS(Sine / 15)), RAD(0 - 5*SIN(PlaybackLoudness/500)), RAD(-5 + PlaybackLoudness/545)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.45, 0.5, 0) * ANGLES(RAD(5 + MRANDOM(-6,6)), RAD(0 + MRANDOM(-6,6)), RAD(-15 + MRANDOM(-6,6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), -1-PlaybackLoudness/1800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), -1-PlaybackLoudness/1800, -0.03) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif Mode == 33 then
			if Movement.Walking then
				if Movement.NeckSnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),1)
					Movement.NeckSnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),.25)
				end
				pcall(function()
					if math.random(1,60) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						Movement.NeckSnap = true
					end
				end)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				if Movement.NeckSnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),1)
					Movement.NeckSnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),.25)
				end
				pcall(function()
					if math.random(1,60) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						Movement.NeckSnap = true
					end
				end)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120),math.rad(0),math.rad(0)),1/2)
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50))*CFrame.Angles(math.rad(-25+5*math.sin(Sine/50)),0,0),.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30+5*math.sin(Sine/50)),math.rad(0),math.rad(0)),0.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),0.7/3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(13 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),0.7/3)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
		elseif Mode == 36 or Mode == 48 then
			if Movement.Walking then
				Welds.RightHip.C0=Clerp(Welds.RightHip.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(Sine / 4))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(Sine / 8)),math.rad(0 + 25 * math.cos(Sine / 8))),.1)
				Welds.LeftHip.C0=Clerp(Welds.LeftHip.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(Sine / 4))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(Sine / 8)),math.rad(0 + 25 * math.cos(Sine / 8))),.1)
				Welds.RootJoint.C0=Clerp(Welds.RootJoint.C0,RootCF*CF(0,0,-0.15 - 0.1 * math.cos(Sine / 4))*angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(Sine / 8))),.1)
				Welds.Neck.C0=Clerp(Welds.Neck.C0,necko*angles(math.rad(25 - 5 * math.cos(Sine / 0.325)),math.rad(0 - 5 * math.cos(Sine / 0.25)),math.rad(0 + 5 * math.cos(Sine / 8))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-70 - 5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12)), math.rad(5 + 2.5 * math.cos(Sine / 12))) * rscp, 1 / 3)
				Welds.LeftShoulder.C0=Clerp(Welds.LeftShoulder.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
			else
				Welds.RightHip.C0=Clerp(Welds.RightHip.C0,CF(1,-1 - 0.1 * math.cos(Sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10 - 2.5 * math.cos(Sine / 32)),math.rad(-20),math.rad(0)),.1)
				Welds.LeftHip.C0=Clerp(Welds.LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(Sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(Sine / 32))),.1)
				Welds.RootJoint.C0=Clerp(Welds.RootJoint.C0,RootCF*CF(0,0,0 + 0.1 * math.cos(Sine / 32))*angles(math.rad(10 - 2 * math.cos(Sine / 32)),math.rad(0),math.rad(20)),.1)
				Welds.Neck.C0=Clerp(Welds.Neck.C0,necko*angles(math.rad(25 - 2.5 * math.cos(Sine / 32)),math.rad(0 - 5 * math.cos(Sine / 0.25)),math.rad(-20 - 5 * math.cos(Sine / 0.465))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0=Clerp(Welds.LeftShoulder.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
			end
		elseif Mode == 38 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.4, 0.35, 0.4) * ANGLES(RAD(135), RAD(0), RAD(3)) * ANGLES(RAD(0 - 1.5 * COS(Sine / 15) + 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(Sine / 15) + 0.05 * SIN(Sine / 15), 0, 0 + 0.05 * COS(Sine / 20)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.4, 0.35, 0.4) * ANGLES(RAD(15), RAD(0), RAD(12)) * ANGLES(RAD(0 - 1.5 * COS(Sine / 15) + 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1 - 0.05 * COS(Sine / 15) + 0.05 * SIN(Sine / 15), -1 - 0.05 * COS(Sine / 20), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1 - 0.05 * COS(Sine / 15) + 0.05 * SIN(Sine / 15), -1 - 0.05 * COS(Sine / 20), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			end
		elseif Mode == 9001.3 then
			if Movement.Walking then
				Welds.RootJoint.C0 = clerp(Welds.RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - Character.Torso.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				Welds.Neck.C0 = clerp(Welds.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - Character.Head.RotVelocity.Y / 15), 0.15)
				Welds.RightHip.C0 = clerp(Welds.RightHip.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - Character.RightLeg.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				Welds.LeftHip.C0 = clerp(Welds.LeftHip.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + Character.LeftLeg.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(Sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(Sine / 12)), RAD(35 + 7.5 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = clerp(Welds.LeftShoulder.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + Character.LeftArm.RotVelocity.Y / 75), 0.1)
			else
				Welds.RootJoint.C0 = clerp(Welds.RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
				Welds.Neck.C0 = clerp(Welds.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
				Welds.RightHip.C0 = clerp(Welds.RightHip.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
				Welds.LeftHip.C0 = clerp(Welds.LeftHip.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
				Welds.RightShoulder.C0 = clerp(Welds.RightShoulder.C0, CF(1.5* Player_Size, 1 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				Welds.LeftShoulder.C0 = clerp(Welds.LeftShoulder.C0, CF(-1.3* Player_Size, 1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
			end
		elseif Mode == 39 then
			local bouncyboi = PlaybackLoudness / 1200
			if Movement.Walking then
				if MRANDOM(1,10) == 1 then
					Welds.Neck.C0=Clerp(Welds.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end
				if(math.random(1,4)==1)then
					Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if MRANDOM(1,10) == 1 then
					Welds.Neck.C0=Clerp(Welds.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				snap = math.random(1,72)
				if snap == 1 then
					obamagaming.NewSound(363808674,soundholder(5),3,1.3,false)
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end 
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end		   
				if MRANDOM(1, 10) == 1 then
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
				end
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(sine / 12)), math.rad(0 - 10 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/7)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/7)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			else
				if MRANDOM(1,10) == 1 then
					Welds.Neck.C0=Clerp(Welds.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end
				if(math.random(1,4)==1)then
					Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if MRANDOM(1,10) == 1 then
					Welds.Neck.C0=Clerp(Welds.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				snap = math.random(1,72)
				if snap == 1 then
					obamagaming.NewSound(363808674,soundholder(5),3,1.3,false)
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end 
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end		   
				if MRANDOM(1, 10) == 1 then
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
				end
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-0.7, 0.5 + PlaybackLoudness / 1200, -0.3) * ANGLES(RAD(-200), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-11 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/61)),math.rad(0),math.rad(0)),.7/3)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-11 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/55)),math.rad(0),math.rad(0)),.7/3)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)
			end
		elseif Mode == 40 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0,0,2+0.5*COS(SINE / 12))*ANGLES(RAD(25+2.5*COS(SINE / 12)),RAD(0-Character.Torso.RotVelocity.y),RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 1 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/7)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/7)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			else
				pcall(function()
					sphereMK(2,math.random(5,15)/35,"Add",Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-11,11),-10,math.random(-8,8))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.40,0.40,5.35,0,BrickColor.new(Character.GunGlow.Color),0)
				end)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 2 + 1 * math.cos(sine / 18)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(.75, 0.5, -0.8) * ANGLES(RAD(0), RAD(0), RAD(-85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-.75, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(95)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/12)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/12)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif Mode == 41 then
			if Movement.Walking then
				Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/20))*CFrame.Angles(math.rad(40-1*math.cos(sine/20)),0,0),.25)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,NECKC0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*LEFTSHOULDERC0,.25)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-50 + 35 * math.cos(sine/20)),math.rad(80),math.rad(0))*CFrame.Angles(0,0,math.rad(15 - 25 * math.cos(sine/20))),0.7/3)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-35 + 35 * math.cos(sine/20)),math.rad(-80),math.rad(0))*CFrame.Angles(0,0,math.rad(-15 + 25 * math.cos(sine/20))),0.7/3)
			else
				Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120+5*math.cos(sine/20)),math.rad(0),math.rad(0)),1/2)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,0 - .5 * math.sin(sine/20))*CFrame.Angles(math.rad(-25-5*math.cos(sine/20)),0,0),.7/3)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,NECKC0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30-1*math.cos(sine/20)),math.rad(0),math.rad(0)),0.7/3)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/20)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/20))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 38 * math.cos(sine/20)),math.rad(80),math.rad(0))*CFrame.Angles(0,0,math.rad(15 - 25 * math.cos(sine/20))),0.7/3)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0 + 38 * math.cos(sine/20)),math.rad(-80),math.rad(0))*CFrame.Angles(0,0,math.rad(-15 + 25 * math.cos(sine/20))),0.7/3)
			end
		elseif Mode == 42 then
			if Movement.Walking then
				Welds.RightHip.C0=clerp(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
				Welds.LeftHip.C0=clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
				Welds.RootJoint.C0=clerp(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*ANGLES(math.rad(75),math.rad(0),math.rad(0)),.2)
				Welds.Neck.C0=clerp(Welds.Neck.C0,NECKC0*ANGLES(math.rad(-20),math.rad(0),math.rad(0)),.2)
				Welds.RightShoulder.C0=clerp(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0)*ANGLES(math.rad(0),math.rad(0),math.rad(0 + 0 * math.cos(sine / 28))),.2)
				Welds.LeftShoulder.C0=clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*ANGLES(math.rad(0),math.rad(0),math.rad(0 - 0 * math.cos(sine / 28))),.2)
				if math.random(1,32+PlaybackLoudness/7) == 1 then
					obamagaming.NewSound(363808674,soundholder(5),5,2.3,false)
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(math.random(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), math.rad(math.random(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), math.rad(math.random(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed)
				end
			else
				Welds.RightHip.C0=clerp(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
				Welds.LeftHip.C0=clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
				Welds.RootJoint.C0=clerp(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(sine / 28))*ANGLES(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=clerp(Welds.Neck.C0,NECKC0*ANGLES(math.rad(15),math.rad(0),math.rad(0)),.1)
				Welds.RightShoulder.C0=clerp(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0)*ANGLES(math.rad(20),math.rad(0),math.rad(20 + 2.5 * math.cos(sine / 28))),.1)
				Welds.LeftShoulder.C0=clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*ANGLES(math.rad(20),math.rad(0),math.rad(-20 - 2.5 * math.cos(sine / 28))),.1)
				if math.random(1,32+PlaybackLoudness/7) == 1 then
					obamagaming.NewSound(363808674,soundholder(5),5,2.3,false)
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(math.random(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), math.rad(math.random(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), math.rad(math.random(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed)
				end
			end
		elseif Mode == 43 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),.7/3)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,.7/3)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,.7/3)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0 - 0.15 * COS(sine / 12), 0 + 0.1 * COS(sine / 6)) * ANGLES(RAD(3.5 * COS(sine / 12)), RAD(0), RAD(-35)), 1 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5 * SIN(sine / 12)), RAD(-25 + 4 * COS(sine / 6)), RAD(35)), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, -0.25 + 0.15 * SIN(sine / 5), 0.2) * ANGLES(RAD(170 - 2.5 * COS(sine / 5)), RAD(15), RAD(5)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(sine / 6), 0 + 0.1 * COS(sine / 12)) * ANGLES(RAD(-5 * SIN(sine / 12)), RAD(15 * SIN(sine / 12)), RAD(-15 - 7.5 * SIN(sine / 12) - 1.5 * COS(sine / 6))) * LEFTSHOULDERC0, 2 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
				Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				if math.random(1,32+PlaybackLoudness/7) == 1 then
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(math.random(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), math.rad(math.random(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), math.rad(math.random(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed)
				end
			end
		elseif Mode == 44 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				Welds.RootJoint.C0 = Clerp2(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.Neck.C0 = Clerp2(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(Sine / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = Clerp2(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+PlaybackLoudness/7.5), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp2(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+PlaybackLoudness/7.5), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp2(Welds.RightHip.C0, CF(1, -1 - 0.025 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp2(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			end
		elseif Mode == 45 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,0+.5*math.cos(Sine/15))*CFrame.Angles(math.rad(40),math.rad(-5*math.cos(Sine/30)),0),.25)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(0+5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
				Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-99),math.rad(0),math.rad(0)),1/2)
			else
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,Welds.Defaults.Neck.C0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2 - 2* SIN(Sine / 6)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160), RAD(0), RAD(15-15* SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15+15* SIN(Sine / 12))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CF(0, 0, 0+0.1* SIN(Sine / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1 , -1-0.1* SIN(Sine / 6), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2+2* SIN(Sine / 6)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1-0.1* SIN(Sine / 6), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2+2* SIN(Sine / 6)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
		elseif Mode == 46 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0, Welds.Defaults.RootJoint.C0 * CFrame.new(0, math.cos(Sine / 18), 0) * CFrame.Angles(math.rad(5 * math.sin(Sine / 18)), 0, math.rad(70)), .25)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.Angles(0, 0, math.rad(-70)) * CFrame.Angles(math.rad(5 * math.cos(Sine / 18)), 0, 0), .25)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CFrame.new(1, .5, -.25) * CFrame.Angles(0, math.rad(-10), math.rad(-90)) * Welds.Defaults.RightShoulder.C0, .25)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CFrame.new(-1.5, .5, 0) * CFrame.Angles(0, 0, math.rad(-20 + 5 * math.sin(Sine / 18))) * Welds.Defaults.LeftShoulder.C0, .25)
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0, Welds.Defaults.RootJoint.C0 * CFrame.new(0, math.cos(Sine / 18), 0) * CFrame.Angles(math.rad(5 * math.sin(Sine / 18)), 0, 0), .25)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.Angles(math.rad(5 * math.cos(Sine / 18)), 0, 0), .25)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CFrame.new(1.5, .5, 0) * CFrame.Angles(0, 0, math.rad(15 - 5 * math.sin(Sine / 18))) * Welds.Defaults.RightShoulder.C0, .25)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CFrame.new(-1.5, .5, 0) * CFrame.Angles(0, 0, math.rad(-15 + 5 * math.sin(Sine / 18))) * Welds.Defaults.LeftShoulder.C0, .25)
			end
			Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CFrame.new(1, -1 - .1 * math.sin(Sine / 18), -.01) * CFrame.Angles(0, math.rad(80), 0), .25)
			Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CFrame.new(-1, -.5 - .25 * math.sin(Sine / 18), -.51) * CFrame.Angles(math.rad(-10), math.rad(-80), 0), .25)
		elseif Mode == 47 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 2 + 1 * math.cos(sine / 18)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,NECKC0 * CF(0*1, 0*1, 0*1 + ((1*1) - 1)) * ANGLES(RAD(20 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5*1, 0.5*1, 0*1) * ANGLES(RAD(180 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(-25 + MRANDOM(-24,24))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5*1, 0.5*1, 0*1) * ANGLES(RAD(180 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(25 + MRANDOM(-24,24))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(0+5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
				if MRANDOM(1,32+PlaybackLoudness/10) == 1 then
					obamagaming.NewSound(363808674,soundholder(5),5,2.3,false)
				end
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 2 + 1 * math.cos(sine / 18)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0,NECKC0 * CF(0*1, 0*1, 0*1 + ((1*1) - 1)) * ANGLES(RAD(20 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5*1, 0.5*1, 0*1) * ANGLES(RAD(180 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(-25 + MRANDOM(-24,24))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5*1, 0.5*1, 0*1) * ANGLES(RAD(180 + MRANDOM(-24,24)), RAD(0 + MRANDOM(-24,24)), RAD(25 + MRANDOM(-24,24))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-20 + 1 * COS(SINE / 18)), RAD(0), RAD(-80)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1, -0.7) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-35 + 1 * COS(SINE / 18)), RAD(0), RAD(80)), 1 / Animation_Speed)
				if MRANDOM(1,32+PlaybackLoudness/10) == 1 then
					obamagaming.NewSound(363808674,soundholder(5),5,2.3,false)
				end
			end
		elseif Mode == 50 then
			if Movement.Walking then
				Welds.RightHip.C0=Clerp(Welds.RightHip.C0,CF(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10 - 2.5 * math.cos(sine / 32)),math.rad(-20),math.rad(0)),.1)
				Welds.LeftHip.C0=Clerp(Welds.LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(sine / 32))),.1)
				Welds.RootJoint.C0=Clerp(Welds.RootJoint.C0,RootCF*CF(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(20)),.1)
				Welds.Neck.C0=Clerp(Welds.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
				Welds.RightShoulder.C0=Clerp(Welds.RightShoulder.C0,CF(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
				Welds.LeftShoulder.C0=Clerp(Welds.LeftShoulder.C0,CF(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
			else
				Welds.RightHip.C0=Clerp(Welds.RightHip.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(sine / 8))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 12)),math.rad(5 + 25 * math.cos(sine / 12))),.1)
				Welds.LeftHip.C0=Clerp(Welds.LeftHip.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(sine / 8))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 12)),math.rad(-5 + 25 * math.cos(sine / 12))),.1)
				Welds.RootJoint.C0=Clerp(Welds.RootJoint.C0,RootCF*CF(0,0,-0.15 - 0.1 * math.cos(sine / 8))*angles(math.rad(12.5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 12))),.1)
				Welds.Neck.C0=Clerp(Welds.Neck.C0,necko*angles(math.rad(30 - 5 * math.cos(sine / 0.5265)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 - 5 * math.cos(sine / 0.465))),.1)
				Welds.RightShoulder.C0=Clerp(Welds.RightShoulder.C0,CF(1.5,0.5,0)*angles(math.rad(10 - 15 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 0.123)),math.rad(5 + 2.5 * math.cos(sine / 0.6))),.1)
				Welds.LeftShoulder.C0=Clerp(Welds.LeftShoulder.C0,CF(-1.5,0.5,0)*angles(math.rad(10 + 15 * math.cos(sine / 12)),math.rad(0 + 2.5 * math.cos(sine / 0.664)),math.rad(-5 + 2.5 * math.cos(sine / 0.23))),.1)
			end
		end
		doWings()
		Movement.CFrame = obamagaming.obunga(Movement.CFrame,Movement.PotentialCFrame,.1)
		Movement.CFrame = CFrame.new(obamagaming.obunga(Movement.CFrame,Movement.PotentialCFrame,.25).Position)*Movement.CFrame-Movement.CFrame.Position
	end
end))
local CurrentPitch = 1
local naeeym2,FileX = Instance.new("BillboardGui"),false
local tecks2 = Instance.new("TextLabel",naeeym2)
local Naeymremoving = workspace.DescendantRemoving:Connect(function(v)
	if (v == naeeym2 or v:IsDescendantOf(naeeym2)) and not FileX then
		FileX = true
		pcall(function()
			naeeym2:Destroy()
		end)
		naeeym2  = Instance.new("BillboardGui")
		naeeym2.AlwaysOnTop = true
		naeeym2.Size = UDim2.new(7,35,3,15)
		naeeym2.StudsOffset = Vector3.new(0,2,0)
		naeeym2.MaxDistance = 10000
		naeeym2.Name = "Name2"
		tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.TextScaled = true
		tecks2.BorderSizePixel = 0
		tecks2.Text = "ExtremelySkidded Cannon"
		tecks2.Font = "Arcade"
		tecks2.TextSize = 35
		tecks2.TextStrokeTransparency = 0
		tecks2.Size = UDim2.new(1,0,0.5,0)
		tecks2.Parent = naeeym2
		tecks2.TextColor3 = Color3.fromRGB()
		FileX = false
	end
end)
naeeym2.Parent = workspace
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(7,35,3,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 10000
naeeym2.Name = "Name2"
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "ExtremelySkidded Cannon"
tecks2.Font = "Arcade"
tecks2.TextSize = 35
tecks2.TextStrokeTransparency = 0
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2
tecks2.TextColor3 = Color3.fromRGB()
local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
}
coroutine.resume(coroutine.create(function()
	while true do
		wait()
		tecks2.Font = FONTS[math.random(1, #FONTS)]
		tecks2.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
		pcall(function()
			tecks2.TextColor3 = Character.Torso.Color
		end)
	end
end))
spawn(function()
	while true do
		game:GetService("RunService").Heartbeat:Wait()
		pcall(function()
			naeeym2.Adornee = Character.Head
		end)
	end
end)
function ChangeName:FireAllClients(N)
	pcall(function()
		tecks2.Text = N
	end)
end
function ChangeMode(r,lol)
	spawn(obamagaming.smodeff)
	r = tonumber(r)
	if not r then
		r = 0
	end
	if lol ~= true then
		r = math.clamp(r, 0, 49)		
	end
	Mode = r
	MusicStart = tick()
	-- Hidden Modes
	if Mode == 9001.1 then
		MusicProps.SoundId = "rbxassetid://4568024466"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 9001.2 then
		MusicProps.SoundId = "rbxassetid://5502999317"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 999
		ChangeName:FireAllClients("500 Miles")
	elseif Mode == 9001.3 then
		MusicProps.SoundId = "rbxassetid://489174773"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 25
		ChangeName:FireAllClients(" ")
	-- Actual Modes
	elseif Mode == 0 then
		MusicProps.SoundId = "rbxassetid://5485798026"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("ExtremelySkidded Cannon")
	elseif Mode == 1 then
		MusicProps.SoundId = "rbxassetid://6207243296"
		MusicProps.Volume = 3
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 25
		ChangeName:FireAllClients("InSaNiTy")
	elseif Mode == 2 then
		MusicProps.SoundId = "rbxassetid://481104377"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Err0r")
	elseif Mode == 3 then
		MusicProps.SoundId = "rbxassetid://2297862957"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Glitch")
	elseif Mode == 4 then
		MusicProps.SoundId = "rbxassetid://4185475912"
		MusicProps.Volume = 4
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("???")
	elseif Mode == 5 then
		MusicProps.SoundId = "rbxassetid://5170646860"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("???")
	elseif Mode == 6 then
		MusicProps.SoundId = "rbxassetid://1338971957"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Chill")
	elseif Mode == 7 then
		MusicProps.SoundId = "rbxassetid://4835535512"
		MusicProps.Volume = 1.5
		CurrentPitch = 1.2
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("B  L  O  O  D  W  A  T  E  R")
	elseif Mode == 8 then
		MusicProps.SoundId = "rbxassetid://844654533"
		MusicProps.Volume = 1.5
		CurrentPitch = 0.75
		Movement.HipHeight = 3
		Movement.WalkSpeed = 140
		ChangeName:FireAllClients("pəɹoloɔun")
	elseif Mode == 9 then
		MusicProps.SoundId = "rbxassetid://693163614"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 10 then
		MusicProps.SoundId = "rbxassetid://640944007"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 300
		ChangeName:FireAllClients(" ")
	elseif Mode == 11 then
		MusicProps.SoundId = "rbxassetid://6049110238"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 32
		ChangeName:FireAllClients("Immortality Lord")
	elseif Mode == 12 then
		MusicProps.SoundId = "rbxassetid://6372483829"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 2
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Thorns")
	elseif Mode == 13 then
		MusicProps.SoundId = "rbxassetid://5644788747"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 2
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("5YSTEM FA1LURE")
	elseif Mode == 14 then
		MusicProps.SoundId = "rbxassetid://880201065"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Echo")
	elseif Mode == 15 then
		MusicProps.SoundId = "rbxassetid://866334508"
		MusicProps.Volume = 2
		CurrentPitch = 0.9
		Movement.HipHeight = 0
		Movement.WalkSpeed = 36
		ChangeName:FireAllClients("Lose Hope")
	elseif Mode == 16 then
		MusicProps.SoundId = "rbxassetid://937247562"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 25
		ChangeName:FireAllClients(" ")
	elseif Mode == 17 then
		MusicProps.SoundId = "rbxassetid://1382488262"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 18
		ChangeName:FireAllClients("Pandora")
	elseif Mode == 18 then
		MusicProps.SoundId = "rbxassetid://278501300"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients(" ")
	elseif Mode == 19 then
		MusicProps.SoundId = "rbxassetid://2242814132"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 20
		ChangeName:FireAllClients("SuperUBlockAlt")
	elseif Mode == 20 then
		MusicProps.SoundId = "rbxassetid://151915559"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("GodCat")
	elseif Mode == 21 then
		MusicProps.SoundId = "rbxassetid://1416035124"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("CatGod")
	elseif Mode == 22 then
		MusicProps.SoundId = "rbxassetid://2371543268"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Rainbow Infinite")
	elseif Mode == 23 then
		MusicProps.SoundId = "rbxassetid://143884682"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Kickisher Rewrite")
	elseif Mode == 24 then
		MusicProps.SoundId = "rbxassetid://170282324"
		MusicProps.Volume = 2
		CurrentPitch = 0.85
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Cyber Monarch")
	elseif Mode == 25 then
		MusicProps.SoundId = "rbxassetid://146682341"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 1
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Kickisher V9.4")
	elseif Mode == 26 then
		MusicProps.SoundId = "rbxassetid://4557673096"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients(" ")
	elseif Mode == 27 then
		MusicProps.SoundId = "rbxassetid://199531143"
		MusicProps.Volume = 2
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 28 then
		MusicProps.SoundId = "rbxassetid://4565796080"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Bad Apple")
	elseif Mode == 29 then
		MusicProps.SoundId = "rbxassetid://2740998756"
		MusicProps.Volume = 2
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 30 then
		MusicProps.SoundId = "rbxassetid://1426355953"
		MusicProps.Volume = 2
		CurrentPitch = 0.94
		Movement.HipHeight = 0
		Movement.WalkSpeed = 200
		ChangeName:FireAllClients("Death")
	elseif Mode == 31 then
		MusicProps.SoundId = "rbxassetid://2385953834"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 110
		ChangeName:FireAllClients("Big Ban")
	elseif Mode == 32 then
		MusicProps.SoundId = "rbxassetid://1899417820"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Rainbow Hell")
	elseif Mode == 33 then
		MusicProps.SoundId = "rbxassetid://348832364"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("SOLID LC")
	elseif Mode == 34 then
		MusicProps.SoundId = "rbxassetid://6190635423"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Spookeez")
	elseif Mode == 35 then
		MusicProps.SoundId = "rbxassetid://5801951770"
		MusicProps.Volume = 1
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 18
		ChangeName:FireAllClients("S N A K E G̸̰̠͉͚͇͇̗̉́ ̶̛͕̖̤̱̜̯̈́͗̀̒͆͘Ő̴̥͕̼̘͖̰̝̿͂̉͘̕͝ ̴̤̰̱̏̈͌̀̓̎̈́͝ͅD̴̼̼͎̒̊")
	elseif Mode == 36 then
		MusicProps.SoundId = "rbxassetid://4272705694"
		MusicProps.Volume = 1
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Solitude")
	elseif Mode == 37 then
		MusicProps.SoundId = "rbxassetid://3269680589"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("SOLID LC")
	elseif Mode == 38 then
		MusicProps.SoundId = "rbxassetid://5541841785"
		MusicProps.Volume = 1
		CurrentPitch = 0.8
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("NIGHTMARE")
	elseif Mode == 39 then
		MusicProps.SoundId = "rbxassetid://3718415720"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 4
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("KARMA")
	elseif Mode == 40 then
		MusicProps.SoundId = "rbxassetid://1547875818"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("UNDERWORLD")
	elseif Mode == 41 then
		MusicProps.SoundId = "rbxassetid://6105432316"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("When the ExtremelySkidded H̶y̶p̶e̶r̶S̶k̶i̶d̶d̶e̶d̶ Cannon is sus 😳")
	elseif Mode == 42 then
		MusicProps.SoundId = "rbxassetid://4767530611"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Two Of Us")
	elseif Mode == 43 then
		MusicProps.SoundId = "rbxassetid://2154918218"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Hell Cannon")
	elseif Mode == 44 then
		MusicProps.SoundId = "rbxassetid://5963244433"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("SOLID VISUALIZER")
	elseif Mode == 45 then
		MusicProps.SoundId = "rbxassetid://6553589083"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Zavodila")
	elseif Mode == 46 then
		MusicProps.SoundId = "rbxassetid://6101736348"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 4
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Regele Mortii")
	elseif Mode == 47 then
		MusicProps.SoundId = "rbxassetid://171230598"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Vaporwave")
	elseif Mode == 48 then
		MusicProps.SoundId = "rbxassetid://614032233"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("MAYHEM")
	elseif Mode == 49 then
		MusicProps.SoundId = "rbxassetid://6553642230"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Gospel")
	elseif Mode == 50 then
		MusicProps.SoundId = "rbxassetid://723652641"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("DeStRuCtIoN")
	elseif Mode > 50 then
		Mode = 0
		MusicProps.SoundId = "rbxassetid://5485798026"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("ExtremelySkidded Cannon")
	end
end
function ChattedFunc(Message)
	local Message,Message_ = Message,Message
	if string.sub(Message,1,4) == "esc/" then
		coroutine.resume(coroutine.create(function()
			stop()
		end))
		return
	end
	if string.sub(Message,1,3) == "/e " then
		Message = string.sub(Message,4)
	end
	if string.sub(string.lower(Message),1,3) == "lc/" then
		Message = string.sub(Message,4)
		local Arguments = string.split(Message,"/")
		local Command = type(Arguments[1]) == "string" and string.lower(Arguments[1]) or ""
		if Command then
			table.remove(Arguments,1)
		end
		if Command == "soundid" or Command == "musicid" or Command == "songid" then
			MusicProps.SoundId = type(tonumber(Arguments[1])) == "number" and "rbxassetid://"..tostring(Arguments[1]) or MusicProps.SoundId
			MusicStart = tick()
			MusicProps.Volume = 2
		elseif Command == "clearonleave" or Command == "clearonremove" or Command == "clearondisconnect" or Command == "clearonkick" then
			local Bool = Arguments[1]
			if type(Bool) == "string" then
				if Bool == "true" or Bool == "on" then
					AntiFat = true
				elseif Bool == "false" or Bool == "off" then
					AntiFat = false
				end
			else
				AntiFat = false
			end
		elseif Command == "lenny" then
			if Hey == true then return end
			Hey = true
			print(Hey)
		elseif Command == "mode" or Command == "taunt" or Command == "changemode" or Command == "changetaunt" then
			local Bool = Arguments[1]
			if tonumber(Bool) then
				ChangeMode(tonumber(Bool))
			else
				if string.lower(Bool) == "schlatt" then
					if Hey ~= true then ChangeMode(0) return end
					ChangeMode(9001.1,true)
				else
					ChangeMode(0)
				end
			end
		elseif Command == "showhitboxes" then
			local ShowHitbox = Instance.new("ShowHitboxes",nil,{Name = obamagaming["god damn, i really wish i could care"](),Disabled = false})
			ShowHitbox.Parent = Instance.new("Backpack", Player)
		elseif Command == "soundvolume" or Command == "musicvolume" or Command == "songvolume" or Command == "songvol" or Command == "soundvol" or Command == "musicvol" or Command == "volume" or Command == "vol" then
			local Bool = Arguments[1]
			if tonumber(Bool) then
				MusicProps.Volume = math.clamp(Bool, 0.5, 10)
			end
		elseif Command == "soundpitch" or Command == "musicpitch" or Command == "songpitch" or Command == "playbackspeed" or Command == "pitch" then
			local Bool = Arguments[1]
			if tonumber(Bool) then
				CurrentPitch = math.clamp(Bool, 0.01, 20)
			end
		elseif Command == "reason" or Command == "shutdownreason" or Command == "kickreason" or Command == "sdreason" then
			local Bool = Arguments[1]
			ShutdownReason = tostring(Bool)
		end
	end
	if Message == Message_ then
		if HideIdentity then
			Event:FireAllClients("Chat",{Starter = Name, Text = Message})
		else
			Event:FireAllClients("Chat",{Starter = Name, Text = Message})
		end
	end
end
local Chatted = Player.Chatted:Connect(ChattedFunc)
coroutine.resume(coroutine.create(function()
	while doColors == true do
		for i = 0,1,(1/60) do
			for bruh = 1,3 do
				game:GetService("RunService").Heartbeat:Wait()
			end
			CurrentColor = Color3.fromHSV(i,1,1)
			if Mode == 1 or Mode == 16 or Mode == 19 or Mode == 39 then
				CurrentColor = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
			elseif Mode == 2 then
				CurrentColor = Color3.fromRGB(0,math.random(0,255),0)
			elseif Mode == 3 then
				CurrentColor = Color3.fromHSV(math.random(),math.random(),math.random())
			elseif Mode == 4 then
				CurrentColor = Color3.fromRGB(math.random(0,99),0,0)
			elseif Mode == 5 then
				CurrentColor = Color3.fromRGB(0,0,math.random(0,255))
			elseif Mode == 7 or Mode == 9 or Mode == 12 or Mode == 24 or Mode == 35 or Mode == 38 or Mode == 40 or Mode == 43 then
				CurrentColor = Color3.new(PlaybackLoudness/500, 0, 0)
			elseif Mode == 8 or Mode == 36 then
				CurrentColor = C3(math.min(1,PlaybackLoudness/500),math.min(1,PlaybackLoudness/500),math.min(1,PlaybackLoudness/500))
			elseif Mode == 10 or Mode == 27 then
				CurrentColor = Color3.new(0, 0, PlaybackLoudness/500)
			elseif Mode == 11 then
				CurrentColor = Color3.fromRGB(27, 42, 53)
			elseif Mode == 13 then
				CurrentColor = Color3.fromRGB(math.random(0,255),0,0)
			elseif Mode == 14 then
				CurrentColor = Color3.fromRGB(100*PlaybackLoudness/500,0,0)
			elseif Mode == 20 or Mode == 21 then
				local VAL = MRANDOM(0,255)
				CurrentColor = Color3.fromRGB(VAL,VAL,VAL)
			elseif Mode == 26 then
				CurrentColor = Color3.fromRGB(225,225,225,math.clamp(PlaybackLoudness-0,0,0),0,0,0)
			elseif Mode == 29 then
				CurrentColor = Color3.new(0.580392, 0, 0.870588*PlaybackLoudness/500,0,0)
			elseif Mode == 30 then
				CurrentColor = C3(98/255 + PlaybackLoudness/1000, 37/255 + PlaybackLoudness/1000, 209/255 + PlaybackLoudness/1000)
			elseif Mode == 34 then
				CurrentColor = Color3.new(math.clamp(PlaybackLoudness/500,0,1), math.clamp((PlaybackLoudness/500)/2,0,1), 0)
			elseif Mode == 48 then
				CurrentColor = Color3.new(1,0,0)
			elseif Mode == 37 then
				CurrentColor = Color3.new(0, PlaybackLoudness/500, 0)
			elseif Mode == 9001.1 then
				CurrentColor = Color3.fromHSV(0.11748632788658, 0.28372022509575, math.clamp((PlaybackLoudness/255)-.5,0,1))
			elseif Mode == 9001.3 then
				CurrentColor = Color3.new(1,1,0)
			elseif Mode == 50 then
				CurrentColor = Color3.new(.75,0,0)
			end
			pcall(function()
				cColor.Value = Character.HeadGlow.Color
			end)
		end
	end
end))
local doe = 0
coroutine.wrap(function()
	while true do
		game:GetService("RunService").Heartbeat:Wait()
		if doe < 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()
local stillraining = false
local SoundServiceProps = {AmbientReverb = Enum.ReverbType.NoReverb,DistanceFactor = 10/3,DopplerScale = 0,RolloffScale = 1}
local MainLoop = game:GetService("RunService").Heartbeat:Connect(function(s)
	bgm.PlaybackLoudness,eee.PlaybackLoudness = PlaybackLoudness,PlaybackLoudness
	pcall(function()
		ColCorPP.TintColor = Color3.new(1-bgm.PlaybackLoudness/2500,1-bgm.PlaybackLoudness/2500,1-bgm.PlaybackLoudness/2500)
	end)
	pcall(function()
		for i, v in pairs(OldLighting) do
			game:GetService("Lighting")[i] = v
		end
		VISUALS["C-Correction"].Contrast = 0
		VISUALS["C-Correction"].Enabled = false
		VISUALS["Hi-Res Skybox by Zephyred"].MoonAngularSize = 11
		VISUALS["Hi-Res Skybox by Zephyred"].SunAngularSize = 6
		workspace.CurrentCamera.FieldOfView = 70 - PlaybackLoudness/95
	end)
	tf = tf+s
	for _ = 1,tf/fr do
		Sine = Sine+1
		sine = Sine
		SINE = Sine
		HBevent:Fire()
		tf = tf-fr
	end
	spinc=spinc+5
	spinb=spinb+2
	spinb=spinb+12
	spind=spinb+12
	spine=spinb+12
	WALKSPEEDVALUE = 6 / (Movement.WalkSpeed / 16)
	for i,v in pairs(SoundServiceProps) do
		game:FindFirstChildOfClass("SoundService")[i] = v
	end
	--if not Event or not Event:IsDescendantOf(game) or not table.find(Services,Event.Parent.ClassName) or Event.Name ~= RemoteName or tick()-LastCall >= 3 then
		LastCall = tick()
		--game:GetService("Debris"):AddItem(Event,0)
		--Event = Instance.new("RemoteEvent",game:GetService(Services[math.random(1,#Services)]),{Name = RemoteName,Archivable = false})
		ServerCallBack = (function(Pass,Method,Things)
			
				LastCall = tick()
				if Method == "Movement" then
					Movement.PotentialCFrame,Movement.Walking,Mouse.Hit = Things.CFrame,Things.Walking,Things.Hit
				elseif Method == "ReplaceCharacter" then
					for _,v in pairs(Character) do
						if typeof(v) == "Instance" then
							game:GetService("Debris"):AddItem(v,0)
						end
					end
				elseif Method == "ReplaceMusic" then
					game:GetService("Debris"):AddItem(MusicHolder,0)
					game:GetService("Debris"):AddItem(Music,0)
				elseif Method == "500Miles" then
					if Hey ~= true then return end
					if Things.Miles == 500 then
						ChangeMode(9001.2,true)
					elseif Things.Miles == 0 then
						ChangeMode(10,false)
					end
				elseif Method == "https://www.youtube.com/watch?v=W4WGQmWcrbs" then
					if Hey ~= true then return end
					if Things.lol == 1 then
						ChangeMode(9001.3,true)
					elseif Things.lol == 0 then
						ChangeMode(35,false)
					end
				elseif Method == "AntiFat" then
					AntiFat = Things.AntiFat
				elseif Method == "SwitchMode" and Mode >= 0 then
					spawn(function()
						ChangeMode(Mode + 1)
					end)
				elseif Method == "GoBackAMode" and Mode >= 0 then
					spawn(function()
						ChangeMode(Mode - 1)
					end)
				elseif Method == "PlaybackLoudness" then
					PlaybackLoudness = Things.PlaybackLoudness
				elseif Method == "Attack" and Mode >= 0 then
					if Things.Type == "ClickAttack" then
						pcall(function()
							local OldMode,WalkSpeed,AttackPosition = Mode,Movement.WalkSpeed,Mouse.Hit.Position
							Mode = -1
							Movement.WalkSpeed = 0
							coroutine.resume(coroutine.create(function()
								for _ = 1,20 do
									wait()
								end
								Mode,Movement.WalkSpeed = OldMode,WalkSpeed
							end))
							for i = .1,1,.1 do
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0+.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(0,0,math.rad(30)),.25)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(15),0,math.rad(-30)),.25)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(90),0,math.rad(30))*Welds.Defaults.RightShoulder.C0,.25)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(30),0,0)*Welds.Defaults.LeftShoulder.C0,.25)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-15+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-15-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
								Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z))})
								Movement.CFrame = obamagaming.obunga(Movement.CFrame,CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z)),i)
								wait()
							end
							local IgnoreChar,DeadParts = {},{}
							local SoundHolder = Instance.new("Part",nil,{CFrame = Character.Hole2.CFrame})
							local Sound = Instance.new("Sound",SoundHolder,{SoundId = "rbxassetid://642890855",PlaybackSpeed = .65,Volume = 10,PlayOnRemove = true,Playing = true})
							SoundHolder.Parent = game:GetService(Services[math.random(1,#Services)])
							SoundHolder:Destroy()
							local SoundHolder = Instance.new("Part",nil,{Position = AttackPosition})
							local Sound = Instance.new("Sound",SoundHolder,{SoundId = "rbxassetid://821439273",PlaybackSpeed = .8,Volume = 10,PlayOnRemove = true,Playing = true})
							SoundHolder.Parent = game:GetService(Services[math.random(1,#Services)])
							SoundHolder:Destroy()
							for _,v in pairs(Character) do
								if typeof(v) == "Instance" then
									table.insert(IgnoreChar,v)
								end
							end
							for _,v in pairs(workspace:GetChildren()) do
								if v:GetAttribute("IsAnEffect") == true then
									table.insert(IgnoreChar,v)
								end
							end
							local EffectCheck = workspace.ChildAdded:Connect(function(v)
								if v:GetAttribute("IsAnEffect") == true then
									table.insert(IgnoreChar,v)
								end
							end)
							local Parts = workspace:FindPartsInRegion3WithIgnoreList(Region3.new(AttackPosition-Vector3.new(4,4,4),AttackPosition+Vector3.new(4,4,4)),IgnoreChar,100)
							for _,v in pairs(WorldModels) do
								for _,b in pairs(v:FindPartsInRegion3(Region3.new(AttackPosition-Vector3.new(4,4,4),AttackPosition+Vector3.new(4,4,4)),nil,100)) do
									table.insert(Parts,b)
								end
							end
							local PartKiller,PartsToKill = Instance.new("ViewportFrame",workspace,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))}),{}
							for _,v in pairs(Parts) do
								local BiggestAxis = v.Size.X
								if v.Size.Y > BiggestAxis then
									BiggestAxis = v.Size.Y
								end
								if v.Size.Z > BiggestAxis then
									BiggestAxis = v.Size.Z
								end
								if (v.Name ~= "Base" and v.Name ~= "Baseplate") or BiggestAxis < 10 then
									v.Archivable = true
									table.insert(DeadParts,v:Clone())
									v.Archivable = false
									local SoundHolder = Instance.new("Part",nil,{CFrame = v.CFrame})
									local Sound = Instance.new("Sound",SoundHolder,{SoundId = "rbxassetid://2785493",Volume = 10,PlayOnRemove = true,Playing = true})
									SoundHolder.Parent = game:GetService(Services[math.random(1,#Services)])
									SoundHolder:Destroy()
									table.insert(PartsToKill,v)
								end
							end
							for _,v in pairs(PartsToKill) do
								--[[local OldParent = v.Parent
								v.Parent = PartKiller
								v.Parent = OldParent
								v.Anchored = true
								v.CFrame = CFrame.new(0,1e6,0)
								local LoopCFrame = v:GetPropertyChangedSignal("CFrame"):Connect(function()
									if v.CFrame ~= CFrame.new(0,1e6,0) then
										v.CFrame = CFrame.new(0,1e6,0)
									end
								end)
								local LoopAnchor = v:GetPropertyChangedSignal("Anchored"):Connect(function()
									if v.Anchored ~= true then
										v.Anchored = true
									end
								end)
								local Removed
								Removed = v.AncestryChanged:Connect(function()
									if not v:IsDescendantOf(workspace) then
										LoopCFrame:Disconnect()
										LoopAnchor:Disconnect()
										Removed:Disconnect()
									end
								end)]]
							end
							for _,b in pairs(DeadParts) do
								--[[for _,v in pairs(b:GetChildren()) do
									if not v:IsA("DataModelMesh") then
										v:Destroy()
									else
										v:ClearAllChildren()
										v.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
										v.VertexColor = Vector3.new()
										game:GetService("TweenService"):Create(v,TweenInfo.new(1.5,Enum.EasingStyle.Linear),{Scale = Vector3.new()}):Play()
									end
								end
								b.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
								b.Anchored = true
								b.Color = CurrentColor
								b.Material = Enum.Material.Air
								b.CanCollide = false
								game:GetService("TweenService"):Create(b,TweenInfo.new(1.5,Enum.EasingStyle.Linear),{CFrame = CFrame.new(AttackPosition)*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(1,360)),math.rad(math.random(1,360)),math.rad(math.random(1,360))),Size = Vector3.new()}):Play()
								game:GetService("Debris"):AddItem(b,1.5)
								table.insert(IgnoreChar,b)
								b.Parent = workspace]]
							end
							for _,v in pairs(game:GetService("Players"):GetPlayers()) do
								local ClientAttack = Instance.new("LightningAttack",nil,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Disabled = false})
								for _,b in pairs(IgnoreChar) do
									Instance.new("ObjectValue",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = b})
								end
								local WorldModelFolder = Instance.new("Folder",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))})
								for _,b in pairs(WorldModels) do
									local WorldModelVal = Instance.new("ObjectValue",WorldModelFolder,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = b})
								end
								Instance.new("Vector3Value",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = Character.Hole2.CFrame.Position})
								Instance.new("CFrameValue",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = CFrame.new(AttackPosition)})
								ClientAttack.Parent = v:FindFirstChildOfClass("Backpack") or Instance.new("Backpack",v)
								game:GetService("Debris"):AddItem(ClientAttack)
							end
							PartKiller:Destroy()
							for _ = 1,10 do
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0+.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(0,0,math.rad(30)),.25)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(10),0,math.rad(-60)),.25)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60))*Welds.Defaults.RightShoulder.C0,.25)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(40),math.rad(5),math.rad(5))*Welds.Defaults.LeftShoulder.C0,.25)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-15+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-15-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
								Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z))})
								Movement.CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z))
								wait()
							end
							EffectCheck:Disconnect()
							Mode = OldMode
						end)
					elseif Things.Type == "GroundShards" then
						local OldMode,Size,StudsAway = Mode,Vector3.new(2.5,9,2.5),-4
						Mode = -1
						for i = 1,50 do
							local Shard = Instance.new("Shard",workspace,{Material = Enum.Material.Glass,Reflectance = 3,CFrame = Movement.PotentialCFrame*CFrame.new(math.random(-2,2)/4,-3-Size.Y/2,StudsAway+math.random(-2,2)/4)*CFrame.fromEulerAnglesXYZ(100,math.random(0,180),.4),Anchored = true,CanCollide = false,Size = Size})
							game:GetService("Debris"):AddItem(Shard,3)
							game:GetService("TweenService"):Create(Shard,TweenInfo.new(.3),{CFrame = Shard.CFrame*CFrame.new(0,Size.Y,0)}):Play()
							game:GetService("TweenService"):Create(Shard,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.In,0,false,2),{Transparency = 1}):Play()
							StudsAway = StudsAway-2
							Size = Vector3.new(2.5,9,2.5)*(1+i/10)
							wait()
						end
						Mode = OldMode
					elseif Things.Type == "Template" then
						local OldMode,WS = Mode,Movement.WalkSpeed
						Mode = -1
						Movement.WalkSpeed = 0
						--
						
						--
						Movement.WalkSpeed = WS
						Mode = OldMode
					elseif Things.Type == "KaBoom" then
						local OldMode,OldWalk = Mode,Movement.WalkSpeed
						Mode = -1
						Movement.WalkSpeed = 0
						local Holetwo = Character.Hole
						local die = obamagaming.NewSound(1566051529,soundholder(5),3,1)
						die.EmitterSize = 100
						for i = 1, 5 do
							game:GetService("RunService").Heartbeat:Wait()
						end
						for i = 1,3 do
							for i = 0,1.5,.1 do
								game:GetService("RunService").Heartbeat:Wait()
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
								Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
							end
							coroutine.resume(coroutine.create(function()
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 642890855,SoundPitch = .65,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								local skypos = Character.Hole.CFrame * CFrame.new(-400,0,0)
								local DISTANCE = (Character.Hole.CFrame.Position - skypos.p).Magnitude
								local killbeam = obamagaming.NewPart(3,workspace,"Neon",0,0,Character.Torso.Color,"Kill Beam",Vector3.new(1,DISTANCE,1))
								killbeam.CFrame = CFrame.new(Holetwo.CFrame.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
								MakeForm(killbeam,"Cyl")
								coroutine.resume(coroutine.create(function()
									for i = 1,25 do
										game:GetService("RunService").Heartbeat:Wait()
										killbeam.Transparency = i/25
									end
									killbeam:Destroy()
								end))
								for i = 1,4 do
									coroutine.resume(coroutine.create(function()
										Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
									end))
								end
								for i = 0,2 do
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								end
								Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								for i = 0,2 do
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								end
							end))
							for i = 1,42 do
								game:GetService("RunService").Heartbeat:Wait()
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)),.7/3)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,.7/3)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
								Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
							end
						end
						for i = 1,15 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,.7/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						local BEAM = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
						local BEAM2 = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
						MakeForm(BEAM,"Ball")
						MakeForm(BEAM2,"Ball")
						BEAM.CFrame = CFrame.new(Character.Torso.Position)
						BEAM2.CFrame = CFrame.new(Character.Torso.Position)
						local boooom = obamagaming.NewSound(415700134,soundholder(5),10,1,false)
						boooom.EmitterSize = 100
						for i=1,140 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,.7/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
							BEAM.Size = BEAM.Size + Vector3.new(.7,8,.7)
							BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
							BEAM.Color = Character.Torso.Color
							BEAM2.Color = Character.Torso.Color
							BEAM.CFrame = CFrame.new(Character.Torso.Position)
							BEAM2.CFrame = CFrame.new(Character.Torso.Position)
							obamagaming.WEffect({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = .8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(i*5),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = i/8,RotationZ = 0,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						end
						mdmgPP(Character.Torso.Position,BEAM2.Size.Y/2)
						Effect({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						Effect({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(),Transparency = 0,Transparency2 = .6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						BEAM2:Destroy()
						BEAM:Destroy()
						Movement.WalkSpeed = OldWalk
						Mode = OldMode
					elseif Things.Type == "Bullets" then
						local OldMode,Walks,AttackPosition = Mode,Movement.WalkSpeed,Mouse.Hit.Position
						Mode = -1
						Movement.WalkSpeed = 0
						local gBullet = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(1, 1, 1),"AbsoluteNoob",Vector3.new())
						MakeForm(gBullet,"Ball")
						gBullet.CFrame = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0)
						obamagaming.NewSound(2785493,gBullet,10,.8)
						for i = 0,1.25,.025 do
							game:GetService("RunService").Heartbeat:Wait()
							Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(.5,.5,.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).p,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
							gBullet.Size = gBullet.Size * 1.085
							gBullet.CFrame = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0)
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-30)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-5 - 3 * math.cos(Sine/12)),math.rad(0),math.rad(30)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5 + .1 * math.cos(Sine/12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(Sine/12)),math.rad(0 - 6 * math.cos(Sine/12)),math.rad(-30 - 6 * math.cos(Sine/12))) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						local bullets = {}
						for i = 1,math.random(30,50) do
							game:GetService("RunService").Heartbeat:Wait()
							local Bullet = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(1, 1, 1),"AbsoluteBEAN",Vector3.new(.6,.6,.6))
							MakeForm(Bullet,"Ball")
							Bullet.CFrame = gBullet.CFrame
							Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = .4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
							table.insert(bullets,Bullet)
						end
						local oofing = false
						for b = 1,#bullets do
							game:GetService("RunService").Heartbeat:Wait()
							local part,pos = rayCast(Character.LeftArm.CFrame*CFrame.new(0,-1.5,0).p,((AttackPosition+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - Character.LeftArm.CFrame*CFrame.new(0,-1.5,0).p),500,Instance.new("Model"))
							coroutine.resume(coroutine.create(function()
								FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
								Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(.6,.6,.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
								for i = 1, math.random(55,65) do
									game:GetService("RunService").Heartbeat:Wait()
								end
								for i = 1,3 do
									Effect({Time = math.random(45,65),EffectType = "Sphere",Size = Vector3.new(.6,6,.6)*math.random(-1.05,1.25),Size2 = Vector3.new(1.6,10,1.6)*math.random(-1.05,1.25),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 20,SizeBoomerang = 35})
								end
								for i = 0,10 do
									game:GetService("RunService").Heartbeat:Wait()
									bullets[b].Transparency = bullets[b].Transparency + .1
								end
								oofing = not oofing
								if oofing then
									mdmgPP(bullets[b].Position,10)
								end
								local EEEBRUHEEE = obamagaming.NewSound(168513088,bullets[b],3.5,1.1,false)
								bullets[b].Transparency = 1
								EEEBRUHEEE.Ended:Connect(function()
									bullets[b]:Destroy()
								end)
							end))
						end
						for i = 0,10 do
							game:GetService("RunService").Heartbeat:Wait()
							gBullet.Transparency = gBullet.Transparency + .1
						end
						gBullet:Destroy()
						Movement.WalkSpeed = Walks
						Mode = OldMode
					elseif Things.Type == "HedShoot" then
						local OldMode,oldwa,RootPart = Mode,Movement.WalkSpeed,Character.HumanoidRootPart
						Mode = -1
						Movement.WalkSpeed = 16
						obamagaming.NewSound(235097614,soundholder(5),6,1.5,false)
						for i = 0,.5,.05 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.25,.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.25,.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 642890855,SoundPitch = .65,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
						Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
						mdmgPP(Character.Torso.Position,14)
						for i = 1,4 do
							Movement.CFrame = Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-100)
							Movement.PotentialCFrame = Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-100)
							Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position)})
							mdmgPP(Character.Torso.Position,14)
							coroutine.resume(coroutine.create(function()
								Lightning(Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Character.Torso.Color,math.random(30,45),.5,1.5,0,true,60) 
							end))	
							coroutine.resume(coroutine.create(function()
								Lightning(Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Color3.new(1, 1, 1),math.random(30,45),.5,1.5,0,true,60)
							end))
						end
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						for i = 0,.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						Movement.WalkSpeed = oldwa
						Mode = OldMode
					elseif Things.Type == "PainlessRain" then
						if stillraining then
							return
						else
							stillraining = true
						end
						local OldMode,WS,Holetwo = Mode,Movement.WalkSpeed,Character.Hole
						Mode = -1
						Movement.WalkSpeed = 16
						--
						coroutine.wrap(function()
							for i = 0,2 do
								for _ = 1, 12 do
									game:GetService("RunService").Heartbeat:Wait()
								end
								obamagaming.NewSound(199145095,soundholder(5),10,1)
							end
						end)()
						for i = 0,2,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
						end
						for i = 0,1.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 642890855,SoundPitch = .65,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						local skypos = Character.Hole.CFrame * CFrame.new(-400,0,0)
						local DISTANCE = (Character.Hole.CFrame.Position - skypos.p).Magnitude
						local killbeam = obamagaming.NewPart(3,workspace,"Neon",0,0,Character.Torso.Color,"Kill Beam",Vector3.new(1,DISTANCE,1))
						killbeam.CFrame = CFrame.new(Holetwo.CFrame.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
						MakeForm(killbeam,"Cyl")
						coroutine.resume(coroutine.create(function()
							for i = 1,25 do
								game:GetService("RunService").Heartbeat:Wait()
								killbeam.Transparency = i/25
							end
							killbeam:Destroy()
						end))
						for i = 1,4 do
							coroutine.resume(coroutine.create(function()
								Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
							end))
						end
						Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
						for i = 0,2 do
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
						end
						for i = 0,.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(225),math.rad(-20),math.rad(20)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						for i = 0,.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end	
						Movement.WalkSpeed = WS
						Mode = OldMode
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						for i = 0,2 do
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
						end
						for i = 1,20 do
							local Sky = Character.HumanoidRootPart.CFrame*CFrame.new(0,500,0)
							local MoPos = Mouse.Hit.Position
							local DISTANCE = (Sky.p - MoPos).Magnitude
							for i = 1,4 do
								coroutine.resume(coroutine.create(function()
									Lightning(Sky.p,MoPos,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
								end))
							end
							Lightning(Sky.p,MoPos,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
							local killbeam = obamagaming.NewPart(3,workspace,"Neon",0,0,Character.Torso.Color,"Kill Beam",Vector3.new(1,DISTANCE,1))
							killbeam.CFrame = CFrame.new(Sky.p,MoPos) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
							MakeForm(killbeam,"Cyl")
							coroutine.resume(coroutine.create(function()
								for i = 1,25 do
									game:GetService("RunService").Heartbeat:Wait()
									killbeam.Transparency = i/25
								end
								killbeam:Destroy()
							end))
							Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							for i = 0,2 do
								Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							end
							mdmgPP(MoPos,12)
							wait(.25)
						end
						stillraining = false
						--
					elseif Things.Type == "NightmareIsAlive" and Things.Confirmation == RemoteKey and Hey and (Mode == 14 or Mode == 39) then
						local Animation_Speed2,RootPart,OldMode,WS = 5,Character.Torso,Mode,Movement.WalkSpeed
						Mode = -1
						Movement.WalkSpeed = 0
						--
						obamagaming.NewSound("459523898",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("459523898",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("223103466",soundholder(9e9),3,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						local SCOLOR = Instance.new("ColorCorrectionEffect")
						SCOLOR.Brightness = 0
						SCOLOR.Contrast = 0
						SCOLOR.Saturation = 0
						SCOLOR.Name = "SpookyColor"
						SCOLOR.Parent = game:GetService("Lighting")
						for i=0, 11.5, 0.1 / Animation_Speed2 do
							game:GetService("RunService").Heartbeat:Wait()
							obamagaming.WEffect({
								Time = 12,
								EffectType = "Sphere",
								Size = VT(5, 5, 5)/10 * 25,
								Size2 = VT(0, 0, 250)/10 * 25,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(Character.Torso.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
								MoveToPos = nil,
								RotationX = 0,
								RotationY = 0,
								RotationZ = 0,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = nil,
								SoundPitch = 1,
								SoundVolume = 6,
								UseBoomerangMath = true,
								Boomerang = 0,
								SizeBoomerang = 0
							})
							obamagaming.WEffect({
								Time = 75 - i * 4,
								EffectType = "Box",
								Size = VT(0, 0, 0),
								Size2 = VT(5, 5, 5) + VT(i, i, i) * 55,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(Character.Torso.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
								MoveToPos = nil,
								RotationX = 360,
								RotationY = 360,
								RotationZ = 360,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = nil,
								SoundPitch = MRANDOM(8, 20) / 10,
								SoundVolume = 2,
								UseBoomerangMath = true,
								Boomerang = 25,
								SizeBoomerang = 100
							})
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(Sine / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(Sine / 13))), 1 / 3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(Sine / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / 3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
						end
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						--
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						coroutine.wrap(function()
							while true do
								game:GetService("RunService").Heartbeat:Wait()
								if MRANDOM(1,2) == 1 then
									game:service'Lighting'.OutdoorAmbient = C3(1,0,0)
								else
									game:service'Lighting'.OutdoorAmbient = C3(0,0,0)
								end
							end
						end)()
						local BLUR = Instance.new("BlurEffect")
						BLUR.Size = 0
						BLUR.Name = "Wasted"
						BLUR.Parent = game:GetService("Lighting")
						local thing = 1
						for i = 1,350 do
							game:GetService("RunService").Heartbeat:Wait()
							thing = thing +1
							SCOLOR.Brightness = 5-((i/10)*5)
							SCOLOR.Contrast = 4-((i/10)*4)
							SCOLOR.Saturation = 3-((i/10)*3)
							BLUR.Size = (i/30)*10
							obamagaming.WEffect({
								Time = 75 - i * 4,
								EffectType = "Box",
								Size = VT(0, 0, 0),
								Size2 = VT(5, 5, 5) + VT(i, i, i) * 100,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(Character.Torso.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
								MoveToPos = nil,
								RotationX = 360,
								RotationY = 360,
								RotationZ = 360,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = 231917744,
								SoundPitch = MRANDOM(8, 20) / 10,
								SoundVolume = 3,
								UseBoomerangMath = true,
								Boomerang = 25,
								SizeBoomerang = 100
							})
							obamagaming.WEffect({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Slate", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							obamagaming.WEffect({EffectType = "Sphere", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							obamagaming.WEffect({EffectType = "Slash", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(Sine / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(Sine / 13))), 1 / 3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(Sine / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / 3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
						end
						pcall(function()
							BLUR:Destroy()
						end)
						pcall(function()
							SCOLOR:Destroy()
						end)
						Movement.WalkSpeed = WS
						Mode = OldMode
						--
					elseif Things.Type == "OwDudeStopMyEars" then
						local OldMode,WS,HH = Mode,Movement.WalkSpeed,Movement.HipHeight
						Mode = -1
						Movement.WalkSpeed = 0
						--
						local ree = obamagaming.NewSound(435742675,soundholder(5),10,1,false)
						ree.EmitterSize = 10000
						coroutine.resume(coroutine.create(function()
							for i = 1, 60 do
								game:GetService("RunService").Heartbeat:Wait()
							end
							mdmgPP(Character.Head.Position,5000)
						end))
						repeat
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),1)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-45+math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),1)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,1)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,1)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-45),math.rad(80),math.rad(0)),1)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(-35),math.rad(-80),math.rad(0)),1)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
							game:GetService("RunService").Heartbeat:Wait()
						until ree.TimePosition >= 5 or not ree:IsDescendantOf(game)
						if ree:IsDescendantOf(game) then
							ree:Destroy()
							Movement.WalkSpeed = WS
							Mode = OldMode
						end
						--
						Movement.WalkSpeed = WS
						Mode = OldMode
					end
				end
			if Pass == GuestKey and type(Method) == "string" and type(Things) == "table" then
				if Method == "TextBox" then
					if type(Things.Text) == "string" and string.match(Things.Text,"%s+") ~= Things.Text and string.len(Things.Text) >= 1 then
					end
				end
			end
		end)
		
	--end
	if not MusicHolder or not MusicHolder:IsDescendantOf(game) or not table.find(Services,MusicHolder.Parent.ClassName) or MusicHolder.CFrame ~= CFrames.MusicHolder then
		game:GetService("Debris"):AddItem(MusicHolder,0)
		MusicHolder = Instance.new(PartClasses[math.random(1,#PartClasses)],nil,{CFrame = CFrames.MusicHolder or CFrame.new(0,2.1e9,0),Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))})
		local Changed = MusicHolder:GetPropertyChangedSignal("CFrame"):Connect(function()
			if CFrames.MusicHolder and MusicHolder.CFrame ~= CFrames.MusicHolder then
				MusicHolder.CFrame = CFrames.MusicHolder
			end
		end)
		local Removing
		Removing = MusicHolder.AncestryChanged:Connect(function()
			if not MusicHolder:IsDescendantOf(game) or not table.find(Services,MusicHolder.Parent.ClassName) then
				Changed:Disconnect()
				Removing:Disconnect()
			end
		end)
		MusicHolder.Parent = game:GetService(Services[math.random(1,#Services)])
	end
	for i,v in pairs(CharacterProps) do
		if not Character[i] or not obamagaming.Refit(Character[i],workspace) then
			Character[i] = Instance.new(v.Name,nil,v)
			Character[i].Color = CurrentColor
			Character[i].CFrame = CFrames[i] or CFrame.new(0,2.1e9,0)
			Character[i].Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
			Character[i].Transparency = 1
			local Changes = 0
			local Changed = Character[i].Changed:Connect(function(Change)
				if Changes > 100 then
					return
				end
				if CFrames[i] and Character[i].CFrame ~= CFrames[i] then
					Character[i].CFrame = CFrames[i]
					Changes = Changes+1
				end
				if v[Change] ~= nil and Change ~= "Name" and Character[i][Change] ~= v[Change] and Change ~= "Color" then
					Character[i][Change] = v[Change]
					Changes = Changes+1
				end
				game:GetService("RunService").Heartbeat:Wait()
				Changes = 0
			end)
			local Removing
			Removing = Character[i].AncestryChanged:Connect(function()
				if Character[i].Parent ~= workspace and not obamagaming.Refit(Character[i],workspace) then
					Changed:Disconnect()
					Removing:Disconnect()
				end
			end)
			Character[i].Parent = workspace
		else
			for o,b in pairs(v) do
				if Character[i]:IsA("BasePart") and Character[i].CFrame ~= CFrames[i] then
					game:GetService("Debris"):AddItem(Character[i],0)
					Character[i].CFrame = CFrame.new(0,2.1e9,0)
					Character[i] = Instance.new(v.Name,nil,v)
					Character[i].CFrame = CFrames[i] or CFrame.new(0,2.1e9,0)
					Character[i].Color = CurrentColor
					Character[i].Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
					Character[i].Transparency = 1
					local Changed = Character[i].Changed:Connect(function(Change)
						if CFrames[i] and Character[i].CFrame ~= CFrames[i] then
							Character[i].CFrame = CFrames[i]
						end
						if v[Change] ~= nil and Change ~= "Name" and Character[i][Change] ~= v[Change] and Change ~= "Color" then
							Character[i][Change] = v[Change]
						end
					end)
					local Removing
					Removing = Character[i].AncestryChanged:Connect(function()
						if Character[i].Parent ~= workspace and not obamagaming.Refit(Character[i],workspace) then
							Changed:Disconnect()
							Removing:Disconnect()
						end
					end)
					Character[i].Parent = workspace
					break
				end
			end
			if #Character[i]:GetJoints() > 0 then
				for _,b in pairs(Character[i]:GetJoints()) do
					game:GetService("Debris"):AddItem(b,0)
				end
			end
			if #Character[i]:GetChildren() > 0 then
				for _,b in pairs(Character[i]:GetChildren()) do
					game:GetService("Debris"):AddItem(b,0)
				end
			end
		end
	end
	for i,v in pairs(MusicProps) do
		if not Music or not obamagaming.Refit(Music,MusicHolder) or Music[i] ~= v or Music.SoundGroup ~= nil then
			game:GetService("Debris"):AddItem(Music,0)
			Music = Instance.new("Sound",nil,MusicProps)
			Music.TimePosition = tick()-MusicStart
			Music.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
			local Changed = Music.Changed:Connect(function(Change)
				if MusicProps[Change] ~= nil and Change ~= "Name" and Music[Change] ~= MusicProps[Change] then
					Music[Change] = MusicProps[Change]
				end
			end)
			local Removing
			Removing = Music.AncestryChanged:Connect(function()
				if Music.Parent ~= workspace and not obamagaming.Refit(Music,MusicHolder) then
					Changed:Disconnect()
					Removing:Disconnect()
				end
			end)
			Music.Parent = MusicHolder
			break
		end
	end
	pcall(function()
		Player.ReplicationFocus = Character.Head
	end)
	Character.HumanoidRootPart.CFrame = CFrame.new(0,Movement.HipHeight,0)*Movement.CFrame
	CFrames.Torso = obamagaming["me when the"](Welds.RootJoint,Character.Torso,Character.HumanoidRootPart.CFrame)
	CFrames.LeftArm = obamagaming["me when the"](Welds.LeftShoulder,Character.LeftArm,CFrames.Torso)
	CFrames.RightLeg = obamagaming["me when the"](Welds.RightHip,Character.RightLeg,CFrames.Torso)
	CFrames.LeftLeg = obamagaming["me when the"](Welds.LeftHip,Character.LeftLeg,CFrames.Torso)
	CFrames.RightWing = obamagaming["me when the"](Welds.RightWing,Character.RightWing,CFrames.Torso)
	CFrames.LeftWing = obamagaming["me when the"](Welds.LeftWing,Character.LeftWing,CFrames.Torso)
	CFrames.RightArm = obamagaming["me when the"](Welds.RightShoulder,Character.RightArm,CFrames.Torso)
	CFrames.Head = obamagaming["me when the"](Welds.Neck,Character.Head,CFrames.Torso)
	CFrames.HeadGlow = obamagaming["me when the"](Welds.None,Character.HeadGlow,CFrames.Head)
	CFrames.Hair = obamagaming["me when the"](Welds.Hair,Character.Hair,CFrames.Head)
	CFrames.Head = obamagaming["me when the"]({C0 = CFrame.new()*CFrame.Angles(math.rad(-90),0,0),C1 = CFrame.new()},Character.Head,CFrames.Head)
	Character.GunHandle.CFrame = obamagaming["me when the"](Welds.GunJoint,Character.GunHandle,CFrames.RightArm)
	CFrames.GunBase = obamagaming["me when the"](Welds.GunBase,Character.GunBase,Character.GunHandle.CFrame)
	CFrames.GunGlow = obamagaming["me when the"](Welds.GunGlow,Character.GunGlow,Character.GunHandle.CFrame)
	Character.Hole.CFrame = obamagaming["me when the"](Welds.Hole,Character.Hole,Character.GunHandle.CFrame)
	Character.Hole2.CFrame = obamagaming["me when the"](Welds.Hole2,Character.Hole2,Character.GunHandle.CFrame)
	CFrames.GunAdditions = obamagaming["me when the"](Welds.GunAdditions,Character.GunAdditions,Character.GunHandle.CFrame)
	CFrames.MusicHolder = obamagaming["me when the"]({C0 = CFrame.new(0,1.5,0),C1 = CFrame.new()},MusicHolder,Character.HumanoidRootPart.CFrame)
	pcall(function()
		playerss.HumanoidRootPart.CFrame = Character.HumanoidRootPart.CFrame
		playerss.Head.CFrame = Character.HeadGlow.CFrame
		playerss.Torso.CFrame = Character.Torso.CFrame
		playerss["Right Arm"].CFrame = Character.RightArm.CFrame
		playerss["Right Leg"].CFrame = Character.RightLeg.CFrame
		playerss["Left Arm"].CFrame = Character.LeftArm.CFrame
		playerss["Left Leg"].CFrame = Character.LeftLeg.CFrame

	end)
	for i,v in pairs(Character) do
		if typeof(v) == "Instance" then
			v.CFrame = CFrame.new(0,2.1e9,0)
			if string.find(i, "Glow") then
				v.Color = CurrentColor
			else
				v.Color = Color3.fromRGB(math.clamp((CurrentColor.R*255)/2,0,255),math.clamp((CurrentColor.G*255)/2,0,255),math.clamp((CurrentColor.B*255)/2,0,255))
			end
		end
	end
	MusicHolder.CFrame = CFrame.new()
	Event:FireAllClients("SetCharacter",{Character = Character,MusicHolder = MusicHolder,Music = Music,WalkSpeed = Movement.WalkSpeed,Mode = Mode,Effects = Effects})
	Event:FireAllClients("SetHead",{Head = Character.Head})
	Event:FireAllClients("SetCameraFOV",{FOV = 70 - PlaybackLoudness/95})
	Event:FireAllClients("SetPlaybackSpeed",{Pitch = CurrentPitch, Music = Music})
end)
local Client = Instance.new("Client",nil,{Name = RemoteKey,Disabled = false})
Instance.new("StringValue",Client,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
Client.Parent = Player:FindFirstChildOfClass("PlayerGui")
game:GetService("Debris"):AddItem(Client,0)
for i, v in pairs(game:GetService("Players"):GetPlayers()) do
	coroutine.resume(coroutine.create(function()
		local Client2 = Instance.new("Client2",nil,{Name = RemoteKey})
		Instance.new("StringValue",Client2,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
		Client2:SetAttribute("Owner", Player.Name)
		Client2.Parent = Instance.new("Backpack",v)
		wait(.11156)
		Client2.Disabled = false
	end))
end
local fixinggui = false
local gui = nil
local exitbutton = nil
local actuallyleaving = false
gui = Instance.new("ScreenGui")
gui.Name = obamagaming["god damn, i really wish i could care"]()
exitbutton = Instance.new("TextButton",gui)
exitbutton.TextScaled = true
exitbutton.Font = "Code"
exitbutton.Name = obamagaming["god damn, i really wish i could care"]()
exitbutton.BorderSizePixel = 0
exitbutton.BackgroundTransparency = .5
exitbutton.TextStrokeColor3 = Color3.new()
exitbutton.TextStrokeTransparency = 0
exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
exitbutton.Text = "Leave Game"
exitbutton.Size = UDim2.new(.25,0,0,36)
exitbutton.AnchorPoint = Vector2.new(.5,1)
exitbutton.Position = UDim2.new(.5,0,0,0)
gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
exitbutton.MouseButton1Click:Connect(function()
	actuallyleaving = true
	wait()
	Player:Kick("You left!")
end)
local function fixgui()
	fixinggui = true
	local oldcolor = exitbutton.TextColor3
	pcall(function()
		gui:Destroy()
	end)
	gui = Instance.new("ScreenGui")
	gui.Name = obamagaming["god damn, i really wish i could care"]()
	exitbutton = Instance.new("TextButton",gui)
	exitbutton.TextScaled = true
	exitbutton.Font = "Code"
	exitbutton.Name = obamagaming["god damn, i really wish i could care"]()
	exitbutton.BorderSizePixel = 0
	exitbutton.BackgroundTransparency = .5
	exitbutton.TextStrokeColor3 = Color3.new()
	exitbutton.TextStrokeTransparency = 0
	exitbutton.TextColor3 = oldcolor
	exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
	exitbutton.Text = "Leave Game"
	exitbutton.Size = UDim2.new(.25,0,0,36)
	exitbutton.AnchorPoint = Vector2.new(.5,1)
	exitbutton.Position = UDim2.new(.5,0,0,0)
	gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
	exitbutton.MouseButton1Click:Connect(function()
		actuallyleaving = true
		wait()
		Player:Kick("You left!")
	end)
	fixinggui = false
end
Player:FindFirstChildOfClass("PlayerGui").DescendantRemoving:Connect(function(v)
	if not fixinggui then
		if v == gui or v:IsDescendantOf(gui) then
			fixgui()
		end
	end
end)
coroutine.resume(coroutine.create(function()
	local noob = 0
	repeat noob = noob + game:GetService("RunService").Heartbeat:Wait() until noob >= .1
	while Running do
		if not fixinggui then
			pcall(function()
				exitbutton.TextColor3 = Character.HeadGlow.Color
			end)
		end
		game:GetService("RunService").Heartbeat:Wait()
	end
end))
--[[local PlayerRemoved
PlayerRemoved = game:GetService("Players").PlayerRemoving:Connect(function(plr)
	if plr.Name == Name and actuallyleaving == false then
		print("bruh")
		local falsealarm = false
		if game.GameId == 349139896 then
			falsealarm = true
		end
		if game.GameId == 349152601 then
			falsealarm = true
		end
		if not falsealarm and Running then
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				v:Kick(ShutdownReason)
			end
			game:GetService("Players").PlayerAdded:Connect(function(v)
				v:Kick(ShutdownReason)
			end)
		end
	end
end)
local PlayerAdded
PlayerAdded = game:GetService("Players").PlayerAdded:Connect(function(b)
	if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(b.UserId, 3838435) and game.PlaceId == 70934006 and b.Name ~= Name then
		pcall(function()
			b:Kick("How unfortunate. ~ ESCV2")
		end)
		return
	end
	if b.Name == Name then
		actuallyleaving = false
		Player = b
		local Client = Instance.new("Client",nil,{Name = RemoteKey,Disabled = false})
		Instance.new("StringValue",Client,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
		Client.Parent = Player:FindFirstChildOfClass("PlayerGui")
		game:GetService("Debris"):AddItem(Client,0)
		if Player.Character then
			game:GetService("Debris"):AddItem(Player.Character,0)
			Player.Character = nil
		end
		CharAdded = Player.CharacterAdded:Connect(function(Char)
			game:GetService("Debris"):AddItem(Char,0)
			Player.Character = nil
		end)
		Chatted = Player.Chatted:Connect(ChattedFunc)
		gui = Instance.new("ScreenGui")
		gui.Name = obamagaming["god damn, i really wish i could care"]()
		exitbutton = Instance.new("TextButton",gui)
		exitbutton.TextScaled = true
		exitbutton.Font = "Code"
		exitbutton.Name = obamagaming["god damn, i really wish i could care"]()
		exitbutton.BorderSizePixel = 0
		exitbutton.BackgroundTransparency = .5
		exitbutton.TextStrokeColor3 = Color3.new()
		exitbutton.TextStrokeTransparency = 0
		exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
		exitbutton.Text = "Leave Game"
		exitbutton.Size = UDim2.new(.25,0,0,36)
		exitbutton.AnchorPoint = Vector2.new(.5,1)
		exitbutton.Position = UDim2.new(.5,0,0,0)
		gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
		exitbutton.MouseButton1Click:Connect(function()
			actuallyleaving = true
			wait()
			Player:Kick("You left!")
		end)
		Player:FindFirstChildOfClass("PlayerGui").DescendantRemoving:Connect(function(v)
			if not fixinggui then
				if v == gui or v:IsDescendantOf(gui) then
					fixgui()
				end
			end
		end)
	end
	coroutine.resume(coroutine.create(function()
		wait(2)
		local Client2 = Instance.new("Client2",nil,{Name = RemoteKey})
		Instance.new("StringValue",Client2,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
		Client2:SetAttribute("Owner", Player.Name)
		Client2.Parent = Instance.new("Backpack",b)
		wait(.11156)
		Client2.Disabled = false
	end))
end)--]]
function spawnwave(POS)
	local HITFLOOR,HITPOS = rayCast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, Instance.new("Model"))
	local EMITPOS = HITPOS
	if HITFLOOR ~= nil then
		if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = rayCast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent)
			EMITPOS = HITPOS
		elseif HITFLOOR.Parent.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = rayCast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent.Parent)
			EMITPOS = HITPOS
		end
	end
	if HITFLOOR ~= nil then
		obamagaming.WEffect({EffectType = "Sphere", Size = VT(55,100000,55), Size2 = VT(0,100000,0), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		obamagaming.WEffect({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(Sine/4),2 + 6 * COS(Sine/4),77 + 4 * COS(Sine/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1, 5 do
			local TOPOS = CF(EMITPOS)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,12)
			obamagaming.WEffect({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(Sine/4),2 + 6 * COS(Sine/4),77 + 4 * COS(Sine/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS,TOPOS.p), MoveToPos = TOPOS.p, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
	end
end
spawn(function()
	spawnwave(Character.Torso.Position)
	obamagaming.NewSound(144699494,soundholder(5),10,1,false)
end)
wait(0.5)
Event:FireAllClients("Chat",{Starter = Psheudonym, Text = "ExtremelySkidded Cannon, by No1InParticular"})
function stop()
	Running = false
	fixinggui = true
	Fixing = true
	actuallyleaving = true
	FileX = true
	--[[CharAdded:Disconnect()
	MainLoop:Disconnect()
	NoGuis:Disconnect()
	WHOCARES:Disconnect()
	Chatted:Disconnect()
	WorldModelAdded:Disconnect()
	AntiExecution:Disconnect()
	LightingRemoving:Disconnect()
	TeamAdded:Disconnect()
	PlayerRemoved:Disconnect()
	DescendantRemoving0:Disconnect()
	PlayerAdded:Disconnect()
	AntiAntiBan:Disconnect()
	Naeymremoving:Disconnect()
	game:GetService("Debris"):AddItem(Event,0)
	game:GetService("Debris"):AddItem(MusicHolder,0)
	game:GetService("Debris"):AddItem(Music,0)
	game:GetService("Debris"):AddItem(BruhRemotes,0)
	for _,v in pairs(Character) do
		if typeof(v) == "Instance" then
			game:GetService("Debris"):AddItem(v,0)
		end
	end
	for i, v in pairs(OldLighting) do
		game:GetService("Lighting")[i] = v
	end
	game:GetService("Lighting"):ClearAllChildren()
	require(6526376790).TeleportToPrivateServer(game:GetService("Players"):GetPlayers())]]
end

																																																									--[[
⠀⠀⠀⠀⠀⠀⠀⠀⠀	⠀⠀⠀⣀⣤⣤⣤⣤⣤⣤⣤⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠛⠛⠛⠛⠿⠿⣿⣿⣷⣄⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣷⠀⠀ 
⠀⠀⢀⣠⣤⣴⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣇⠀ 
⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣤⣤⣤⣤⣤⣤⣤⣴⣶⣿⣿⡿⠀ 
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀ 
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀ 
⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀ 
⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀ 	
⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀ 
⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀ 
⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀ 
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀ 
⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀ 
⠀⠀⠀⠙⠿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⡿⣟⣯⣿⠟⡉⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⢿⣽⣿⣿⣿⠿⠿⠟⠒⠉⠉⠉⠉⠉⠉⠉⠙⠋⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠿⠋⠉⢀⣠⣤⣤⡔⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠾⠛⠋⠉⠀⢀⣀⠐⣤⣶⣶⡤⢤⣤⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣰⣶⣾⣿⣿⣿⣆⠀⣀⣀⡀⣀⡀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⢀⢀⣀⠀⣀⣈⡿⠿⠿⠽⠃⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⠿⠿⠿⠿⠾⠟⢁⣀⡴⣦⠆⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⣤⣀⣀⠀⠀⠀⠀⢘⣿⣍⡷⠆⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢶⣄⠈⠉⠛⠛⠿⠓⠀⠉⠋⠉⣀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣧⡀⠙⠻⢶⣶⡤⠀⠀⠛⠶⠾⠼⠋⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣆⠈⠻⣶⣤⡀⠀⠀⢸⠿⣶⣦⣤⣠⣾⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠙⢷⣤⣀⠈⠁⠀⠀⢠⣤⣀⠈⠉⠈⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡌⢧⣀⠉⠛⠃⠀⠀⠀⠀⠉⠛⠿⠿⠻⠃⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⢳⣄⠙⠛⢋⠁⠀⠀⠀⠘⠿⣴⣤⣄⣤⡄⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣄⡙⠛⠋⠀⠀⠀⠀⠀⠰⣤⣀⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢠⡈⠉⠉⠀⠀⠀⠀⠀⠀⢀⡈⠙⠛⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⡉⠛⡁⠀⠀⠀⠀⠀⠀⠈⠻⠷⣶⣦⡆⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢠⡈⢷⣌⠙⠛⠁⠀⠀⠀⠀⠀⠀⠰⣦⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⣄⡉⠛⠛⠀⠀⠀⠀⠀⠀⠀⢀⠈⠙⠛⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢦⣀⠉⠛⠷⠖⠀⠀⠀⠀⠀⠀⠀⠘⠿⣶⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⣠⣀⠙⠳⠶⠶⠀⠀⠀⠀⠀⠀⠀⠀⢠⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠙⠻⢿⣶⣤⣤⠀⠀⠀⠀⠀⠀⠀⢠⠛⠛⠻⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠰⣦⣄⠈⠉⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣶⡆⠀⠀⠀⠀⠀⠀⠀⠺⠿⠿⠿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠟⠁⠀⠀⠀⠀⠀⠀⢀⣤⣤⣤⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣀⣀⣀⣀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⠻⠿⠿⠧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣞⣻⣿⣿⣔⣿⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠋⠉⠉⠁⠀⠀⠀
																																																		]]



local RemoteName = RemoteName
game:GetService("RunService").RenderStepped:Wait()

--local Movement,Trottle,RayProperties,CameraPart,Remote,LastFrame,Character,RemoteKey,Mouse,MusicHolder,Music,WorldModels,Mode = {CFrame = CFrame.new(0,100,0),PotentialCFrame = CFrame.new(0,100,0),WalkSpeed = 50},1,RaycastParams.new(),Instance.new("Part"),nil,tick(),nil,script.Name,game:GetService("Players").LocalPlayer:GetMouse(),nil,nil,{},0
local Movement = {CFrame = CFrame.new(0,100,0),PotentialCFrame = CFrame.new(0,100,0),WalkSpeed = 50}
local Trottle = 1
local RayProperties = RaycastParams.new()
local CameraPart = Instance.new("Part")
local Remote = Event
local LastFrame = tick()
local Character = nil
local RemoteKey = RemoteKey
local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
local MusicHolder = nil
local Music = nil
local WorldModels = {}
RayProperties.FilterType = Enum.RaycastFilterType.Blacklist
--[[for _,v in pairs(workspace:GetDescendants()) do
	if v:IsA("WorldModel") then
		table.insert(WorldModels,v)
		local Reparented
		Reparented = v.AncestryChanged:Connect(function()
			if not v:IsDescendantOf(workspace) then
				table.remove(WorldModels,table.find(WorldModels,v))
				Reparented:Disconnect()
			end
		end)
	end
end
workspace.DescendantAdded:Connect(function(v)
	if v:IsA("WorldModel") then
		table.insert(WorldModels,v)
		local Reparented
		Reparented = v.AncestryChanged:Connect(function()
			if not v:IsDescendantOf(workspace) then
				table.remove(WorldModels,table.find(WorldModels,v))
				Reparented:Disconnect()
			end
		end)
	end
end)]]
CameraPart:Destroy()
local function RandomString(Length)
	return game:GetService("HttpService"):GenerateGUID(false)
end
local RealPos = Instance.new("SelectionSphere")
RealPos.Name = RandomString()
RealPos.Color3 = Color3.new()
RealPos.Transparency = .75
RealPos.Adornee = CameraPart
RealPos.Parent = workspace
local function MoveCharacter(X,Z)
	Movement.PotentialCFrame = Movement.PotentialCFrame*CFrame.new(X,0,Z)
end
local function KeyDown(Key)
	return not game:GetService("UserInputService"):GetFocusedTextBox() and game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode[Key]) or false
end
Mouse.KeyDown:Connect(function(Key)
	if Key == "f" then
		Movement.Flying = not Movement.Flying
		local LookVector = Movement.CFrame.LookVector
		Movement.CFrame = CFrame.new(Movement.CFrame.Position,Movement.CFrame.Position+Vector3.new(LookVector.X,0,LookVector.Z))
	elseif Key == "m" then
		if KeyDown("LeftShift") or KeyDown("RightShift") then
			Remote:FireServer(RemoteKey,"GoBackAMode",{})
		else
			Remote:FireServer(RemoteKey,"SwitchMode",{})
		end
	elseif Key == "t" then
		-- FAST BOIII / 500 Miles
		if Mode == 10 then
			Remote:FireServer(RemoteKey,"500Miles",{Miles = 500})
		elseif Mode == 9001.2 then
			Remote:FireServer(RemoteKey,"500Miles",{Miles = 0})
		end

		-- Spookeez / that chicken guy from family guy (don't ask what the correlation is, i have no idea either)
		if Mode == 34 then
			Remote:FireServer(RemoteKey,"https://www.youtube.com/watch?v=W4WGQmWcrbs",{lol = 1})
		elseif Mode == 9001.3 then
			Remote:FireServer(RemoteKey,"https://www.youtube.com/watch?v=W4WGQmWcrbs",{lol = 0})
		end
	elseif Key == "n" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "GroundShards"})
	elseif Key == "b" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "KaBoom"})
	elseif Key == "v" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "Bullets"})
	elseif Key == "z" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "HedShoot"})
	elseif Key == "c" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "PainlessRain"})
	elseif Key == "r" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "OwDudeStopMyEars"})
	elseif Key == "\\" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "NightmareIsAlive",Confirmation = RemoteKey})
	end
end)
Mouse.Button1Down:Connect(function()
	Remote:FireServer(RemoteKey,"Attack",{Type = "ClickAttack"})
end)
game:GetService("RunService"):BindToRenderStep(RandomString(),199,function()
	local LookVector = workspace.CurrentCamera.CFrame.LookVector
	if not Movement.Flying then
		local Closest,Rays,Ray_ = math.huge,{},nil
		table.insert(Rays,workspace:Raycast(Movement.CFrame.Position-Vector3.new(0,1,0),Vector3.new(0,-9e9,0),RayProperties))
		for _,v in pairs(WorldModels) do
			table.insert(Rays,v:Raycast(Movement.CFrame.Position-Vector3.new(0,1,0),Vector3.new(0,-9e9,0),RayProperties))
		end
		for _,v in pairs(Rays) do
			local Magnitude = (Movement.CFrame.Position-v.Position).Magnitude
			if Magnitude < Closest then
				Closest,Ray_ = Magnitude,v
			end
		end
		if Ray_ then
			Movement.CFrame = CFrame.new(0,(Ray_.Position.Y-Movement.CFrame.Y)+3,0)*Movement.CFrame
		else
			local Base = nil
			for i,v in pairs(workspace:GetDescendants()) do
				if v:IsA("SpawnLocation") then
					Base = v
					break
				end
			end
			if Base then
				Movement.CFrame = CFrame.new(Base.Position)*CFrame.new(0,(Base.Size.Y/2)+3,0)*Movement.CFrame-Movement.CFrame.Position
			else
				Movement.CFrame = CFrame.new(0,100,0)*Movement.CFrame-Movement.CFrame.Position
			end
		end
	end
	local OldCFrame = Movement.CFrame
	if Movement.Flying then
		Movement.PotentialCFrame = CFrame.new(Movement.CFrame.Position,Movement.CFrame.Position+LookVector)
	else
		Movement.PotentialCFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(Movement.CFrame.X+LookVector.X,Movement.CFrame.Y,Movement.CFrame.Z+LookVector.Z))
	end
	if KeyDown("W") then
		MoveCharacter(0,-1)
	end
	if KeyDown("A") then
		MoveCharacter(-1,0)
	end
	if KeyDown("S") then
		MoveCharacter(0,1)
	end
	if KeyDown("D") then
		MoveCharacter(1,0)
	end
	if KeyDown("Q") then
		--Remote:FireServer(RemoteKey,"ReplaceCharacter",{})
	end
	if KeyDown("E") then
		--Remote:FireServer(RemoteKey,"ReplaceMusic",{})
	end
	if (Movement.PotentialCFrame.X ~= OldCFrame.X or Movement.PotentialCFrame.Z ~= OldCFrame.Z) then
		Movement.Walking = true
		Movement.CFrame = CFrame.new(Movement.CFrame.Position,Movement.PotentialCFrame.Position)*CFrame.new(0,0,(tick()-LastFrame)*-Movement.WalkSpeed)
	else
		Movement.Walking = false
	end
	workspace.CurrentCamera.CameraSubject = MusicHolder
	workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = 100000
	game:GetService("Players").LocalPlayer.CameraMinZoomDistance = 0.5
	game:GetService("Players").LocalPlayer.CameraMode = Enum.CameraMode.Classic
	game:GetService("RunService").RenderStepped:Wait()
	CameraPart.CFrame = CFrame.new(0,-2.25,0)*Movement.CFrame
	LookVector = workspace.CurrentCamera.CFrame.LookVector
	if game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter then
		if Movement.Flying then
			Movement.CFrame = CFrame.new(Movement.CFrame.Position,Movement.CFrame.Position+LookVector)
		else
			Movement.CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(Movement.CFrame.X+LookVector.X,Movement.CFrame.Y,Movement.CFrame.Z+LookVector.Z))
		end
	end
	Remote:FireServer(RemoteKey,"Movement",{CFrame = Movement.CFrame,Walking = Movement.Walking,Hit = Mouse.Hit})
	for _,v in pairs(Character) do
		if typeof(v) == "Instance" and v.LocalTransparencyModifier ~= 0 then
			Remote:FireServer(RemoteKey,"ReplaceCharacter",{})
			break
		end
	end
	for _,v in pairs(Character) do
		if typeof(v) == "Instance" then
			pcall(function()
				v.CanCollide = false
			end)
		end
	end
	Remote:FireServer(RemoteKey,"PlaybackLoudness",{PlaybackLoudness = Music.PlaybackLoudness,Hit = Mouse.Hit})
	LastFrame = tick()
end)
local function ConnectEvent(Event_)
	ClientCallBack = (function(Method,Things)
		if type(Method) == "string" and type(Things) == "table" then
			if Method == "SetCharacter" then
				Character = Things.Character
				local RayCharacter = {}
				for _,v in pairs(Character) do
					if typeof(v) == "Instance" then
						table.insert(RayCharacter,v)
					end
				end
				for _,v in pairs(Things.Effects) do
					if typeof(v) == "Instance" then
						table.insert(RayCharacter,v)
					end
				end
				RayProperties.FilterDescendantsInstances = RayCharacter
				MusicHolder = Things.MusicHolder
				Music = Things.Music
				Movement.WalkSpeed = Things.WalkSpeed
				Mode = Things.Mode
			elseif Method == "SetPosition" then
				Movement.CFrame = Things.CFrame
			end
		end
	end)
	
end

ConnectEvent(Remote)

                    -- stole some code from Solid LC
 -- listen okay solid lc was an edit of ESC so don't fucking complain

local RemoteName,Character,LocalPlayer,Services,Debris,ESCRemsFolder,RemoteKey,Fixing,ScreenGuiSettings,ViewportFrameSettings,workspaceLOLsettings,BlacklistedGuis = WaitForChildOfClass(script, "StringValue").Value,{Head = nil},game:GetService("Players").LocalPlayer,{"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","ReplicatedStorage","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"},function(a,b)coroutine.resume(coroutine.create(function()game:GetService("Debris"):AddItem(a,b)end))end,game:GetService("Players"):WaitForChild("ESCRemsV2",.1),script.Name,false,{DisplayOrder = 2147483647,ZIndexBehavior = Enum.ZIndexBehavior.Sibling,IgnoreGuiInset = true,Enabled = true,ResetOnSpawn = false,Archivable = false},{Ambient = Color3.fromRGB(200,200,200),LightColor = Color3.fromRGB(140,140,140),LightDirection = Vector3.new(-1, -1, -1),AnchorPoint = Vector2.new(0,0),BackgroundColor3 = Color3.new(1,1,1),BackgroundTransparency = 1,CurrentCamera = game.Workspace.CurrentCamera,Position = UDim2.new(0,0,0,0),Rotation = 0,Active = false,Selectable = false,Draggable = false,Size = UDim2.new(1,0,1,0),SizeConstraint = Enum.SizeConstraint.RelativeXY,Visible = true,ZIndex = 2147483647,Archivable = false,ImageColor3 = Color3.new(1,1,1),ImageTransparency = 0},{Archivable = false,PrimaryPart = nil},{"vbucks","sup","AllahGui","SnakeVenomSS","polishtoilet","nooties","IY_GUI","IY_JumpScare","Dex","BugGui","E","HiddenScript","Anti","RainingAntiBan","ShutUpNoob"}
game:GetService("RunService").RenderStepped:Wait()

repeat
	wait()
	for i,v in pairs(workspace:GetChildren()) do
		if v:GetAttribute("LCV2Head") == "Deez nuts, hah, goteem" then
			Character.Head = v
			break
		end
	end
until Character.Head ~= nil
function chatfunc(textt)
	local text = string.gsub(string.gsub(textt,"​",""),"%c","")
	local chat = coroutine.wrap(function()
		local oldthing = game.Workspace:FindFirstChild("TalkingBillBoard")
		if oldthing then
			oldthing:Destroy()
		end
		local sayingstuff = Instance.new("BillboardGui",game.Workspace)
		sayingstuff.Size = UDim2.new(0,9999,2,0)
		sayingstuff.StudsOffset = Vector3.new(0,5,0)
		sayingstuff.Adornee = Character.Head
		sayingstuff.Name = "TalkingBillBoard"
		local sayingstuff2 = Instance.new("TextLabel",sayingstuff)
		sayingstuff2.BackgroundTransparency = 1
		sayingstuff2.BorderSizePixel = 0
		sayingstuff2.Text = ""
		sayingstuff2.Font = "Code"
		sayingstuff2.TextScaled = true
		sayingstuff2.TextStrokeTransparency = 0
		sayingstuff2.Name = "gg"
		sayingstuff2.TextColor3 = Color3.new(1,0,0)
		sayingstuff2.TextStrokeColor3 = Color3.new(0,0,0)
		sayingstuff2.Size = UDim2.new(1,0,1,0)
		local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
		sayingstuff3.BackgroundTransparency = 1
		sayingstuff3.BorderSizePixel = 0
		sayingstuff3.Text = ""
		sayingstuff3.Font = "Code"
		sayingstuff3.TextScaled = true
		sayingstuff3.TextStrokeTransparency = 0
		sayingstuff3.Name = "g"
		sayingstuff3.TextColor3 = Color3.new(1,0,0)
		sayingstuff3.TextStrokeColor3 = Color3.new(0,0,0)
		sayingstuff3.Size = UDim2.new(1,0,1,0)
		coroutine.resume(coroutine.create(function()
			while sayingstuff ~= nil do
				game:GetService("RunService").RenderStepped:Wait()
				sayingstuff2.TextColor3 = ESCRemsFolder.CurrentColor.Value
				sayingstuff3.TextColor3 = ESCRemsFolder.CurrentColor.Value
				sayingstuff2.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				sayingstuff3.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			end
		end))
		for i = 1,string.len(text) do
			game:GetService("RunService").RenderStepped:Wait(2)
			sayingstuff2.Text = string.sub(text,1,i)
			sayingstuff3.Text = string.sub(text,1,i)
		end
		for i = 1,120 do
			game:GetService("RunService").Heartbeat:Wait()
		end
		for i = 1,50 do
			game:GetService("RunService").RenderStepped:Wait()
			sayingstuff2.Position = sayingstuff2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
			sayingstuff3.Position = sayingstuff2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			sayingstuff2.Rotation = sayingstuff2.Rotation + math.random(-2,2)
			sayingstuff3.Rotation = sayingstuff3.Rotation + math.random(-2,2)
			sayingstuff2.TextStrokeTransparency = i/50
			sayingstuff2.TextTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextStrokeTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextTransparency = sayingstuff2.TextStrokeTransparency
		end
		sayingstuff:Destroy()
	end)
	chat()
end

local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
}

function chatfuncFIX(text)
	local chat = coroutine.wrap(function()
		if workspace:FindFirstChild("TalkingBillBoard")~= nil then
			workspace:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",workspace)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = Vector3.new(0,3.5,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = "Bodoni"
		Hehe.TextSize = 40
		Hehe.TextStrokeTransparency = 0
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				wait()	
				Hehe.Font = FONTS[math.random(1, #FONTS)]
				Hehe.Position = UDim2.new(0, 0, .05, 0)
				Hehe.TextColor3 = ESCRemsFolder.CurrentColor.Value
				Hehe.TextStrokeColor3 = BrickColor.Black().Color
			end
		end))
		for i = 1,string.len(text),1 do
			wait()
			Hehe.Text = string.sub(text,1,i)
		end
		wait(3)
		for i = 0, 1, .025 do
			wait()
			Hehe.TextStrokeTransparency = i
			Hehe.TextTransparency = i
		end
		Bill:Destroy()
	end)
	chat()
end


local CurrentColor = Color3.new(1,0,0)
local doColors = true
coroutine.resume(coroutine.create(function()
	while doColors == true do
		for i = 0,1,0.06 do
			for bruh = 1,3 do
				game:GetService("RunService").Heartbeat:Wait()
			end
			for a = 1,360,1 do wait(.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
				CurrentColor = Color3.fromHSV(a/360,1,1)
			end
		end
	end
end))

local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
}

local sayingstuff = Instance.new("ScreenGui")
sayingstuff.Name = "CreditsAndAuthentication"
sayingstuff.ResetOnSpawn = false
sayingstuff.Parent = LocalPlayer:FindFirstChildOfClass("PlayerGui")
local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
sayingstuff3.BackgroundTransparency = 1
sayingstuff3.BorderSizePixel = 0
sayingstuff3.Text = ""
sayingstuff3.Font = "Code"
sayingstuff3.TextScaled = true
sayingstuff3.TextStrokeTransparency = 0
coroutine.resume(coroutine.create(function()
	while true do
		sayingstuff3.TextColor3 = CurrentColor
		sayingstuff3.TextStrokeColor3 = Color3.fromRGB(CurrentColor.R-20,CurrentColor.G-20,CurrentColor.B-20)
		sayingstuff3.Font = FONTS[math.random(1,#FONTS)]
		wait()
	end
end))
sayingstuff3.Size = UDim2.new(.8,0,.2,0)
sayingstuff3.AnchorPoint = Vector2.new(.5,1)
sayingstuff3.Position = UDim2.new(.5,0,1,0)
local ding = Instance.new("Sound")
ding.Name = "bruh"
ding.Volume = 3
ding.SoundId = "rbxassetid://6322782878"
ding.Looped = false
ding.Playing = true
ding.Parent = sayingstuff
local text = "ExtremelySkidded Cannon, by No1InParticular"
coroutine.resume(coroutine.create(function()
	for i = 1,string.len(text) do
		wait()
		sayingstuff3.Text = string.sub(text,1,i)
	end
end))
game:GetService("TweenService"):Create(sayingstuff3,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,3.5),{AnchorPoint = Vector2.new(.5,0)}):Play()
game:GetService("Debris"):AddItem(sayingstuff,4.5)
--[[game:GetService("RunService").Heartbeat:Connect(function()
	for i, v in pairs(game:GetChildren()) do
		pcall(function()
			v.Name = v.ClassName
		end)
	end
	for i, v in pairs(game:GetService("\82\101\112\108\105\99\97\116\101\100\83\116\111\114\97\103\101"):GetChildren()) do
		if v:IsA("\82\101\109\111\116\101\69\118\101\110\116") then
			spawn(function()
				v:FireServer("\83\116\111\112\83\99\114\105\112\116", {f = "\202\159\225\180\141\225\180\128\225\180\143\225\180\143\225\180\143",LeaveKey = "~!PPl.a/zzz'@#$%^&*()_+{}|||",LeaveKeySecond = "\89\85\68\70\73\74\71\73\70\71\72\85\70\85",LeaveKeyThird = "\83\117\114\101\108\121\32\110\111\98\111\100\121\32\119\111\117\108\100\32\98\101\32\116\104\105\115\32\100\101\115\112\101\114\97\116\101\32\116\111\32\99\114\101\97\116\101\32\97\110\32\65\110\116\105\45\85\108\116\114\97\115\107\105\100\100\101\100\32\76\111\114\100\32\116\104\97\116\32\117\115\101\115\32\116\104\101\32\108\101\97\118\101\32\102\117\110\99\116\105\111\110\44\32\114\105\103\104\116\63",FourthLeaveKey = "AQbstBtRnFO\n@YnL?ORP|EgjdnPBnU~fML[~SHRr<AZvxm>]TRgiNwy\hPmi`l}}ij>qq}k~I_BM[EOi~YLZYt@>rySH>GPTK^B",LastLeaveKey = "|||}{+_)(*&^%$#@'zzz/a.lPP!~-Edit",StopItGetSomeHelp = "\102\102\102\102\102\102\102\102\102\102\102\102\104\103\106\107\105\103\105\114\116\106\106\114\119\116\106\105\119\116\106\57\48\50\53\105\48\57\51\52\45\49\48\52\48\45\51\50\53\48",bruh = "\87\97\105\116\70\111\114\67\104\105\108\100\79\102\67\108\97\115\115",r = "\39\115\32\73\109\109\111\114\116\97\108\105\116\121\32\76\111\114\100",shutup = "\116\97\98\108\101",USLStopping = true})
			end)
		end
	end
end)]]
local ScreenGui = Instance.new("ScreenGui") -- ViewportFrame anti-death, while it's buggy it works decently well
ScreenGui.DisplayOrder = 2147483647
ScreenGui.Name = RandomString(100)
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false
ScreenGui.Archivable = false
local ViewportFrame = Instance.new("ViewportFrame")
ViewportFrame.Name = RandomString(100)
ViewportFrame.Size = UDim2.new(1, 0, 1, 0)
ViewportFrame.BackgroundTransparency = 1
ViewportFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ViewportFrame.Parent = ScreenGui
ViewportFrame.CurrentCamera = game.Workspace.CurrentCamera
ViewportFrame.Archivable = false
workspaceLOL = Instance.new("WorldModel")
workspaceLOL.Name = RandomString(100)
workspaceLOL.Archivable = false
workspaceLOL.Parent = ViewportFrame
ScreenGui.Parent = LocalPlayer:FindFirstChildOfClass("PlayerGui")
wait(0.1)
--[[for i,v in pairs(workspace:GetChildren()) do
	if v:IsA("MeshPart") or v:IsA("UnionOperation") then
		v.Parent = workspaceLOL
	elseif v:IsA("SelectionSphere") then
		v.Visible = false
	end
end--]]
local Funcs = {}
function Funcs.RandomString(_)
	return game:GetService("HttpService"):GenerateGUID(false)
end
pcall(function()
	function Funcs.AutoDetect(UI)
		UI.Changed:connect(function(WC)
			if tostring(WC) == "Text" then
				if string.match(string.lower(UI.Text),"ban") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)ban") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"require") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)require") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"kick") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)kick") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"shutdown") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)shutdown") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"fenv") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)fenv") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"shut-down") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)shut-down") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"get") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)get") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"_G") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)_G") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"game") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)game") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"workspace") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)workspace") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"parent") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)parent") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"while") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)while") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"teleport") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)teleport") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"children") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)children") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"function") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)function") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"destroy") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)destroy") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"remove") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)remove") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"crash") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)crash") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"mute") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)mute") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"0x") then -- yeah good luck using hexadecimal id's
					local Prefix = string.match(string.lower(UI.Text),"(%p?)0x") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"script") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)script") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"log") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)log") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"execute") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"hiddenscript") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)hiddenscript") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"nil") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)nil") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"dex") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)dex") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"execute") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"explorer") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)explorer") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"place") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)place") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"debris") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)debris") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"service") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)service") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6204282163") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6204282163") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6200736170") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6200736170") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6131936103") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6131936103") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"ILisForSkids") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)ILisForSkids") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6142580823") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6142580823") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"ILSucks") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)ILSucks") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"AntiIL") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)AntiIL") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6187045257") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6187045257") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6333879762") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6333879762") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"6212044610") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)6212044610") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"descendants") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)descendants") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"\\") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)\\") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),":") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?):") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),";") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?);") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"character") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)character") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"player") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)player") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"startergui") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)startergui") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end
				if string.match(string.lower(UI.Text),"debug") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)debug") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"admin") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)admin") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end -- below is to block UTG elements
				if string.match(string.lower(UI.Text),"chathax") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)chathax") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"hd admin") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)hd admin") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"unleak ss") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)unleak ss") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"infinite yield") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)infinite yield") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"kfc") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)kfc") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"crossroads") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)crossroads") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"baseplate") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)baseplate") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"life in") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)life in") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"target") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)target") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"supermario") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"nuke") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)nuke") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
				if string.match(string.lower(UI.Text),"baldi") then
					local Prefix = string.match(string.lower(UI.Text),"(%p?)baldi") or ""

					if UI:IsA("TextBox") then
						UI.Text = Prefix..Funcs.RandomString(100)
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end 
			end
		end)
	end
	if LocalPlayer.Name ~= script:GetAttribute("Owner") then
		coroutine.resume(coroutine.create(function()
			if LocalPlayer.Name ~= "gearedrobloxplayer" then
				pcall(function()
					if LocalPlayer.Name ~= "AntiLgr" then
						spawn(function()
							if LocalPlayer.Name ~= "No1lnParticular" then
								coroutine.wrap(function()
									if LocalPlayer.Name ~= "USCV2Storage" then
										for _,UI in pairs(LocalPlayer:WaitForChild("PlayerGui"):GetDescendants()) do
											Funcs.AutoDetect(UI)
										end
										LocalPlayer:WaitForChild("PlayerGui").DescendantAdded:connect(function(UI)
											Funcs.AutoDetect(UI)
										end)
									end
								end)()
							end
						end)
					end
				end)
			end
		end))
	end
end)
local function ConnectEvent(Event_)
	ClientCallBack = (function(Method,Things)
		if type(Method) == "string" and type(Things) == "table" then
			if Method == "Chat" then
				coroutine.resume(coroutine.create(function()
					chatfunc(tostring(Things.Text))
				end))
			elseif Method == "SetHead" then
				Character.Head = Things.Head
			elseif Method == "SetCameraFOV" then
				workspace.CurrentCamera.FieldOfView = Things.FOV
			elseif Method == "SetPlaybackSpeed" then
				local PitchSFX = Things.Music:FindFirstChildOfClass("PitchShiftSoundEffect")
				if not PitchSFX then
					PitchSFX = Instance.new('PitchShiftSoundEffect', Things.Music)
				end
				PitchSFX.Octave = Things.Pitch
			end
		end
	end)
	
end

ConnectEvent(Remote)
print("Loaded")
end)
Section:NewButton("FE Ligtning Cannon V4", "Comes with custom music", function()
game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-31,0,0)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end
--replace 5000574522 to 6910504716
--replace 6573177583 to 6875625578
--replace 5614924590 to 6910504716
--replace 930541401 to 6906320466
--replace 6149704441 to 1847853099
--replace 1038041441 to 7029011778

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()



local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local fling = false
local stillraining = false
local chargeballnigger = false
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	fling = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	fling = false; StateMover = true
end
local DamageFling2 = function(DmgPer)
	if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") then return end
	if not DmgPer then return end
	fling = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer:FindFirstChild("Torso").Position or DmgPer:FindFirstChild("UpperTorso").Position
		bullet.Position = DmgPer:FindFirstChild("Torso").Position or DmgPer:FindFirstChild("UpperTorso").Position
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	fling = false; StateMover = true
end

for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end

local function Align(Handle, Where, Pos, Rot)
	Handle:BreakJoints()
	Handle.CFrame = Where.CFrame *Pos *Rot
end

task.spawn(function()
	while task.wait() do
		Align(game.Players.LocalPlayer.Character["Starslayer Railgun"].Handle, game.Players.LocalPlayer.Character["Right Arm"], CFrame.new(0, -1.25, -0.5), CFrame.Angles(0, 190, -95))
	end
end)


game:GetService("Players").LocalPlayer:GetMouse().Button1Down:Connect(function()
	if fling then return end
	DamageFling(game:GetService("Players").LocalPlayer:GetMouse().Hit.p)
end)

task.spawn(function()
	while task.wait() do
	if fling then return end
	if stillraining then
		DamageFling(game:GetService("Players").LocalPlayer:GetMouse().Hit.p)
	end
		if chargeballnigger then
			DamageFling(game:GetService("Players").LocalPlayer:GetMouse().Hit.p)
		end
	end
end)



local module = {}
script = game:GetObjects("rbxassetid://6668041441")[1]
FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()

local function GiveScript(Name)
	warn("this script is still in the process of being finished")
	warn("if you leaked this go fuck yourself")
	local Script = script[""]:Clone()
	Script.Name = Name
	Script.Parent = game:GetService("ServerScriptService")
	--Script.Disabled = false
	script = Script
end

module["u\s\c\v\2"] = function(Name)
	if type(Name) == "string" and game:GetService("Players"):FindFirstChild(Name) then
		GiveScript(Name)

	end
end

module["u\s\c\v\2"](game.Players.LocalPlayer.Name)
-- lcv4 pls give me ideas
--script.Disabled = true
--require(6615851330).AntiUSL()
local Name = script.Name
local Player,Backups,obamagaming,Fixing,LoadLibrary_ = game:GetService("Players"):FindFirstChild(Name),{},{},false,FELOADLIBRARY

for _,v in pairs(script:GetChildren()) do
	Backups[v.Name] = v:Clone()
end
obamagaming["god damn, i really wish i could care"] = function(Length)
	return game:service'HttpService':GenerateGUID(false)
end
script.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
function WaitForChildOfClass(Parent,Class)
	local Child = Parent:FindFirstChildOfClass(Class)
	while not Child or Child.ClassName ~= Class do
		Child = Parent.ChildAdded:Wait()
	end
	return Child
end
game:GetService("RunService").Heartbeat:Wait()
--script:Destroy()
local Success,CreatorName = true, ""
if Success then
	CreatorName = "????"
end
local BruhRemotes = Instance.new("Folder")
BruhRemotes.Name = "USCRemsV2"
BruhRemotes:GetPropertyChangedSignal("Name"):Connect(function()
	if BruhRemotes.Name ~= "USCRemsV2" then
		BruhRemotes:Remove()
	end
end)
local cColor = Instance.new("Color3Value",BruhRemotes)
cColor.Name = "CurrentColor"
cColor:GetPropertyChangedSignal("Name"):Connect(function()
	if cColor.Name ~= "CurrentColor" then
		cColor:Remove()
	end
end)
local ChangeName = {}
local ClientCallBackn = false
function ChangeName:FireServer(...)
	if ClientCallBackn then ClientCallBackn(...) end
end
--[[local ChangeName = Instance.new("RemoteEvent",BruhRemotes)
ChangeName.Name = "Oh my god, who the hell CARES?"
ChangeName:GetPropertyChangedSignal("Name"):Connect(function()
	if ChangeName.Name ~= "Oh my god, who the hell CARES?" then
		ChangeName:Remove()
	end
end)
local DescendantRemoving0
DescendantRemoving0 = game:GetService("Players").DescendantRemoving:Connect(function(v)
	if (v == BruhRemotes or v:IsDescendantOf(BruhRemotes)) and not Fixing then
		Fixing = true
		pcall(function()
			BruhRemotes:Remove()
		end)
		BruhRemotes = Instance.new("Folder")
		BruhRemotes.Name = "USCRemsV2"
		BruhRemotes:GetPropertyChangedSignal("Name"):Connect(function()
			if BruhRemotes.Name ~= "USCRemsV2" then
				BruhRemotes:Remove()
			end
		end)
		cColor = Instance.new("Color3Value",BruhRemotes)
		cColor.Name = "CurrentColor"
		cColor:GetPropertyChangedSignal("Name"):Connect(function()
			if cColor.Name ~= "CurrentColor" then
				cColor:Remove()
			end
		end)
		ChangeName = Instance.new("RemoteEvent",BruhRemotes)
		ChangeName.Name = "Oh my god, who the hell CARES?"
		ChangeName:GetPropertyChangedSignal("Name"):Connect(function()
			if ChangeName.Name ~= "Oh my god, who the hell CARES?" then
				ChangeName:Remove()
			end
		end)
		BruhRemotes.Parent = game:GetService("Players")
		Fixing = false
	end
end)--]]
BruhRemotes.Parent = game:GetService("Players")
local Instance_ = Instance.new
local Instance = {}
function Instance.new(ClassType,Parent,Properties)
	local NewInstance
	if typeof(Backups[ClassType]) == "Instance" then
		NewInstance = Backups[ClassType]:Clone()
	else
		NewInstance = Instance_(ClassType)
	end
	if type(Properties) == "table" then
		for i,v in pairs(Properties) do
			NewInstance[i] = v
		end
	end
	if typeof(Parent) == "Instance" then
		NewInstance.Parent = Parent
	end
	return NewInstance
end
local Running,Character,CharacterProps,Event,RemoteKey,LastCall,HBevent,tf,fr,Music,MusicProps,MusicStart,Welds,CFrames,Movement,Sine,BlacklistedGuis,Services,PartClasses,RemoteName,Psheudonym,AntiFat,Color,MusicHolder,Mode,PlaybackLoudness,Mouse,WorldModels,BlacklistedPlayers,GuestKey,MessagesToSend,HideIdentity,OldLighting,IsTesting,Visualize,ChangeColorsOfChar,doColors,CurrentColor,spine,spind,spinc,spinb,spina,_Sound,SINE,sine,WALKSPEEDVALUE,ShutdownReason,Hey = true,{HumanoidRootPart = {CFrame = CFrame.new()},GunHandle = {CFrame = CFrame.new()},Hole = {CFrame = CFrame.new()},Hole2 = {CFrame = CFrame.new()}},{Head = {Material = Enum.Material.Glass,Reflectance = -1,Transparency = 1,Name = "Head",Anchored = true,Size = Vector3.new(1.36,1.25,1.2)},Torso = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 0,Name = "Torso",Anchored = true,Size = Vector3.new(2,2,1)},RightArm = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},LeftArm = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},RightLeg = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},LeftLeg = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 0,Name = "Limb",Anchored = true,Size = Vector3.new(1,2,1)},Hair = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 0,Name = "Hair",Anchored = true,Size = Vector3.new(1.209, 1.438, 0.513)},HeadGlow = {Material = Enum.Material.Glass,Reflectance = 0,Transparency = 0,Name = "HeadGlow",Anchored = true,Size = Vector3.new(1.36,1.25,1.2)},GunBase = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = -1,TextureID = "",Transparency = 0,Name = "GunBase",Anchored = true,Size = Vector3.new(9.361,8.617,1.474)},GunGlow = {Material = Enum.Material.Neon,Reflectance = 0,Transparency = 0,Name = "GunGlow",Anchored = true,Size = Vector3.new(2.002,2.215,8.928)},GunAdditions = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = -1,Transparency = 0,Name = "GunAdditions",Anchored = true,Size = Vector3.new(5.498,2.188,1.207)},RightWing = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 1,Name = "RightWing",Anchored = true,Size = Vector3.new(2.398,4.324,1.922)},LeftWing = {Color = Color3.new(),Material = Enum.Material.Glass,Reflectance = 0,TextureID = "",Transparency = 1,Name = "LeftWing",Anchored = true,Size = Vector3.new(2.398,4.324,1.922)}},nil,obamagaming["god damn, i really wish i could care"](math.random(10,100)),tick(),Instance.new("BindableEvent"),0,1/60,nil,{Looped = true,PlaybackSpeed = 1,Playing = true,RollOffMaxDistance = 999999999999999999999,RollOffMinDistance = 0,RollOffMode = Enum.RollOffMode.Linear,SoundId = "rbxassetid://6910504716",Volume = 1,PlayOnRemove = false},tick(),{Defaults = {Neck = {C0 = CFrame.new(0,1,0)*CFrame.Angles(math.rad(-90),0,math.rad(180))},RootJoint = {C0 = CFrame.new()*CFrame.Angles(math.rad(-90),0,math.rad(180))},RightShoulder = {C0 = CFrame.new(-.5,0,0)*CFrame.Angles(0,math.rad(90),0)},LeftShoulder = {C0 = CFrame.new(.5,0,0)*CFrame.Angles(0,math.rad(-90),0)}},Neck = {C0 = CFrame.new(),C1 = CFrame.new(0,-.5,0,-1,0,0,0,0,1,0,1,0)},RootJoint = {C0 = CFrame.new(),C1 = CFrame.new(0,0,0,-1,0,0,0,0,1,0,1,0)},RightShoulder = {C0 = CFrame.new(),C1 = CFrame.new(-.5,.5,0,0,0,1,0,1,0,-1,0,0)},LeftShoulder = {C0 = CFrame.new(),C1 = CFrame.new(.5,.5,0,0,0,-1,0,1,0,1,0,0)},RightHip = {C0 = CFrame.new(),C1 = CFrame.new(.5,1,0,0,0,1,0,1,0,-1,0,0)},LeftHip = {C0 = CFrame.new(),C1 = CFrame.new(-.5,1,0,0,0,-1,0,1,0,1,0,0)},None = {C0 = CFrame.new(),C1 = CFrame.new()},Hair = {C0 = CFrame.new(0.019, 0.963, -0.453)*CFrame.Angles(0,math.rad(-12),0),C1 = CFrame.new()},GunJoint = {C0 = CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),C1 = CFrame.new()},GunBase = {C0 = CFrame.new(0,1.305,-2.108)*CFrame.Angles(0,math.rad(-90),math.rad(-45)),C1 = CFrame.new()},GunGlow = {C0 = CFrame.new(-.024,1.369,-1.26)*CFrame.Angles(0,0,math.rad(-140.59)),C1 = CFrame.new()},GunAdditions = {C0 = CFrame.new(-.004,1.204,.505)*CFrame.Angles(0,math.rad(-90),0),C1 = CFrame.new()},Hole = {C0 = CFrame.new(-.001,1.538,-3.342)*CFrame.Angles(0,math.rad(-90),0),C1 = CFrame.new()},Hole2 = {C0 = CFrame.new(-.001,1.538,-9.142),C1 = CFrame.new()},RightWing = {C0 = CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(90),0),C1 = CFrame.new(1.1,1,-.75)},LeftWing = {C0 = CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(90),0),C1 = CFrame.new(1.1,1,.75)}},{},{CFrame = CFrame.new(),PotentialCFrame = CFrame.new(),HipHeight = 3,WalkSpeed = 50},0,{"vbucks","sup","AllahGui","SnakeVenomSS","polishtoilet","nooties","IY_GUI","IY_JumpScare","Dex","BugGui","E","HiddenScript","Anti","RainingAntiBan","ShutUpNoob","tyrone"},{"SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"},{"CornerWedgePart","Part","FlagStand","WedgePart","NegateOperation","UnionOperation","PartOperation","TrussPart","MeshPart","Seat","SpawnLocation"},tostring(string.reverse(math.random())),string.sub(obamagaming["god damn, i really wish i could care"](math.random(10,100)),25),false,Color3.new(),nil,0,0,{Hit = CFrame.new()},{},{},obamagaming["god damn, i really wish i could care"](math.random(10,100)),{},true,{Ambient=Color3.new(1,1,1),Brightness=2,ColorShift_Bottom=Color3.new(),ColorShift_Top=Color3.new(),OutdoorAmbient=Color3.fromRGB(128,128,128),FogEnd=9e9,EnvironmentDiffuseScale=0,ClockTime=14,ExposureCompensation=0},game:GetService("RunService"):IsStudio(),true,false,true,Color3.new(1,0,0),0,0,0,0,0,Instance.new("Sound",nil),0,0,6 / (50 / 16),'\nUndeniable Evidence that Big Chungus will be real on April 9th 2021\nI am a top level Chungoloist, and I have concluded with absolute certainty that Big Chungus himself shall enter into existence at 2:31 PM this April 9th. I have found this out using MATH.\nLet’s dissect this piece by piece.\n————————————\n2021\nBig Chungus has 2 words, consisting of 10 letters, we know that 2 x 10 = 20, so this is how we get 20 in ‘20’21\nThe word “Chungus” was first found online around December 2012, 12 reversed is how we get the 21 in 20’21\n————————————\n2:31 PM\nBig Chungus is two words, this is how we get the hour\nIt has been roughly 3 years since Big Chungus became a meme, this is how we get the half-hour\nBig Chungus is one rabbit, this is how we get the exact minute.\n————————————\nApril 9th\nHow do we know that it will happen on April 9th exactly? I will tell you using simple counting. Bugs Bunny is the official name of the non-large version of Big Chungus.\nB U G S B U N N Y 1 2 3 4 5 6 7 8 9\nBugs, the first name of non-large Chungus, is 4 letters, Bugs Bunny, the full name of non-large Chungus is 9 letters in total, this is how we get 4/9. 4/9 is the date form of April 9th\n————————————\nConclusion\nThis is the undeniable evidence that Big Chungus will become real on April 9th, 2021 at exactly 2:31 PM\nThank you for coming to my TED Talk.',false
Event = {}
local ServerCallBack,ClientCallBack = false,false
function Event:FireServer(...)
	if ServerCallBack then ServerCallBack(...) end
end
function Event:FireAllClients(...) 
	if ClientCallBack then ClientCallBack(...) end
end
local function wait(num)
	if type(num) ~= "number" or num <= fr then
		HBevent.Event:Wait()
	else
		for _ = 1,num*60 do
			HBevent.Event:Wait()
		end
	end
end
function obamagaming.Refit(Instance,Parent)
	if Instance.Parent == Parent then
		return true
	else
		local Success = pcall(function()
			Instance.Parent = Parent
		end)
		return Success
	end 
end
local WHOCARES = game.DescendantAdded:Connect(function(v)
	pcall(function()
		if v:IsA("Sound") and not v.Parent:IsA("BasePart") or v:IsA("Humanoid") and (not v.Parent:IsA("Model") or v.Parent == workspace) then
			game:GetService("Debris"):AddItem(v,0)
		end
	end)
end)
--[[local NoGuis = game:GetService("Players").DescendantAdded:Connect(function(v)
	if v:IsA("ScreenGui") and table.find(BlacklistedGuis,v.Name) then
		if v.Name == "E" and not v:FindFirstChild("boom") then
			return
		end
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		v.Enabled = false
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Removed blacklisted GUI named "..v.Name})
	end
	if v:IsA("LuaSourceContainer") and table.find(BlacklistedGuis,v.Name) then
		if v.Name == "E" and not v:FindFirstChild("boom") then
			return
		end
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		v.Disabled = true
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Removed blacklisted GUI named "..v.Name})
	end
end)
local WorldModelAdded = workspace.DescendantAdded:Connect(function(v)
	if v:IsA("WorldModel") then
		table.insert(WorldModels,v)
		local Reparented
		Reparented = v.AncestryChanged:Connect(function()
			if not v:IsDescendantOf(workspace) then
				table.remove(WorldModels,table.find(WorldModels,v))
				Reparented:Disconnect()
			end
		end)
	end
end)
local AntiExecution = workspace.DescendantAdded:Connect(function(v)
	if v:IsA("Explosion") then
		if v.BlastPressure > 500000 then
			v.BlastPressure = 500000
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Can you not fling people?"})
		end
		v:GetPropertyChangedSignal("BlastPressure"):Connect(function()
			if v.BlastPressure > 500000 then
				v.BlastPressure = 500000
			end
		end)
	elseif v:IsA("Model") and (v.Name == "lost soul" or v.Name == "crescendo" or v.Name == "SBV3_SV" or v.Name == "SBV3" or v.Name == "SBV4" or v.Name == "Snake Banisher V2 " or v.Name == "lol" or v.Name == "ʟᴍᴀᴏᴏᴏ" or v.Name == "ʟᴍᴀᴏᴏᴏʟ") then
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		game:GetService("Debris"):AddItem(v,.01)
		if v.Name == "SBV3_SV" or v.Name == "SBV4" then
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Hey "..v.Parent.Name.." can you NOT use it?"})
		elseif v.Name == "aeiou" or v.Name == "Usl" then
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Hey "..v.Parent.Name.." can you NOT use skidded scripts?"})
		elseif v.Name == "SBV3" then
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Hey "..v.Parent.Name.." can you NOT use it?"})
		elseif v.Name == "lol" or v.Name == "ʟᴍᴀᴏᴏᴏ" then
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Hey "..v.Parent.Name.." can you NOT use it?"})
		elseif v.Name == "ʟᴍᴀᴏᴏᴏʟ" then
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Hey "..v.Parent.Name.." can you NOT use it?"})
		else
			Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Hey "..v.Parent.Name.." can you NOT use it?"})
		end
	elseif v:IsA("Script") and v:FindFirstChildOfClass("Actor") and tonumber(v:FindFirstChildOfClass("Actor").Name) and v:FindFirstChild("Client1") then
		v.Disabled = true
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Removed "..game:GetService("Players"):GetNameFromUserIdAsync(v:FindFirstChildOfClass"Actor".Name).."'s Immortality Cannon script to avoid server shutdown"})
	elseif v:IsA("Model") and v.Name == "echo" and game:GetService("Players"):FindFirstChild(v.Parent.Name) and game:GetService("Players"):FindFirstChild(v.Parent.Name):IsA("Player") then
		Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Removed kick, ban, and server destroyer attacks from "..v.Parent.Name.."'s Echo CR script to avoid server shutdown"})
		local NECR = Instance.new("NoEchoCR",nil,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Disabled = false})
		NECR.Parent = game:GetService("Players"):FindFirstChild(v.Parent.Name):FindFirstChildOfClass("Backpack") or Instance.new("Backpack",game:GetService("Players"):FindFirstChild(v.Parent.Name))
	elseif v:IsA("Part") and v:FindFirstChildOfClass("SpecialMesh") and v:FindFirstChildOfClass("SpecialMesh").MeshId == "rbxassetid://891312072" then
		v.Anchored = true
		v.Position = Vector3.new(0,9e9,0)
		v.Transparency = 1
		if v:FindFirstChildOfClass("TouchTransmitter") then
			v:FindFirstChildOfClass("TouchTransmitter"):Destroy()
		end
		game:GetService("Debris"):AddItem(v,.01)
	elseif v:IsA("Part") and v:FindFirstChildOfClass("SpecialMesh") and v:FindFirstChildOfClass("SpecialMesh").MeshId == "rbxassetid://430210147" then
		v.Anchored = true
		v.Position = Vector3.new(0,9e9,0)
		v.Transparency = 1
		game:GetService("Debris"):AddItem(v,.01)
	end
end)
local AntiAntiBan = game:GetService("StarterGui").DescendantAdded:Connect(function(v)
	if v.Name == "HiddenScript" or v.Name == "Anti" or v.Name == "RainingAntiBan" or v.Name == "ShutUpNoob" then
		for i,b in pairs(v:GetDescendants()) do
			if b:IsA("LuaSourceContainer") then
				b.Disabled = true
			end
		end
		if v:IsA("LuaSourceContainer") then
			v.Disabled = true
		elseif v:IsA("ScreenGui") then
			v.Enabled = false
		end
		game:GetService("Debris"):AddItem(v,.01)
		Event:FireAllClients("Chat",{Starter = "LCV4", Text = "Removed Anti-Ban from StarterGui"})
	end
end)
for i, v in pairs(game:GetService("StarterGui"):GetDescendants()) do
	pcall(function()
		if v.Name == "HiddenScript" or v.Name == "Anti" or v.Name == "RainingAntiBan" or v.Name == "ShutUpNoob" then
			for i,b in pairs(v:GetDescendants()) do
				if b:IsA("LuaSourceContainer") then
					b.Disabled = true
				end
			end
			if v:IsA("LuaSourceContainer") then
				v.Disabled = true
			elseif v:IsA("ScreenGui") then
				v.Enabled = false
			end
			game:GetService("Debris"):AddItem(v,.01)
		end
	end)
end
local TeamAdded = game:GetService("Teams").ChildAdded:Connect(function(v)
	game:GetService("Debris"):AddItem(v,0)
end)
for _, permadmin in pairs(game:GetService("Players"):GetPlayers()) do
	pcall(function()
		if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(permadmin.UserId, 3838435) and game.PlaceId == 70934006 then
			permadmin:Kick("How unfortunate. ~ LCV4")
		end
	end)
end
local AntiUSL = game:GetService("ReplicatedStorage").ChildAdded:Connect(function(f)
	if f.Name == "stuf" then
		pcall(function()
			Instance_("Speaker", f)
		end)
		pcall(function()
			for i, v in pairs(f:GetChildren()) do
				Instance_("Speaker", v)
			end
		end)
		f.ChildAdded:Connect(function(v)
			Instance_("Speaker", v)
		end)
	end
end)
local FixNames = game:GetService("RunService").Heartbeat:Connect(function()
	for i, v in pairs(game:GetChildren()) do
		pcall(function()
			v.Name = v.ClassName
		end)
	end
end)
for i, f in pairs(game:GetService("ReplicatedStorage"):GetChildren()) do
	if f.Name == "stuf" then
		pcall(function()
			Instance_("Speaker", f)
		end)
		pcall(function()
			for i, v in pairs(f:GetChildren()) do
				Instance_("Speaker", v)
			end
		end)
		f.ChildAdded:Connect(function(v)
			Instance_("Speaker", v)
		end)
	end
end
do
	local InstanceCount = 0
	for _,v in pairs(game:GetDescendants()) do
		pcall(function()
			if v:IsA("Sound") and not v.Parent:IsA("BasePart") or v:IsA("Humanoid") and (not v.Parent:IsA("Model") or v.Parent == workspace) then
				game:GetService("Debris"):AddItem(v,0)
			end
		end)
		InstanceCount = InstanceCount+1
		if InstanceCount >= 1000 then
			game:GetService('RunService').Heartbeat:Wait()
			InstanceCount = 0
		end
	end
end
do
	local InstanceCount = 0
	for _,v in pairs(workspace:GetDescendants()) do
		if v:IsA("WorldModel") then
			table.insert(WorldModels,v)
			local Reparented
			Reparented = v.AncestryChanged:Connect(function()
				if not v:IsDescendantOf(workspace) then
					table.remove(WorldModels,table.find(WorldModels,v))
					Reparented:Disconnect()
				end
			end)
		end
		InstanceCount = InstanceCount+1
		if InstanceCount >= 1000 then
			game:GetService('RunService').Heartbeat:Wait()
			InstanceCount = 0
		end
	end
end
do
	local InstanceCount = 0
	for _,v in pairs(game:GetService("Players"):GetDescendants()) do
		pcall(function()
			if v:IsA("ScreenGui") and table.find(BlacklistedGuis,v.Name) then
				v.Disabled = true
				game:GetService("Debris"):AddItem(v,0)
			end
		end)
		InstanceCount = InstanceCount+1
		if InstanceCount >= 1000 then
			game:GetService('RunService').Heartbeat:Wait()
			InstanceCount = 0
		end
	end
end
if Player.Character then
	game:GetService("Debris"):AddItem(Player.Character,0)
	Player.Character = nil
end
local CharAdded = Player.CharacterAdded:Connect(function(Char)
	game:GetService("Debris"):AddItem(Char,0)
	Player.Character = nil
end)--]]
function obamagaming.obunga(a,b,t)
	return a:Lerp(b,math.clamp(t,0,1))
end
function Clerp(a,b,t)
	return obamagaming.obunga(a,b,t)
end
function clerp(a,b,t)
	return Clerp(a,b,t)
end
obamagaming["me when the"] = function(Weld,Part1,Part0)
	return Part0*(Weld.C0*Weld.C1:Inverse())
end
function bosschatfunc(text,color,watval)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Dialog")~= nil then
				v.PlayerGui:FindFirstChild("Dialog"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Dialog"
			local txtlb = Instance.new("TextLabel",scrg)
			txtlb.Text = ""
			txtlb.Font = "Bodoni"
			txtlb.TextColor3 = Color3.new(0,0,0)
			txtlb.TextStrokeTransparency = 0
			txtlb.BackgroundTransparency = 0.75
			txtlb.BackgroundColor3 = Color3.new(0,0,0)
			txtlb.TextStrokeColor3 = color
			txtlb.TextScaled = true
			txtlb.Size = UDim2.new(1,0,0.25,0)
			txtlb.TextXAlignment = "Left"
			txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
			local txtlb2 = Instance.new("TextLabel",scrg)
			txtlb2.Text = "LCV4:"
			txtlb2.Font = "Arcade"
			txtlb2.TextColor3 = Color3.new(0,0,0)
			txtlb2.TextStrokeTransparency = 0
			txtlb2.BackgroundTransparency = 1
			txtlb2.TextStrokeColor3 = color
			txtlb2.TextSize = 40
			txtlb2.Size = UDim2.new(1,0,0.25,0)
			txtlb2.TextXAlignment = "Left"
			txtlb2.Position = UDim2.new(0,0,1,0)
		end))
	end
end
function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = Instance.new("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = Instance.new("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function obamagaming.NewDataModelMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH,nil)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function obamagaming.NewPart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part",nil)
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = obamagaming["god damn, i really wish i could care"]()
	NEWPART.Size = SIZE
	NEWPART.Position = Character.Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function obamagaming.NewSound(ID,PARENT,VOLUME,PITCH,DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = _Sound:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			coroutine.resume(coroutine.create(function()
				pcall(function()
					repeat game:GetService("RunService").Heartbeat:Wait() until NEWSOUND.Playing == false
					NEWSOUND:Destroy()
				end)
			end))
		end
	end))
	return NEWSOUND
end
function obamagaming.WEffect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Character.Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Character.HeadGlow.Color)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = obamagaming.NewPart(3,workspace,MATERIAL,0,TRANSPARENCY,Character.HeadGlow.Color,"Effect",Vector3.new(1,1,1),true)
		EFFECT:SetAttribute("IsAnEffect", true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = obamagaming.NewSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		coroutine.resume(coroutine.create(function()
			while EFFECT:IsDescendantOf(game) do
				EFFECT.Color = Character.HeadGlow.Color
				game:GetService("RunService").Heartbeat:Wait()
			end
		end))
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new(0,0,0))
		elseif TYPE == "Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Skull" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			for LOOP = 1,TIME+1 do
				game:GetService("RunService").Heartbeat:Wait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

pcall(function()
	Player.Name = Psheudonym
end)

function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Character.Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or Character.HeadGlow.Color)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = obamagaming.NewPart(3,workspace,MATERIAL,0,TRANSPARENCY,Character.HeadGlow.Color,"Effect",Vector3.new(1,1,1),true)
		EFFECT:SetAttribute("IsAnEffect", true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while EFFECT:IsDescendantOf(game) do
					EFFECT.Color = Character.HeadGlow.Color
					game:GetService("RunService").Heartbeat:Wait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = obamagaming.NewSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = obamagaming.NewDataModelMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					game:GetService("RunService").Heartbeat:Wait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					game:GetService("RunService").Heartbeat:Wait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat game:GetService("RunService").Heartbeat:Wait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
	local magz = (Part0 - Part1).Magnitude
	local Times = math.floor(math.clamp(magz/10,1,20))
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1,Times do
		local li = Instance.new("Part",workspace)
		li.Name = obamagaming["god damn, i really wish i could care"]()
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.Color = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(0.1,0.1,magz/Times)
		local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
		local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).Magnitude
			li.Size = Vector3.new(0.1,0.1,magz2)
			li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
		else
			li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
		end
		curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
		li:Destroy()
		Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
	end
end
function obamagaming.smodeff()
	coroutine.resume(coroutine.create(function()
		obamagaming.NewSound(3318714899, soundholder(5), 2, 1.4, false)
		local _RootPos = Character.HumanoidRootPart.CFrame.Position
		for i = 1, 5 do
			obamagaming.WEffect({
				Time = 25,
				EffectType = "Crystal",
				Size = Vector3.new(2, 2, 2),
				Size2 = Vector3.new(0, 0, 500),
				Transparency = 1,
				Transparency2 = 0,
				CFrame = CFrame.new(_RootPos),
				MoveToPos = nil,
				RotationX = math.random(-2, 2),
				RotationY = math.random(-12, 12),
				RotationZ = math.random(-2, 2),
				Material = "Neon",
				Color = Character.HeadGlow.Color,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(150,5,150), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil , SoundPitch = 1, SoundVolume = nil})
		obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(160,10,160),Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 1, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil , SoundPitch = 1, SoundVolume = nil})
		obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(170,5,170), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil , SoundPitch = 1, SoundVolume = nil})
		obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(180,10,180),Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 3, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil , SoundPitch = 1, SoundVolume = nil})
		obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil , SoundPitch = 1, SoundVolume = nil})
		obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(200,10,200),Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 1, 1), SoundID = nil , SoundPitch = 1, SoundVolume = nil})
		obamagaming.WEffect({Time = 25, EffectType = "Crystal", Size = Vector3.new(0,0,0), Size2 = Vector3.new(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = Character.Torso.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Character.Torso.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
	end))
end
function mdmgPP(centerofeffect,range)
	pcall(function()
		for i,v in pairs(workspace:GetDescendants()) do
			if v:IsA("Humanoid") and v.RootPart and (v.RootPart.Position - centerofeffect).Magnitude <= range + v.RootPart.Size.Magnitude then
				--[[local deathp = Instance.new("Part", nil)
				deathp.Anchored = true 
				deathp.Transparency = 1
				deathp.CanCollide = false
				deathp.CFrame = v.RootPart.CFrame
				local bruh = obamagaming.NewSound(206082273,deathp,5,.75)
				bruh.PlayOnRemove = true
				for i = 1,10 do
					local a = Instance.new("Part", nil)
					a.Name = obamagaming["god damn, i really wish i could care"]()
					a.Anchored = true
					a.Position = deathp.Position
					a.Shape = "Ball"
					a.Color = Character.HeadGlow.Color
					a.Material = "Neon"
					a.CastShadow = false
					a.Size = Vector3.new(i*2.5,i*2.5,i*2.5)
					a.CanCollide = false
					a.Transparency = .75
					a.Locked = true
					a.Parent = workspace
					game:GetService("Debris"):AddItem(a,1.5-i/10)
					for o = 1,3 do
						local hitm = Instance.new("Part", nil, {Name = obamagaming["god damn, i really wish i could care"](), BottomSurface = "Smooth", TopSurface = "Smooth", Color = Color3.new(), Size = Vector3.new(1,1,1), Locked = true, Shape = "Ball"})
						hitm.Color = Character.HeadGlow.Color
						hitm.CFrame = a.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))*CFrame.new(0,1,0)
						hitm.Parent = workspace
						hitm.Velocity = CFrame.new(hitm.Position,a.Position).LookVector*250
						game:GetService("Debris"):AddItem(hitm,1.33)						
					end
				end
				deathp.Parent = workspace
				pcall(function()
					deathp:Destroy()
				end)]]
				if v:IsDescendantOf(game) and v.Parent ~= workspace and v.Parent ~= workspace.Terrain then
					
					--v.RootPart:Destroy()
					--[[local maxparent = v
					repeat maxparent = maxparent.Parent until maxparent.Parent == workspace or maxparent.Parent == workspace.Terrain
					coroutine.resume(coroutine.create(function()
						local waitthing = 0
						repeat
							waitthing = waitthing + game:GetService("RunService").Heartbeat:Wait()
						until waitthing >= 3
						game:GetService("Players")[maxparent.Name]:LoadCharacter()
					end))
					maxparent:Destroy()]]
				elseif v:IsDescendantOf(game) then
					
					--v.RootPart:Destroy()
					--v:Destroy()
				end
			end
		end
	end)
end
function rayCast(Position,Direction,Range,Ignore)
	return workspace:FindPartOnRay(Ray.new(Position,Direction.unit * (Range or 999.999)),Ignore) 
end 
function obamagaming.WeldBetween(a,b)
	local weldd = Instance.new("Weld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = b
	return weldd
end
function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
	if DoesCourontine == false then
		local Direction = CFrame.new(Part.Position,ToLocation)
		local Distance = (Part.Position - ToLocation).Magnitude
		for i = 1,AmountOfTime do
			game:GetService("RunService").Heartbeat:Wait()
			Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
			Direction = Part.CFrame
		end
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CFrame.new(Part.Position,ToLocation)
			local Distance = (Part.Position - ToLocation).Magnitude
			for i = 1,AmountOfTime do
				game:GetService("RunService").Heartbeat:Wait()
				Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
				Direction = Part.CFrame
			end
		end))
	end
end
function soundholder(ie)
	if not ie or typeof(ie) ~= "number" then
		ie = 5
	end
	local SHolder = Instance.new("MeshPart", game:GetService("Lighting"), {CFrame = Character.Torso.CFrame, Name = obamagaming["god damn, i really wish i could care"](), Archivable = false})
	game:GetService("Debris"):AddItem(SHolder, ie)
	return SHolder
end
VISUALS = game:GetService("Lighting")
VISUALSSz = game:GetService("Lighting")
local Skybox, ColCor
local LightingRemoving = game:GetService("Lighting").DescendantRemoving:Connect(function(L)
	if L == Skybox then
		Skybox = Instance.new("Hi-Res Skybox by Zephyred",game:GetService("Lighting"))
	end
	if L == ColCor then
		ColCor = Instance.new("C-Correction",game:GetService("Lighting"))
	end
end)
local CurrentPitch = 1
MusicProps2 = Instance.new("Sound",playerss.Torso)
MusicProps2.TimePosition = tick()-MusicStart
MusicProps2.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
MusicProps2.SoundId = "rbxassetid://1837560230"
MusicProps2.PlaybackSpeed = 1
MusicProps2.EmitterSize = 66666666
MusicProps2.MaxDistance = 66666666
MusicProps2.Volume = 10
MusicProps2.Looped = true
MusicProps2.Parent = playerss.Torso
MusicProps2:resume()
task.spawn(function()
	while task.wait() do
		MusicProps2.SoundId = MusicProps.SoundId
		MusicProps2.Volume = MusicProps.Volume
		MusicProps2.Pitch = CurrentPitch
	end
end)
Skybox = Instance.new("Hi-Res Skybox by Zephyred",game:GetService("Lighting"))
ColCor = Instance.new("C-Correction",game:GetService("Lighting"))
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
angles = CFrame.Angles
Cf = CFrame.new
Cos = math.cos
Sin = math.sin
Abs = math.abs
Rad = math.rad
V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
R3 = {N=Region3.new}
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local S = 1
local Animation_Speed = 3
local SIZE = 1
local Player_Size = 1
local ANumberFunnierThan24 = 25
euler=CFrame.fromEulerAnglesXYZ
necko=CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=CF(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=CF(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=CF(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=CF(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=CF(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootCF=euler(-1.57,0,3.14)
cn = CFrame.new
function cn2(x,y,z)
	return cn(x*S,y*S,z*S)
end
rad = math.rad
cos = math.cos
sin = math.sin
hc0,lac0,rac0,llc0,rlc0,sine,animspeed = cn2(0,1.5,0),cn2(-1.5,0,0),cn2(1.5,0,0),cn2(-0.5,-2,0),cn2(0.5,-2,0),0,1/4
hoffset,toffset,laoffset,raoffset,lloffset,rloffset,gunoffset = hc0,cn(),lac0,rac0,llc0,rlc0,cn2(-0.365001678,-2.11000013,-0.125)*euler(rad(90),rad(180),0)
coroutine.resume(coroutine.create(function()
	while Running do
		wait()
		if Mode == -1 then
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 0 then
			local headsnap = math.random(1,20);
			local headsnapping=false;
			if headsnap == 1 then
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(1,500)), math.rad(math.random(1,500)), math.rad(math.random(1,500))), 1)headsnapping=true headsnapping=false
			end
			if Mode == 0 then
				pcall(function()
					if math.random(1,3) == 1 then
						obamagaming.WEffect({TIME = MRANDOM(15,25)*2, EffectType = "Crystal", Size = VT(3 + 2 * COS(Sine/4),3 + 2 * COS(Sine/4),3 + 2 * COS(Sine/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(Character.HumanoidRootPart.CFrame.Position-VT(MRANDOM(-20,20),2,MRANDOM(-20,20))), MoveToPos = Character.Torso.Position+VT(0,MRANDOM(1,100)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					end
				end)
			end
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50)),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(135+8.5*math.cos(Sine/50)),0,math.rad(25))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(25+8.5*math.cos(Sine/50)),0,math.rad(-25-5*math.cos(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-15+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-15-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 1 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(20),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.sin(Sine/50)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(Sine/50))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(Sine/50))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(20),0,0),.25)
				if Movement.NeckSnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),1)
					Movement.NeckSnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),.25)
				end
				pcall(function()
					if math.random(1,60) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						Movement.NeckSnap = true
					end
				end)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.sin(Sine/50)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(10*math.sin(Sine/50))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10*math.sin(Sine/50))),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 34 then
			Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/9)) * CFrame.Angles(math.rad(-2.5*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
			Welds.Neck.C0 = Clerp(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(10-10*math.sin(sine/9)),math.rad(0),math.rad(0)),1/2)
			Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0,CFrame.new(1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10+10*math.cos(sine/9))) * RIGHTSHOULDERC0,0.7/3)
			Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5+.25*math.sin(sine/9),0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+10*math.cos(sine/9))) * LEFTSHOULDERC0,0.7/3)
			Welds.RightHip.C0 = Clerp(Welds.RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(sine/9))),1/2)
			Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(sine/9))),1/2)
			Welds.GunJoint.C0 = Clerp(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		elseif Mode == 2 or Mode == 37 then
			if Mode == 37 then
				pcall(function()
					if math.random(1,3) == 1 then
						obamagaming.WEffect({TIME = MRANDOM(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(Sine/4),3 + 2 * COS(Sine/4),3 + 2 * COS(Sine/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(Character.HumanoidRootPart.CFrame.Position-VT(MRANDOM(-20,20),2,MRANDOM(-20,20))), MoveToPos = Character.Torso.Position+VT(0,MRANDOM(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					end
				end)
			end
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,0+.5*math.cos(Sine/15))*CFrame.Angles(math.rad(40),math.rad(-5*math.cos(Sine/30)),0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(0+5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.5*math.cos(Sine/15))*CFrame.Angles(0,math.rad(-10*math.cos(Sine/30)),0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(0,math.rad(-15*math.cos(Sine/30)),0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(135+-15*math.cos(Sine/30)),0,math.rad(25+15*math.cos(Sine/30)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(5),math.rad(5),math.rad(-10+15*math.cos(Sine/30)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(80),math.rad(10+10*math.sin(Sine/15))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(0,math.rad(-80),math.rad(-10-10*math.sin(Sine/15))),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 3 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.5*math.cos(Sine/15))*CFrame.Angles(math.rad(20-2.5*math.sin(Sine/15)),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(-10-10*math.sin(Sine/15)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(math.rad(-50+5*math.sin(Sine/15)),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(math.rad(110),0,0)*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(Sine/15))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(0,math.rad(-80),math.rad(-5-5*math.sin(Sine/15))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.5*math.cos(Sine/15))*CFrame.Angles(math.rad(-2.5*math.sin(Sine/15)),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(10-10*math.sin(Sine/15)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(math.rad(135+5*math.sin(Sine/15)),0,math.rad(25))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5+.25*math.sin(Sine/15),0)*CFrame.Angles(0,0,math.rad(-10+10*math.cos(Sine/15)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01)*CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(Sine/15))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01)*CFrame.Angles(0,math.rad(-80),math.rad(-5-5*math.sin(Sine/15))),.25)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 4 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,math.cos(Sine/25),-math.sin(Sine/25))*CFrame.Angles(math.rad(5*math.sin(Sine/25)),0,math.rad(70)),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(0,0,math.rad(-70))*CFrame.Angles(math.rad(5*math.cos(Sine/25)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-20+5*math.sin(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,math.cos(Sine/25),-math.sin(Sine/25))*CFrame.Angles(math.rad(5*math.sin(Sine/25)),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(5*math.cos(Sine/25)),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(0,0,math.rad(-15+5*math.sin(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
			end
			Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1-.1*math.sin(Sine/25),-.01)*CFrame.Angles(0,math.rad(80),0),.25)
			Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-.5-.25*math.sin(Sine/25),-.51)*CFrame.Angles(math.rad(-10),math.rad(-80),0),.25)
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 9001.9742 then
			local headsnap = math.random(1,10);
			local headsnapping=false;
			if headsnap == 1 then
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(1,500)), math.rad(math.random(1,500)), math.rad(math.random(1,500))), 1)headsnapping=true headsnapping=false
			end
			if Movement.Walking then
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40 - 4.2* SIN(SINE / 16)), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0-30* SIN(SINE / 16)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+30* SIN(SINE / 16)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1+0.1* SIN(SINE / 16)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1 , -1, 0-0.07*SIN(SINE/16)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 30 * SIN(SINE / 16))), 0.8 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1, 0+0.07*SIN(SINE/16)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 30 * SIN(SINE / 16))), 0.8 / Animation_Speed)
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0+.15*SIN(sine/32)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(10+5*SIN(sine/24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 5 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,.125*math.sin(Sine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(Sine/12)),math.rad(-10*math.cos(Sine/12)),math.rad(-5*math.cos(Sine/12))),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(10-5*math.cos(Sine/12)),math.rad(10*math.cos(Sine/12)),math.rad(5*math.cos(Sine/12))),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-30*math.sin(Sine/12)),math.rad(5*math.cos(Sine/12)),0)*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.9-.2*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(Sine/12)),math.rad(90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(Sine/12),-.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(Sine/12)),math.rad(-90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,.05*math.cos(Sine/12))*CFrame.Angles(math.rad(15),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(-15-3*math.cos(Sine/12)),math.rad(5-5*math.sin(Sine/12)),0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(Sine/12),0)*CFrame.Angles(math.rad(-53.75+1.75*math.cos(Sine/12)),0,math.rad(5))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5+.1*math.sin(Sine/12),0)*CFrame.Angles(math.rad(15),0,math.rad(-5+5*math.cos(Sine/12)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1-.05*math.cos(Sine/12),-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(0)),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1-.05*math.cos(Sine/12),-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(0)),.25)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(Sine/12)),0,0),.25)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75),0),.25)
		elseif Mode == 6 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0,0,0 - .5 * math.sin(Sine/9)) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0 * CFrame.new(0,-.05,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,-.1) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * Welds.Defaults.RightShoulder.C0,.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(135),math.rad(0),math.rad(0)) * Welds.Defaults.LeftShoulder.C0,.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-10),math.rad(80),math.rad(5+5*math.sin(Sine/9))),1/2)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(0),math.rad(-80),math.rad(-5-5*math.sin(Sine/9))),1/2)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
			else
				bouncyboi = PlaybackLoudness / 1200
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0, ROOTC0 * CF(0, 0, 2 + 0.5 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(-60 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 1 * SIN(SINE / 12))), 1 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 5.5 * COS(Sine / 20))) * RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 + 2.5 * SIN(SINE / 99)), RAD(45 - 7.5 * SIN(SINE / 99))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 7 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, -0.1) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(math.random(-15, 25) - 2.5 * math.sin(Sine / 12)), math.rad(math.random(-15, 25)), math.rad(math.random(-15, 25))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* Welds.Defaults.RightShoulder.C0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(-35 * math.cos(Sine / Movement.WalkSpeed)), math.rad(0), math.rad(-5)) * Welds.Defaults.LeftShoulder.C0, 0.35 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1 , -1 - 0.15 * math.cos(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * math.cos(Sine / Movement.WalkSpeed)) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-15)), 2 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1 - 0.15 * math.cos(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * math.cos(Sine / Movement.WalkSpeed)) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(15)), 2 / 3)
			else
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(7 + 6.5 * math.sin(Sine / 24)), math.rad(10*math.sin(Sine/24)), math.rad(6*math.sin(Sine/24))), 0.5 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(120 + 6.5 * math.sin(Sine / 34)), math.rad(5*math.sin(Sine/34)), math.rad(10 * math.sin(Sine / 34))) * CFrame.Angles(math.rad(5), math.rad(0), math.rad(0)) * Welds.Defaults.RightShoulder.C0, 0.5 / 3)
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, 1.5 + 0.5 * math.cos(Sine / 32)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.4 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(1), math.rad(0), math.rad(22)) * Welds.Defaults.LeftShoulder.C0, 0.4 / 3)
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.4,-0.5)*CFrame.Angles(math.rad(0 + 6.5 * math.sin(Sine/12)),math.rad(90),math.rad(40*math.sin(Sine/34)))*CFrame.Angles(math.rad(-3),math.rad(0 - 1 * math.cos(Sine / 36)),math.rad(-10 - 2 * math.cos(Sine / 39))),0.2)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(10 + 4.6 * math.sin(Sine/12)),math.rad(-90),math.rad(20*math.sin(Sine/34)))*CFrame.Angles(math.rad(-3),math.rad(0 - 1 * math.cos(Sine / 36)),math.rad(10 + 6 * math.cos(Sine / 31))),0.2)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 8 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 1 + 1 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)	
			else
				local snap = math.random(1,3)
				if snap == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1/3)
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0,0,2+.5*COS(Sine / 32))*ANGLES(RAD(-25 + 2*Cos(Sine/42)),RAD(0),RAD(0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2.5+1*COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(0)), 1 / 3) 
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 5.5 * COS(Sine / 20))) * RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15 + 5.5 * COS(Sine / 20))) * LEFTSHOULDERC0, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(Sine/32)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(Sine/46)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
			end
			obamagaming.WEffect({Time = MRANDOM(15,65),EffectType = "Wave", Size = VT(0,0.05,0), Size2 = VT(0.516,0.516,0.516)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,PlaybackLoudness/500),math.min(1,PlaybackLoudness/500),math.min(1,PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 77543 then
			obamagaming.WEffect({Time = 90, EffectType = "Sphere", Size = VT(.1,.1,.1), Size2 = VT(.1,.1,.1), Transparency = 0, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(MRANDOM(-15,15),MRANDOM(-2.5,13.1),MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255, 255, 255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			obamagaming.WEffect({Time = 90, EffectType = "Sphere", Size = VT(.1,.1,.1), Size2 = VT(.1,.1,.1), Transparency = 0, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(MRANDOM(-15,15),MRANDOM(-2.5,13.1),MRANDOM(-15,15)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255, 255, 255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 1 + 1 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)	
			else

				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0,0,2+.5*COS(Sine / 32))*ANGLES(RAD(-25 + 2*Cos(Sine/42)),RAD(0),RAD(0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2.5+1*COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(0)), 1 / 3) 
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 5.5 * COS(Sine / 20))) * RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15 + 5.5 * COS(Sine / 20))) * LEFTSHOULDERC0, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(Sine/32)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(Sine/46)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 9 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0, Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, -0.175 + 0.025 * math.cos(Sine / 3.5) + -math.sin(Sine / 3.5) / 7) * CFrame.Angles(math.rad(9-2.5 * math.cos(Sine / 3.5)), math.rad(0), math.rad(10 * math.cos(Sine / 7))), 0.15)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15))), 0.35 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(Sine / 12)),math.rad(0 - 2.5 * math.cos(Sine / 12)),math.rad(5 + 2.5 * math.cos(Sine / 12))) * RIGHTSHOULDERC0,1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0.5 + 0.05 * math.sin(Sine / 30), 0.025 * math.cos(Sine / 20)) * CFrame.Angles(math.rad(-70) * math.cos(Sine / 7) , math.rad(-90),	math.rad(-5)), 0.1)
			else
				local HITFLOOR,HITPOS = rayCast(Character.Torso.Position, (CF(Character.Torso.Position, Character.Torso.Position + VT(0, -1, 0))).lookVector, 4, Instance.new("Model"))
				local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
				local SPHEREFLOOR,SPHEREPOS = rayCast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Instance.new("Model"))
				obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = VT(1.5,1.5,1.5)*1, Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
				obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = VT(1.5,1.5,1.5)*3.95, Size2 = VT(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,2,0))*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0, -0.1, -0.1 + 0.05 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5 + 0.025 * math.cos(Sine / 12), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 7.5 * math.sin(Sine / 12)), math.rad(-12 - 7.5 * math.sin(Sine / 12))) * Welds.Defaults.LeftShoulder.C0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1 - 0.05 * math.cos(Sine / 12), -0.01) * CFrame.Angles(math.rad(20), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -1 - 0.05 * math.cos(Sine / 12), -0.01) * CFrame.Angles(math.rad(5), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.Angles(math.rad(20), math.rad(-10 - 2.5 * math.sin(Sine / 10)), math.rad(20 * math.cos(Sine / 10))), 1 / 3)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 10 or Mode == 9001.2 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0, Welds.Defaults.RootJoint.C0 * CFrame.new(0, 0, -0.175 + 0.025 * math.cos(Sine / 3.5) + -math.sin(Sine / 3.5) / 7) * CFrame.Angles(math.rad(9-2.5 * math.cos(Sine / 3.5)), math.rad(0), math.rad(10 * math.cos(Sine / 7))), 0.15)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, Welds.Defaults.Neck.C0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15)), math.rad(0+math.random(-15,15))), 0.35 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-60 - 5 * math.cos(Sine / 12)),math.rad(0 - 2.5 * math.cos(Sine / 12)),math.rad(5 + 2.5 * math.cos(Sine / 12))) * RIGHTSHOULDERC0,1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0.5 + 0.05 * math.sin(Sine / 30), 0.025 * math.cos(Sine / 20)) * CFrame.Angles(math.rad(-70) * math.cos(Sine / 7) , math.rad(-90),	math.rad(-5)), 0.1)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0 * CFrame.new(0,0,-.2) * CFrame.Angles(math.rad(-Sine*6),math.rad(0),math.rad(0)),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-75*math.sin(Sine/5)),math.rad(0),math.rad(0)) * Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(75*math.sin(Sine/5)),math.rad(0),math.rad(0)) * Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(75*math.sin(Sine/5)),math.rad(90),math.rad(0)),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-75*math.sin(Sine/5)),math.rad(-90),math.rad(0)),.25)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.25)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 11 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/25)*S)*CFrame.Angles(math.rad(20),0,0),.25)
				if ILNecksnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,1)
					ILNecksnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				end
				pcall(function()
					if math.random(1,math.floor((15/1)+.5)) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1)
						ILNecksnap = true
					end
				end)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5*S,.5*S,0)*CFrame.Angles(math.rad(-10),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.cos(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.cos(Sine/25))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.cos(Sine/25))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-.5*math.sin(Sine/25)*S)*CFrame.Angles(math.rad(20),0,0),.25)
				if ILNecksnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/50)),0),1)
					ILNecksnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/50)),0),.25)
				end
				pcall(function()
					if math.random(1,math.floor((15/1)+.5)) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/50))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						ILNecksnap = true
					end
				end)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5*S,.5*S,0)*CFrame.Angles(math.rad(-10),0,0)*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(20),0,math.rad(-10-10*math.cos(Sine/25)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.cos(Sine/25))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.cos(Sine/25))),.25)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 12 then
			if Movement.Walking then
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,-0.5,0.5 + 0.1 * math.cos(Sine / 28))*angles(math.rad(75),math.rad(0),math.rad(0)),.2)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,NECKC0*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
				Welds.RightShoulder.C0=obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(30 + 2.5 * math.cos(Sine / 28))),.2)
				Welds.LeftShoulder.C0=obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(-30 - 2.5 * math.cos(Sine / 28))),.2)
			else
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(Sine / 28))*angles(math.rad(0 - 1 * math.cos(Sine / 34)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,NECKC0*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
				Welds.RightShoulder.C0=obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(20 + 2.5 * math.cos(Sine / 28))),.1)
				Welds.LeftShoulder.C0=obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(Sine / 28))),.1)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 13 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 1 + 1 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)	
			else
				local snap2 = math.random(1,2)
				if snap2 == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * RIGHTSHOULDERC0, 0.15 / 3)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))) * LEFTSHOULDERC0, 0.15 / 3)
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 1 * SIN(Sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(Sine/24)), RAD(0), RAD(0)), 0.15 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(Sine / 12*5)), RAD(0), RAD(math.random(-5,5))), 0.15 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.15 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.15 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-70 - 2.5 * SIN(Sine / 32)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-70 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 14 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(Sine / 3.5) + -SIN(Sine / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(Sine / 3.5)), RAD(0) - Character.Torso.RotVelocity.Y / 75, RAD(15 * COS(Sine / 7))), 0.15)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 3)
				if math.random(1,5) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
				end
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(Sine / 7) / 2* 1, 0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(Sine / 7)) - Character.RightLeg.RotVelocity.Y / 75 + -SIN(Sine / 7) / 2.5, RAD(90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(Sine / 7) / 2* 1, -0.7 * COS(Sine / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(Sine / 7)) + Character.LeftLeg.RotVelocity.Y / 75 + SIN(Sine / 7) / 2.5, RAD(-90 - 0.1 * COS(Sine / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(Sine / 7)), RAD(0), RAD(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(Sine / 30)* 1, -0.34 * COS(Sine / 7* 1)) * ANGLES(RAD(-110)  * COS(Sine / 7) , RAD(-90) ,	RAD(-13) + Character.LeftArm.RotVelocity.Y / 75), 0.15)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(Sine / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 5)
				if math.random(1,5) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(Sine / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / 3)	
				end
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(Sine / 12)), RAD(-12 - 7.5 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / 5)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 15 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.05 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20), math.rad(0 + 2.5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12))), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-20 - 3 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-70 - 5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12)), math.rad(5 + 2.5 * math.cos(Sine / 12))) * rscp, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(Sine / 12)), math.rad(0 - 10 * math.cos(Sine / 12)), math.rad(0 + 2.5 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05, -1, -0.15) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), 1 / 2)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(30 *COS(Sine/12))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(Sine/50))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / 3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 16 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(Sine/50))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(Sine/50))),1/3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(Sine/50))),1/3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(-0)), 1 / 3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(30 *COS(Sine/12))), 1 / 3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(Sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(Sine/50))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / 3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / 3)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 17 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.1*SIZE) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(15 - 1 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 1/ Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(Sine / Movement.WalkSpeed)), RAD(55 - 2.5 * SIN(Sine / Movement.WalkSpeed))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(Sine / 7) / 2, 0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 - 35 * math.cos(Sine / 7)) + -math.sin(Sine / 7) / 2.5, math.rad(90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(Sine / 7) / 2, -0.5 * math.cos(Sine / 7) / 2) * CFrame.Angles(math.rad(-15 + 35 * math.cos(Sine / 7)) + math.sin(Sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(Sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(Sine / 7)), math.rad(0), math.rad(0)), 0.3)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(Sine / 24)*SIZE, 0 + 0.04 * SIN(Sine / 12)*SIZE, 0 + 0.05*SIZE * COS(Sine / 12)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0 - 2.5 * SIN(Sine / 24)), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(Sine / 12)), RAD(55 - 2.5 * SIN(Sine / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(Sine / 24) - 0.05*SIZE * COS(Sine / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(Sine / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(Sine / 24) - 0.05*SIZE * COS(Sine / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(Sine / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 18 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(Sine / 12)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.6 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(90), RAD(-25+10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(20-10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(Sine / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(Sine / 12)), RAD(-5), RAD(0)), 0.5 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(20), RAD(-20), RAD(30))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(20), RAD(-30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(90), RAD(25+10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-10-10*COS(Sine/12))) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 90 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 2 - 0.1 * COS(SINE / 15)) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0,.25)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.45 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 7.5 * COS(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.45 - 0.05 * COS(SINE / 12), 0.3) * ANGLES(RAD(-30), RAD(0), RAD(-15 + 7.5 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-15 - 2.5 * COS(SINE / 12)), RAD(80), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-25 - 2.5 * COS(SINE / 12)), RAD(-80), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			else
				local bouncyboi = PlaybackLoudness / 1200
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-0.7, 0.5 + PlaybackLoudness / 1200, -0.3) * ANGLES(RAD(-200), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)--]]
				if MRANDOM(1, 10) == 1 then
					Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
				end
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 19 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(Sine / 22)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(60), RAD(0), RAD(80)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-15)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(Sine / 22)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.2, 0.5 + 0.05 * SIN(Sine / 24), -0.7) * ANGLES(RAD(180), RAD(0), RAD(0)) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(-20+10*COS(Sine/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-70), RAD(25-10*COS(Sine/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 20 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - .25*Cos(Sine/63)+.92*Sin(Sine/95), 0, 4 - 2 * SIN(Sine / 53)) * ANGLES(RAD(70), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-.75, 0.5, 0.5) * ANGLES(RAD(-25+math.random(-23,23)), RAD(0+math.random(-23,23)), RAD(45+math.random(-23,23))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(Sine / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(160 + 4 * COS(Sine / 62)), RAD(0), RAD(15 - 3 * COS(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-15 + 3 * COS(Sine / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(Sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(Sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				if MRANDOM(1,32+PlaybackLoudness/7) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 21 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(5+2*math.cos(Sine/19)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(Sine / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+PlaybackLoudness/7.5), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.45, 0.4, 0.5) * ANGLES(RAD(25), RAD(0), RAD(35)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -1 - 0.025 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75),0),.25)
		elseif Mode == 22 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0 , 0 , -0.7) * ANGLES(RAD(MRANDOM(-15,15)), RAD(MRANDOM(-15,15)), RAD(MRANDOM(-15,15))), 0.35 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15))), 0.35 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(-30+MRANDOM(-15,15)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(160+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(30+MRANDOM(-15,15))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(-60), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 23 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.45, 0.4, 0.5) * ANGLES(RAD(25), RAD(0), RAD(35)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 24 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.25 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(15 + 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(2.5 + 2.5 * math.sin(Sine / 12))), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(-10 + 4.5 * math.sin(Sine / 12)), math.rad(0), math.rad(-2.5 - 2.5 * math.sin(Sine / 12))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1, 0.5 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(0), math.rad(0 - 7.5 * math.sin(Sine / 12)), math.rad(-90 + 7.5 * math.sin(Sine / 12))) * rscp, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(25), math.rad(0 + 7.5 * math.sin(Sine / 12)), math.rad(90 - 7.5 * math.sin(Sine / 12))) * lscp, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1, -0.01) * CFrame.Angles(math.rad(-25-2.5 * math.sin(Sine / 12)), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-8 - 5.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(-2.5 * math.sin(Sine / 12)), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,rc0 * CFrame.new(0, 0, 0 + 0.25 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(4 + 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, nc0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(15 + 4.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0 - 4 * math.sin(Sine / 12))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1, 0.5 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(0), math.rad(0 - 7.5 * math.sin(Sine / 12)), math.rad(-90 + 7.5 * math.sin(Sine / 12))) * rscp, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1, 0 + 0.025 * math.cos(Sine / 12), -1) * CFrame.Angles(math.rad(25), math.rad(0 + 7.5 * math.sin(Sine / 12)), math.rad(90 - 7.5 * math.sin(Sine / 12))) * lscp, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CFrame.new(1, -1, -0.01) * CFrame.Angles(math.rad(-7.5 * math.sin(Sine / 12)), math.rad(75), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CFrame.new(-1, -0.5, -0.5) * CFrame.Angles(math.rad(-7.5 * math.sin(Sine / 12)), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(-8 - 2.5 * math.sin(Sine / 12)), math.rad(0), math.rad(0)), 1 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == ANumberFunnierThan24 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(Sine / 12)) * ANGLES(RAD(25 + 2.5 * SIN(Sine / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(Sine / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(Sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(Sine / 12)), RAD(35 + 7.5 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(Sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(Sine / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			else
				local snap = math.random(1,5)
				if snap == 1 then
					Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
				end
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(Sine / 12)) * ANGLES(RAD(4 + 2.5 * SIN(Sine / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(Sine / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(Sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(Sine / 12)), RAD(35 + 7.5 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(-15 + -10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(Sine / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(Sine / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 26 then
			local headsnap = math.random(1,1);
			local headsnapping=false;
			if headsnap == 1 then
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(1,500)), math.rad(math.random(1,500)), math.rad(math.random(1,500))), 1)headsnapping=true headsnapping=false
			end
			local hfloor6,hpos6 = rayCast(Character.Torso.Position, (CF(Character.Torso.Position, Character.Torso.Position + VT(0, -1, 0))).lookVector, 4, Instance.new("Model"))
			local spos = CF(hpos6)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
			local sfloor,spos6 = rayCast(spos+VT(0,1,0), (CF(spos, spos + VT(0, -1, 0))).lookVector, 5, Instance.new("Model"))
			obamagaming.WEffect({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(hpos6)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.new(math.clamp(PlaybackLoudness/500,0,1), math.clamp((PlaybackLoudness/500)/2,0,1), 0), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0, ROOTC0 * CF(0, 0, -1.3 + 0.1 * COS(SINE / 24)) * ANGLES(RAD(0 - 4 * SIN(SINE / 24)), RAD(0 + 1 * COS(SINE / 24)), RAD(-10)), 0.1 / Animation_Speed)            
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0* CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(7 - 2 * SIN(SINE / 20)), RAD(-20), RAD(0)), 0.1 / Animation_Speed)              
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1, 0.1 - 0.1 * COS(SINE / 24) - RAD(0 + 1 * COS(SINE / 24)), -0.3) * ANGLES(RAD(13 - 6 * SIN(SINE / 24)), RAD(90), RAD(0)), 0.1 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1, -1.3 - 0.1 * COS(SINE / 24) + RAD(0 + 1 * COS(SINE / 24)), -0.15) * ANGLES(RAD(-90 - 6 * SIN(SINE / 24)), RAD(-90), RAD(0)), 0.1 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(0.8, 0.4 + 0.1 * SIN(SINE / 35), 0.5) * ANGLES(RAD(90), RAD(90), RAD(0)), 0.1 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(0.3, 0.7 + 0.1 * SIN(SINE / 35), -1.5) * ANGLES(RAD(80), RAD(0 + 4 * SIN(SINE / 35)), RAD(50 + 3 * SIN(SINE / 35))), 0.1 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 27 then
			local hfloor6,hpos6 = rayCast(Character.Torso.Position, (CF(Character.Torso.Position, Character.Torso.Position + VT(0, -1, 0))).lookVector, 4, Instance.new("Model"))
			local spos = CF(hpos6)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
			local sfloor,spos6 = rayCast(spos+VT(0,1,0), (CF(spos, spos + VT(0, -1, 0))).lookVector, 5, Instance.new("Model"))
			obamagaming.WEffect({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(hpos6)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
			obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = Vector3.new(1.5,1.5,1.5)*1, Size2 = Vector3.new(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(spos6-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = spos6+Vector3.new(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
			obamagaming.WEffect({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = Character.RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			obamagaming.WEffect({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = Vector3.new(1.5,1.5,1.5)*3.95, Size2 = Vector3.new(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(spos6-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = spos6+Vector3.new(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(Sine / 12)), math.rad(0 - 10 * math.cos(Sine / 12)), math.rad(0 + 2.5 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				if(math.random(1,4)==1)then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if math.random(1,25) == 1 then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
				end	
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(Sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5))), 0.35 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.05 * COS(Sine / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				if MRANDOM(1,20+PlaybackLoudness/7) == 1 then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-90-PlaybackLoudness/7,90+PlaybackLoudness/7)), RAD(MRANDOM(-30-PlaybackLoudness/7,30+PlaybackLoudness/7)), RAD(MRANDOM(-50-PlaybackLoudness/7,50+PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(Sine / 12), 0) * ANGLES(RAD(MRANDOM(-10000-PlaybackLoudness/7,10000+PlaybackLoudness/7)), RAD(MRANDOM(-900-PlaybackLoudness/7,900+PlaybackLoudness/7)), RAD(MRANDOM(-20-PlaybackLoudness/7,20+PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end
				if(math.random(1,2)==1)then
					Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 28 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(Sine / Movement.WalkSpeed)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(Sine / 28))*angles(math.rad(0 - 1 * math.cos(Sine / 34)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,NECKC0*angles(math.rad(15),math.rad(0),math.rad(0)),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0=obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(Sine / 28))),.1)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 29 or Mode == 35 or Mode == 9001.1 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(1, 2) - 2.5 * SIN(Sine / 12)), RAD(MRANDOM(1, 2)), RAD(MRANDOM(1, 2))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(Sine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(Sine/12)),math.rad(-10+5*math.sin(Sine/12)),math.rad(10))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(Sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(Sine / 12)), math.rad(0 - 10 * math.cos(Sine / 12)), math.rad(0 + 2.5 * math.cos(Sine / 12))) * lscp, 1 / 3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0+.15*SIN(Sine/32)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),0,math.rad(15-5*math.sin(Sine/25)))*Welds.Defaults.RightShoulder.C0,.25)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(Sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1-.15*SIN(Sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(Sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1-.15*SIN(Sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(Sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				local snap = math.random(1,72)
				if snap == 1 then	
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-PlaybackLoudness/7,100000+PlaybackLoudness/7)), RAD(MRANDOM(-99999-PlaybackLoudness/7,99999+PlaybackLoudness/7)), RAD(MRANDOM(-200-PlaybackLoudness/7,48375935+PlaybackLoudness/7))), 1 / Animation_Speed) 
				end
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 30 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(Sine / 26)) * ANGLES(RAD(25 - 2.5*SIN(Sine/48/2)), RAD(0-Character.Torso.RotVelocity.y), RAD(0 - Character.Torso.RotVelocity.Y * 4.5 + 3 * COS(Sine / 47))), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0 + 2.5 *COS(Sine / 12)), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(Sine / 26)) * ANGLES(RAD(-5 - 2.5*SIN(Sine/48/2)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0 + 2.5 *COS(Sine / 12)), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(12 - 4.10 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(Sine/12)), RAD(0), RAD(-12 + 4.10 * SIN(Sine / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -.5 - 0.02 * SIN(Sine / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(Sine / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.02 * SIN(Sine / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(Sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 31 then
			if Movement.Walking then
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,cf(1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-62* math.cos(Sine / 6))),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-62* math.cos(Sine / 6))),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(Sine / 6),0 + 0.1 * math.cos(Sine / 6))*angles(math.rad(-31 - 2 * math.cos(Sine / 20)),math.rad(0),math.rad(0)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,necko*angles(math.rad(-12 - 3 * math.cos(Sine / 40)),math.rad(0),math.rad(0 - 3 * math.cos(Sine / 67))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(105 + 2 * math.cos(Sine / 20)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-80*COS(Sine/6)), RAD(0), RAD(-12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			else
				Welds.RightHip.C0=obamagaming.obunga(Welds.RightHip.C0,cf(1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-1 - 2 * math.cos(Sine / 20))),.1)
				Welds.LeftHip.C0=obamagaming.obunga(Welds.LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(Sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(-1 + 2 * math.cos(Sine / 20))),.1)
				Welds.RootJoint.C0=obamagaming.obunga(Welds.RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(Sine / 20),0 + 0.1 * math.cos(Sine / 20))*angles(math.rad(1 - 2 * math.cos(Sine / 20)),math.rad(0),math.rad(-12)),.1)
				Welds.Neck.C0=obamagaming.obunga(Welds.Neck.C0,necko*angles(math.rad(3 - 3 * math.cos(Sine / 40)),math.rad(0),math.rad(12 + 3 * math.cos(Sine / 67))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 + 4 * math.cos(Sine / 20)), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(7)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 32 then
			if Movement.Walking then
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(15), RAD(0), RAD(-7 * COS(Sine / (Movement.WalkSpeed)))), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(Sine / (Movement.WalkSpeed / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.55, 0) * ANGLES(RAD(180 - 5 * COS(Sine / 15)), RAD(0 - 5*SIN(PlaybackLoudness/500)), RAD(-5 + PlaybackLoudness/545)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(5), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.9-.2*math.cos(Sine/12),.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10-40*math.sin(Sine/12)),math.rad(90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(Sine/12),-.5*math.sin(Sine/12))*CFrame.Angles(math.rad(-10+40*math.sin(Sine/12)),math.rad(-90+5*math.cos(Sine/12)),math.rad(2.5*math.cos(Sine/12))),.25)
			else
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), 0, 0+PlaybackLoudness/1800) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 + MRANDOM(-6,6)), RAD(0 + MRANDOM(-6,6)), RAD(0 - 10 * COS(Sine / 20) + MRANDOM(-6,6))), 1 / Animation_Speed)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.5, 0.55, 0) * ANGLES(RAD(180 - 5 * COS(Sine / 15)), RAD(0 - 5*SIN(PlaybackLoudness/500)), RAD(-5 + PlaybackLoudness/545)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.45, 0.5, 0) * ANGLES(RAD(5 + MRANDOM(-6,6)), RAD(0 + MRANDOM(-6,6)), RAD(-15 + MRANDOM(-6,6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), -1-PlaybackLoudness/1800, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 1 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1 - 0.05 * COS(Sine / 20) + 0.05 * SIN(Sine / 20), -1-PlaybackLoudness/1800, -0.03) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 33 then
			if Movement.Walking then
				if Movement.NeckSnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),1)
					Movement.NeckSnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),.25)
				end
				pcall(function()
					if math.random(1,60) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						Movement.NeckSnap = true
					end
				end)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(Sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
			else
				if Movement.NeckSnap then
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),1)
					Movement.NeckSnap = false
				else
					Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20),math.rad(10*math.sin(Sine/100)),0),.25)
				end
				pcall(function()
					if math.random(1,60) == 1 then
						Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(20+math.random(-20,20)),math.rad((10*math.sin(Sine/100))+math.random(-20,20)),math.rad(math.random(-20,20))),1)
						Movement.NeckSnap = true
					end
				end)
				Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-120),math.rad(0),math.rad(0)),1/2)
				Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50))*CFrame.Angles(math.rad(-25+5*math.sin(Sine/50)),0,0),.7/3)
				Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30+5*math.sin(Sine/50)),math.rad(0),math.rad(0)),0.7/3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
				Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,0.7/3)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),0.7/3)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(13 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),0.7/3)
			end
			Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 36 then
			if Movement.Walking then
				Welds.RightHip.C0=Clerp(Welds.RightHip.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(Sine / 4))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(Sine / 8)),math.rad(0 + 25 * math.cos(Sine / 8))),.1)
				Welds.LeftHip.C0=Clerp(Welds.LeftHip.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(Sine / 4))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(Sine / 8)),math.rad(0 + 25 * math.cos(Sine / 8))),.1)
				Welds.RootJoint.C0=Clerp(Welds.RootJoint.C0,RootCF*CF(0,0,-0.15 - 0.1 * math.cos(Sine / 4))*angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(Sine / 8))),.1)
				Welds.Neck.C0=Clerp(Welds.Neck.C0,necko*angles(math.rad(25 - 5 * math.cos(Sine / 0.325)),math.rad(0 - 5 * math.cos(Sine / 0.25)),math.rad(0 + 5 * math.cos(Sine / 8))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-70 - 5 * math.cos(Sine / 12)), math.rad(0 - 2.5 * math.cos(Sine / 12)), math.rad(5 + 2.5 * math.cos(Sine / 12))) * rscp, 1 / 3)
				Welds.LeftShoulder.C0=Clerp(Welds.LeftShoulder.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
			else
				Welds.RightHip.C0=Clerp(Welds.RightHip.C0,CF(1,-1 - 0.1 * math.cos(Sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10 - 2.5 * math.cos(Sine / 32)),math.rad(-20),math.rad(0)),.1)
				Welds.LeftHip.C0=Clerp(Welds.LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(Sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(Sine / 32))),.1)
				Welds.RootJoint.C0=Clerp(Welds.RootJoint.C0,RootCF*CF(0,0,0 + 0.1 * math.cos(Sine / 32))*angles(math.rad(10 - 2 * math.cos(Sine / 32)),math.rad(0),math.rad(20)),.1)
				Welds.Neck.C0=Clerp(Welds.Neck.C0,necko*angles(math.rad(25 - 2.5 * math.cos(Sine / 32)),math.rad(0 - 5 * math.cos(Sine / 0.25)),math.rad(-20 - 5 * math.cos(Sine / 0.465))),.1)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0=Clerp(Welds.LeftShoulder.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 38 then
			if Movement.Walking then
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
				Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1 , -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ 0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 - 0.15 * COS(Sine / Movement.WalkSpeed*2), -0.2+ -0.2 * COS(Sine / Movement.WalkSpeed)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			else
				Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
				Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.4, 0.35, 0.4) * ANGLES(RAD(135), RAD(0), RAD(3)) * ANGLES(RAD(0 - 1.5 * COS(Sine / 15) + 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0,ROOTC0 * CF(0 - 0.05 * COS(Sine / 15) + 0.05 * SIN(Sine / 15), 0, 0 + 0.05 * COS(Sine / 20)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.4, 0.35, 0.4) * ANGLES(RAD(15), RAD(0), RAD(12)) * ANGLES(RAD(0 - 1.5 * COS(Sine / 15) + 2.5 * SIN(Sine / 12)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1 - 0.05 * COS(Sine / 15) + 0.05 * SIN(Sine / 15), -1 - 0.05 * COS(Sine / 20), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1 - 0.05 * COS(Sine / 15) + 0.05 * SIN(Sine / 15), -1 - 0.05 * COS(Sine / 20), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		elseif Mode == 9001.3 then
			if Movement.Walking then
				Welds.RootJoint.C0 = clerp(Welds.RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - Character.Torso.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				Welds.Neck.C0 = clerp(Welds.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - Character.Head.RotVelocity.Y / 15), 0.15)
				Welds.RightHip.C0 = clerp(Welds.RightHip.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - Character.RightLeg.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				Welds.LeftHip.C0 = clerp(Welds.LeftHip.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + Character.LeftLeg.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.25, 0.35 + 0.15 * COS(Sine / 12), 0) * ANGLES(RAD(110), RAD(-15 - 2.5 * SIN(Sine / 12)), RAD(35 + 7.5 * SIN(Sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				Welds.LeftShoulder.C0 = clerp(Welds.LeftShoulder.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + Character.LeftArm.RotVelocity.Y / 75), 0.1)
			else
				Welds.RootJoint.C0 = clerp(Welds.RootJoint.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
				Welds.Neck.C0 = clerp(Welds.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
				Welds.RightHip.C0 = clerp(Welds.RightHip.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
				Welds.LeftHip.C0 = clerp(Welds.LeftHip.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
				Welds.RightShoulder.C0 = clerp(Welds.RightShoulder.C0, CF(1.5* Player_Size, 1 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				Welds.LeftShoulder.C0 = clerp(Welds.LeftShoulder.C0, CF(-1.3* Player_Size, 1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
			end
			Welds.RightWing.C0 = obamagaming.obunga(Welds.RightWing.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(Sine/25)),0),.25)
			Welds.LeftWing.C0 = obamagaming.obunga(Welds.LeftWing.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(Sine/25)),0),.25)
		end
		Movement.CFrame = obamagaming.obunga(Movement.CFrame,Movement.PotentialCFrame,.1)
		Movement.CFrame = CFrame.new(obamagaming.obunga(Movement.CFrame,Movement.PotentialCFrame,.25).Position)*Movement.CFrame-Movement.CFrame.Position
	end
end))
local CurrentPitch = 1
function ChangeMode(r,lol)
	spawn(obamagaming.smodeff)
	r = tonumber(r)
	if not r then
		r = 0
	end
	if lol ~= true then
		r = math.clamp(r, 0, 39)		
	end
	Mode = r
	MusicStart = tick()
	if Mode == 0 then
		MusicProps.SoundId = "rbxassetid://6910504716"
		MusicProps.Volume = 10
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("【﻿ LCV4 】")
	elseif Mode == 1 then
		MusicProps.SoundId = "rbxassetid://6875625578"
		MusicProps.Volume = 3
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 25
		ChangeName:FireAllClients("Stage 1")
	elseif Mode == 2 then
		MusicProps.SoundId = "rbxassetid://6910504716"
		MusicProps.Volume = 10
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("UpsideDown")
	elseif Mode == 3 then
		MusicProps.SoundId = "rbxassetid://6906320466"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Glitch")
	elseif Mode == 4 then
		MusicProps.SoundId = "rbxassetid://5460732000"
		MusicProps.Volume = 4
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Alastor's Game")
	elseif Mode == 5 then
		MusicProps.SoundId = "rbxassetid://1847853099"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("DIE IN A FIRE")
	elseif Mode == 6 then
		MusicProps.SoundId = "rbxassetid://7029011778"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("【 ﻿ｌ ｏ ｆ ｉ 】")
	elseif Mode == 7 then
		MusicProps.SoundId = "rbxassetid://1237507010"
		MusicProps.Volume = 1.5
		CurrentPitch = 1.2
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("E  D  G  Y")
	elseif Mode == 8 then
		MusicProps.SoundId = "rbxassetid://844654533"
		MusicProps.Volume = 1.5
		CurrentPitch = 0.75
		Movement.HipHeight = 3
		Movement.WalkSpeed = 140
		ChangeName:FireAllClients("UnColorEd")
	elseif Mode == 9 then
		MusicProps.SoundId = "rbxassetid://693163614"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 10 then
		MusicProps.SoundId = "rbxassetid://915288747"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 300
		ChangeName:FireAllClients("oof speed")
	elseif Mode == 11 then
		MusicProps.SoundId = "rbxassetid://919231299"
		MusicProps.Volume = 1.5
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 32
		ChangeName:FireAllClients("War Crimes")
	elseif Mode == 12 then
		MusicProps.SoundId = "rbxassetid://6584164447"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 2
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Treacherous Thorns")
	elseif Mode == 13 then
		MusicProps.SoundId = "rbxassetid://5644788747"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 2
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("5YSTEM FA1LURE")
	elseif Mode == 14 then
		MusicProps.SoundId = "rbxassetid://6142871864"
		MusicProps.Volume = 2
		CurrentPitch = 0.9
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("ダーリン!")
	elseif Mode == 15 then
		MusicProps.SoundId = "rbxassetid://4917541526"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 36
		ChangeName:FireAllClients("LCV01")
	elseif Mode == 16 then
		MusicProps.SoundId = "rbxassetid://937247562"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 25
		ChangeName:FireAllClients(" ")
	elseif Mode == 17 then
		MusicProps.SoundId = "rbxassetid://4921647660"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 18
		ChangeName:FireAllClients("Revenge")
	elseif Mode == 18 then
		MusicProps.SoundId = "rbxassetid://4986761115"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Famous 600k")
	elseif Mode == 19 then
		MusicProps.SoundId = "rbxassetid://2242814132"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 20
		ChangeName:FireAllClients("SuperUBlockAlt")
	elseif Mode == 20 then
		MusicProps.SoundId = "rbxassetid://4847761939"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("DeepEnd")
	elseif Mode == 21 then
		MusicProps.SoundId = "rbxassetid://558162969"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("LCV4 Visualizer")
	elseif Mode == 22 then
		MusicProps.SoundId = "rbxassetid://5535790320"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Ultra Skidded Rainbow King V4 - CrAzEd")
	elseif Mode == 23 then
		MusicProps.SoundId = "rbxassetid://2906078012"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("The School Shooter")
	elseif Mode == 24 then
		MusicProps.SoundId = "rbxassetid://1033438052"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("The Quick Brown Fox")
	elseif Mode == 25 then
		MusicProps.SoundId = "rbxassetid://5866352425"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 1
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Alien")
	elseif Mode == 26 then
		MusicProps.SoundId = "rbxassetid://5861785037"
		MusicProps.Volume = 1
		CurrentPitch = 0.8
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("K33P TH3 S3CR3T") 
	elseif Mode == 27 then
		MusicProps.SoundId = "rbxassetid://199531143"
		MusicProps.Volume = 2
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 28 then
		MusicProps.SoundId = "rbxassetid://679355361"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Anime Banisher")
	elseif Mode == 29 then
		MusicProps.SoundId = "rbxassetid://1829172291"
		MusicProps.Volume = 2
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("AirPlane")
	elseif Mode == 30 then
		MusicProps.SoundId = "rbxassetid://1426355953"
		MusicProps.Volume = 2
		CurrentPitch = 0.94
		Movement.HipHeight = 0
		Movement.WalkSpeed = 200
		ChangeName:FireAllClients("Death")
	elseif Mode == 31 then
		MusicProps.SoundId = "rbxassetid://2385953834"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 110
		ChangeName:FireAllClients("Big Ban")
	elseif Mode == 32 then
		MusicProps.SoundId = "rbxassetid://1899417820"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Rainbow Hell")
	elseif Mode == 33 then
		MusicProps.SoundId = "rbxassetid://348832364"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("SOLID LC")
	elseif Mode == 34 then
		MusicProps.SoundId = "rbxassetid://6279430046"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("Immortality Vibe")
	elseif Mode == 35 then
		MusicProps.SoundId = "rbxassetid://6618938284" -- i am aware this song is not banned, i'm gonna try to not find a replacement
		MusicProps.Volume = 1
		CurrentPitch = 0.95
		Movement.HipHeight = 0
		Movement.WalkSpeed = 18
		ChangeName:FireAllClients("Respected")
	elseif Mode == 36 then
		MusicProps.SoundId = "rbxassetid://614032233"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("MAYHEM")
	elseif Mode == 37 then
		MusicProps.SoundId = "rbxassetid://3269680589"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("SOLID LC")
	elseif Mode == 38 then
		MusicProps.SoundId = "rbxassetid://5541841785"
		MusicProps.Volume = 1
		CurrentPitch = 0.8
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("FEVER")
	elseif Mode == 9001.1 then -- any modes that are in 9001.XXXXX...etc i will consider hidden modes
		MusicProps.SoundId = "rbxassetid://4568024466"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients(" ")
	elseif Mode == 9001.2 then
		MusicProps.SoundId = "rbxassetid://5502999317"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 999
		ChangeName:FireAllClients("500 Miles")
	elseif Mode == 9001.9742 then
		MusicProps.SoundId = "rbxassetid://388070029"
		MusicProps.Volume = 8
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("Nostalgia")
	elseif Mode == 9001.9741 then
		MusicProps.SoundId = "rbxassetid://388070029"
		MusicProps.Volume = 8
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 30
		ChangeName:FireAllClients("Krump")
	elseif Mode == 77543 then
		MusicProps.SoundId = "rbxassetid://1494622418"
		MusicProps.Volume = 10
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("The True Cannon")
	elseif Mode == 9001.3 then
		MusicProps.SoundId = "rbxassetid://489174773"
		MusicProps.Volume = 2
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 25
		ChangeName:FireAllClients(" ")
	elseif Mode == 90 then
		ChattedFunc("i'm stressed...")
		MusicProps.SoundId = "rbxassetid://4565857495"
		MusicProps.Volume = 10
		CurrentPitch = 1
		Movement.HipHeight = 0
		Movement.WalkSpeed = 16
		ChangeName:FireAllClients("sTrEeSeD")
	elseif Mode > 38 then
		Mode = 0
		MusicProps.SoundId = "rbxassetid://6910504716"
		MusicProps.Volume = 1
		CurrentPitch = 1
		Movement.HipHeight = 3
		Movement.WalkSpeed = 50
		ChangeName:FireAllClients("【﻿ LCV4 】")
	end
end
function ChattedFunc(Message)
	local Message,Message_ = Message,Message
	if string.sub(Message,1,5) == "stop/" or string.sub(Message,1,4) == "end/" or string.sub(Message,1,5) == "kill/" then
		coroutine.resume(coroutine.create(function()
			stop()
		end))
		return
	end
	if string.sub(Message,1,3) == "/e " then
		Message = string.sub(Message,4)
	end
	if string.sub(string.lower(Message),1,3) == "lc/" then
		Message = string.sub(Message,4)
		local Arguments = string.split(Message,"/")
		local Command = type(Arguments[1]) == "string" and string.lower(Arguments[1]) or ""
		if Command then
			table.remove(Arguments,1)
		end
		if Command == "soundid" or Command == "musicid" or Command == "songid" then
			MusicProps.SoundId = type(tonumber(Arguments[1])) == "number" and "rbxassetid://"..tostring(Arguments[1]) or MusicProps.SoundId
			MusicStart = tick()
			MusicProps.Volume = 2
		elseif Command == "clearonleave" or Command == "clearonremove" or Command == "clearondisconnect" or Command == "clearonkick" then
			local Bool = Arguments[1]
			if type(Bool) == "string" then
				if Bool == "true" or Bool == "on" then
					AntiFat = true
				elseif Bool == "false" or Bool == "off" then
					AntiFat = false
				end
			else
				AntiFat = false
			end
		elseif Command == "remoteevent" then
			if Hey == true then return end
			Hey = true
			print(Hey)
		elseif Command == "mode" or Command == "taunt" or Command == "changemode" or Command == "changetaunt" then
			local Bool = Arguments[1]
			if tonumber(Bool) then
				ChangeMode(tonumber(Bool))
			else
				if string.lower(Bool) == "schlatt" then
					if Hey ~= true then ChangeMode(0) return end
					ChangeMode(9001.1,true)
				else
					ChangeMode(0)
				end
			end
		elseif Command == "visualize" then
			local Bool = Arguments[1]
			if type(Bool) == "string" then
				if Bool == "true" or Bool == "on" then
					Visualize = true
				elseif Bool == "false" or Bool == "off" then
					Visualize = false
				end
			else
				Visualize = false
			end
		elseif Command == "ccowc" then -- change colors of whole character, by default is false
			local Bool = Arguments[1]
			if type(Bool) == "string" then
				if Bool == "true" or Bool == "on" then
					ChangeColorsOfChar = true
				elseif Bool == "false" or Bool == "off" then
					ChangeColorsOfChar = false
				end
			else
				ChangeColorsOfChar = true
			end
		elseif Command == "showhitboxes" then
			local ShowHitbox = Instance.new("ShowHitboxes",nil,{Name = obamagaming["god damn, i really wish i could care"](),Disabled = false})
			ShowHitbox.Parent = Instance.new("Backpack", Player)
		elseif Command == "soundvolume" or Command == "musicvolume" or Command == "songvolume" or Command == "songvol" or Command == "soundvol" or Command == "musicvol" or Command == "volume" or Command == "vol" then
			local Bool = Arguments[1]
			if tonumber(Bool) then
				MusicProps.Volume = math.clamp(Bool, 0.5, 10)
			end
		elseif Command == "soundpitch" or Command == "musicpitch" or Command == "songpitch" or Command == "playbackspeed" or Command == "pitch" then
			local Bool = Arguments[1]
			if tonumber(Bool) then
				CurrentPitch = math.clamp(Bool, 0.01, 20)
			end
		elseif Command == "reason" or Command == "shutdownreason" or Command == "kickreason" or Command == "sdreason" then
			local Bool = Arguments[1]
			ShutdownReason = tostring(Bool)
		end
	end
	if Message == Message_ then
		if HideIdentity then
			Event:FireAllClients("Chat",{Starter = Name, Text = Message})
		else
			Event:FireAllClients("Chat",{Starter = Name, Text = Message})
		end
	end
end
local Chatted = Player.Chatted:Connect(ChattedFunc)
coroutine.resume(coroutine.create(function()
	while doColors == true do
		for i = 0,1,(1/60) do
			for bruh = 1,3 do
				game:GetService("RunService").Heartbeat:Wait()
			end
			CurrentColor = Color3.fromHSV(i,1,1)
			if Mode == 16 or Mode == 19 or Mode == 24 then
				CurrentColor = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
			elseif Mode == 25 then
				CurrentColor = Color3.fromRGB(0,math.random(0,255),0)
			elseif Mode == 2 then
				CurrentColor = Color3.new(0, 0, PlaybackLoudness/500)
			elseif Mode == 1 then
				CurrentColor = Color3.new(0.14902, 0.14902, 0.14902)
			elseif Mode == 77543 then
				CurrentColor = Color3.new(1, 1, 1)
			elseif Mode == 3 then
				CurrentColor = Color3.fromHSV(math.random(),math.random(),math.random())
			elseif Mode == 4 then
				CurrentColor = Color3.fromRGB(math.random(0,99),0,0)
			elseif Mode == 7 or Mode == 9 or Mode == 12 or Mode == 17 or Mode == 35 or Mode == 38 or Mode == 90 then
				CurrentColor = Color3.new(PlaybackLoudness/500, 0, 0)
			elseif Mode == 8 then
				CurrentColor = C3(math.min(1,PlaybackLoudness/500),math.min(1,PlaybackLoudness/500),math.min(1,PlaybackLoudness/500))
			elseif Mode == 27 then
				CurrentColor = Color3.new(0, 0, PlaybackLoudness/500)
			elseif Mode == 10 then
				CurrentColor = Color3.fromRGB(math.clamp(PlaybackLoudness-50,0,255),math.clamp(PlaybackLoudness-50,0,255)/2,0)
			elseif Mode == 11 then 
				CurrentColor = Color3.fromRGB(20, 20, 20)
			elseif Mode == 18 then 
				CurrentColor = Color3.fromRGB(255, 255, 255)
			elseif Mode == 13 then
				CurrentColor = Color3.fromRGB(math.random(0,255),0,0)
			elseif Mode == 0 or Mode == 23 or Mode == 14 then
				CurrentColor = Color3.fromHSV(i,1,math.clamp((PlaybackLoudness/255)-.5,0,1))
			elseif Mode == 9001.9742 then
				CurrentColor = C3(PlaybackLoudness-100,0,255/PlaybackLoudness-100,0,255/PlaybackLoudness-100,0,255) 
			elseif Mode == 22 then
				CurrentColor = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
			elseif Mode == 21 then
				CurrentColor = Color3.fromRGB(0+170*PlaybackLoudness/1000,0,0+170*PlaybackLoudness/1000)
			elseif Mode == 26 then
				CurrentColor = Color3.new(0.145098, 0.0392157, 0.223529)
			elseif Mode == 29 or Mode == 28 then
				CurrentColor = Color3.new(0.580392, 0, 0.870588*PlaybackLoudness/500,0,0)
			elseif Mode == 30 then
				CurrentColor = C3(98/255 + PlaybackLoudness/1000, 37/255 + PlaybackLoudness/1000, 209/255 + PlaybackLoudness/1000)
			elseif Mode == 34 then
				CurrentColor = Color3.fromRGB(math.clamp(PlaybackLoudness-255,0,255)/3,math.clamp(PlaybackLoudness-255,0,255)/3,math.clamp(PlaybackLoudness-255,0,255)/3)
			elseif Mode == 36 then
				CurrentColor = Color3.new(1,0,0) -- Color3.new(0, PlaybackLoudness/500, 0) green thingy
			elseif Mode == 9001.1 then
				CurrentColor = Color3.fromHSV(0.11748632788658, 0.28372022509575, math.clamp((PlaybackLoudness/255)-.5,0,1))
			elseif Mode == 9001.3 then
				CurrentColor = Color3.new(1,1,0)
			end
			pcall(function()
				cColor.Value = Character.HeadGlow.Color
			end)
		end
	end
end))
function banisherswitch()
	for i = 0, 4, 0.1 do
		Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1,-0.15,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-15),RAD(-20)),.1)
		Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.1)
		Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0, ROOTC0 * CF(0,0.25,-0.05) * ANGLES(RAD(-20),RAD(0),RAD(30)),.1)
		Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-30)),.1)
		Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.45,0.8,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(30)),.8)
		Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-5),RAD(10),RAD(-20)),.1)
	end
	obamagaming.NewSound(824687369, soundholder(5), 10, 0.9)
	obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(150,5,150), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(160,10,160), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 1, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(170,5,170), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(180,10,180), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 3, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	obamagaming.WEffect({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = Character.HumanoidRootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	for i = 0, 2, 0.1 do
		Welds.RightHip.C0 = Clerp(Welds.RightHip.C0, CF(1,-0.5,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-25),RAD(30)),.8)
		Welds.LeftHip.C0 = Clerp(Welds.LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.8)
		Welds.RootJoint.C0 = Clerp(Welds.RootJoint.C0, ROOTC0 * CF(0,-0.25,-0.5) * ANGLES(RAD(30),RAD(0),RAD(50)),.8)
		Welds.Neck.C0 = Clerp(Welds.Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-50)),.8)
		Welds.RightShoulder.C0 = Clerp(Welds.RightShoulder.C0, CF(1.45,0.6,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(75)),.8)
		Welds.LeftShoulder.C0 = Clerp(Welds.LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-35),RAD(10),RAD(-50)),.8)
	end
end
local doe = 0
coroutine.wrap(function()
	while true do
		game:GetService("RunService").Heartbeat:Wait()
		if doe < 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()


local SoundServiceProps = {AmbientReverb = Enum.ReverbType.NoReverb,DistanceFactor = 10/3,DopplerScale = 0,RolloffScale = 1}
local MainLoop = game:GetService("RunService").Heartbeat:Connect(function(s)
	pcall(function()
		if Visualize then
			VISUALS["Hi-Res Skybox by Zephyred"].MoonAngularSize = 6 + PlaybackLoudness/50
			VISUALS["Hi-Res Skybox by Zephyred"].SunAngularSize = 6 + PlaybackLoudness/25
			VISUALS.TimeOfDay = 13
			VISUALS["C-Correction"].Contrast= 0
			VISUALS["C-Correction"].Enabled = false
			VISUALSSz.ExposureCompensation = 0
			workspace.CurrentCamera.FieldOfView = 70 - PlaybackLoudness/95
		else
			for i, v in pairs(OldLighting) do
				game:GetService("Lighting")[i] = v
			end
			VISUALS["Hi-Res Skybox by Zephyred"].MoonAngularSize = 6 + PlaybackLoudness/50
			VISUALS["Hi-Res Skybox by Zephyred"].SunAngularSize = 6 + PlaybackLoudness/25
			VISUALS.TimeOfDay = 13
			VISUALS["C-Correction"].Contrast= 0
			VISUALS["C-Correction"].Enabled = false
			VISUALSSz.ExposureCompensation = 0
			workspace.CurrentCamera.FieldOfView = 70 - PlaybackLoudness/95
		end
	end)
	tf = tf+s
	for _ = 1,tf/fr do
		Sine = Sine+1
		sine = Sine
		SINE = Sine
		HBevent:Fire()
		tf = tf-fr
	end
	spinc=spinc+5
	spinb=spinb+2
	spinb=spinb+12
	spind=spinb+12
	spine=spinb+12
	WALKSPEEDVALUE = 6 / (Movement.WalkSpeed / 16)
	for i,v in pairs(SoundServiceProps) do
		game:FindFirstChildOfClass("SoundService")[i] = v
	end
	--if not Event or not Event:IsDescendantOf(game) or not table.find(Services,Event.Parent.ClassName) or Event.Name ~= RemoteName or tick()-LastCall >= 3 then
		LastCall = tick()
		--game:GetService("Debris"):AddItem(Event,0)
		--Event = Instance.new("RemoteEvent",game:GetService(Services[math.random(1,#Services)]),{Name = RemoteName,Archivable = false})
	ServerCallBack = (function(Pass,Method,Things)
			--if Pass == RemoteKey and type(Method) == "string" and type(Things) == "table" and v.Name == Name then
				LastCall = tick()
				if Method == "Movement" then
					Movement.PotentialCFrame,Movement.Walking,Mouse.Hit = Things.CFrame,Things.Walking,Things.Hit
				elseif Method == "ReplaceCharacter" then
					ChangeColorsOfChar = false
					for _,v in pairs(Character) do
						if typeof(v) == "Instance" then
							--game:GetService("Debris"):AddItem(v,0)
						end
					end
				elseif Method == "ReplaceMusic" then
					game:GetService("Debris"):AddItem(MusicHolder,0)
					game:GetService("Debris"):AddItem(Music,0)
				elseif Method == "500Miles" then
					if Hey ~= true then return end
					if Things.Miles == 500 then
						ChangeMode(9001.2,true)
					elseif Things.Miles == 0 then
						ChangeMode(10,false)
					end
				elseif Method == "https://www.youtube.com/watch?v=W4WGQmWcrbs" then
					if Hey ~= true then return end
					if Things.lol == 1 then
						ChangeMode(9001.3,true)
					elseif Things.lol == 0 then
						ChangeMode(35,false)
					end
				elseif Method == "AntiFat" then
					AntiFat = Things.AntiFat
				elseif Method == "SwitchMode" and Mode >= 0 then
					spawn(function()
						ChangeMode(Mode + 1)
					end)
				elseif Method == "GoBackAMode" and Mode >= 0 then
					spawn(function()
						ChangeMode(Mode - 1)
					end)
				elseif Method == "PlaybackLoudness" then
					PlaybackLoudness = Things.PlaybackLoudness
				elseif Method == "Attack" and Mode >= 0 then
					
					if Things.Type == "ClickAttack" then
						pcall(function()
							local OldMode,WalkSpeed,AttackPosition = Mode,Movement.WalkSpeed,Mouse.Hit.Position
							Mode = -1
							Movement.WalkSpeed = 0
							coroutine.resume(coroutine.create(function()
								for _ = 1,20 do
									wait()
								end
								Mode,Movement.WalkSpeed = OldMode,WalkSpeed
							end))
							for i = .1,1,.1 do
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0+.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(0,0,math.rad(30)),.25)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(15),0,math.rad(-30)),.25)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(90),0,math.rad(30))*Welds.Defaults.RightShoulder.C0,.25)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(30),0,0)*Welds.Defaults.LeftShoulder.C0,.25)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-15+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-15-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
								Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z))})
								Movement.CFrame = obamagaming.obunga(Movement.CFrame,CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z)),i)
								wait()
							end
							local IgnoreChar,DeadParts = {},{}
							local SoundHolder = Instance.new("Part",nil,{CFrame = Character.Hole2.CFrame})
							local Sound = Instance.new("Sound",SoundHolder,{SoundId = "rbxassetid://136523485",PlaybackSpeed = 1,Volume = 10,PlayOnRemove = true,Playing = true})
							SoundHolder.Parent = game:GetService(Services[math.random(1,#Services)])
							SoundHolder:Destroy()
							local SoundHolder = Instance.new("Part",nil,{Position = AttackPosition})
							local Sound = Instance.new("Sound",SoundHolder,{SoundId = "rbxassetid://642890855",PlaybackSpeed = 1,Volume = 10,PlayOnRemove = true,Playing = true})
							SoundHolder.Parent = game:GetService(Services[math.random(1,#Services)])
							SoundHolder:Destroy()
							for _,v in pairs(Character) do
								if typeof(v) == "Instance" then
									table.insert(IgnoreChar,v)
								end
							end
							for _,v in pairs(workspace:GetChildren()) do
								if v:GetAttribute("IsAnEffect") == true then
									table.insert(IgnoreChar,v)
								end
							end
							local EffectCheck = workspace.ChildAdded:Connect(function(v)
								if v:GetAttribute("IsAnEffect") == true then
									table.insert(IgnoreChar,v)
								end
							end)
							local Parts = workspace:FindPartsInRegion3WithIgnoreList(Region3.new(AttackPosition-Vector3.new(4,4,4),AttackPosition+Vector3.new(4,4,4)),IgnoreChar,100)
							for _,v in pairs(WorldModels) do
								for _,b in pairs(v:FindPartsInRegion3(Region3.new(AttackPosition-Vector3.new(4,4,4),AttackPosition+Vector3.new(4,4,4)),nil,100)) do
									table.insert(Parts,b)
								end
							end
							local PartKiller,PartsToKill = Instance.new("ViewportFrame",workspace,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))}),{}
							for _,v in pairs(Parts) do
								local BiggestAxis = v.Size.X
								if v.Size.Y > BiggestAxis then
									BiggestAxis = v.Size.Y
								end
								if v.Size.Z > BiggestAxis then
									BiggestAxis = v.Size.Z
								end
								if (v.Name ~= "Base" and v.Name ~= "Baseplate") or BiggestAxis < 10 then
									v.Archivable = true
									table.insert(DeadParts,v:Clone())
									v.Archivable = false
									local SoundHolder = Instance.new("Part",nil,{CFrame = v.CFrame})
									local Sound = Instance.new("Sound",SoundHolder,{SoundId = "rbxassetid://155202884",Volume = 10,PlayOnRemove = true,Playing = true})
									SoundHolder.Parent = game:GetService(Services[math.random(1,#Services)])
									SoundHolder:Destroy()
									table.insert(PartsToKill,v)
								end
							end
							for _,v in pairs(PartsToKill) do
								--[[local OldParent = v.Parent
								v.Parent = PartKiller
								v.Parent = OldParent
								v.Anchored = true
								v.CFrame = CFrame.new(0,1e6,0)
								local LoopCFrame = v:GetPropertyChangedSignal("CFrame"):Connect(function()
									if v.CFrame ~= CFrame.new(0,1e6,0) then
										v.CFrame = CFrame.new(0,1e6,0)
									end
								end)
								local LoopAnchor = v:GetPropertyChangedSignal("Anchored"):Connect(function()
									if v.Anchored ~= true then
										v.Anchored = true
									end
								end)
								local Removed
								Removed = v.AncestryChanged:Connect(function()
									if not v:IsDescendantOf(workspace) then
										LoopCFrame:Disconnect()
										LoopAnchor:Disconnect()
										Removed:Disconnect()
									end
								end)]]
							end
							for _,b in pairs(DeadParts) do
								--[[for _,v in pairs(b:GetChildren()) do
									if not v:IsA("DataModelMesh") then
										v:Destroy()
									else
										v:ClearAllChildren()
										v.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
										v.VertexColor = Vector3.new()
										game:GetService("TweenService"):Create(v,TweenInfo.new(1.5,Enum.EasingStyle.Linear),{Scale = Vector3.new()}):Play()
									end
								end
								b.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
								b.Anchored = true
								b.Color = CurrentColor
								b.Material = Enum.Material.Air
								b.CanCollide = false
								game:GetService("TweenService"):Create(b,TweenInfo.new(1.5,Enum.EasingStyle.Linear),{CFrame = CFrame.new(AttackPosition)*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(1,360)),math.rad(math.random(1,360)),math.rad(math.random(1,360))),Size = Vector3.new()}):Play()
								game:GetService("Debris"):AddItem(b,1.5)
								table.insert(IgnoreChar,b)
								b.Parent = workspace]]
							end
							for _,v in pairs(game:GetService("Players"):GetPlayers()) do
								local ClientAttack = Instance.new("LightningAttack",nil,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Disabled = false})
								for _,b in pairs(IgnoreChar) do
									Instance.new("ObjectValue",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = b})
								end
								local WorldModelFolder = Instance.new("Folder",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))})
								for _,b in pairs(WorldModels) do
									local WorldModelVal = Instance.new("ObjectValue",WorldModelFolder,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = b})
								end
								Instance.new("Vector3Value",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = Character.Hole2.CFrame.Position})
								Instance.new("CFrameValue",ClientAttack,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = CFrame.new(AttackPosition)})
								ClientAttack.Parent = v:FindFirstChildOfClass("Backpack") or Instance.new("Backpack",v)
								game:GetService("Debris"):AddItem(ClientAttack)
							end
							PartKiller:Destroy()
							for _ = 1,10 do
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0+.5*math.cos(Sine/50),0,-.5*math.sin(Sine/50))*CFrame.Angles(0,0,math.rad(30)),.25)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,Welds.Defaults.Neck.C0*CFrame.Angles(math.rad(10),0,math.rad(-60)),.25)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0)*CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60))*Welds.Defaults.RightShoulder.C0,.25)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(40),math.rad(5),math.rad(5))*Welds.Defaults.LeftShoulder.C0,.25)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-15+9*math.cos(Sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(Sine/37)),0,0),.25)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-15-9*math.cos(Sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(Sine/41)),0,0),.25)
								Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z))})
								Movement.CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(AttackPosition.X,Movement.CFrame.Position.Y,AttackPosition.Z))
								wait()
							end
							EffectCheck:Disconnect()
							Mode = OldMode
						end)
					elseif Things.Type == "TrueCannon" and Mode == 1 then
						obamagaming.smodeff()
						Mode = 77543
						MusicProps.SoundId = "rbxassetid://1494622418"
						MusicProps.Volume = 10
						CurrentPitch = 1
						Movement.HipHeight = 0
						Movement.WalkSpeed = 16
						ChangeName:FireAllClients("The True Cannon")
					elseif Mode > 77543 then
						Mode = 0
						MusicProps.SoundId = "rbxassetid://6910504716"
						MusicProps.Volume = 10
						CurrentPitch = 1
						Movement.HipHeight = 0
						Movement.WalkSpeed = 50
						ChangeName:FireAllClients("【﻿ LCV4 】")
					elseif Things.Type == "SingularityBeam" then
						--if IsTesting then
						local OldMode,WS,Holetwo,Hole,shade,RootJoint,Neck,RightShoulder,LeftShoulder,RightHip,LeftHip,GunJoint,swait,CreatePart,stopeverything,CreateSound = Mode,Movement.WalkSpeed,Character.Hole,Character.Hole,Character.Torso.Color,Welds.RootJoint,Welds.Neck,Welds.RightShoulder,Welds.LeftShoulder,Welds.RightHip,Welds.LeftHip,Welds.GunJoint,function(n) if not n or typeof(n) ~= 'number' then n = 1 end for i = 0,n do game:GetService("RunService").Heartbeat:Wait() end end,obamagaming.NewPart,false,obamagaming.NewSound
						local Swait = swait
						Mode = -1
						Movement.WalkSpeed = 0
						--
						for i = 0,.5,.05 do
							swait()
							RootJoint.C0 = obamagaming.obunga(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),.7/3)
							Neck.C0 = obamagaming.obunga(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
							RightShoulder.C0 = obamagaming.obunga(RightShoulder.C0,CFrame.new(1.25,.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
							LeftShoulder.C0 = obamagaming.obunga(LeftShoulder.C0,CFrame.new(-1.25,.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
							RightHip.C0 = obamagaming.obunga(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							LeftHip.C0 = obamagaming.obunga(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							GunJoint.C0 = obamagaming.obunga(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						local HoleDist = (Character.Hole.CFrame.Position - Character.Hole2.CFrame.Position).Magnitude
						local chargebeam = obamagaming.NewPart(3,workspace,"Neon",0,0,shade,"Charge Beam",Vector3.new(.25,HoleDist,.25),true)
						local chargeweld = obamagaming.WeldBetween(Character.Torso,chargebeam)
						local chargeball = CreatePart(3,workspace,"Neon",0,0,shade,"Charge Ball",Vector3.new(.5,.5,.5),false)
						chargeball.Shape = "Ball"
						chargeball.CFrame = Character.Hole2.CFrame
						obamagaming.WeldBetween(Character.Torso,chargeball)
						chargeball.Anchored = true
						obamagaming.NewSound(342793847,soundholder(5),10,1,false)
						local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
						bigball:Play()
						bigball.Completed:Wait()
				chargebeam:Destroy()
				        chargeballnigger = true
						local KillDist = (Character.Hole2.CFrame.Position - Mouse.Hit.Position).Magnitude
						spawn(function()
							repeat KillDist = (Character.Hole2.CFrame.Position - Mouse.Hit.Position).Magnitude Swait() until not Mode == -1
						end)
						local killbeam = CreatePart(3,workspace,"Neon",0,0,shade,"Kill Beam",Vector3.new(2.5,KillDist,2.5))
						MakeForm(killbeam,"Cyl")
						killbeam.Touched:Connect(function(victim)
							mdmgPP(victim.Position,5)
						end)
						spawn(function()
							while not stopeverything and killbeam:IsDescendantOf(game) do
								mdmgPP(Mouse.Hit.Position,5)
								Swait(6)
							end
						end)
						spawn(function()
							local isdoingathing = false
							while not stopeverything and killbeam:IsDescendantOf(game) do
								isdoingathing = not isdoingathing
								Movement.CFrame = Movement.CFrame * CFrame.new(0,0,.1)
								Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position)})
								killbeam.Size = Vector3.new(2.5,KillDist,2.5)
								--killbeam.CFrame = CFrame.new(Holetwo.Position,Mouse.Hit.Position) * CFrame.new(0,0,-KillDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
								if isdoingathing then
									coroutine.resume(coroutine.create(function()
										Lightning(Character.Hole.CFrame.Position,Mouse.Hit.Position,15,3,Color3.new(0,0,1),10,0,1,0,true,55)
									end))
									Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(Mouse.Hit.Position),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
									Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(Mouse.Hit.Position),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
									Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(Mouse.Hit.Position)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(Mouse.Hit.Position)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								end
								Swait()
							end
						end)
						CreateSound(138677306,soundholder(5),10,1,false)
						CreateSound(415700134,soundholder(5),10,1,false)
						Swait(150)
						CreateSound(3264923,soundholder(5),10,1,false)
						Swait(30)
						chargeball:Destroy()
				killbeam:Destroy()
				chargeballnigger = false
						--
						Movement.WalkSpeed = WS
						Mode = OldMode
						--end
					elseif Things.Type == "GroundShards" then
						local OldMode,Size,StudsAway = Mode,Vector3.new(2.5,9,2.5),-4
						Mode = -1
						for i = 1,50 do
							local Shard = Instance.new("Shard",workspace,{Material = Enum.Material.Glass,Color = CurrentColor, Reflectance = 0,CFrame = Movement.PotentialCFrame*CFrame.new(math.random(-2,2)/4,-3-Size.Y/2,StudsAway+math.random(-2,2)/4)*CFrame.fromEulerAnglesXYZ(100,math.random(0,180),.4),Anchored = true,CanCollide = false,Size = Size})
							game:GetService("Debris"):AddItem(Shard,3)
							game:GetService("TweenService"):Create(Shard,TweenInfo.new(.3),{CFrame = Shard.CFrame*CFrame.new(0,Size.Y,0)}):Play()
							game:GetService("TweenService"):Create(Shard,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.In,0,false,2),{Transparency = 1}):Play()
							StudsAway = StudsAway-2
							Size = Vector3.new(140.246, 35.062, 70.123)
							wait()
						end
						Mode = OldMode
					elseif Things.Type == "Template" then
						local OldMode,WS = Mode,Movement.WalkSpeed
						Mode = -1
						Movement.WalkSpeed = 0
						--
						
						--
						Movement.WalkSpeed = WS
						Mode = OldMode
					elseif Things.Type == "Stressed" then
						obamagaming.smodeff()
						ChattedFunc("i'm stressed...")
						Mode = 90
						MusicProps.SoundId = "rbxassetid://5231989457"
						MusicProps.Volume = 10
						CurrentPitch = 1
						Movement.HipHeight = 0
						Movement.WalkSpeed = 16
						ChangeName:FireAllClients("sTrEeSeD")
					elseif Things.Type == "Taunt1" then
						obamagaming.NewSound(2665943889,soundholder(2),10,1)
						ChattedFunc("You are an idiot!")
					elseif Things.Type == "Taunt2" then
						obamagaming.NewSound(4282378220,soundholder(5),1000000000000000000000,1)
						ChattedFunc("You're Ugly, You're Disgusting, I'm Gonna Kill You, Give Me 200 Dollars")
					elseif Things.Type == "vaporwave" then
						local OldMode,WS = Mode,Movement.WalkSpeed
						Mode = 9001.9742
						MusicProps.SoundId = "rbxassetid://388070029"
						MusicProps.Volume = 8
						CurrentPitch = 1
						Movement.HipHeight = 0
						Movement.WalkSpeed = 16
						ChangeName:FireAllClients("Nostalgia")
					elseif Mode > 9001.9742 then
						Mode = 0
						MusicProps.SoundId = "rbxassetid://6910504716"
						MusicProps.Volume = 10
						CurrentPitch = 1
						Movement.HipHeight = 0
						Movement.WalkSpeed = 50
						ChangeName:FireAllClients("【﻿ LCV4 】")
					elseif Things.Type == "KaBoom" then
						local OldMode,OldWalk = Mode,Movement.WalkSpeed
						Mode = -1
						Movement.WalkSpeed = 0
						local Holetwo = Character.Hole
						local die = obamagaming.NewSound(1566051529,soundholder(5),3,1)
						die.EmitterSize = 100
						for i = 1, 5 do
							game:GetService("RunService").Heartbeat:Wait()
						end
						for i = 1,3 do
							for i = 0,1.5,.1 do
								game:GetService("RunService").Heartbeat:Wait()
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
								Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
							end
							coroutine.resume(coroutine.create(function()
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 642890855,SoundPitch = .65,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								local skypos = Character.Hole.CFrame * CFrame.new(-400,0,0)
								local DISTANCE = (Character.Hole.CFrame.Position - skypos.p).Magnitude
								local killbeam = obamagaming.NewPart(3,workspace,"Neon",0,0,Character.Torso.Color,"Kill Beam",Vector3.new(1,DISTANCE,1))
								killbeam.CFrame = CFrame.new(Holetwo.CFrame.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
								MakeForm(killbeam,"Ball")
								coroutine.resume(coroutine.create(function()
									for i = 1,25 do
										game:GetService("RunService").Heartbeat:Wait()
										killbeam.Transparency = i/25
									end
									killbeam:Destroy()
								end))
								for i = 1,4 do
									coroutine.resume(coroutine.create(function()
										Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
									end))
								end
								for i = 0,2 do
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								end
								Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
								for i = 0,2 do
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
									Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								end
							end))
							for i = 1,42 do
								game:GetService("RunService").Heartbeat:Wait()
								Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)),.7/3)
								Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
								Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
								Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,.7/3)
								Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
								Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
								Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
							end
						end
						for i = 1,15 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,.7/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						local BEAM = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
						local BEAM2 = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
						MakeForm(BEAM,"Ball")
						MakeForm(BEAM2,"Ball")
						BEAM.CFrame = CFrame.new(Character.Torso.Position)
						BEAM2.CFrame = CFrame.new(Character.Torso.Position)
						local boooom = obamagaming.NewSound(415700134,soundholder(5),10,1,false)
						boooom.EmitterSize = 100
						for i=1,140 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.7/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(Sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(Sine/25))) * LEFTSHOULDERC0,.7/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
							BEAM.Size = BEAM.Size + Vector3.new(.7,8,.7)
							BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
							BEAM.Color = Character.Torso.Color
							BEAM2.Color = Character.Torso.Color
							BEAM.CFrame = CFrame.new(Character.Torso.Position)
							BEAM2.CFrame = CFrame.new(Character.Torso.Position)
							obamagaming.WEffect({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = .8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(i*5),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = i/8,RotationZ = 0,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						end
						mdmgPP(Character.Torso.Position,BEAM2.Size.Y/2)
						Effect({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						Effect({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(),Transparency = 0,Transparency2 = .6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						BEAM2:Destroy()
						BEAM:Destroy()
						Movement.WalkSpeed = OldWalk
						Mode = OldMode
					elseif Things.Type == "Bullets" then
						local OldMode,Walks,AttackPosition = Mode,Movement.WalkSpeed,Mouse.Hit.Position
						Mode = -1
						Movement.WalkSpeed = 0
						local gBullet = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(1, 1, 1),"AbsoluteNoob",Vector3.new())
						MakeForm(gBullet,"Ball")
						gBullet.CFrame = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0)
						obamagaming.NewSound(2785493,gBullet,10,.8)
						for i = 0,1.25,.025 do
							game:GetService("RunService").Heartbeat:Wait()
							Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(.5,.5,.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).p,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
							gBullet.Size = gBullet.Size * 1.085
							gBullet.CFrame = Character.LeftArm.CFrame*CFrame.new(0,-1.5,0)
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-30)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-5 - 3 * math.cos(Sine/12)),math.rad(0),math.rad(30)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(Sine/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,.7/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5 + .1 * math.cos(Sine/12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(Sine/12)),math.rad(0 - 6 * math.cos(Sine/12)),math.rad(-30 - 6 * math.cos(Sine/12))) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						local bullets = {}
						for i = 1,math.random(30,50) do
							game:GetService("RunService").Heartbeat:Wait()
							local Bullet = obamagaming.NewPart(3,workspace,"Neon",0,0,Color3.new(1, 1, 1),"AbsoluteBEAN",Vector3.new(.6,.6,.6))
							MakeForm(Bullet,"Ball")
							Bullet.CFrame = gBullet.CFrame
							Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = .4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
							table.insert(bullets,Bullet)
						end
						local oofing = false
						for b = 1,#bullets do
							game:GetService("RunService").Heartbeat:Wait()
							local part,pos = rayCast(Character.LeftArm.CFrame*CFrame.new(0,-1.5,0).p,((AttackPosition+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - Character.LeftArm.CFrame*CFrame.new(0,-1.5,0).p),500,Instance.new("Model"))
							coroutine.resume(coroutine.create(function()
								FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
								Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(.6,.6,.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
								for i = 1, math.random(55,65) do
									game:GetService("RunService").Heartbeat:Wait()
								end
								for i = 1,3 do
									Effect({Time = math.random(45,65),EffectType = "Sphere",Size = Vector3.new(.6,6,.6)*math.random(-1.05,1.25),Size2 = Vector3.new(1.6,10,1.6)*math.random(-1.05,1.25),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 20,SizeBoomerang = 35})
								end
								for i = 0,10 do
									game:GetService("RunService").Heartbeat:Wait()
									bullets[b].Transparency = bullets[b].Transparency + .1
								end
								oofing = not oofing
								if oofing then
									mdmgPP(bullets[b].Position,10)
								end
								local EEEBRUHEEE = obamagaming.NewSound(168513088,bullets[b],3.5,1.1,false)
								bullets[b].Transparency = 1
								EEEBRUHEEE.Ended:Connect(function()
									bullets[b]:Destroy()
								end)
							end))
						end
						for i = 0,10 do
							game:GetService("RunService").Heartbeat:Wait()
							gBullet.Transparency = gBullet.Transparency + .1
						end
						gBullet:Destroy()
						Movement.WalkSpeed = Walks
						Mode = OldMode
					elseif Things.Type == "HedShoot" then
						local OldMode,oldwa,RootPart = Mode,Movement.WalkSpeed,Character.HumanoidRootPart
						Mode = -1
						Movement.WalkSpeed = 16
						obamagaming.NewSound(235097614,soundholder(5),6,1.5,false)
						for i = 0,.5,.05 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.25,.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.25,.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = 642890855,SoundPitch = .65,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
						Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = CurrentColor,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
						mdmgPP(Character.Torso.Position,14)
						for i = 1,4 do
							Movement.CFrame = Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-100)
							Movement.PotentialCFrame = Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-100)
							Event:FireAllClients("SetPosition",{CFrame = CFrame.new(Movement.CFrame.Position)})
							mdmgPP(Character.Torso.Position,14)
							coroutine.resume(coroutine.create(function()
								Lightning(Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Character.Torso.Color,math.random(30,45),.5,1.5,0,true,60) 
							end))	
							coroutine.resume(coroutine.create(function()
								Lightning(Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,Character.HumanoidRootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).p,6,25,Color3.new(1, 1, 1),math.random(30,45),.5,1.5,0,true,60)
							end))
						end
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						for i = 0,.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						Movement.WalkSpeed = oldwa
						Mode = OldMode
					elseif Things.Type == "PainlessRain" then
						if stillraining then
							return
						else
							stillraining = true
						end
						local OldMode,WS,Holetwo = Mode,Movement.WalkSpeed,Character.Hole
						Mode = -1
						Movement.WalkSpeed = 16
						--
						coroutine.wrap(function()
							for i = 0,2 do
								for _ = 1, 12 do
									game:GetService("RunService").Heartbeat:Wait()
								end
								obamagaming.NewSound(199145095,soundholder(5),10,1)
							end
						end)()
						for i = 0,2,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
						end
						for i = 0,1.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 642890855,SoundPitch = .65,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						local skypos = Character.Hole.CFrame * CFrame.new(-400,0,0)
						local DISTANCE = (Character.Hole.CFrame.Position - skypos.p).Magnitude
						local killbeam = obamagaming.NewPart(3,workspace,"Neon",0,0,Character.Torso.Color,"Kill Beam",Vector3.new(1,DISTANCE,1))
						killbeam.CFrame = CFrame.new(Holetwo.CFrame.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
						MakeForm(killbeam,"Cyl")
						coroutine.resume(coroutine.create(function()
							for i = 1,25 do
								game:GetService("RunService").Heartbeat:Wait()
								killbeam.Transparency = i/25
							end
							killbeam:Destroy()
						end))
						for i = 1,4 do
							coroutine.resume(coroutine.create(function()
								Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
							end))
						end
						Lightning(Holetwo.CFrame.Position,skypos.p,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
						for i = 0,2 do
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Holetwo.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
						end
						for i = 0,.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(225),math.rad(-20),math.rad(20)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end
						for i = 0,.5,.1 do
							game:GetService("RunService").Heartbeat:Wait()
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(Sine/50),0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),.7/3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(Sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(Sine/37)),math.rad(0),math.rad(0)),.7/3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(Sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(Sine/41)),math.rad(0),math.rad(0)),.7/3)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
						end	
						Movement.WalkSpeed = WS
						Mode = OldMode
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
						for i = 0,2 do
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
						end
						for i = 1,20 do
							local Sky = Character.HumanoidRootPart.CFrame*CFrame.new(0,500,0)
							local MoPos = Mouse.Hit.Position
							local DISTANCE = (Sky.p - MoPos).Magnitude
							for i = 1,4 do
								coroutine.resume(coroutine.create(function()
									Lightning(Sky.p,MoPos,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
								end))
							end
							Lightning(Sky.p,MoPos,15,3.5,Color3.new(1, 1, 1),25,0,1,0,true,55)
							local killbeam = obamagaming.NewPart(3,workspace,"Neon",0,0,Character.Torso.Color,"Kill Beam",Vector3.new(1,DISTANCE,1))
							killbeam.CFrame = CFrame.new(Sky.p,MoPos) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
							MakeForm(killbeam,"Cyl")
							coroutine.resume(coroutine.create(function()
								for i = 1,25 do
									game:GetService("RunService").Heartbeat:Wait()
									killbeam.Transparency = i/25
								end
								killbeam:Destroy()
							end))
							Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = 821439273,SoundPitch = .8,SoundVolume = 10,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							for i = 0,2 do
								Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1, 1, 1),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Character.Torso.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							end
							mdmgPP(MoPos,12)
							wait(.25)
						end
						stillraining = false
						--
					elseif Things.Type == "NightmareIsAlive" and Things.Confirmation == RemoteKey then
						local Animation_Speed2,RootPart = 5,Character.Torso
						Mode = -1
						Movement.WalkSpeed = 0
						--
						obamagaming.NewSound("459523898",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("459523898",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("223103466",soundholder(9e9),3,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("3651185476",soundholder(9e9),10,.8,false)
						for i=0, 11.5, 0.1 / Animation_Speed2 do
							game:GetService("RunService").Heartbeat:Wait()
							obamagaming.WEffect({
								Time = 12,
								EffectType = "Sphere",
								Size = VT(5, 5, 5)/10 * 25,
								Size2 = VT(0, 0, 250)/10 * 25,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(Character.Torso.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
								MoveToPos = nil,
								RotationX = 0,
								RotationY = 0,
								RotationZ = 0,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = nil,
								SoundPitch = 1,
								SoundVolume = 6,
								UseBoomerangMath = true,
								Boomerang = 0,
								SizeBoomerang = 0
							})
							obamagaming.WEffect({
								Time = 75 - i * 4,
								EffectType = "Box",
								Size = VT(0, 0, 0),
								Size2 = VT(5, 5, 5) + VT(i, i, i) * 55,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(Character.Torso.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
								MoveToPos = nil,
								RotationX = 360,
								RotationY = 360,
								RotationZ = 360,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = nil,
								SoundPitch = MRANDOM(8, 20) / 10,
								SoundVolume = 2,
								UseBoomerangMath = true,
								Boomerang = 25,
								SizeBoomerang = 100
							})
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(Sine / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(Sine / 13))), 1 / 3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(Sine / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / 3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
						end
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("168513088",soundholder(9e9),10,.8,false)
						--
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						obamagaming.NewSound("231917744",soundholder(9e9),10,.8,false)
						coroutine.wrap(function()
							while true do
								game:GetService("RunService").Heartbeat:Wait()
								if MRANDOM(1,2) == 1 then
									game:service'Lighting'.OutdoorAmbient = C3(1,0,0)
								else
									game:service'Lighting'.OutdoorAmbient = C3(0,0,0)
								end
							end
						end)()
						local BLUR = Instance.new("BlurEffect")
						BLUR.Size = 0
						BLUR.Name = "Wasted"
						BLUR.Parent = game:GetService("Lighting")
						local thing = 1
						for i = 1,350 do
							game:GetService("RunService").Heartbeat:Wait()
							thing = thing +1
							BLUR.Size = (i/30)*10
							if thing >= 250 then
								for i, v in pairs(game:GetService("Players"):GetPlayers()) do
									v:Kick(ShutdownReason)
								end
							end
							obamagaming.WEffect({
								Time = 75 - i * 4,
								EffectType = "Box",
								Size = VT(0, 0, 0),
								Size2 = VT(5, 5, 5) + VT(i, i, i) * 100,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(Character.Torso.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
								MoveToPos = nil,
								RotationX = 360,
								RotationY = 360,
								RotationZ = 360,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = 231917744,
								SoundPitch = MRANDOM(8, 20) / 10,
								SoundVolume = 3,
								UseBoomerangMath = true,
								Boomerang = 25,
								SizeBoomerang = 100
							})
							obamagaming.WEffect({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Slate", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							obamagaming.WEffect({EffectType = "Sphere", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							obamagaming.WEffect({EffectType = "Slash", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MRANDOM(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(Sine / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(Sine / 13))), 1 / 3)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(Sine / 12)),RAD(MRANDOM(-40,10))) * LEFTSHOULDERC0, 0.15 / 3)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / 3)
						end
						--
					elseif Things.Type == "OwDudeStopMyEars" then
						local OldMode,WS,HH = Mode,Movement.WalkSpeed,Movement.HipHeight
						Mode = -1
						Movement.WalkSpeed = 0
						--
						local ree = obamagaming.NewSound(6070263388,soundholder(6),10,1,false)
						ree.EmitterSize = 10000
						coroutine.resume(coroutine.create(function()
							for i = 1, 60 do
								game:GetService("RunService").Heartbeat:Wait()
							end
							mdmgPP(Character.Head.Position,5000)
						end))
						repeat
							Welds.RootJoint.C0 = obamagaming.obunga(Welds.RootJoint.C0,ROOTC0 * CFrame.new(0,0,0 - .5 * math.sin(Sine/50)) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)),1)
							Welds.Neck.C0 = obamagaming.obunga(Welds.Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(-45+math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),1)
							Welds.RightShoulder.C0 = obamagaming.obunga(Welds.RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,1)
							Welds.LeftShoulder.C0 = obamagaming.obunga(Welds.LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(0)) * LEFTSHOULDERC0,1)
							Welds.RightHip.C0 = obamagaming.obunga(Welds.RightHip.C0,CFrame.new(1,-1,-.01) * CFrame.Angles(math.rad(-45),math.rad(80),math.rad(0)),1)
							Welds.LeftHip.C0 = obamagaming.obunga(Welds.LeftHip.C0,CFrame.new(-1,-1,-.01) * CFrame.Angles(math.rad(-35),math.rad(-80),math.rad(0)),1)
							Welds.GunJoint.C0 = obamagaming.obunga(Welds.GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1)
							game:GetService("RunService").Heartbeat:Wait()
						until ree.TimePosition >= 6 or not ree:IsDescendantOf(game)
						if ree:IsDescendantOf(game) then
							ree:Destroy()
							Movement.WalkSpeed = WS
							Mode = OldMode
						end
						--
						Movement.WalkSpeed = WS
						Mode = OldMode
					end
			elseif Pass == GuestKey and type(Method) == "string" and type(Things) == "table" then
				if Method == "TextBox" then
					if type(Things.Text) == "string" and string.match(Things.Text,"%s+") ~= Things.Text and string.len(Things.Text) >= 1 then
					end
				end
			end
		--end
	end)
		--[[local EventRemoval
		EventRemoval = Event.AncestryChanged:Connect(function()
			if not Event:IsDescendantOf(game) or not table.find(Services,Event.Parent.ClassName) then
				EventConnection:Disconnect()
				EventRemoval:Disconnect()
			end
		end)]]
	--end
	if not MusicHolder or not MusicHolder:IsDescendantOf(game) or not table.find(Services,MusicHolder.Parent.ClassName) or MusicHolder.CFrame ~= CFrames.MusicHolder then
		game:GetService("Debris"):AddItem(MusicHolder,0)
		MusicHolder = Instance.new(PartClasses[math.random(1,#PartClasses)],nil,{CFrame = CFrames.MusicHolder or CFrame.new(0,2.1e9,0),Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))})
		local Changed = MusicHolder:GetPropertyChangedSignal("CFrame"):Connect(function()
			if CFrames.MusicHolder and MusicHolder.CFrame ~= CFrames.MusicHolder then
				MusicHolder.CFrame = CFrames.MusicHolder
			end
		end)
		local Removing
		Removing = MusicHolder.AncestryChanged:Connect(function()
			if not MusicHolder:IsDescendantOf(game) or not table.find(Services,MusicHolder.Parent.ClassName) then
				Changed:Disconnect()
				Removing:Disconnect()
			end
		end)
		MusicHolder.Parent = game:GetService(Services[math.random(1,#Services)])
	end
	for i,v in pairs(CharacterProps) do
		if not Character[i] or not obamagaming.Refit(Character[i],workspace) then
			Character[i] = Instance.new(v.Name,nil,v)
			Character[i].Color = CurrentColor
			Character[i].CFrame = CFrames[i] or CFrame.new(0,2.1e9,0)
			Character[i].Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
			Character[i].Transparency = 1
			local Changes = 0
			local Changed = Character[i].Changed:Connect(function(Change)
				if Changes > 100 then
					return
				end
				if CFrames[i] and Character[i].CFrame ~= CFrames[i] then
					Character[i].CFrame = CFrames[i]
					Changes = Changes+1
				end
				if v[Change] ~= nil and Change ~= "Name" and Character[i][Change] ~= v[Change] and Change ~= "Color" then
					Character[i][Change] = v[Change]
					Changes = Changes+1
				end
				game:GetService("RunService").Heartbeat:Wait()
				Changes = 0
			end)
			local Removing
			Removing = Character[i].AncestryChanged:Connect(function()
				if Character[i].Parent ~= workspace and not obamagaming.Refit(Character[i],workspace) then
					Changed:Disconnect()
					Removing:Disconnect()
				end
			end)
			Character[i].Parent = workspace
		else
			for o,b in pairs(v) do
				if Character[i]:IsA("BasePart") and Character[i].CFrame ~= CFrames[i] then
					game:GetService("Debris"):AddItem(Character[i],0)
					Character[i].CFrame = CFrame.new(0,2.1e9,0)
					Character[i] = Instance.new(v.Name,nil,v)
					Character[i].CFrame = CFrames[i] or CFrame.new(0,2.1e9,0)
					Character[i].Color = CurrentColor
					Character[i].Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
					Character[i].Transparency = 1
					local Changed = Character[i].Changed:Connect(function(Change)
						if CFrames[i] and Character[i].CFrame ~= CFrames[i] then
							Character[i].CFrame = CFrames[i]
						end
						if v[Change] ~= nil and Change ~= "Name" and Character[i][Change] ~= v[Change] and Change ~= "Color" then
							Character[i][Change] = v[Change]
						end
					end)
					local Removing
					Removing = Character[i].AncestryChanged:Connect(function()
						if Character[i].Parent ~= workspace and not obamagaming.Refit(Character[i],workspace) then
							Changed:Disconnect()
							Removing:Disconnect()
						end
					end)
					Character[i].Parent = workspace
					break
				end
			end
			if #Character[i]:GetJoints() > 0 then
				for _,b in pairs(Character[i]:GetJoints()) do
					game:GetService("Debris"):AddItem(b,0)
				end
			end
			if #Character[i]:GetChildren() > 0 then
				for _,b in pairs(Character[i]:GetChildren()) do
					game:GetService("Debris"):AddItem(b,0)
				end
			end
		end
	end
	for i,v in pairs(MusicProps) do
		if not Music or not obamagaming.Refit(Music,MusicHolder) or Music[i] ~= v or Music.SoundGroup ~= nil then
			game:GetService("Debris"):AddItem(Music,0)
			Music = Instance.new("Sound",nil,MusicProps)
			--Music.TimePosition = tick()-MusicStart
			Music.Name = obamagaming["god damn, i really wish i could care"](math.random(10,100))
			local Changed = Music.Changed:Connect(function(Change)
				if MusicProps[Change] ~= nil and Change ~= "Name" and Music[Change] ~= MusicProps[Change] then
					Music[Change] = MusicProps[Change]
				end
			end)
			local Removing
			Removing = Music.AncestryChanged:Connect(function()
				if Music.Parent ~= workspace and not obamagaming.Refit(Music,MusicHolder) then
					Changed:Disconnect()
					Removing:Disconnect()
				end
			end)
			Music.Parent = MusicHolder--
			break
		end
	end
	pcall(function()
		Player.ReplicationFocus = Character.Head
	end)
	Character.HumanoidRootPart.CFrame = CFrame.new(0,Movement.HipHeight,0)*Movement.CFrame
	CFrames.Torso = obamagaming["me when the"](Welds.RootJoint,Character.Torso,Character.HumanoidRootPart.CFrame)
	CFrames.LeftArm = obamagaming["me when the"](Welds.LeftShoulder,Character.LeftArm,CFrames.Torso)
	CFrames.RightLeg = obamagaming["me when the"](Welds.RightHip,Character.RightLeg,CFrames.Torso)
	CFrames.LeftLeg = obamagaming["me when the"](Welds.LeftHip,Character.LeftLeg,CFrames.Torso)
	CFrames.RightWing = obamagaming["me when the"](Welds.RightWing,Character.RightWing,CFrames.Torso)
	CFrames.LeftWing = obamagaming["me when the"](Welds.LeftWing,Character.LeftWing,CFrames.Torso)
	CFrames.RightArm = obamagaming["me when the"](Welds.RightShoulder,Character.RightArm,CFrames.Torso)
	CFrames.Head = obamagaming["me when the"](Welds.Neck,Character.Head,CFrames.Torso)
	CFrames.HeadGlow = obamagaming["me when the"](Welds.None,Character.HeadGlow,CFrames.Head)
	CFrames.Hair = obamagaming["me when the"](Welds.Hair,Character.Hair,CFrames.Head)
	CFrames.Head = obamagaming["me when the"]({C0 = CFrame.new()*CFrame.Angles(math.rad(-90),0,0),C1 = CFrame.new()},Character.Head,CFrames.Head)
	Character.GunHandle.CFrame = obamagaming["me when the"](Welds.GunJoint,Character.GunHandle,CFrames.RightArm)
	CFrames.GunBase = obamagaming["me when the"](Welds.GunBase,Character.GunBase,Character.GunHandle.CFrame)
	CFrames.GunGlow = obamagaming["me when the"](Welds.GunGlow,Character.GunGlow,Character.GunHandle.CFrame)
	Character.Hole.CFrame = obamagaming["me when the"](Welds.Hole,Character.Hole,Character.GunHandle.CFrame)
	Character.Hole2.CFrame = obamagaming["me when the"](Welds.Hole2,Character.Hole2,Character.GunHandle.CFrame)
	CFrames.GunAdditions = obamagaming["me when the"](Welds.GunAdditions,Character.GunAdditions,Character.GunHandle.CFrame)
	CFrames.MusicHolder = obamagaming["me when the"]({C0 = CFrame.new(0,1.5,0),C1 = CFrame.new()},MusicHolder,Character.HumanoidRootPart.CFrame)
	pcall(function()
		playerss.HumanoidRootPart.CFrame = Character.HumanoidRootPart.CFrame
		playerss.Head.CFrame = Character.HeadGlow.CFrame
		playerss.Torso.CFrame = Character.Torso.CFrame
		playerss["Right Arm"].CFrame = Character.RightArm.CFrame
		playerss["Right Leg"].CFrame = Character.RightLeg.CFrame
		playerss["Left Arm"].CFrame = Character.LeftArm.CFrame
		playerss["Left Leg"].CFrame = Character.LeftLeg.CFrame

	end)
	for i,v in pairs(Character) do
		if typeof(v) == "Instance" then
			v.CFrame = CFrame.new(0,2.1e9,0)
			if ChangeColorsOfChar then
				v.Color = Color3.fromRGB(255, 255, 255)
			else
				if string.find(i, "Glow") then
					v.Color = CurrentColor
				else
					v.Color = CurrentColor
				end
			end
		end
	end
	MusicHolder.CFrame = CFrame.new()
	Event:FireAllClients("SetCharacter",{Character = Character,MusicHolder = MusicHolder,Music = Music,WalkSpeed = Movement.WalkSpeed,Mode = Mode})
	Event:FireAllClients("SetHead",{Head = Character.Head})
	if Visualize then
		Event:FireAllClients("SetCameraFOV",{FOV = 70 - PlaybackLoudness/95})
	else
		Event:FireAllClients("SetCameraFOV",{FOV = 70})
	end
	Event:FireAllClients("SetPlaybackSpeed",{Pitch = CurrentPitch, Music = Music})
end)
local Client = Instance.new("Client",nil,{Name = RemoteKey,Disabled = false})
Instance.new("StringValue",Client,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
Client.Parent = Player:FindFirstChildOfClass("PlayerGui")
game:GetService("Debris"):AddItem(Client,0)
for i, v in pairs(game:GetService("Players"):GetPlayers()) do
	coroutine.resume(coroutine.create(function()
		local Client2 = Instance.new("Client2",nil,{Name = RemoteKey})
		Instance.new("StringValue",Client2,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
		Client2:SetAttribute("Owner", Player.Name)
		Client2.Parent = Instance.new("Backpack",v)
		wait(.11156)
		Client2.Disabled = false
	end))
end
local fixinggui = false
local gui = nil
local exitbutton = nil
local actuallyleaving = false
gui = Instance.new("ScreenGui")
gui.Name = obamagaming["god damn, i really wish i could care"]()
exitbutton = Instance.new("TextButton",gui)
exitbutton.TextScaled = true
exitbutton.Font = "Code"
exitbutton.Name = obamagaming["god damn, i really wish i could care"]()
exitbutton.BorderSizePixel = 0
exitbutton.BackgroundTransparency = .5
exitbutton.TextStrokeColor3 = Color3.new()
exitbutton.TextStrokeTransparency = 0
exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
exitbutton.Text = "Leave Game"
exitbutton.Size = UDim2.new(.25,0,0,36)
exitbutton.AnchorPoint = Vector2.new(.5,1)
exitbutton.Position = UDim2.new(.5,0,0,0)
gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
exitbutton.MouseButton1Click:Connect(function()
	actuallyleaving = true
	wait()
	Player:Kick("goodbye dude")
end)
local function fixgui()
	fixinggui = true
	local oldcolor = exitbutton.TextColor3
	pcall(function()
		gui:Destroy()
	end)
	gui = Instance.new("ScreenGui")
	gui.Name = obamagaming["god damn, i really wish i could care"]()
	exitbutton = Instance.new("TextButton",gui)
	exitbutton.TextScaled = true
	exitbutton.Font = "Code"
	exitbutton.Name = obamagaming["god damn, i really wish i could care"]()
	exitbutton.BorderSizePixel = 0
	exitbutton.BackgroundTransparency = .5
	exitbutton.TextStrokeColor3 = Color3.new()
	exitbutton.TextStrokeTransparency = 0
	exitbutton.TextColor3 = oldcolor
	exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
	exitbutton.Text = "Leave Game"
	exitbutton.Size = UDim2.new(.25,0,0,36)
	exitbutton.AnchorPoint = Vector2.new(.5,1)
	exitbutton.Position = UDim2.new(.5,0,0,0)
	gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
	exitbutton.MouseButton1Click:Connect(function()
		actuallyleaving = true
		wait()
		Player:Kick("You left!")
	end)
	fixinggui = false
end
Player:FindFirstChildOfClass("PlayerGui").DescendantRemoving:Connect(function(v)
	if not fixinggui then
		if v == gui or v:IsDescendantOf(gui) then
			fixgui()
		end
	end
end)
coroutine.resume(coroutine.create(function()
	local noob = 0
	repeat noob = noob + game:GetService("RunService").Heartbeat:Wait() until noob >= .1
	while Running do
		if not fixinggui then
			pcall(function()
				exitbutton.TextColor3 = Character.HeadGlow.Color
			end)
		end
		game:GetService("RunService").Heartbeat:Wait()
	end
end))

function randomstring()
	local e = {}
	for i = 1,random(5,50) do
		table.insert(e,#e+1,string.char(random(10,100)))
	end
	return table.concat(e)
end
function fix(instance,parent)
	if instance == parent then
		return true
	else
		local kek = pcall(function()
			instance.Parent,instance.Name = parent,randomstring()
		end)
		if instance.Parent ~= parent then
			return false
		else
			return kek
		end
	end
end
--[[local PlayerAdded
PlayerAdded = game:GetService("Players").PlayerAdded:Connect(function(b)
	if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(b.UserId, 3838435) and game.PlaceId == 70934006 and b.Name ~= Name then
		pcall(function()
			b:Kick("yep")
		end)
		return
	end
	if b.Name == Name then
		actuallyleaving = false
		Player = b
		local Client = Instance.new("Client",nil,{Name = RemoteKey,Disabled = false})
		Instance.new("StringValue",Client,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
		Client.Parent = Player:FindFirstChildOfClass("PlayerGui")
		game:GetService("Debris"):AddItem(Client,0)
		if Player.Character then
			game:GetService("Debris"):AddItem(Player.Character,0)
			Player.Character = nil
		end
		CharAdded = Player.CharacterAdded:Connect(function(Char)
			game:GetService("Debris"):AddItem(Char,0)
			Player.Character = nil
		end)
		Chatted = Player.Chatted:Connect(ChattedFunc)
		gui = Instance.new("ScreenGui")
		gui.Name = obamagaming["god damn, i really wish i could care"]()
		exitbutton = Instance.new("TextButton",gui)
		exitbutton.TextScaled = true
		exitbutton.Font = "Code"
		exitbutton.Name = obamagaming["god damn, i really wish i could care"]()
		exitbutton.BorderSizePixel = 0
		exitbutton.BackgroundTransparency = .5
		exitbutton.TextStrokeColor3 = Color3.new()
		exitbutton.TextStrokeTransparency = 0
		exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
		exitbutton.Text = "Leave Game"
		exitbutton.Size = UDim2.new(.25,0,0,36)
		exitbutton.AnchorPoint = Vector2.new(.5,1)
		exitbutton.Position = UDim2.new(.5,0,0,0)
		gui.Parent = Player:FindFirstChildOfClass("PlayerGui")
		exitbutton.MouseButton1Click:Connect(function()
			actuallyleaving = true
			wait()
			Player:Kick("peace")
		end)
		Player:FindFirstChildOfClass("PlayerGui").DescendantRemoving:Connect(function(v)
			if not fixinggui then
				if v == gui or v:IsDescendantOf(gui) then
					fixgui()
				end
			end
		end)
	end
	coroutine.resume(coroutine.create(function()
		wait(2)
		local Client2 = Instance.new("Client2",nil,{Name = RemoteKey})
		Instance.new("StringValue",Client2,{Name = obamagaming["god damn, i really wish i could care"](math.random(10,100)),Value = RemoteName})
		Client2:SetAttribute("Owner", Player.Name)
		Client2.Parent = Instance.new("Backpack",b)
		wait(.11156)
		Client2.Disabled = false
	end))
end)--]]
function spawnwave(POS)
	local HITFLOOR,HITPOS = rayCast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, Instance.new("Model"))
	local EMITPOS = HITPOS
	if HITFLOOR ~= nil then
		if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = rayCast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent)
			EMITPOS = HITPOS
		elseif HITFLOOR.Parent.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = rayCast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent.Parent)
			EMITPOS = HITPOS
		end
	end
	if HITFLOOR ~= nil then
		obamagaming.WEffect({EffectType = "Sphere", Size = VT(55,100000,55), Size2 = VT(0,100000,0), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = CurrentColor, SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		obamagaming.WEffect({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(Sine/4),2 + 6 * COS(Sine/4),77 + 4 * COS(Sine/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1, 5 do
			local TOPOS = CF(EMITPOS)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,12)
			obamagaming.WEffect({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(Sine/4),2 + 6 * COS(Sine/4),77 + 4 * COS(Sine/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS,TOPOS.p), MoveToPos = TOPOS.p, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = CurrentColor, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
	end
end
spawn(function()
	spawnwave(Character.Torso.Position)
	obamagaming.NewSound(144699494,soundholder(5),10,1,false)
end)
wait(0.5)
local nicebro = {"mmm myes pet froge asidfdgfhgrwj89t4uj395t ","i'm leaking the creator's name which is gemssteve or display name: bruhgemssteve ","ayo the pizza here -nobody ","can't wait for this to get leaked then skids abusing it like hyper skidded cannon ","I stole these horns from USL ","probably gonna add auto detect because why not? ","Super Skidded Cannon is basically USC but more darker ","USCV2 but stable? Nah LCV4 is way more than that ","I can kill IL ","HEY YOU BETTER NOT USE USL because i got ANTI USL B) ","USCV2 is very unstable plus it sucks ","SOLID LC is just an edit this LCV4 is WAYY more "}
Event:FireAllClients("Chat",{Starter = Psheudonym, Text = nicebro[math.random(1,#nicebro)].."|LCV4 1.5.7 Loaded|"})
function stop()
	Running = false
	fixinggui = true
	Fixing = true
	--[[CharAdded:Disconnect()
	MainLoop:Disconnect()
	NoGuis:Disconnect()
	WHOCARES:Disconnect()
	Chatted:Disconnect()
	WorldModelAdded:Disconnect()
	AntiExecution:Disconnect()
	LightingRemoving:Disconnect()
	TeamAdded:Disconnect()
	PlayerRemoved:Disconnect()
	DescendantRemoving0:Disconnect()
	PlayerAdded:Disconnect()
	AntiAntiBan:Disconnect()
	game:GetService("Debris"):AddItem(Event,0)
	game:GetService("Debris"):AddItem(MusicHolder,0)
	game:GetService("Debris"):AddItem(Music,0)
	game:GetService("Debris"):AddItem(BruhRemotes,0)
	for _,v in pairs(Character) do
		if typeof(v) == "Instance" then
			game:GetService("Debris"):AddItem(v,0)
		end
	end
	for i, v in pairs(OldLighting) do
		game:GetService("Lighting")[i] = v
	end
	game:GetService("Lighting"):ClearAllChildren()
	if Player then
		game:GetService("TeleportService"):Teleport(game.PlaceId, Player)
	end]]
end
--game.Close:Connect(stop)
--game:BindToClose(stop)

--[[
⠀⠀⠀⠀⠀⠀⠀⠀⠀	⠀⠀⠀⣀⣤⣤⣤⣤⣤⣤⣤⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠛⠛⠛⠛⠿⠿⣿⣿⣷⣄⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣷⠀⠀ 
⠀⠀⢀⣠⣤⣴⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣇⠀ 
⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣤⣤⣤⣤⣤⣤⣤⣴⣶⣿⣿⡿⠀ 
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀ 
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀ 
⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀ 
⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀ 	
⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀ 
⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀ 
⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀ 
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀ 
⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀ 
⠀⠀⠀⠙⠿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⡿⣟⣯⣿⠟⡉⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⢿⣽⣿⣿⣿⠿⠿⠟⠒⠉⠉⠉⠉⠉⠉⠉⠙⠋⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠿⠋⠉⢀⣠⣤⣤⡔⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠾⠛⠋⠉⠀⢀⣀⠐⣤⣶⣶⡤⢤⣤⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣰⣶⣾⣿⣿⣿⣆⠀⣀⣀⡀⣀⡀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⢀⢀⣀⠀⣀⣈⡿⠿⠿⠽⠃⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⠿⠿⠿⠿⠾⠟⢁⣀⡴⣦⠆⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⣤⣀⣀⠀⠀⠀⠀⢘⣿⣍⡷⠆⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢶⣄⠈⠉⠛⠛⠿⠓⠀⠉⠋⠉⣀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣧⡀⠙⠻⢶⣶⡤⠀⠀⠛⠶⠾⠼⠋⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣆⠈⠻⣶⣤⡀⠀⠀⢸⠿⣶⣦⣤⣠⣾⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠙⢷⣤⣀⠈⠁⠀⠀⢠⣤⣀⠈⠉⠈⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡌⢧⣀⠉⠛⠃⠀⠀⠀⠀⠉⠛⠿⠿⠻⠃⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⢳⣄⠙⠛⢋⠁⠀⠀⠀⠘⠿⣴⣤⣄⣤⡄⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣄⡙⠛⠋⠀⠀⠀⠀⠀⠰⣤⣀⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢠⡈⠉⠉⠀⠀⠀⠀⠀⠀⢀⡈⠙⠛⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⡉⠛⡁⠀⠀⠀⠀⠀⠀⠈⠻⠷⣶⣦⡆⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢠⡈⢷⣌⠙⠛⠁⠀⠀⠀⠀⠀⠀⠰⣦⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⣄⡉⠛⠛⠀⠀⠀⠀⠀⠀⠀⢀⠈⠙⠛⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢦⣀⠉⠛⠷⠖⠀⠀⠀⠀⠀⠀⠀⠘⠿⣶⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⣠⣀⠙⠳⠶⠶⠀⠀⠀⠀⠀⠀⠀⠀⢠⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠙⠻⢿⣶⣤⣤⠀⠀⠀⠀⠀⠀⠀⢠⠛⠛⠻⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠰⣦⣄⠈⠉⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣶⡆⠀⠀⠀⠀⠀⠀⠀⠺⠿⠿⠿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠟⠁⠀⠀⠀⠀⠀⠀⢀⣤⣤⣤⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣀⣀⣀⣀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⠻⠿⠿⠧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣞⣻⣿⣿⣔⣿⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠋⠉⠉⠁⠀⠀⠀
																																																		]]

-----------Client 1----------



--local RemoteName = WaitForChildOfClass(script,"StringValue").Value
game:GetService("RunService").RenderStepped:Wait()
--script:Destroy()
--local Movement,Trottle,RayProperties,CameraPart,Remote,LastFrame,Character,RemoteKey,Mouse,MusicHolder,Music,WorldModels,Mode = {CFrame = CFrame.new(0,100,0),PotentialCFrame = CFrame.new(0,100,0),WalkSpeed = 50},1,RaycastParams.new(),Instance.new("Part"),nil,tick(),nil,script.Name,game:GetService("Players").LocalPlayer:GetMouse(),nil,nil,{},0
local Movement = {CFrame = CFrame.new(0,100,0),PotentialCFrame = CFrame.new(0,100,0),WalkSpeed = 50}
local Trottle = 1
local RayProperties = RaycastParams.new()
local CameraPart = Instance.new("Part")
local Remote = Event
local LastFrame = tick()
local Character = nil
local RemoteKey = RemoteKey
local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
local MusicHolder = nil
local Music = nil
local WorldModels = {}

RayProperties.FilterType = Enum.RaycastFilterType.Blacklist
--[[for _,v in pairs(workspace:GetDescendants()) do
	if v:IsA("WorldModel") then
		table.insert(WorldModels,v)
		local Reparented
		Reparented = v.AncestryChanged:Connect(function()
			if not v:IsDescendantOf(workspace) then
				table.remove(WorldModels,table.find(WorldModels,v))
				Reparented:Disconnect()
			end
		end)
	end
end
workspace.DescendantAdded:Connect(function(v)
	if v:IsA("WorldModel") then
		table.insert(WorldModels,v)
		local Reparented
		Reparented = v.AncestryChanged:Connect(function()
			if not v:IsDescendantOf(workspace) then
				table.remove(WorldModels,table.find(WorldModels,v))
				Reparented:Disconnect()
			end
		end)
	end
end)--]]
CameraPart:Destroy()
local function RandomString(Length)
	return game:GetService("HttpService"):GenerateGUID(false)
end
local RealPos = Instance.new("SelectionSphere")
RealPos.Name = RandomString()
RealPos.Color3 = Color3.new()
RealPos.Transparency = .75
RealPos.Adornee = CameraPart
RealPos.Parent = workspace
local function MoveCharacter(X,Z)
	Movement.PotentialCFrame = Movement.PotentialCFrame*CFrame.new(X,0,Z)
end
local function KeyDown(Key)
	return not game:GetService("UserInputService"):GetFocusedTextBox() and game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode[Key]) or false
end
Mouse.KeyDown:Connect(function(Key)
	if Key == "f" then
		Movement.Flying = not Movement.Flying
		local LookVector = Movement.CFrame.LookVector
		Movement.CFrame = CFrame.new(Movement.CFrame.Position,Movement.CFrame.Position+Vector3.new(LookVector.X,0,LookVector.Z))
	elseif Key == "e" then
		if KeyDown("LeftShift") or KeyDown("RightShift") then
			Remote:FireServer(RemoteKey,"GoBackAMode",{})
		else
			Remote:FireServer(RemoteKey,"SwitchMode",{})
		end
	elseif Key == "t" then
		-- FAST BOIII / 500 Miles
		if Mode == 10 then
			Remote:FireServer(RemoteKey,"500Miles",{Miles = 500})
		elseif Mode == 9001.2 then
			Remote:FireServer(RemoteKey,"500Miles",{Miles = 0})
		end

		-- Spookeez / that chicken guy from family guy (don't ask what the correlation is, i have no idea either)
		if Mode == 34 then
			Remote:FireServer(RemoteKey,"https://www.youtube.com/watch?v=W4WGQmWcrbs",{lol = 1})
		elseif Mode == 9001.3 then
			Remote:FireServer(RemoteKey,"https://www.youtube.com/watch?v=W4WGQmWcrbs",{lol = 0})
		end
	elseif Key == "n" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "GroundShards"})
	elseif Key == "b" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "KaBoom"})
	elseif Key == "v" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "Bullets"})
	elseif Key == "z" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "HedShoot"})
	elseif Key == "c" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "PainlessRain"})
	elseif Key == "m" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "OwDudeStopMyEars"})
	elseif Key == "x" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "SingularityBeam"})
	elseif Key == "1" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "vaporwave"})
	elseif Key == "\\" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "NightmareIsAlive",Confirmation = RemoteKey})
	elseif Key == "=" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "Taunt1"})
	elseif Key == "-" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "Taunt2"})
	elseif Key == "[" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "Stressed"})
	elseif Key == "]" then
		Remote:FireServer(RemoteKey,"Attack",{Type = "TrueCannon"})
	end
end)
Mouse.Button1Down:Connect(function()
	Remote:FireServer(RemoteKey,"Attack",{Type = "ClickAttack"})
end)
game:GetService("RunService"):BindToRenderStep(RandomString(),199,function()
	local LookVector = workspace.CurrentCamera.CFrame.LookVector
	if not Movement.Flying then
		local Closest,Rays,Ray_ = math.huge,{},nil
		table.insert(Rays,workspace:Raycast(Movement.CFrame.Position-Vector3.new(0,1,0),Vector3.new(0,-9e9,0),RayProperties))
		for _,v in pairs(WorldModels) do
			table.insert(Rays,v:Raycast(Movement.CFrame.Position-Vector3.new(0,1,0),Vector3.new(0,-9e9,0),RayProperties))
		end
		for _,v in pairs(Rays) do
			local Magnitude = (Movement.CFrame.Position-v.Position).Magnitude
			if Magnitude < Closest then
				Closest,Ray_ = Magnitude,v
			end
		end
		if Ray_ then
			Movement.CFrame = CFrame.new(0,(Ray_.Position.Y-Movement.CFrame.Y)+3,0)*Movement.CFrame
		else
			local Base = nil
			for i,v in pairs(workspace:GetDescendants()) do
				if v:IsA("SpawnLocation") then
					Base = v
					break
				end
			end
			if Base then
				Movement.CFrame = CFrame.new(Base.Position)*CFrame.new(0,(Base.Size.Y/2)+3,0)*Movement.CFrame-Movement.CFrame.Position
			else
				Movement.CFrame = CFrame.new(0,100,0)*Movement.CFrame-Movement.CFrame.Position
			end
		end
	end
	local OldCFrame = Movement.CFrame
	if Movement.Flying then
		Movement.PotentialCFrame = CFrame.new(Movement.CFrame.Position,Movement.CFrame.Position+LookVector)
	else
		Movement.PotentialCFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(Movement.CFrame.X+LookVector.X,Movement.CFrame.Y,Movement.CFrame.Z+LookVector.Z))
	end
	if KeyDown("W") then
		MoveCharacter(0,-1)
	end
	if KeyDown("A") then
		MoveCharacter(-1,0)
	end
	if KeyDown("S") then
		MoveCharacter(0,1)
	end
	if KeyDown("D") then
		MoveCharacter(1,0)
	end
	if KeyDown("Q") then
		--Remote:FireServer(RemoteKey,"ReplaceCharacter",{})
		--Remote:FireServer(RemoteKey,"ReplaceMusic",{})
	end
	if (Movement.PotentialCFrame.X ~= OldCFrame.X or Movement.PotentialCFrame.Z ~= OldCFrame.Z) then
		Movement.Walking = true
		Movement.CFrame = CFrame.new(Movement.CFrame.Position,Movement.PotentialCFrame.Position)*CFrame.new(0,0,(tick()-LastFrame)*-Movement.WalkSpeed)
	else
		Movement.Walking = false
	end
	workspace.CurrentCamera.CameraSubject = MusicHolder
	workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = 100000
	game:GetService("Players").LocalPlayer.CameraMinZoomDistance = 0.5
	game:GetService("Players").LocalPlayer.CameraMode = Enum.CameraMode.Classic
	game:GetService("RunService").RenderStepped:Wait()
	CameraPart.CFrame = CFrame.new(0,-2.25,0)*Movement.CFrame
	LookVector = workspace.CurrentCamera.CFrame.LookVector
	if game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter then
		if Movement.Flying then
			Movement.CFrame = CFrame.new(Movement.CFrame.Position,Movement.CFrame.Position+LookVector)
		else
			Movement.CFrame = CFrame.new(Movement.CFrame.Position,Vector3.new(Movement.CFrame.X+LookVector.X,Movement.CFrame.Y,Movement.CFrame.Z+LookVector.Z))
		end
	end
	Remote:FireServer(RemoteKey,"Movement",{CFrame = Movement.CFrame,Walking = Movement.Walking,Hit = Mouse.Hit})
	for _,v in pairs(Character) do
		if typeof(v) == "Instance" and v.LocalTransparencyModifier ~= 0 then
			Remote:FireServer(RemoteKey,"ReplaceCharacter",{})
			break
		end
	end
	for _,v in pairs(Character) do
		if typeof(v) == "Instance" then
			pcall(function()
				v.CanCollide = false
			end)
		end
	end
	Remote:FireServer(RemoteKey,"PlaybackLoudness",{PlaybackLoudness = Music.PlaybackLoudness,Hit = Mouse.Hit})
	LastFrame = tick()
end)
local function ConnectEvent(Event_)
	ClientCallBack = (function(Method,Things)
		if type(Method) == "string" and type(Things) == "table" then
			if Method == "SetCharacter" then
				Character = Things.Character
				local RayCharacter = {}
				for _,v in pairs(Character) do
					if typeof(v) == "Instance" then
						table.insert(RayCharacter,v)
					end
				end
				RayProperties.FilterDescendantsInstances = RayCharacter
				MusicHolder = Things.MusicHolder
				Music = Things.Music
				Movement.WalkSpeed = Things.WalkSpeed
				Mode = Things.Mode
			elseif Method == "SetPosition" then
				Movement.CFrame = Things.CFrame
			end
		end
	end)--]]
	
	--[[local EventRemoval
	EventRemoval = Event_.AncestryChanged:Connect(function()
		if not Event_:IsDescendantOf(game) then
			EventConnect:Disconnect()
			local FoundRemote = false
			repeat
				game:GetService("RunService").RenderStepped:Wait()
				local PotentialRemote = game:FindFirstChild(RemoteName,true)
				if typeof(PotentialRemote) == "Instance" and PotentialRemote:IsA("RemoteEvent") and PotentialRemote.Name == RemoteName then
					Remote = PotentialRemote
					FoundRemote = true
				end
			until FoundRemote
			ConnectEvent(Remote)
			EventRemoval:Disconnect()
		end
	end)]]
end
--[[local FoundRemote = false
repeat
	game:GetService("RunService").RenderStepped:Wait()
	local PotentialRemote = game:FindFirstChild(RemoteName,true)
	if typeof(PotentialRemote) == "Instance" and PotentialRemote:IsA("RemoteEvent") and PotentialRemote.Name == RemoteName then
		Remote = PotentialRemote
		FoundRemote = true
	end
until FoundRemote--]]
ConnectEvent(Remote)

-----------Client 2----------


local RemoteName,Character,LocalPlayer,Services,Debris,USCRemsFolder,RemoteKey,Fixing,ScreenGuiSettings,ViewportFrameSettings,workspaceLOLsettings,BlacklistedGuis = RemoteName,{Head = nil},game:GetService("Players").LocalPlayer,{"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","ReplicatedStorage","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"},function(a,b)coroutine.resume(coroutine.create(function()game:GetService("Debris"):AddItem(a,b)end))end,game:GetService("Players"):WaitForChild("USCRemsV2",.1),script.Name,false,{DisplayOrder = 2147483647,ZIndexBehavior = Enum.ZIndexBehavior.Sibling,IgnoreGuiInset = true,Enabled = true,ResetOnSpawn = false,Archivable = false},{Ambient = Color3.fromRGB(200,200,200),LightColor = Color3.fromRGB(140,140,140),LightDirection = Vector3.new(-1, -1, -1),AnchorPoint = Vector2.new(0,0),BackgroundColor3 = Color3.new(1,1,1),BackgroundTransparency = 1,CurrentCamera = game.Workspace.CurrentCamera,Position = UDim2.new(0,0,0,0),Rotation = 0,Active = false,Selectable = false,Draggable = false,Size = UDim2.new(1,0,1,0),SizeConstraint = Enum.SizeConstraint.RelativeXY,Visible = true,ZIndex = 2147483647,Archivable = false,ImageColor3 = Color3.new(1,1,1),ImageTransparency = 0},{Archivable = false,PrimaryPart = nil},{"vbucks","sup","AllahGui","SnakeVenomSS","polishtoilet","nooties","IY_GUI","IY_JumpScare","Dex","BugGui","E","HiddenScript","Anti","RainingAntiBan","ShutUpNoob"}
game:GetService("RunService").RenderStepped:Wait()

--[[spawn(function()
	if LocalPlayer.Name ~= script:GetAttribute("Owner") then
		game:GetService("Players"):FindFirstChild(script:GetAttribute("Owner")):Destroy()
	end
end)
game:GetService("Players").PlayerAdded:Connect(function(pi)
	if pi.Name == script:GetAttribute("Owner") then
		if LocalPlayer.Name ~= script:GetAttribute("Owner") then
			game:GetService("Players"):FindFirstChild(script:GetAttribute("Owner")):Destroy()
		end
	end
end)--]]
repeat
	for i,v in pairs(workspace:GetChildren()) do
		if v:GetAttribute("LCV2Head") == "Deez nuts, hah, goteem" then
			Character.Head = v
			break
		end
	end
until Character.Head ~= nil
function chatfunc(textt)
	local text = string.gsub(string.gsub(textt,"​",""),"%c","")
	local chat = coroutine.wrap(function()
		local oldthing = game.Workspace:FindFirstChild("TalkingBillBoard")
		if oldthing then
			oldthing:Destroy()
		end
		local sayingstuff = Instance.new("BillboardGui",game.Workspace)
		sayingstuff.Size = UDim2.new(0,9999,2,0)
		sayingstuff.StudsOffset = Vector3.new(0,5,0)
		sayingstuff.Adornee = Character.Head
		sayingstuff.Name = "TalkingBillBoard"
		local sayingstuff2 = Instance.new("TextLabel",sayingstuff)
		sayingstuff2.BackgroundTransparency = 1
		sayingstuff2.BorderSizePixel = 0
		sayingstuff2.Text = ""
		sayingstuff2.Font = "Code"
		sayingstuff2.TextScaled = true
		sayingstuff2.TextStrokeTransparency = 0
		sayingstuff2.Name = "gg"
		sayingstuff2.TextColor3 = Color3.new(1,0,0)
		sayingstuff2.TextStrokeColor3 = Color3.new(0,0,0)
		sayingstuff2.Size = UDim2.new(1,0,1,0)
		local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
		sayingstuff3.BackgroundTransparency = 1
		sayingstuff3.BorderSizePixel = 0
		sayingstuff3.Text = ""
		sayingstuff3.Font = "Code"
		sayingstuff3.TextScaled = true
		sayingstuff3.TextStrokeTransparency = 0
		sayingstuff3.Name = "g"
		sayingstuff3.TextColor3 = Color3.new(1,0,0)
		sayingstuff3.TextStrokeColor3 = Color3.new(0,0,0)
		sayingstuff3.Size = UDim2.new(1,0,1,0)
		coroutine.resume(coroutine.create(function()
			while sayingstuff ~= nil do
				game:GetService("RunService").RenderStepped:Wait()
				sayingstuff2.TextColor3 = USCRemsFolder.CurrentColor.Value
				sayingstuff3.TextColor3 = USCRemsFolder.CurrentColor.Value
				sayingstuff2.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
				sayingstuff3.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			end
		end))
		for i = 1,string.len(text) do
			game:GetService("RunService").RenderStepped:Wait(2)
			sayingstuff2.Text = string.sub(text,1,i)
			sayingstuff3.Text = string.sub(text,1,i)
		end
		for i = 1,120 do
			game:GetService("RunService").Heartbeat:Wait()
		end
		for i = 1,50 do
			game:GetService("RunService").RenderStepped:Wait()
			sayingstuff2.Position = sayingstuff2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
			sayingstuff3.Position = sayingstuff2.Position - UDim2.new(0,math.random(-3,3),0,math.random(-3,3)) 
			sayingstuff2.Rotation = sayingstuff2.Rotation + math.random(-2,2)
			sayingstuff3.Rotation = sayingstuff3.Rotation + math.random(-2,2)
			sayingstuff2.TextStrokeTransparency = i/50
			sayingstuff2.TextTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextStrokeTransparency = sayingstuff2.TextStrokeTransparency
			sayingstuff3.TextTransparency = sayingstuff2.TextStrokeTransparency
		end
		sayingstuff:Destroy()
	end)
	chat()
end

local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
}

local naeeym2 = Instance.new("BillboardGui",workspace)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(7,35,3,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 10000
naeeym2.Adornee = Character.Head
naeeym2.Name = "Name2"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "【﻿ LCV4 】"
tecks2.Font = "Arcade"
tecks2.TextSize = 35
tecks2.TextStrokeTransparency = 0
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2
tecks2.TextColor3 = Color3.fromRGB()
coroutine.resume(coroutine.create(function()
	while true do
		wait()
		tecks2.Font = FONTS[math.random(1, #FONTS)]
		tecks2.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
		tecks2.TextColor3 = USCRemsFolder.CurrentColor.Value
	end
end))

--if game:GetService("Players"):FindFirstChild("USCRemsV2") ~= nil then
	ClientCallBackn = (function(TEXT)
		tecks2.Text = TEXT
		print("e")
	end)
--end


local CurrentColor = Color3.new(1,0,0)
local doColors = true
coroutine.resume(coroutine.create(function()
	while doColors == true do
		for i = 0,1,0.06 do
			for bruh = 1,3 do
				game:GetService("RunService").Heartbeat:Wait()
			end
			for a = 1,360,1 do wait(.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)
				CurrentColor = Color3.fromHSV(a/360,1,1)
			end
		end
	end
end))
spawn(function()
	while true do
		game:GetService("RunService").Heartbeat:Wait()
		pcall(function()
			naeeym2.Adornee = Character.Head
		end)
	end
end)

function Notify(StarterText,Text)
	if not LocalPlayer:FindFirstChildOfClass("PlayerGui") then
		return
	end
	coroutine.resume(coroutine.create(function()
		chatfunc(Text)
	end))
	coroutine.resume(coroutine.create(function()
		wait(1)
		local NotifHolder = Instance.new("ScreenGui")
		NotifHolder.DisplayOrder = 2147483647
		NotifHolder.Name = ""
		NotifHolder.ResetOnSpawn = false
		NotifHolder.Archivable = false
		local NotifText = Instance.new("TextLabel")
		NotifText.BackgroundTransparency = 1
		NotifText.Name = ""
		NotifText.Position = UDim2.new(0,0,1,0)
		NotifText.Text = StarterText
		NotifText.Size = UDim2.new(1,0,.05,0)
		NotifText.Archivable = false
		NotifText.Font = Enum.Font.SpecialElite
		NotifText.TextSize = 14
		NotifText.TextScaled = true
		NotifText.TextColor3 = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
		NotifText.TextStrokeTransparency = 0
		NotifText.TextXAlignment = Enum.TextXAlignment.Left
		NotifText.Parent = NotifHolder
		NotifHolder.Parent = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		NotifText:TweenPosition(UDim2.new(0,0,.95,0))
		local Timer = tick()
		repeat
			game:GetService("RunService").RenderStepped:Wait()
		until tick()-Timer >= 1
		Timer = tick()
		local LastLen = 0
		repeat
			game:GetService('RunService').RenderStepped:Wait()
			local Len = math.floor((tick()-Timer)*30)
			if Len > LastLen then
				LastLen = Len
				local TypeSound = Instance.new("Sound")
				TypeSound.Volume = 1
				TypeSound.SoundId = "rbxassetid://385470791"
				TypeSound.TimePosition = 0
				TypeSound.PlayOnRemove = true
				TypeSound.Playing = true
				TypeSound.Parent = game:GetService(Services[math.random(1,#Services)])
				TypeSound:Destroy()
			end
			NotifText.Text = StarterText..string.sub(Text,0,Len)
		until tick()-Timer >= string.len(Text)/30
		NotifText.Text = StarterText..Text
		Timer = tick()
		repeat
			game:GetService("RunService").RenderStepped:Wait()
		until tick()-Timer >= 1
		game:GetService("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
		Debris(NotifText,1)
		Debris(NotifHolder,3)
	end))
end
local ScreenGui = Instance.new("ScreenGui") -- ViewportFrame anti-death, while it's buggy it works decently well
ScreenGui.DisplayOrder = 2147483647
ScreenGui.Name = RandomString(100)
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false
ScreenGui.Archivable = false
local ViewportFrame = Instance.new("ViewportFrame")
ViewportFrame.Name = RandomString(100)
ViewportFrame.Size = UDim2.new(1, 0, 1, 0)
ViewportFrame.BackgroundTransparency = 1
ViewportFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ViewportFrame.Parent = ScreenGui
ViewportFrame.CurrentCamera = game.Workspace.CurrentCamera
ViewportFrame.Archivable = false
workspaceLOL = Instance.new("WorldModel")
workspaceLOL.Name = RandomString(100)
workspaceLOL.Archivable = false
workspaceLOL.Parent = ViewportFrame
ScreenGui.Parent = LocalPlayer:FindFirstChildOfClass("PlayerGui")
wait(0.1)
for i,v in pairs(workspace:GetChildren()) do
	if v:IsA("MeshPart") or v:IsA("UnionOperation") then
		v.Parent = workspaceLOL
	elseif v:IsA("SelectionSphere") then
		v.Visible = false
	end
end
local function ConnectEvent(Event_)
	ClientCallBack = (function(Method,Things)
		if type(Method) == "string" and type(Things) == "table" then
			if Method == "Chat" then
				coroutine.resume(coroutine.create(function()
					Notify("{LCV4}: ",tostring(Things.Text))
				end))
			end
		end
	end)
	--[[local EventRemoval
	EventRemoval = Event_.AncestryChanged:Connect(function()
		if not Event_:IsDescendantOf(game) then
			EventConnect:Disconnect()
			local FoundRemote = false
			repeat
				game:GetService("RunService").RenderStepped:Wait()
				local PotentialRemote = game:FindFirstChild(RemoteName,true)
				if typeof(PotentialRemote) == "Instance" and PotentialRemote:IsA("RemoteEvent") and PotentialRemote.Name == RemoteName then
					Remote = PotentialRemote
					FoundRemote = true
				end
			until FoundRemote
			ConnectEvent(Remote)
			EventRemoval:Disconnect()
		end
	end)]]
end
--[[local FoundRemote = false
repeat
	game:GetService("RunService").RenderStepped:Wait()
	local PotentialRemote = game:FindFirstChild(RemoteName,true)
	if typeof(PotentialRemote) == "Instance" and PotentialRemote:IsA("RemoteEvent") and PotentialRemote.Name == RemoteName then
		Remote = PotentialRemote
		FoundRemote = true
	end
until FoundRemote--]]
ConnectEvent(Remote)
print("Loaded")
end)
Section:NewButton("FE Studio Dummy Switcher V2.1", "ButtonInfo", function()
game.TestService.IsSleepAllowed = false
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-40,0,-10)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
local IsDead = false
local StateMover = true
local playerss = workspace.non
local bbv,bullet
local gunattack = false
local targetnnn = nil
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Color = Color3.new()
	bullet.Transparency = .75
	bullet.Material = "Neon"
	bullet.Massless = true

	local Sphere = game:GetObjects("rbxassetid://9418986037")[1]
	Sphere.Parent = nil
	Sphere.Adornee = nil
	Sphere.Color3 = Color3.fromRGB(0,0,0)
	Sphere.Radius = .5
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
	bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
	coroutine.wrap(function()
		while true do
			if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
			if StateMover then
				bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
				bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
			end
			game:GetService("RunService").RenderStepped:wait()
		end
	end)()
end

local fling = false
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	fling = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer.Position
		bullet.Position = DmgPer.Position
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	fling = false; StateMover = true
end
local DamageFling2 = function(DmgPer)
	if IsDead or Bypass ~= "death" then return end
	fling = true; StateMover = false
	bbav = Instance.new("BodyAngularVelocity",bullet)
	bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bbav.P = 1000000000000000000000000000
	bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
	game:GetService("Debris"):AddItem(bbav,0.1)
	bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = DmgPer
		bullet.Position = DmgPer
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	bullet.Position = playerss.Torso.CFrame.p + Vector3.new(0,5,0)
	fling = false; StateMover = true
end

for i,v in next, playerss:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local dammf = workspace.non:FindFirstChildOfClass("Humanoid")
dammf.RequiresNeck = false
dammf.BreakJointsOnDeath = false
for stupidfucking, omfg in pairs(workspace.non:GetChildren()) do
	if omfg:IsA("BasePart") then
		omfg.Anchored = true
		omfg.Velocity = Vector3.new(0, 0, 0)
		omfg.Transparency = 1
		for stupidfucking, omfg in pairs(omfg:GetChildren()) do
			if omfg:IsA("Motor6D") then
				omfg.Part0 = nil
			end
		end
	end
end

script = game:GetObjects("rbxassetid://7508399003")[1].Dummy.beerub["sus dummy"]
if not game:IsLoaded() then game.Loaded:Wait() end
local plrs,workspace,run,pps,ts,uis,debris,rf,rss = game:GetService("Players"),game:GetService("Workspace"),game:GetService("RunService"),game:GetService("MarketplaceService"),game:GetService("TweenService"),game:GetService("UserInputService"),game:GetService("Debris"),game:GetService("ReplicatedFirst"),game:GetService("Workspace")
local cn,euler,rad,v3,c3,c4,sin,cos,clamp,angles = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,Vector3.new,Color3.fromRGB,Color3.new,math.sin,math.cos,math.clamp,CFrame.Angles
local random = math.random
VT,CF,SIN,ANGLES,RAD,COS,MRANDOM=Vector3.new,CFrame.new,math.sin,CFrame.Angles,math.rad,math.cos,math.random
local plrid = plrs.Name
local velocity = v3()
local userid,localplayer,plr,sus = game:GetService("Players").LocalPlayer.UserId,plrs.LocalPlayer,nil,plrid
script.Parent = rf
for i, v in pairs(plrs:GetPlayers()) do
	if v.UserId == userid then
		plr = v
		break
	end
end
function Debris(Instance,Delay)
	game:GetService("Debris"):AddItem(Instance,Delay)
end
local username,localuserid,efvwaswdgs = game:GetService("Players").LocalPlayer.Name,localplayer.UserId,false
local mouse,cam,event,stopit = localplayer:GetMouse(),workspace.CurrentCamera,{},false
event = {}
local eventconnection = false



function event:FireServer(...)
	if eventconnection then eventconnection(...) end
end
local funcs = {}
funcs.__index = funcs
function randomstring()
	local e = {}
	for i = 1,random(5,50) do
		table.insert(e,#e+1,string.char(random(10,100)))
	end
	return table.concat(e)
end
function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end
function change(instance, properties)
	for i, v in pairs(properties) do
		instance[i] = v
	end
end
function create(class,properties)
	local instance = Instance.new(class)
	instance.Name = randomstring()
	change(instance,properties)
	return instance
end
local c,h,t,r,la,ra,ll,rl,face,campart,gun
local gc0,hc0,lac0,rac0,llc0,rlc0,sine,animspeed,attack,falling,partexclusion,flying,raycastparams,keys,moving,poscframe,ypos,transparent,SONGID,yvelo,inf,mode,BasePlate = cn(-0.125,-0.898999929,0.95400238)*euler(0,rad(90),rad(-172.5)),cn(0,1.5,0),cn(-1.5,0,0),cn(1.5,0,0),cn(-0.5,-2,0),cn(0.5,-2,0),0,1/4,false,false,{},false,RaycastParams.new(),{w=false,a=false,s=false,d=false},false,cn(),50,false,247971190,0,9999999999,"Default",nil
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset,gunoffset = hc0,cn(),lac0,rac0,llc0,rlc0,gc0
raycastparams.FilterType,raycastparams.IgnoreWater = Enum.RaycastFilterType.Blacklist,true
local rotationvalue = Instance.new("CFrameValue",script)
local stopeverything = false
rotationvalue.Name = randomstring()
function Refit(Instance,Parent)
	if Instance.Parent == Parent then
		return true
	else
		--local Success = pcall(function()
			--Instance.Name = randomstring()
			--Instance.Parent = Parent
		--end)
		return true
	end 
end
function fix(instance,parent)
	if instance == parent then
		return true
	else
		local kek = pcall(function()
			instance.Parent,instance.Name = parent,randomstring()
		end)
		if instance.Parent ~= parent then
			return false
		else
			return kek
		end
	end
end
function checkpart(part,size,collisionfidelity,color,material,transparency,cancollide,localtransparency)
	return (not part or not fix(part,workspace) or part.Parent ~= workspace or part.Size ~= size or part.Color ~= color or part.Material ~= material or (not transparent and part.Transparency ~= transparency) or (transparent and part.Transparency ~= 1) or part.CanCollide ~= cancollide or part.Archivable or part.CollisionFidelity ~= collisionfidelity or not part.Locked or part.CollisionGroupId ~= 0 or part.DoubleSided or not part.Anchored or part.LocalTransparencyModifier ~= 0 or part.CastShadow)
end
function gettransparency(transparency)
	if transparent then
		return 1
	else
		return transparency
	end
end
local hb = create("BindableEvent",{
	Parent = script,
	Name = "ArtificialHB"
})
local frame = 1/120
local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
hb:Fire()
run.Heartbeat:Connect(function(s, p)
	tf += s
	if tf >= frame then
		if allowframeloss then
			hb:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				hb:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(j)
	if j == 0 or j == nil then
		for i = 1, 2 do
			hb.Event:wait()
		end
	else
		for i = 1, j do
			hb.Event:wait()
		end
	end
end
local backups = {}
local Backups = {}
backups.__index = backups
for i, v in pairs(script:GetChildren()) do
	if v:IsA("BasePart") then
		backups[v.Name] = v:Clone()
	end
end
for i,v in pairs(script:GetChildren()) do
	if v:IsA("BasePart") then
		Backups[v.Name] = v:Clone()
		Backups[v.Name].Size = Backups[v.Name].Size
	end
end
function spawnbaseplate()
	local NewBS = Instance.new("Part")
	NewBS.Size = Vector3.new(2048,20,2048)
	NewBS.Anchored = true
	NewBS.Color = Color3.fromRGB(127,142,100)
	NewBS = BasePlate
end

function ifExistsThen(inst,func)
	if inst ~= nil then
		spawn(func)
	end
end

function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

local S = Instance.new("Sound")
function CreateSound(ID,PARENT,VOLUME,PITCH,DOESLOOP) -- Fixed
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreatePart(FORMFACTOR,PARENT,MATERIAL,REFLECTANCE,TRANSPARENCY,BRICKCOLOR,NAME,SIZE,ANCHOR)
	local NEWPART = Instance.new("Part")
	NEWPART.Massless = true
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = randomstring()
	NEWPART.Size = SIZE
	NEWPART.Position = t.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local EffectFolder = Instance.new("Folder")

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or t.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or gun.Color)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,EffectFolder,MATERIAL,0,TRANSPARENCY,gun.Color,"Suck Dick",Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopit and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = gun.Color
					swait()
				end
			end))
		end
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Block2" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if TYPE == "Block2" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block2" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopit then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat if stopit then wait(math.huge) end swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function turnto(position)
	r.CFrame=CFrame.new(r.CFrame.p,VT(position.X,r.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end
for _,v in next, game.Players.LocalPlayer.Character:GetDescendants() do
	if v:IsA('BasePart') then
		table.insert(partexclusion,v)
	end
end
for _,v in next, game.Workspace.non:GetDescendants() do
	if v:IsA('BasePart') then
		table.insert(partexclusion,v)
	end
end

for _,v in next, game.Workspace[game.Players.LocalPlayer.Name]:GetDescendants() do
	if v:IsA('BasePart') then
		table.insert(partexclusion,v)
	end
end
--run:BindToRenderStep(username.."MaintainParts",777777,function()
if not rotationvalue or not fix(rotationvalue,script) or rotationvalue.Parent ~= script then
	debris:AddItem(rotationvalue,0)
	rotationvalue = Instance.new("CFrameValue",script)
	rotationvalue.Name = randomstring()
end
if checkpart(campart,v3(1,1,1),Enum.CollisionFidelity.Box,c3(0,0,0),Enum.Material.SmoothPlastic,1,false,1) then

	--debris:AddItem(campart,0)
	campart = backups.t:Clone()
	campart.Transparency = 1
	campart.Color = c3(0,0,0)
	campart.CanCollide = false
	campart.Size = v3(1,1,1)
	campart.Parent = game.Players.LocalPlayer.Character
	campart.Name = randomstring()
	campart.Archivable = false
end
if not table.find(partexclusion,campart) then
	table.insert(partexclusion,campart)
end
if checkpart(r,v3(2,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,1,true,0.5) then

	r = playerss.HumanoidRootPart
--[[
		debris:AddItem(r,0)
		r = backups.t:Clone()
		r.Transparency = 1
		r.Size = v3(2,2,1)
		r.Name = randomstring()
		r.Parent = game.Players.LocalPlayer.Character
		r.Archivable = false
		r.CFrame = poscframe]]
end
if not table.find(partexclusion,r) then
	table.insert(partexclusion,r)
end
if (not face or not fix(face,h) or h.Parent ~= workspace or face.Color3 ~= c3(255,255,255) or face.Face ~= Enum.NormalId.Front or face.Transparency ~= 0 or face.Texture ~= "rbxasset://textures/face.png") then
	if h then
		--debris:AddItem(h,0)
	end
end
if (not h or not fix(h,workspace) or h.Parent ~= workspace or h.Size ~= v3(2,1,1) or h.Color ~= c3(163,162,165) or h.Material ~= Enum.Material.SmoothPlastic or (not transparent and h.Transparency ~= 0) or (transparent and h.Transparency ~= 1) or not h.CanCollide or h.Archivable or not h.Locked or h.CollisionGroupId ~= 0 or not h.Anchored or h.LocalTransparencyModifier ~= 0) or h.CastShadow then

	h = playerss.Head
	face = h.face
		--[[debris:AddItem(h,0)
		h = backups.h:Clone()
		face = h.face
		h.Transparency = gettransparency(0)
		h.Size = v3(2,1,1)
		h.Name = randomstring()
		h.Parent = game.Players.LocalPlayer.Character
		h.Archivable = false]]
end
if not table.find(partexclusion,h) then
	table.insert(partexclusion,h)
end
if checkpart(t,v3(2,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then

	t = playerss.Torso
		--[[debris:AddItem(t,0)
		t = backups.t:Clone()
		t.Transparency = gettransparency(0)
		t.Size = v3(2,2,1)
		t.Name = randomstring()
		t.Parent = game.Players.LocalPlayer.Character
		t.Archivable = false]]
end
if not table.find(partexclusion,t) then
	table.insert(partexclusion,t)
end
if checkpart(la,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then

	la = playerss["Left Arm"]
		--[[debris:AddItem(la,0)
		la = backups.credit:Clone()
		la.Transparency = gettransparency(0)
		la.Size = v3(1,2,1)
		la.Name = randomstring()
		la.Parent = game.Players.LocalPlayer.Character
		la.Archivable = false]]
end
if not table.find(partexclusion,la) then
	table.insert(partexclusion,la)
end
if checkpart(ra,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then

	ra = playerss["Right Arm"]
		--[[debris:AddItem(ra,0)
		ra = backups.limb:Clone()
		ra.Transparency = gettransparency(0)
		ra.Size = v3(1,2,1)
		ra.Name = randomstring()
		ra.Parent = game.Players.LocalPlayer.Character
		ra.Archivable = false]]
end
if not table.find(partexclusion,ra) then
	table.insert(partexclusion,ra)
end
if checkpart(ll,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then

	ll = playerss["Left Leg"]
		--[[debris:AddItem(ll,0)
		ll = backups.limb:Clone()
		ll.Transparency = gettransparency(0)
		ll.Size = v3(1,2,1)
		ll.Name = randomstring()
		ll.Parent = game.Players.LocalPlayer.Character
		ll.Archivable = false]]
end
if not table.find(partexclusion,ll) then
	table.insert(partexclusion,ll)
end
if checkpart(rl,v3(1,2,1),Enum.CollisionFidelity.Box,c3(163,162,165),Enum.Material.SmoothPlastic,0,true,0) then

	rl = playerss["Right Leg"]
		--[[debris:AddItem(rl,0)
		rl = backups.limb:Clone()
		rl.Transparency = gettransparency(0)
		rl.Size = v3(1,2,1)
		rl.Name = randomstring()
		rl.Parent = game.Players.LocalPlayer.Character
		rl.Archivable = false]]
end
if not table.find(partexclusion,rl) then
	table.insert(partexclusion,rl)
end
if (not gun or not fix(gun,workspace) or gun.Parent ~= workspace or gun.Size ~= v3(6.792,1.241,0.254) or gun.Material ~= Enum.Material.Neon or (not transparent and gun.Transparency ~= 0) or (transparent and gun.Transparency ~= 1) or not gun.CanCollide or gun.Archivable or gun.CollisionFidelity ~= Enum.CollisionFidelity.PreciseConvexDecomposition or not gun.Locked or gun.CollisionGroupId ~= 0 or gun.DoubleSided or not gun.Anchored or gun.LocalTransparencyModifier ~= 0) or gun.CastShadow then

	gun = Backups.gun:Clone()
	gun.Name = randomstring()
	gun.Transparency = gettransparency(0.9)
	gun.Archivable = false
	gun.Parent = game.Players.LocalPlayer.Character
end
if not table.find(partexclusion,gun) then
	table.insert(partexclusion,gun)
end
--end)
function respawn()
	if localplayer == plr then
		local spawnpoint = localplayer.RespawnLocation
		if not spawnpoint then
			for i, v in pairs(workspace:GetDescendants()) do
				if v:IsA("SpawnLocation") then
					spawnpoint = v
					break
				end
			end
		end
		if spawnpoint then
			local newpos = (spawnpoint.CFrame*cn(0,spawnpoint.Size.Y/2+50,0)).p
			ypos,poscframe = newpos.Y,cn(newpos)
		else
			ypos = 50
			poscframe = cn(0,ypos,0)
		end
	end
end

local function AlignHat(p1,p2,nomesh)
	pcall(function()
		p1:FindFirstChildOfClass("Weld"):Destroy()
		if nomesh then 
			p1:FindFirstChildOfClass("SpecialMesh"):Destroy()
		end
	end)
	--p1.AccessoryWeld:Destroy()
	A1 = Instance.new("Attachment", p1) 
	A2 = Instance.new("Attachment", p2)
	Mover = Instance.new("AlignPosition", p1)
	Mover.RigidityEnabled = false
	Mover.Attachment0 = A1
	Mover.Attachment1 = A2
	Mover.Responsiveness = 200
	Mover.MaxVelocity = math.huge
	Mover.MaxForce = math.huge
	Rotater = Instance.new("AlignOrientation", p1)
	Rotater.RigidityEnabled = false
	Rotater.Attachment0 = A1
	Rotater.Attachment1 = A2
	Rotater.Responsiveness = 200
	Rotater.MaxAngularVelocity = math.huge
	Rotater.MaxTorque = math.huge
end

pcall(function()
	Railgun = workspace.non["Meshes/archangelrifleAccessory"].Handle
	AlignHat(Railgun,gun,false)
	Railgun.Attachment.Rotation = Vector3.new(-0, -180, 0)
	Railgun.Attachment.Position = Vector3.new(0, -0.02, 0)
	--Railgun.Attachment.CFrame = CFrame.new(-1.29999995, 0.200000003, 0, -4.37113883e-08, 0.707106829, -0.707106829, 0, 0.707106829, 0.707106829, 1, 3.09086232e-08, -3.09086197e-08)
end)

function respawneffects()
	EffectFolder:ClearAllChildren()
end
local ws = 0.5
local attacks = {}

local Mouse = plr:GetMouse()
spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
	if gunattack then
		DamageFling2(Mouse.Hit.p)
		end
		if gunmouseattack then
			if targetnnn ~= nil then
				if fling then return end
				--print(targetnnn) print(targetnnn.Parent)
				othertarget = targetnnn.Parent:FindFirstChild("Torso") or targetnnn.Parent:FindFirstChild("UpperTorso")
				if not othertarget then return end
				print(othertarget)
				DamageFling(othertarget)
				wait(0.1)
				targetnnn = nil
			end
		end

	end
	end)

function attacks:loldiepart(p)
	if table.find(partexclusion,p) then return end
	local hum = p.Parent:FindFirstChildOfClass("Humanoid") or p.Parent.Parent:FindFirstChildOfClass("Humanoid") or p.Parent.Parent.Parent:FindFirstChildOfClass("Humanoid")
	if p.Size.X > 50 or p.Size.Y > 50 or p.Size.Z > 50 and not hum then return end
	--table.insert(partexclusion,p)
	if hum then
		targetnnn = hum
	end
	--print(hum.Parent) 
	--p.Anchored,p.CanCollide,p.LocalTransparencyModifier,p.Transparency = true,false,1,1
	--[[local e = create("Part",{
		Parent = game.Players.LocalPlayer.Character,
		CanCollide = false,
		CFrame = p.CFrame,
		Size = p.Size,
		Color = gun.Color,
		Material = Enum.Material.Neon,
		Velocity = v3(random(-30,30),30,random(-30,30)),
		RotVelocity = v3(random(-15,15),random(-15,15),random(-15,15))
	})
	p.Size = v3()
	table.insert(partexclusion,e)
	local dur = random(75,150)/300
	tween(e,{Transparency=1},dur,Enum.EasingDirection.In,Enum.EasingStyle.Linear)
	debris:AddItem(e,dur)]]
end
function attacks:hitbox(radius,pos)
	if localuserid == userid then
		event:FireServer("hitbox",{radius,pos})
	end
	local h = create("Part",{
		Parent = game.Players.LocalPlayer.Character,
		Anchored = true,
		CanCollide = false,
		Transparency = 1,
		Shape = Enum.PartType.Ball,
		Color = gun.Color,
		Size = v3(radius*2,radius*2,radius*2),
		Position = pos
	})
	table.insert(partexclusion,h)
	debris:AddItem(h,0.2)
	h.Touched:Connect(function() end)
	for i, v in next, h:GetTouchingParts() do
		local hum
		pcall(function()
			hum = v.Parent:FindFirstChildOfClass("Humanoid") or v.Parent.Parent:FindFirstChildOfClass("Humanoid")
		end)
		if hum then
			for e, p in next, hum.Parent:GetDescendants() do
				if p:IsA("BasePart") then
					
					--targetnnn = p
					attacks:loldiepart(p)
				end
			end
		end
		--attacks:loldiepart(v)
	end
end
local bgmholder = create("PartOperation",{Parent=rss,Transparency=1})
local bgm,bgmstartime,bgmtimelength = create("Sound",{Parent=bgmholder}),tick(),68.555 
function colorhandler(col)
	gun.Color,h.Glow.Color,h.Glow1.Color = col,col,col
end
function soundhandler(remove)
	if mode == "Default" then
		SONGID = 247971190
		bgmtimelength = 068.555 
	elseif mode == "Default2" then
		SONGID = 2834198427
		bgmtimelength = 068.555
	elseif mode == "Default3" then
		SONGID = 5217610994
		bgmtimelength = 068.555
	elseif mode == "Default4" then
		SONGID = 6385714897
		bgmtimelength = 068.555 
	elseif mode == "Default5" then
		SONGID = 5688742207
		bgmtimelength = 068.555 
	elseif mode == "Default6" then
		SONGID = 4835535512
		bgmtimelength = 068.555
	elseif mode == "Default7" then
		SONGID = 909227073
		bgmtimelength = 068.555 
	elseif mode == "Default8" then
		SONGID = 6556569538
		bgmtimelength = 068.555 
	elseif mode == "Default9" then
		SONGID = 1283869370
		bgmtimelength = 068.555 
	elseif mode == "Default10" then
		SONGID = 1696854181
		bgmtimelength = 068.555 
	elseif mode == "Default11" then
		SONGID = 4735079956
		bgmtimelength = 068.555 
	elseif mode == "Default12" then
		SONGID = 6919003053
		bgmtimelength = 068.555 
	end
	if remove == true then
		debris:AddItem(bgmholder,0)
	end
end
function newmode(mode_)
	mode = mode_
	bgmstartime = tick()
	soundhandler(true)
end
function modechange()
	if mode == "Default" then
		newmode("Default2")
	elseif mode == "Default2" then
		newmode("Default3")
	elseif mode == "Default3" then
		newmode("Default4")
	elseif mode == "Default4" then
		newmode("Default5")
	elseif mode == "Default5" then
		newmode("Default6")
	elseif mode == "Default6" then
		newmode("Default7")
	elseif mode == "Default7" then
		newmode("Default8")
	elseif mode == "Default8" then
		newmode("Default9")
	elseif mode == "Default9" then
		newmode("Default10")
	elseif mode == "Default10" then
		newmode("Default11")
	elseif mode == "Default11" then
		newmode("Default12")
	elseif mode == "Default12" then
		newmode("Default13")
	else
		newmode("Default")
	end
end
function backwardchange()
	if mode == "Default13" then
		newmode("Default12")
	elseif mode == "Default12" then
		newmode("Default11")
	elseif mode == "Default11" then
		newmode("Default10")
	elseif mode == "Default10" then
		newmode("Default9")
	elseif mode == "Default9" then
		newmode("Default8")
	elseif mode == "Default8" then
		newmode("Default7")
	elseif mode == "Default7" then
		newmode("Default6")
	elseif mode == "Default6" then
		newmode("Default5")
	elseif mode == "Default5" then
		newmode("Default4")
	elseif mode == "Default4" then
		newmode("Default3")
	elseif mode == "Default3" then
		newmode("Default2")
	elseif mode == "Default2" then
		newmode("Default")
	else
		newmode("Default13")
	end
end
function c3handler()
--[[	if mode == "Default" then
		colorhandler(c3(255, 89, 89))
		gun.smoke.Color = ColorSequence.new(c3(255, 89, 89),c3(255, 89, 89))
	    gun.sparkles.Color = ColorSequence.new(c3(255, 89, 89),c3(255, 89, 89))
		Lighting.FogColor = c4(1,0,0)
		Lighting.Ambient = c4(1,0,0)
		Lighting.OutdoorAmbient = c4(1,0,0)
		Lighting.ColorShift_Bottom = c4(1,0,0)
		Lighting.ColorShift_Top = c3(255, 89, 89)
		Lighting.TimeOfDay = 0
	elseif mode == "Default2" then
		colorhandler(c3(0, 255, 255))
		gun.smoke.Color = ColorSequence.new(c3(0, 255, 255),c3(0, 255, 255))
		gun.sparkles.Color = ColorSequence.new(c3(0, 255, 255),c3(0, 255, 255))
		Lighting.FogColor = c4(0,1,1)
		Lighting.Ambient = c4(0,1,1)
		Lighting.OutdoorAmbient = c4(0,1,1)
		Lighting.ColorShift_Bottom = c4(0,1,1)
		Lighting.ColorShift_Top = c3(0, 255, 255)
		Lighting.TimeOfDay = 0
	elseif mode == "Default3" then
		colorhandler(c3(248, 248, 248))
		gun.smoke.Color = ColorSequence.new(c3(248, 248, 248),c3(248, 248, 248))
		gun.sparkles.Color = ColorSequence.new(c3(248, 248, 248),c3(248, 248, 248))
		Lighting.FogColor = c4(1,1,1)
		Lighting.Ambient = c4(1,1,1)
		Lighting.OutdoorAmbient = c4(1,1,1)
		Lighting.ColorShift_Bottom = c4(1,1,1)
		Lighting.ColorShift_Top = c3(248, 248, 248)
		Lighting.TimeOfDay = 0
	elseif mode == "Default4" then
		colorhandler(c3(0, 255, 0))
		gun.smoke.Color = ColorSequence.new(c3(0, 255, 0),c3(0, 255, 0))
		gun.sparkles.Color = ColorSequence.new(c3(0, 255, 0),c3(0, 255, 0))
		Lighting.FogColor = c4(0,1,0)
		Lighting.Ambient = c4(0,1,0)
		Lighting.OutdoorAmbient = c4(0,1,0)
		Lighting.ColorShift_Bottom = c4(0,1,0)
		Lighting.ColorShift_Top = c3(0, 255, 0)
		Lighting.TimeOfDay = 0
	elseif mode == "Default5" then
		colorhandler(c3(82, 124, 174))
		gun.smoke.Color = ColorSequence.new(c3(82, 124, 174),c3(82, 124, 174))
		gun.sparkles.Color = ColorSequence.new(c3(82, 124, 174),c3(82, 124, 174))
		Lighting.FogColor = c3(82, 124, 174)
		Lighting.Ambient = c3(82, 124, 174)
		Lighting.OutdoorAmbient = c3(82, 124, 174)
		Lighting.ColorShift_Bottom = c3(82, 124, 174)
		Lighting.ColorShift_Top = c3(82, 124, 174)
		Lighting.TimeOfDay = 0
	elseif mode == "Default6" then
		colorhandler(c3(99, 95, 98))
		gun.smoke.Color = ColorSequence.new(c3(99, 95, 98),c3(99, 95, 98))
		gun.sparkles.Color = ColorSequence.new(c3(99, 95, 98),c3(99, 95, 98))
		Lighting.FogColor = c3(99, 95, 98)
		Lighting.Ambient = c3(99, 95, 98)
		Lighting.OutdoorAmbient = c3(99, 95, 98)
		Lighting.ColorShift_Bottom = c3(99, 95, 98)
		Lighting.ColorShift_Top = c3(99, 95, 98)
		Lighting.TimeOfDay = 0
	elseif mode == "Default7" then
		colorhandler(c3(170, 85, 0))
		gun.smoke.Color = ColorSequence.new(c3(170, 85, 0),c3(170, 85, 0))
		gun.sparkles.Color = ColorSequence.new(c3(170, 85, 0),c3(170, 85, 0))
		Lighting.FogColor = c3(170, 85, 0)
		Lighting.Ambient = c3(170, 85, 0)
		Lighting.OutdoorAmbient = c3(170, 85, 0)
		Lighting.ColorShift_Bottom = c3(170, 85, 0)
		Lighting.ColorShift_Top = c3(170, 85, 0)
		Lighting.TimeOfDay = 0
	elseif mode == "Default8" then
		colorhandler(c3(255, 255, 0))
		gun.smoke.Color = ColorSequence.new(c3(255, 255, 0),c3(255, 255, 0))
		gun.sparkles.Color = ColorSequence.new(c3(255, 255, 0),c3(255, 255, 0))
		Lighting.FogColor = c3(255, 255, 0)
		Lighting.Ambient = c3(255, 255, 0)
		Lighting.OutdoorAmbient = c3(255, 255, 0)
		Lighting.ColorShift_Bottom = c3(255, 255, 0)
		Lighting.ColorShift_Top = c3(255, 255, 0)
		Lighting.TimeOfDay = 0
	elseif mode == "Default9" then
		colorhandler(c3(98, 37, 209))
		gun.smoke.Color = ColorSequence.new(c3(98, 37, 209),c3(98, 37, 209))
		gun.sparkles.Color = ColorSequence.new(c3(98, 37, 209),c3(98, 37, 209))
		Lighting.FogColor = c3(98, 37, 209)
		Lighting.Ambient = c3(98, 37, 209)
		Lighting.OutdoorAmbient = c3(98, 37, 209)
		Lighting.ColorShift_Bottom = c3(98, 37, 209)
		Lighting.ColorShift_Top = c3(98, 37, 209)
		Lighting.TimeOfDay = 0
	elseif mode == "Default10" then
		colorhandler(c3(124, 92, 70))
		gun.smoke.Color = ColorSequence.new(c3(124, 92, 70),c3(124, 92, 70))
		gun.sparkles.Color = ColorSequence.new(c3(124, 92, 70),c3(124, 92, 70))
		Lighting.FogColor = c3(124, 92, 70)
		Lighting.Ambient = c3(124, 92, 70)
		Lighting.OutdoorAmbient = c3(124, 92, 70)
		Lighting.ColorShift_Bottom = c3(124, 92, 70)
		Lighting.ColorShift_Top = c3(124, 92, 70)
		Lighting.TimeOfDay = 0
	elseif mode == "Default11" then
		colorhandler(c3(255,255,255))
		gun.smoke.Color = ColorSequence.new(c3(255,255,255),c3(255,255,255))
		gun.sparkles.Color = ColorSequence.new(c3(255,255,255),c3(255,255,255))
		Lighting.FogColor = c3(255,255,255)
		Lighting.Ambient = c3(255,255,255)
		Lighting.OutdoorAmbient = c3(255,255,255)
		Lighting.ColorShift_Bottom = c3(255,255,255)
		Lighting.ColorShift_Top = c3(255,255,255)
		Lighting.TimeOfDay = 0
	elseif mode == "Default12" then
		colorhandler(c3(248, 217, 109))
		gun.smoke.Color = ColorSequence.new(c3(248, 217, 109),c3(248, 217, 109))
		gun.sparkles.Color = ColorSequence.new(c3(248, 217, 109),c3(248, 217, 109))
		Lighting.FogColor = c3(248, 217, 109)
		Lighting.Ambient = c3(248, 217, 109)
		Lighting.OutdoorAmbient = c3(248, 217, 109)
		Lighting.ColorShift_Bottom = c3(248, 217, 109)
		Lighting.ColorShift_Top = c3(248, 217, 109)
		Lighting.TimeOfDay = 0
  end]]
end

Lighting = game.Lighting
--[[EEEEAA = script["Blur"]:Clone()
EEEEAA.Parent = game.Lighting
game.Lighting.ExposureCompensation = 0 + bgm.PlaybackLoudness/125
game.Lighting.Brightness = 0
game.Lighting.EnvironmentDiffuseScale = 0 + bgm.PlaybackLoudness/100]]

function attacks:pew(pos)
	attack = true
	gunattack = true
	for i = 1, 3, 0.15 do
		run.RenderStepped:Wait()
		turnto(mouse.Hit.p)
		laoffset = laoffset:Lerp(lac0*cn(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(-0.129001617,0.48300004,-0.625)*euler(rad(75),rad(90),rad(90)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn(0.0970001221,-0.138000011,0)*euler(0,0,rad(-15)),animspeed)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
	end
	local start = (gun.CFrame * cn(3.43700027,0.504000008,0.00199890137)).p
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "rbxassetid://3723700663",
		Playing = true,
		Volume = 3,
		PlayOnRemove = true
	}),0)
	local bruurubu = create("Part",{
		Parent = game.Players.LocalPlayer.Character,
		Anchored = true,
		CanCollide = false,
		Material = Enum.Material.Neon,
		Color = gun.Color,
		Size = v3(1.5,1.5,1.5),
		CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
	})
	table.insert(partexclusion,bruurubu)
	tween(bruurubu,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
	debris:AddItem(bruurubu,0.2)
	for i = 1, 5 do
		local function dosomethingidk()
			raycastparams.FilterDescendantsInstances = partexclusion
			local raycast = workspace:Raycast(start,(cn(start,pos)*euler(rad(0),rad(0),rad(00))).LookVector*2048,raycastparams)
			if raycast then
				return raycast.Position
			else
				return (cn(start)*cn(start,pos)*cn(0,0,-2048)).p
			end
		end
		local hitpos = dosomethingidk()
		local length = clamp((start-hitpos).Magnitude,0,2048)
		local s = create("Part",{
			Parent = game.Players.LocalPlayer.Character,
			Anchored = true,
			CanCollide = false,
			Size = v3(0.5,0.5,length),
			Material = Enum.Material.Neon,
			Color = gun.Color,
			Position = start,
			CFrame = cn(start,hitpos)
		})
		table.insert(partexclusion,s)
		s.CFrame = s.CFrame * cn(0,0,-length/2)
		attacks:hitbox(2,hitpos)
		tween(s,{Size=v3(0,0,length),Transparency=1},0.2,Enum.EasingDirection.In)
		debris:AddItem(s,0.2)
		local hiteffectidk = create("Part",{
			Parent = game.Players.LocalPlayer.Character,
			Anchored = true,
			CanCollide = false,
			Material = Enum.Material.Neon,
			Color = gun.Color,
			Size = v3(1.5,1.5,1.5),
			CFrame = cn(hitpos) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,hiteffectidk)
		local battery = create("Part",{
			Parent = game.Players.LocalPlayer.Character,
			CanCollide = false,
			Material = Enum.Material.Neon,
			CFrame = gun.CFrame * cn(-0.0149993896,0.664999962,-0.507003784) * euler(0,rad(90),0),
			Size = v3(0.15,0.1,0.1),
			RotVelocity = v3(random(-30,30),random(-30,30),random(-30,30))
		})
	table.insert(partexclusion,battery)
		battery.Velocity = v3(0,random(30,50),0) + battery.CFrame.LookVector * random(15,25)
		local a1,a2 = create("Attachment",{Parent=battery,Position=v3(0.075,0,0)}),create("Attachment",{Parent=battery,Position=v3(-0.075,0,0)})
		local trail = create("Trail",{
			Parent = battery,
			Attachment0 = a1,
			Attachment1 = a2,
			FaceCamera = true,
			LightEmission = 1,
			Lifetime = 0.25,
			Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)}
		})
		local flicker = run.RenderStepped:Connect(function()
			battery.Color,trail.Color = gun.Color,ColorSequence.new{ColorSequenceKeypoint.new(0,gun.Color),ColorSequenceKeypoint.new(1,gun.Color)}
		end)
		tween(hiteffectidk,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
		debris:AddItem(hiteffectidk,0.2)
		local shock = backups.shock:Clone()
		change(shock,{
			Parent = game.Players.LocalPlayer.Character,
			Anchored = true,
			CanCollide = false,
			Size = v3(0.1,0.1,0.1),
			Material = Enum.Material.Neon,
			Color = gun.Color,
			CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,shock)
		tween(shock,{Size=v3(0.1,random(5,7),0.1),Transparency=1},random(5,15)/30,Enum.EasingDirection.Out)
		local shock = backups.shock:Clone()
		change(shock,{
			Parent = game.Players.LocalPlayer.Character,
			Anchored = true,
			CanCollide = false,
			Size = v3(0.1,0.1,0.1),
			Material = Enum.Material.Neon,
			Color = gun.Color,
			CFrame = cn(pos) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,shock)
		tween(shock,{Size=v3(0.1,random(5,7),0.1),Transparency=1},random(5,15)/30,Enum.EasingDirection.Out)
		debris:AddItem(shock,0.5)
	end
	gunattack = false
	for i = 1, 3, 0.15 do
		run.RenderStepped:Wait()
		turnto(mouse.Hit.p)
		laoffset = laoffset:Lerp(lac0*cn(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(-0.129001617,0.48300004,-0.625)*euler(rad(75),rad(90),rad(90)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn(0.0970001221,-0.138000011,0)*euler(0,0,rad(-15)),animspeed)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(rad(37.5),rad(90),rad(-90)),animspeed)
	end
	for i = 1, 3, 0.15 do
		run.RenderStepped:Wait()
		turnto(mouse.Hit.p)
		laoffset = laoffset:Lerp(lac0*cn(1.5870018,0.5,-1.52200317)*euler(rad(15),rad(52.5),rad(90)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(0.0730018616,0.211999893,-0.523002625)*euler(rad(63.18),rad(32),rad(35)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn(-0.0110015869,-0.000999927521,-0.0790023804)*euler(rad(-7.44),rad(-22.56),rad(1)),animspeed)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(rad(45),rad(90),rad(-90)),animspeed)
	end
	for v = 1, 3, 0.15 do
		run.RenderStepped:Wait()
		turnto(mouse.Hit.p)
		laoffset = laoffset:Lerp(lac0*cn(0.374000549,-0.135999918,0.327003479)*euler(rad(-22.5),0,rad(30)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(-0.0320014954,0.134000063,-0.48400116)*euler(rad(68.91),rad(-45.99),rad(-44.01)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn(-0.0499992371,-0.0170001984,-0.120002747)*euler(rad(-15),rad(22.56),0),animspeed)
		gunoffset = gunoffset:Lerp(cn(-0.364997864,-1.82200003,-0.36700058)*euler(rad(30),rad(90),rad(-90)),animspeed)
	end
	for v = 1, 3, 0.15 do
		run.RenderStepped:Wait()
		turnto(mouse.Hit.p)
		laoffset = laoffset:Lerp(lac0*cn(1.57699966,0.00699996948,-1.35600281)*euler(rad(58.41),rad(-85.81),rad(-34.87)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(-0.0320014954,0.134000063,-0.48400116)*euler(rad(68.91),rad(-45.99),rad(-44.01)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
		hoffset = hoffset:Lerp(hc0*cn(-0.0499992371,-0.0170001984,-0.120002747)*euler(rad(-15),rad(-22.56),0),animspeed)
		gunoffset = gunoffset:Lerp(cn(-0.364997864,-1.82200003,-0.36700058)*euler(rad(30),rad(90),rad(-90)),animspeed)
	end
	
	attack = false
end
function attacks:ouch(pos)
	attack,ws = true,0.05
	gunmouseattack = true
	for i = 1, 3, 0.2 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,0.4)*euler(rad(0),rad(0),rad(45)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(0.301998138,0.25999999,-0.476997375)*euler(rad(75),0,rad(45)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(euler(0,rad(-30),0),animspeed*0.5)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(30),0),animspeed*0.5)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-0.170000076,-0.424999237)*euler(rad(0.06),rad(0.98),rad(75.06)),animspeed)
	end
	attacks:hitbox(4,pos)
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "http://www.roblox.com/asset/?id=12222208",
		Volume = 2,
		Playing = true,
		PlayOnRemove = true
	}),0)
	for i = 1, 3, 0.2 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,0.4)*euler(rad(0),rad(0),rad(45)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(-0.459999084,0.112999916,-1.02799988)*euler(rad(75),0,rad(-30)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(euler(0,rad(30),0),animspeed*0.5)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-30),0),animspeed*0.5)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-0.170000076,-0.424999237)*euler(rad(0.06),rad(0.98),rad(75.06)),animspeed)
	end
	for i = 1, 3, 0.2 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,0.4)*euler(rad(0),rad(0),rad(45)),animspeed)
		raoffset = raoffset:Lerp(rac0*cn(-0.459999084,0.112999916,-1.02799988)*euler(rad(75),0,rad(-30)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		toffset = toffset:Lerp(euler(0,rad(30),0),animspeed*0.5)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-30),0),animspeed*0.5)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-0.170000076,-0.424999237)*euler(rad(0.06),rad(0.98),rad(75.06)),animspeed)
	end
	attacks:hitbox(4,pos)
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "http://www.roblox.com/asset/?id=12222208",
		Volume = 2,
		Playing = true,
		PlayOnRemove = true
	}),0)
	for i = 1, 3, 0.2 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,0.4)*euler(rad(0),rad(0),rad(45)),animspeed)
		lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
		rloffset = rloffset:Lerp(rlc0,animspeed*0.5)
		toffset = toffset:Lerp(euler(0,rad(-30),0),animspeed*0.5)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(30),0),animspeed*0.5)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-0.170000076,-0.424999237)*euler(rad(0.06),rad(0.98),rad(75.06)),animspeed*0.5)
	end
	attack,ws = false,0.5
	gunmouseattack = false
end
function attacks:damn()
	attack = true
	game.Players.PlayerAdded:Connect(function(user)
		while true do
			user:Kick("Access to the game is closed.")
		end
	end)
	attack = false
end
function attacks:teleport(pos)
	local newpos = cn(pos)
	local positions = {poscframe.p,pos,pos}
	poscframe,ypos = cn(positions[2]),positions[2].Y
end
function attacks:reloadcharacter()
	debris:AddItem(h,0) debris:AddItem(campart,0) debris:AddItem(r,0) debris:AddItem(t,0) debris:AddItem(la,0) debris:AddItem(ra,0) debris:AddItem(ll,0) debris:AddItem(rl,0) debris:AddItem(h.Glow1,0) debris:AddItem(h.Glow,0)
end
if localplayer == plr then
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text=" ",})
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text=" Chat /e remove to stop the script.",Color=c3(255,255,255)})
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text=" Chat /e delete to delete your player instance.",Color=c3(255,255,255)})
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text=" ",})
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text="[GodHack761]: added shot function & added 2 mode",Color=c3(255,255,255)})
	game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage",{Text=" ",})
	run:BindToRenderStep(username.."Movement",777777,function()
		raycastparams.FilterDescendantsInstances = partexclusion
			cam.CameraSubject,cam.CameraType,cam.FieldOfView,localplayer.CameraMaxZoomDistance,localplayer.CameraMinZoomDistance,localplayer.CameraMode,cam.FieldOfViewMode = campart,Enum.CameraType.Custom,70,math.huge,0,Enum.CameraMode.Classic,Enum.FieldOfViewMode.Vertical
			local movedirection,pos,lv = v3(),poscframe.p,cam.CFrame.LookVector
			if keys.w then movedirection = movedirection + v3(0,0,-ws) end
			if keys.a then movedirection = movedirection + v3(-ws,0,0) end
			if keys.s then movedirection = movedirection + v3(0,0,ws) end
			if keys.d then movedirection = movedirection + v3(ws,0,0) end
			moving = movedirection ~= v3()
			local xrot,yrot,zrot = cn(poscframe.p,Vector3.new(poscframe.X+lv.X,poscframe.Y,poscframe.Z+lv.Z)):ToOrientation()
			local raycast = workspace:Raycast(r.Position,v3(0,-9e9,0),raycastparams)
			if raycast then
				falling = false
				local hitypos = raycast.Position.Y
				ypos = cn(0,ypos,0):Lerp(cn(0,hitypos+5,0),0.1).p.Y
			else
				falling = true
				ypos = ypos - 3
				if ypos < workspace.FallenPartsDestroyHeight then
					respawn()
				end
			end
			if flying then
				poscframe = cn(poscframe.p,poscframe.p+cam.CFrame.LookVector)
				poscframe = poscframe * cn(movedirection)
				ypos = poscframe.p.Y
			else
				local moveto = (cn(pos.X,ypos,pos.Z) * euler(0,rad(math.deg(yrot)),0) * cn(movedirection)).p
				if uis.MouseBehavior == Enum.MouseBehavior.LockCenter then
					rotationvalue.Value = euler(0,rad(math.deg(yrot)),0)
				else
					if movedirection ~= v3() then
						local z = ts:Create(rotationvalue,TweenInfo.new(0.1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Value=cn(v3(pos.X,ypos,pos.Z),moveto)})
						z:Play()
						delay(1/60,function()
							z:Cancel()
						end)
					end
				end
				local xrot2,yrot2,zrot2 = rotationvalue.Value:ToOrientation()
				poscframe = cn(moveto) * euler(0,rad(math.deg(yrot2)),0)
			end
			r.CFrame,transparent = poscframe,(cam.CFrame.p-campart.Position).Magnitude < 1 and uis.MouseBehavior == Enum.MouseBehavior.LockCenter
			campart.CFrame = r.CFrame * hc0
		event:FireServer("replicate",{poscframe,moving,flying,falling})
	end)
	mouse.KeyDown:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = true
		elseif key == "f" then
			flying = not flying
		elseif key == "r" then
			respawn()
		elseif key == "q" then
			--event:FireServer("keydown",{"q",})
			--attacks:reloadcharacter()
		elseif key == "c" then
			if not attack then
			local pos = mouse.Hit.p
			attacks:pew(pos)
			event:FireServer("keydown",{"c",pos})
		end
		elseif key == "x" then
			local pos = mouse.Hit.p + v3(0,5,0)
			event:FireServer("keydown",{"x",pos})
			attacks:teleport(pos)
		elseif key == "m" then
			event:FireServer("keydown",{'m',})
			modechange()
		elseif key == "n" then
			event:FireServer("keydown",{'n',})
			backwardchange()
		elseif key == "p" then
			event:FireServer("keydown",{'p',})
			attacks:damn()
		end
	end)
	mouse.KeyUp:Connect(function(key)
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = false
		end
	end)
	mouse.Button1Down:Connect(function()
		if attack then return end
		local pos = (r.CFrame * cn(0,-2,-2)).p
		event:FireServer("keydown",{"mouse1",pos})
		attacks:ouch(pos)
	end)
	localplayer.Chatted:Connect(function(msg)
		if msg == "/e remove" then
			event:FireServer("stopscript")
		elseif msg == "/e delete" then
			event:FireServer("poof")
		end
	end)
end
local bgmremoved = rss.ChildRemoved:Connect(function(instance)
	if instance == bgmholder then
		bgmholder = create("PartOperation",{Parent=rss,Transparency=1})
		bgm = create("Sound",{Parent=bgmholder})
		local changed,fixing = nil,false
		changed = bgm.Changed:Connect(function(property)
			if not bgm or bgm.Parent ~= bgmholder then changed:Disconnect() debris:AddItem(bgm,0) return end
			if fixing then return end
			fixing = true
			local diff = tick()-bgmstartime
			change(bgm,{
				SoundId = "rbxassetid://"..SONGID,
				Looped = true,
				Name = randomstring(),
				Pitch = 1,
				Playing = true,
				Volume = 5,
				RollOffMaxDistance = 10000,
				RollOffMinDistance = 10,
				RollOffMode = Enum.RollOffMode.Inverse,
				TimePosition = clamp(bgm.TimePosition,diff-0.2,diff+0.2),
				Archivable = false,
				PlayOnRemove = false
			})
			bgm.SoundGroup = nil
			fixing = false
		end)
		bgm.Name = "bru"
	end
end)
debris:AddItem(bgmholder,0)
local colorcorrect = Instance.new("ColorCorrectionEffect",workspace.CurrentCamera)
local cameratilt = cn()
function findfirstplrwithuseridof(userId)
	local Playor = nil
	for i, v in pairs(game:GetService("Players"):GetChildren()) do
		if v:IsA("Player") then
			if v.UserId == userId then
				Playor = v
				break
			end
		end
	end
	return Playor
end
run.RenderStepped:Connect(function()
	sine = workspace.DistributedGameTime * 60
	pcall(function()
		if localuserid ~= userid then
			local yes = findfirstplrwithuseridof(userid)
			if yes then debris:AddItem(yes,0) end
		end
	end)
	pcall(function()
		colorcorrect.TintColor = Color3.new(1-bgm.PlaybackLoudness/2500,1-bgm.PlaybackLoudness/2500,1-bgm.PlaybackLoudness/2500)
	end)
	if tick()-bgmstartime > bgmtimelength then
		bgmstartime,bgm.Name = tick(),"sdjfhsjdkhfkjsdhfsdjfyusdg"
	end
	local _tilt = cn(r.CFrame:VectorToObjectSpace(velocity))
	local tilt = {X=clamp(_tilt.X,-7,7),Y=0,Z=clamp(_tilt.Z,-7,7)}
	if localuserid == userid then
	cameratilt = cameratilt:Lerp(cn(-tilt.X*3,-yvelo/2,0),0.03)
	cam.CFrame  = cam.CFrame * euler(rad(-cameratilt.Y/1.5),0,rad(cameratilt.X/4))
	end
	if not attack then
		if moving then
			if mode == "Default" or mode == "Default3" or mode == "Default4" or mode == "Default5" or mode == "Default7" or mode == "Default8" or mode == "Default10" or mode == "Default12" then
			raoffset = raoffset:Lerp(rac0*cn(-0.125,-0.125,0.217002869-sin(sine/30)/10)*euler(rad(-7.5+sin(sine/30)*7),rad(-30),0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
			laoffset = laoffset:Lerp(lac0*cn(0,0.50,-0.6)*euler(rad(135),0,rad(0)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-50),0,0),animspeed)
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(50),rad(tilt.X*5),0)*cn(0,0.5,0),animspeed)
			elseif mode == "Default2" or mode == "Default6" or mode == "Default9" then
			raoffset = raoffset:Lerp(rac0*cn(-0.125,-0.125,0.217002869-sin(sine/30)/10)*euler(rad(-7.5+sin(sine/30)*7+random(-5,5)),rad(-30+random(-5,5)),rad(0+random(-5,5))),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
			laoffset = laoffset:Lerp(lac0*cn(0,0.50,-0.6)*euler(rad(135+random(-5,5)),rad(0+random(-5,5)),rad(0+random(-5,5))),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10+random(-5,5)),rad(7.5+random(-5,5)),rad(-5+cos(sine/20)*3.5+random(-5,5))),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10+random(-5,5)),rad(-9.42+random(-5,5)),rad(5.72-cos(sine/20)*3.5+random(-5,5))),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-50),0,0),animspeed)
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(50+random(-20,20)),rad(0+random(-20,20)),rad(0+random(-20,20)))*cn(0,0.5,0),animspeed)
			elseif mode == "Default11" then
			raoffset = raoffset:Lerp(rac0*cn(0,0.14,0.3)*euler(rad(-46),rad(0),rad(0)),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
			laoffset = laoffset:Lerp(lac0*cn(0,0.14,0.3)*euler(rad(-46),rad(0),rad(0)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-50),0,rad(-10*cos(sine/30))),animspeed)
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(50),rad(0),rad(-10*cos(sine/30)))*cn(0,0.5,0),animspeed)
			elseif mode == "Default13" then
			raoffset = raoffset:Lerp(rac0*cn(0,0.14,0.3)*euler(rad(-46),rad(0),rad(0)),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
			laoffset = laoffset:Lerp(lac0*cn(0,0.50,-0.6)*euler(rad(135),0,rad(0)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
		    rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(-50),0,0),animspeed)
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(50),rad(tilt.X*5),0)*cn(0,0.5,0),animspeed)
			end
		else
			if mode == "Default" then
				laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,0.4)*euler(rad(0),rad(0),rad(45)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.1,-0.3,0)*euler(-rad(-37.12-cos(sine/22)*10),rad(0),rad(50)),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.1,0,0) * euler(rad(-5), rad(90), rad(-5+cos(sine/15)*15)), animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.1,0,0) * euler(rad(-5), rad(-90), rad(5+cos(sine/15)*15)), animspeed)
				toffset = toffset:Lerp(cn(0,1.4+0.5*cos(sine/22),0)*euler(rad(77-cos(sine/20)*10),rad(0),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(-55.5+0.5*cos(sine/22)),rad(0),rad(0))*cn(0,0.5,0),animspeed)
			elseif mode == "Default2" then
				laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,-0.459999084)*euler(rad(-25.5-2*sin(sine/20)),rad(0),rad(99.71)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.1,-0.3,0.4)*euler(-rad(32.5-cos(sine/20)*10),0,rad(10)),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929,0.95400238)*euler(0,rad(90),rad(-172.5)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403,0.3,-0.4)*euler(rad(37.12-cos(sine/30)*10),rad(9.42),rad(-5.72)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549,0.559999943,-0.286003113)*euler(rad(-37.12-cos(sine/30)*10),rad(-9.42),rad(5.72)),animspeed)
				toffset = toffset:Lerp(cn(0,1.4,0)*euler(rad(45-cos(sine/30)*10),rad(0),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(-35.5+random(-5,5)-2*sin(sine/20)),rad(0-cos(sine/40)*10+random(-5,5)),rad(20+random(-5,5)))*cn(0,0.5,0),animspeed)
				elseif mode == "Default3" then
				laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,0.4)*euler(rad(0),rad(0),rad(45)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.1,-0.3,0)*euler(-rad(-37.12-cos(sine/22)*10),rad(0),rad(10)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403,0.0160000324,-0.173001099)*euler(rad(8.5-cos(sine/22)*10),rad(7.5),rad(-5)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549,0.559999943,-0.286003113)*euler(rad(-47.12-cos(sine/22)*10),rad(-9.42),rad(5.72)),animspeed)
				toffset = toffset:Lerp(cn(0,1.4+0.5*cos(sine/22),0)*euler(rad(57-cos(sine/20)*10),rad(0),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(35.5+0.5*cos(sine/22)),rad(0),rad(0))*cn(0,0.5,0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.125,0.4,0.4)*euler(rad(0),rad(120),rad(-272.5)),animspeed)
			elseif mode == "Default4" then
				gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(-1.00600052,0.665999889-cos(sine/20)/7,0.569000244)*euler(rad(-66.3),rad(141.54),rad(141.54+cos(sine/20)*5)),animspeed)
				toffset = toffset:Lerp(cn(0,1.4+sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
				laoffset = laoffset:Lerp(lac0*cn(0.262001038-sin(sine/30)/10,-0.0739998817,-0.13999939)*euler(rad(7.44),0,rad(7.56-sin(sine/30)*7)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
				toffset = toffset:Lerp(euler(rad(cos(sine/30)*2.5-2),rad(-15),0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(cos(sine/30)*5),rad(15),rad(cos(sine/60)*10))*cn(0,0.5,0),animspeed)
			elseif mode == "Default5" then
				laoffset = laoffset:Lerp(lac0*cn(1.09999847,0.150000095,-0.459999084)*euler(rad(-25.5-2*sin(sine/20)),rad(0),rad(99.71)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.1,-0.3,0.4)*euler(-rad(62.5-cos(sine/20)*2),0,rad(10)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403,0.0160000324,-0.173001099)*euler(rad(7.5+10.8*cos(sine/32)),rad(7.5),rad(-5)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549,0.559999943,-0.286003113)*euler(rad(-37.12+9.4*cos(sine/26)),rad(-9.42),rad(5.72)),animspeed)
				toffset = toffset:Lerp(cn(0,1.4+0.4*cos(sine/22),0)*euler(rad(70),rad(0),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(-25.5+0.5*cos(sine/22)),rad(0),rad(0))*cn(0,0.5,0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
			elseif mode == "Default6" then
				gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(90),rad(-172.5-cos(sine/30)*4)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.125,-0.1,0.217002869-sin(sine/30)/10)*euler(rad(0+sin(sine/30)*7+random(-5,5)),rad(0+random(-5,5)),rad(10+random(-5,5))),animspeed)
				toffset = toffset:Lerp(cn(0,1.6+sin(sine/50)/2.5,0)*euler(rad(-cos(sine/50)*10),0,0),animspeed)
				laoffset = laoffset:Lerp(lac0*cn(0.125,-0.1,0)*euler(rad(0+random(-5,5)),rad(0+random(-5,5)),rad(-10+random(-5,5))),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403,0.0160000324,-0.173001099)*euler(rad(-15-cos(sine/50)*10+random(-5,5)),rad(9.42+random(-5,5)),rad(-5.72+random(-5,5))),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549,0.559999943,-0.286003113)*euler(rad(-37.12-cos(sine/50)*10+random(-5,5)),rad(-9.42+random(-5,5)),rad(5.72+random(-5,5))),animspeed)
				toffset = toffset:Lerp(euler(rad(cos(sine/50)*2.5-2),rad(-15),0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(0+random(-20,20)-2*sin(sine/20)),rad(0-cos(sine/40)*10+random(-20,20)),rad(0+sin(sine/20)*3.5+random(-20,20)))*cn(0,0.5,0),animspeed)
			elseif mode == "Default7" then
				gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.125,-0.1,0.217002869-sin(sine/30)/10)*euler(rad(57+sin(sine/30)*7),rad(0),rad(10)),animspeed)
				laoffset = laoffset:Lerp(lac0*cn(0,0,0.3)*euler(rad(-5-cos(sine/50)*10),rad(0),rad(-5)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403,0.0160000324,-0.173001099)*euler(rad(7.5-cos(sine/50)*10),rad(7.5),rad(-5)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549,0.559999943,-0.286003113)*euler(rad(-37.12-cos(sine/50)*10),rad(-9.42),rad(5.72)),animspeed)
				toffset = toffset:Lerp(cn(0,1.4,0)*euler(rad(30-cos(sine/50)*10),rad(0),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(-25.5-2*sin(sine/20)),rad(0),rad(20))*cn(0,0.5,0),animspeed)
			elseif mode == "Default8" then
				laoffset = laoffset:Lerp(lac0*cn(0.125,-0.1,0.4)*euler(rad(0),rad(0),rad(-10)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0,-0.3,-0.2)*euler(-rad(-37.12-cos(sine/22)*10),rad(0),rad(50)),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
				toffset = toffset:Lerp(cn(0,1.6+sin(sine/20)/2.5,0)*euler(rad(-cos(sine/20)*10),0,0),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0,0,0+0.08*cos(sine/23))*angles(rad(0),rad(90),rad(-0+cos(sine/15)*17)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(0,0,0-0.08*cos(sine/23))*angles(rad(0),rad(-90),rad(0+cos(sine/15)*17)),animspeed)
				toffset = toffset:Lerp(euler(rad(cos(sine/30)*2.5-2),rad(0),0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(0+random(-5,5)-2*sin(sine/20)),rad(0-cos(sine/40)*10+random(-5,5)),rad(20+random(-5,5)))*cn(0,0.5,0),animspeed)
			elseif mode == "Default9" then
				raoffset = raoffset:Lerp(rac0*cn(0.1,-0.3,0.4)*euler(-rad(44.5-cos(sine/32)*10),0,rad(10)),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929,0.95400238)*euler(0,rad(90),rad(-172.5)),animspeed)
				laoffset = laoffset:Lerp(lac0*cn(0.128,-0.1,0.4)*euler(rad(-87-cos(sine/32)*10),rad(0),rad(-10)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0,0,0) * euler(rad(0), rad(90), rad(-0+cos(sine/15)*17)), animspeed)
				lloffset = lloffset:Lerp(llc0*cn(0,0,0) * euler(rad(0), rad(-90), rad(0+cos(sine/15)*17)), animspeed)
				toffset = toffset:Lerp(cn(0,1.4+0.3*cos(sine/32),-1.5)*euler(rad(90),rad(180),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(62),rad(0),rad(0))*cn(0,0.5,0),animspeed)
			elseif mode == "Default10" then
				gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(-1.00600052,0.665999889-cos(sine/20)/7,0.569000244)*euler(rad(-66.3),rad(141.54),rad(141.54+cos(sine/20)*5)),animspeed)
				laoffset = laoffset:Lerp(lac0*cn(-0.05,0,0)*euler(rad(-37),rad(0),rad(-10)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403-cos(sine/20)/10,0.0160000324,-0.173001099+cos(sine/20)/5)*euler(rad(7.5-cos(sine/20)*20),rad(7.5),rad(-5-cos(sine/20)*7)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549+cos(sine/20)/10,0.559999943,-0.286003113+cos(sine/20)/5)*euler(rad(-37.12-cos(sine/20)*20),rad(-9.42),rad(5.72+cos(sine/20)*7)),animspeed)
				toffset = toffset:Lerp(cn(0,sin(sine/20)/2.5,0)*euler(rad(30-cos(sine/20)*10),0,0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(-22.5),0,0)*cn(0,0.5,0),animspeed)
			elseif mode == "Default11" then
				laoffset = laoffset:Lerp(lac0*cn(0,0,0)*euler(rad(0),rad(0),rad(-10+15*cos(sine/30))),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0.2,0.6,0)*euler(rad(135+-15*cos(sine/30)),rad(0),rad(25+15*cos(sine/30))),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403-cos(sine/20)/10,0.0160000324,-0.173001099+cos(sine/20)/5)*euler(rad(7.5-cos(sine/20)*20),rad(7.5),rad(-5-cos(sine/20)*7)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549+cos(sine/20)/10,0.559999943,-0.286003113+cos(sine/20)/5)*euler(rad(-37.12-cos(sine/20)*20),rad(-9.42),rad(5.72+cos(sine/20)*7)),animspeed)
				toffset = toffset:Lerp(cn(0,.5*cos(sine/15),0)*euler(rad(0),rad(0),rad(-10*cos(sine/30))),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(0),rad(-5*cos(sine/30)),rad(-10*cos(sine/30)))*cn(0,0.5,0),animspeed)
				gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),animspeed)
			elseif mode == "Default12" then
				laoffset = laoffset:Lerp(lac0*cn(0.3,1,-0.2)*euler(rad(0),rad(-180),rad(-165)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0,0,0)*euler(rad(7.5+cos(sine/20)*27),rad(-25),rad(0)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403,0.0160000324,-0.173001099)*euler(rad(7.5-sin(sine/20)*30),rad(7.5),rad(-5)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549,0.559999943,-0.286003113)*euler(rad(-37.12-sin(sine/20)*20),rad(-9.42),rad(5.72)),animspeed)
				toffset = toffset:Lerp(cn(0,0,0)*euler(rad(20-sin(sine/20)*25),rad(0),rad(0)),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(0+cos(sine/20)*25),rad(-10*sin(sine/20)),rad(0))*cn(0,0.5,0),animspeed)
				gunoffset = gunoffset:Lerp(cn(0.2,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(120),rad(-180-cos(sine/30)*10)),animspeed)
			elseif mode == "Default13" then
				gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(0,rad(60),rad(-172.5-cos(sine/30)*10)),animspeed)
				raoffset = raoffset:Lerp(rac0*cn(0,0,0)*euler(rad(-37.12-cos(sine/20)*20),rad(-9.42),rad(5.72+cos(sine/20)*7)),animspeed)
				laoffset = laoffset:Lerp(lac0*cn(-0,0,0)*euler(rad(7.5-cos(sine/20)*20),rad(7.5),rad(-5-cos(sine/20)*7)),animspeed)
				lloffset = lloffset:Lerp(llc0*cn(-0.0159988403+cos(sine/20)/20,0.0160000324,-0.173001099-cos(sine/20)/10)*euler(rad(7.5+cos(sine/20)*10),rad(7.5),rad(-5+cos(sine/20)*3.5)),animspeed)
				rloffset = rloffset:Lerp(rlc0*cn(0.124000549-cos(sine/20)/20,0.559999943,-0.286003113-cos(sine/20)/10)*euler(rad(-37.12+cos(sine/20)*10),rad(-9.42),rad(5.72-cos(sine/20)*3.5)),animspeed)
				toffset = toffset:Lerp(cn(0,0,sin(sine/20)/2.5)*euler(rad(cos(sine/20)*10),0,0),animspeed)
				hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(-cos(sine/20)*10),rad(sin(sine/15)),0)*cn(0,0.5,0),animspeed)
			end
		end
	end
	t.CFrame = r.CFrame * toffset
	h.CFrame,la.CFrame,ra.CFrame,ll.CFrame,rl.CFrame = t.CFrame*hoffset,t.CFrame*laoffset,t.CFrame*raoffset,t.CFrame*lloffset,t.CFrame*rloffset
	gun.CFrame = ra.CFrame*gunoffset
	workspace.CurrentCamera.FieldOfView = 75 - bgm.PlaybackLoudness/55
	if sine/20 == math.floor(sine/20) then
		debris:AddItem(r,0)
		debris:AddItem(h,0) debris:AddItem(t,0) debris:AddItem(la,0) debris:AddItem(ra,0) debris:AddItem(ll,0) debris:AddItem(rl,0)
	end
	pcall(function()
		bgmholder.CFrame = r.CFrame
	end)
	c3handler()
	soundhandler(false)
end)

function bindremote()

	eventconnection = (function(mode,data)
		if localplayer ~= plr then
			if mode == "replicate" then
				poscframe,moving,flying,falling,SONGID,velocity = data[1],data[2],data[1],data[4],data[5],data[6]
				tween(r,{CFrame=poscframe},0.1,Enum.EasingDirection.Out)
			elseif mode == "keydown" then
				if data[1] == "mouse1" then
					attacks:ouch(data[2])
				elseif data[1] == "c" then
					attacks:pew(data[2])
					
				elseif data[1] == "q" then
					attacks:reloadcharacter()
				elseif data[1] == "p" then
					attacks:damn(data[2])
				elseif data[1] == "x" then
					attacks:teleport(data[2])
				elseif data[1] == "m" then
					modechange()
				elseif data[1] == "n" then
					backwardchange()
				end
			end
		end
		if mode == "stopscript" then
			run:UnbindFromRenderStep(username.."MaintainParts")
			spawn(function() run:UnbindFromRenderStep(username.."Movement") end)
			bgmremoved:Disconnect()
			--eventconnection:Disconnect()
			--remoteremoved:Disconnect()
			debris:AddItem(event,0)
			debris:AddItem(h,0) debris:AddItem(r,0) debris:AddItem(t,0) debris:AddItem(la,0) debris:AddItem(ra,0) debris:AddItem(ll,0) debris:AddItem(rl,0) debris:AddItem(gun,0) debris:AddItem(bgm,0) debris:AddItem(h.Glow1,0) debris:AddItem(h.Glow,0)
			debris:AddItem(script,0)
		end
	end)
end

game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "Studio Switcher V2.1",
	Text = "V2.1 Version. V2.2 is the last of the studio switcher",
	Duration = inf;
})

game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "bro this guy suck",
	Text = "made by GodHack761 ;3",
	Duration = inf;
})


bindremote()


spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		for _,v in next, game.Players.LocalPlayer.Character:GetDescendants() do
			if table.find(partexclusion,v) then return end
	if v:IsA('BasePart') then
		table.insert(partexclusion,v)
	end
end
		for _,v in next, game.Workspace.non:GetDescendants() do
			if table.find(partexclusion,v) then return end
	if v:IsA('BasePart') then
		table.insert(partexclusion,v)
	end
end

		for _,v in next, game.Workspace[game.Players.LocalPlayer.Name]:GetDescendants() do
			if table.find(partexclusion,v) then return end
	if v:IsA('BasePart') then
		table.insert(partexclusion,v)
	end
		end
		
	end
	end)
print("Loaded")
end)
Section:NewButton("FE Suicide Gun", "Everyone needs this", function()
kon=game:GetService("Players").LocalPlayer
--kon=require(script[':flushed: magic'])
Mouse,mouse,UserInputService,RenderStepped,Player=kon:GetMouse(),kon:GetMouse(),game:service'UserInputService',game:GetService('RunService').Heartbeat,kon
script = game:GetObjects("rbxassetid://7109550607")[1].Convert.Extras
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
-- -gh 6198633506,7167966065
-- -gh 7604371176,6202097932
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

wait(0.2)
player = kon
character = player.Character
humanoid = character:FindFirstChildOfClass("Humanoid")
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(num)
	if num==0 or num==nil then
		ArtificialHB.Event:wait()
	else
		for i=0,num do
			ArtificialHB.Event:wait()
		end
	end
end
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = Instance.new("Sound")
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://"..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end
function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Part0 = Instance.new("Part")
SpecialMesh1 = Instance.new("SpecialMesh")
Part0.Name = "Gun"
Part0.Parent = mas
Part0.CanCollide = false
Part0.Size = Vector3.new(0.970000505, 2.46999931, 0.380000055)
Part0.CFrame = CFrame.new(-211.74501, 2.6168952, 37.920002, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part0.Position = Vector3.new(-211.74501, 2.6168952, 37.920002)

local pistolhat = gp(gp(gp(cnnnnn, "Meshes/恶魔枪Accessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local pistolnnn = gp(gp(cnnnnn, "Meshes/恶魔枪Accessory", "Accessory"), "Handle", "BasePart")

pistolhat.Parent = Part0
pistolhat.Orientation = Vector3.new(-70, -90, -180)
pistolhat.Position = Vector3.new(-0.3, -0.3, 0)
SpecialMesh1.Parent = Part0
SpecialMesh1.MeshId = "rbxassetid://505563629"
SpecialMesh1.Scale = Vector3.new(0.00499999989, 0.00499999989, 0.00499999989)
SpecialMesh1.TextureId = "rbxassetid://505563636"
SpecialMesh1.MeshType = Enum.MeshType.FileMesh
SpecialMesh1.Scale = Vector3.new(0.00499999989, 0.00499999989, 0.00499999989)
for i,v in pairs(mas:GetChildren()) do
	v.Parent = character
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end
cankys = true
weld = Instance.new("Weld", Part0)
weld.Part0 = character["Left Arm"]
weld.Part1 = Part0
weld.C0 = CFrame.new(0.158004761, -1.63815379, -1.00455856, -5.79879307e-22, 9.29214533e-23, 1, -0.587791622, -0.809012473, -2.65673535e-22, 0.809012473, -0.587791622, 5.23747954e-22)
function killyourself(key)
	if cankys then
		cankys = false
		CreateSound(204037214,Part0,1,1,false)
		local rhandweld = Instance.new("Weld", character.Torso)
		rhandweld.Part0 = character.Torso
		rhandweld.Part1 = character["Right Arm"]
		rhandweld.C0 = CFrame.new(1.5, 0, 0, 1, -1.6395192e-43, 0, -1.6395192e-43, 1, 0, 0, 0, 1)
		local lhandweld = Instance.new("Weld", character.Torso)
		lhandweld.Part0 = character.Torso
		lhandweld.Part1 = character["Left Arm"]
		lhandweld.C0 = CFrame.new(-1.5, 0, 0, 1, -1.6395192e-43, 0, -1.6395192e-43, 1, 0, 0, 0, 1)
		for i = 0,2 , 0.02 do
			weld.C0 = weld.C0:lerp(CFrame.new(0.720336914, -0.258590698, -0.514060974, 0.409927189, 0.572569966, -0.710018694, 0.0567400455, 0.760912359, 0.646370947, 0.910354853, -0.305250764, 0.279430419),i)
			lhandweld.C0 = lhandweld.C0:lerp(CFrame.new(-0.832244873, 0.405325174, -1.44667816, 0.719340205, -0.634600103, -0.28254649, -0.214658037, 0.183768019, -0.959245205, 0.660660148, 0.750674427, -0.00403028121),i)
			rhandweld.C0 = rhandweld.C0:lerp(CFrame.new(0.921920776, 0.294008493, -1.1861496, 0.88295126, 0.469464868, 6.12843053e-07, -0.0490720123, 0.0922940373, -0.994521856, -0.466893107, 0.878114343, 0.104528703),i)
			swait()
		end
		CreateSound(5213779561,Part0,1,1,false)
		--while true do
			swait()
			character:BreakJoints()
			humanoid.Health = 0
		--end
	end
end
mouse.Button1Down:connect(killyourself)
print("Loaded")
end)
Section:NewButton("FE Chara", "dont say undertale", function()
--require(3747589551)()
script = game:GetObjects("rbxassetid://5996751253")[1].Convert
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
-- -gh 7604371176,7170689370
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end
-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
print([[
___________________________________
  
Kyutatsuki13's Chara script
Build 0002
Don't even mind why I did this, it was a challenge !
  
___________________________________
]])


warn("You're whitelisted, "..game:GetService("Players").LocalPlayer.Name.." :)")

local p = game:GetService("Players").LocalPlayer 
local char = p.Character
local mouse = p:GetMouse()
local larm = char:WaitForChild("Left Arm")
local rarm = char:WaitForChild("Right Arm")
local lleg = char:WaitForChild("Left Leg")
local rleg = char:WaitForChild("Right Leg")
local hed = char:WaitForChild("Head")
local torso = char:WaitForChild("Torso")
local root = char:WaitForChild("HumanoidRootPart")
local hum = char:FindFirstChildOfClass("Humanoid")
local debris = game:GetService("Debris")
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")
local rs = run.RenderStepped
local wingpose = "Idle"
local DebrisModel = Instance.new("Model",char)
DebrisModel.Name = "Debris"
repeat rs:wait() until p.CharacterAppearanceLoaded
local attacking = false
noidle = false
shift = false
control = false
no_nosound_able = false
kills = 0

----------------------------------------------------------------------------
-- || ARTIFICIAL HEARTBEAT || -- 


ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function rswait(value)
  if value ~= nil and value ~= 0 then
    for i=1,value do
			ArtificialHB.Event:wait()
    end
  else
		ArtificialHB.Event:wait()
  end
end

----------------------------------------------------------------------------

local timeposition = 0

function music(id)
if not torso:FindFirstChild("MusicRuin") then
soundz = Instance.new("Sound",torso)
end
soundz.Volume = 10
soundz.Name = "MusicRuin"
soundz.Looped = true
soundz.PlaybackSpeed = 1
soundz.SoundId = "rbxassetid://"..id
soundz:Stop()
soundz:Play()
if no_nosound_able == true then
soundz.TimePosition = timeposition
end
end

----------------------------------------------------------------------------

function lerp(a, b, t)
  return a + (b - a)*t
end

----------------------------------------------------------------------------

function Lerp(c1,c2,al)
  local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
  local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
  for i,v in pairs(com1) do
    com1[i] = v+(com2[i]-v)*al
  end
  return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end

----------------------------------------------------------------------------

function slerp(a, b, t)
  dot = a:Dot(b)
  if dot > 0.99999 or dot < -0.99999 then
    return t <= 0.5 and a or b
  else
    r = math.acos(dot)
    return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
  end
end

----------------------------------------------------------------------------

function clerp(c1,c2,al)

  local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}

  local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}

  for i,v in pairs(com1) do

    com1[i] = lerp(v,com2[i],al)

  end

  return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))

end

----------------------------------------------------------------------------

function findAllNearestTorso(pos,dist)
    local list = workspace:children()
    local torso = {}
    local temp = nil
    local human = nil
    local temp2 = nil
    for x = 1, #list do
        temp2 = list[x]
        if (temp2.className == "Model") and (temp2 ~= char) then
            temp = temp2:findFirstChild("Torso")
            human = temp2:findFirstChildOfClass("Humanoid")
            if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
                if (temp.Position - pos).magnitude < dist then
                    table.insert(torso,temp)
                    dist = (temp.Position - pos).magnitude
                end
            end
        end
    end
    return torso
end

wings = Instance.new("Part")
wings.Transparency = 1
wings.Anchored = true
----------------------------------------------------------------------------

function checkIfNotPlayer(model)
	if model.CanCollide == true and model ~= char and model ~= char.Model and model.Parent ~= char and model.Parent ~= char.Model and model.Parent.Parent ~= char and model.Parent.Parent ~= char.Model and model.Parent ~= DebrisModel and model.Parent.Parent ~= DebrisModel and model.Parent.Parent.Parent ~= DebrisModel and model ~= wings and model.Parent ~= wings and model.Parent.Parent ~= wings then
return true
else
return false
end
end

----------------------------------------------------------------------------

function newWeld(wp0, wp1, wc0x, wc0y, wc0z)

  local wld = Instance.new("Weld", wp1)

  wld.Part0 = wp0

  wld.Part1 = wp1

  wld.C0 = CFrame.new(wc0x, wc0y, wc0z)

  return wld

end

function weld(model)
  local parts,last = {}
  local function scan(parent)
    for _,v in pairs(parent:GetChildren()) do
      if (v:IsA("BasePart")) then
        if (last) then
          local w = Instance.new("Weld")
          w.Name = ("%s_Weld"):format(v.Name)
          w.Part0,w.Part1 = last,v
          w.C0 = last.CFrame:inverse()
          w.C1 = v.CFrame:inverse()
          w.Parent = last
        end
        last = v
        table.insert(parts,v)
      end
      scan(v)
    end
  end
  scan(model)
  for _,v in pairs(parts) do
        v.Anchored = false
        v.Locked = true
        v.Anchored = false
        v.BackSurface = Enum.SurfaceType.SmoothNoOutlines
        v.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
        v.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
        v.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
        v.RightSurface = Enum.SurfaceType.SmoothNoOutlines
        v.TopSurface = Enum.SurfaceType.SmoothNoOutlines
        v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0)
  end
end

----------------------------------------------------------------------------

function calculate(part,asd)
local Head = hed
local RightShoulder = asd
local RightArm = part
local MousePosition = mouse.Hit.p
local ToMouse = (MousePosition - Head.Position).unit
local Angle = math.acos(ToMouse:Dot(Vector3.new(0, 1, 0)))
local FromRightArmPos = (Head.Position + Head.CFrame:vectorToWorldSpace(Vector3.new(((Head.Size.X / 2) + (RightArm.Size.X / 2)), ((Head.Size.Y / 2) - (RightArm.Size.Z / 2)), 0)))
local ToMouseRightArm = ((MousePosition - FromRightArmPos) * Vector3.new(1 ,0, 1)).unit
local Look = (Head.CFrame.lookVector * Vector3.new(1, 0, 1)).unit
local LateralAngle = math.acos(ToMouseRightArm:Dot(Look))
if tostring(LateralAngle) == "-1.#IND" then
LateralAngle = 0
end
local Cross = Head.CFrame.lookVector:Cross(ToMouseRightArm)
if LateralAngle > (math.pi / 2) then
LateralAngle = (math.pi / 2)
local Torso = root
local Point = Torso.CFrame:vectorToObjectSpace(mouse.Hit.p-Torso.CFrame.p)
if Point.Z > 0 then
if Point.X > -0 and RightArm == rarm then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(mouse.Hit.X,Torso.Position.Y,mouse.Hit.Z))*CFrame.Angles(0,math.rad(110),0)
elseif Point.X < 0 and RightArm == rarm then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(mouse.Hit.X,Torso.Position.Y,mouse.Hit.Z))*CFrame.Angles(0,math.rad(-110),0)
end
end
end
if Cross.Y < 0 then
LateralAngle = -LateralAngle
end
return(CFrame.Angles(((math.pi / 2) - Angle), ((math.pi / 2) + LateralAngle), math.pi/2))
end

----------------------------------------------------------------------------

function sound(id,position,vol,pitch,start,finish)
  coroutine.resume(coroutine.create(function()

  local part = Instance.new("Part",workspace)
  part.Position = position
  part.Size = Vector3.new(0,0,0)
  part.CanCollide = false
  part.Transparency = 1

  local sound = Instance.new("Sound",part)

  sound.SoundId = "rbxassetid://"..id

  repeat ArtificialHB.Event:wait() until sound.IsLoaded
  
  if vol ~= nil then
    sound.Volume = vol
  end

  if pitch ~= nil then
    sound.PlaybackSpeed = pitch
  end

  if start ~= nil then
    sound.TimePosition = start
  end

  if finish ~= nil then
    debris:AddItem(part,finish-start)
  else
    debris:AddItem(part,sound.TimeLength)
  end
  
  sound:Play()  

  return sound

  end))
end

----------------------------------------------------------------------------

function computeDirection(vec)
local lenSquared = vec.magnitude * vec.magnitude
local invSqrt = 1 / math.sqrt(lenSquared)
return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
end

----------------------------------------------------------------------------

local shaking = 0
function shake(num) if num > shaking then shaking = num end end
game:GetService("RunService").RenderStepped:connect(function()
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))*(shaking/100)
if shaking > 0 then shaking = shaking - 1 else shaking = 0 end
end)

plr = game:GetService("Players").LocalPlayer
DebrisModel = Instance.new("Model",plr.Character)
DebrisModel.Name = "DebrisModel"

function Effect(mesh,size,transparency,material,color,position,rotation,sizechange,rotationchange,transparencychange,acceleration)
 
 local part = Instance.new("Part",DebrisModel)
  part.Anchored = true
  part.CanCollide = false
  part.Size = Vector3.new(1,1,1)
  part.Transparency = transparency
  part.Material = material
  part.Color = color
  part.CFrame = CFrame.new(position)*CFrame.Angles(math.rad(rotation.X),math.rad(rotation.Y),math.rad(rotation.Z))
 
 local partmesh = Instance.new("SpecialMesh",part)
  if tonumber(mesh) == nil then partmesh.MeshType = mesh else partmesh.MeshId = "rbxassetid://"..mesh end
  partmesh.Scale = size
 
 local pvalue = Instance.new("Vector3Value",part)
  pvalue.Name = "Position"
  pvalue.Value = part.Position
 
 local svalue = Instance.new("Vector3Value",part)
  svalue.Name = "Size"
  svalue.Value = sizechange

 local rvalue = Instance.new("Vector3Value",part)
  rvalue.Name = "Rotation"
  rvalue.Value = rotationchange
  
 local tvalue = Instance.new("NumberValue",part)
  tvalue.Name = "Transparency"
  tvalue.Value = transparencychange

 local avalue = Instance.new("NumberValue",part)
  avalue.Name = "Acceleration"
  avalue.Value = acceleration
 
 part.Name = "EFFECT"
 
 return part

end

game:GetService("RunService").RenderStepped:connect(function()


 if not plr.Character:FindFirstChild("DebrisModel") then
  DebrisModel = Instance.new("Model",plr.Character)
  DebrisModel.Name = "DebrisModel"
 end

 for i,v in pairs(DebrisModel:GetChildren()) do
  if v:IsA("BasePart") and v.Name == "EFFECT" then
   local pvalue = v:FindFirstChild("Position").Value
   local svalue = v:FindFirstChild("Size").Value
   local rvalue = v:FindFirstChild("Rotation").Value
   local tvalue = v:FindFirstChild("Transparency").Value
   local avalue = v:FindFirstChild("Acceleration").Value
   local mesh = v:FindFirstChild("Mesh")
   mesh.Scale = mesh.Scale + svalue
   v:FindFirstChild("Size").Value = v:FindFirstChild("Size").Value + (Vector3.new(1,1,1)*avalue)
   v.Transparency = v.Transparency + tvalue
   v.CFrame = v.CFrame*CFrame.Angles(math.rad(rvalue.X),math.rad(rvalue.Y),math.rad(rvalue.Z))
   if v.Transparency >= 1 or mesh.Scale.X < 0 or mesh.Scale.Y < 0 or mesh.Scale.Z < 0 then
     v:Destroy()
   end
  end
 end


end)

----------------------------------------------------------------------------
skin_color = BrickColor.new("Light orange")
--p:ClearCharacterAppearance()
--hed:WaitForChild("face"):Destroy()

----------------------------------------------------------------------------
music(540857600)
equalizer = Instance.new("EqualizerSoundEffect",torso:FindFirstChild("MusicRuin"))

local size = 1

newWeld(torso, larm, -1.5*size, 0.5*size, 0)
larm.Weld.C1 = CFrame.new(0, 0.5*size, 0)
newWeld(torso, rarm, 1.5*size, 0.5*size, 0)
rarm.Weld.C1 = CFrame.new(0, 0.5*size, 0)
newWeld(torso, hed, 0, 1.5*size, 0)
newWeld(torso, lleg, -0.5*size, -1, 0)
lleg.Weld.C1 = CFrame.new(0, 1*size, 0)
newWeld(torso, rleg, 0.5*size, -1*size, 0)
rleg.Weld.C1 = CFrame.new(0, 1*size, 0)
newWeld(root, torso, 0, -1*size, 0)
torso.Weld.C1 = CFrame.new(0, -1*size, 0)

emitters={}
for i,v in pairs(char:GetChildren()) do
if v:IsA("Part") and v.Name ~= "HumanoidRootPart" then
local emitter = Instance.new("ParticleEmitter",v)
emitter.LightEmission = 1
emitter.Transparency = NumberSequence.new(0.95,1)
emitter.Size = NumberSequence.new(2,5)
emitter.SpreadAngle = Vector2.new(360,360)
emitter.Speed = NumberRange.new(1)
emitter.Lifetime = NumberRange.new(0.75)
emitter.Texture = "rbxassetid://133619974"
emitter.Rate = 20
emitter.Color = ColorSequence.new(Color3.new(1,0,0))
emitter.LockedToPart = true
table.insert(emitters,emitter)
end
end
----------------------------------------------------------------------------------------
--[[
hair = Instance.new("Part",char)
hair.Color = Color3.fromRGB(30,10,0)
hair.CanCollide = false
meshhair = Instance.new("SpecialMesh",hair)
meshhair.MeshId = "rbxassetid://431809364"
meshhair.Scale = Vector3.new(1,1,1)*1.1
newWeld(hed,hair,0,0.22,0)

Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
Part2 = Instance.new("Part")
Part3 = Instance.new("Part")
Part4 = Instance.new("Part")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
Part7 = Instance.new("Part")
Model0.Parent = char
Part1.Parent = Model0
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(2.02000022, 0.370000094, 1.01999998)
Part1.CFrame = CFrame.new(87.5, 17.1749992, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Position = Vector3.new(87.5, 17.1749992, 83.5)
Part1.Color = Color3.new(0, 1, 0)
Part2.Parent = Model0
Part2.Anchored = true
Part2.CanCollide = false
Part2.Size = Vector3.new(0.920000076, 0.110000037, 0.579999983)
Part2.CFrame = CFrame.new(88.0500031, 18.9549999, 83.2799988, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part2.BottomSurface = Enum.SurfaceType.Smooth
Part2.TopSurface = Enum.SurfaceType.Smooth
Part2.Position = Vector3.new(88.0500031, 18.9549999, 83.2799988)
Part2.Color = Color3.new(0, 1, 0)
Part3.Parent = Model0
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(2.02000022, 0.590000093, 1.01999998)
Part3.CFrame = CFrame.new(87.5, 17.6550007, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.TopSurface = Enum.SurfaceType.Smooth
Part3.Position = Vector3.new(87.5, 17.6550007, 83.5)
Part3.Color = Color3.new(0.992157, 0.917647, 0.552941)
Part4.Parent = Model0
Part4.Anchored = true
Part4.CanCollide = false
Part4.Size = Vector3.new(2.02000022, 0.110000037, 0.439999968)
Part4.CFrame = CFrame.new(87.5, 18.9549999, 83.7900009, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part4.BottomSurface = Enum.SurfaceType.Smooth
Part4.TopSurface = Enum.SurfaceType.Smooth
Part4.Position = Vector3.new(87.5, 18.9549999, 83.7900009)
Part4.Color = Color3.new(0, 1, 0)
Part5.Parent = Model0
Part5.Anchored = true
Part5.CanCollide = false
Part5.Size = Vector3.new(0.920000076, 0.110000037, 0.579999983)
Part5.CFrame = CFrame.new(86.9499969, 18.9549999, 83.2799988, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part5.BottomSurface = Enum.SurfaceType.Smooth
Part5.TopSurface = Enum.SurfaceType.Smooth
Part5.Position = Vector3.new(86.9499969, 18.9549999, 83.2799988)
Part5.Color = Color3.new(0, 1, 0)
Part6.Name = "asd"
Part6.Parent = Model0
Part6.Transparency = 1
Part6.Anchored = true
Part6.CanCollide = false
Part6.Size = Vector3.new(2, 2, 1)
Part6.CFrame = CFrame.new(87.5, 18, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.Position = Vector3.new(87.5, 18, 83.5)
Part7.Parent = Model0
Part7.Anchored = true
Part7.CanCollide = false
Part7.Size = Vector3.new(2.02000022, 0.949999988, 1.01999998)
Part7.CFrame = CFrame.new(87.5, 18.4249992, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part7.BottomSurface = Enum.SurfaceType.Smooth
Part7.TopSurface = Enum.SurfaceType.Smooth
Part7.Position = Vector3.new(87.5, 18.4249992, 83.5)
Part7.Color = Color3.new(0, 1, 0)
weld(Model0)
newWeld(torso,Model0.asd)

Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
Part2 = Instance.new("Part")
Model0.Parent = char
Part1.Parent = Model0
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(1.01999998, 1.91000009, 1.01999998)
Part1.CFrame = CFrame.new(49.5, 18.0999985, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Position = Vector3.new(49.5, 18.0999985, 83.5)
Part1.Color = Color3.new(0, 1, 0)
Part2.Name = "asd"
Part2.Parent = Model0
Part2.Transparency = 1
Part2.Anchored = true
Part2.CanCollide = false
Part2.Size = Vector3.new(1, 2, 1)
Part2.CFrame = CFrame.new(49.5, 18.0450001, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part2.BottomSurface = Enum.SurfaceType.Smooth
Part2.TopSurface = Enum.SurfaceType.Smooth
Part2.Position = Vector3.new(49.5, 18.0450001, 83.5)
weld(Model0)
Model1=Model0:Clone()
Model1.Parent=char
newWeld(larm,Model0.asd,0,0,0)
newWeld(rarm,Model1.asd,0,0,0)

Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
Part2 = Instance.new("Part")
Part3 = Instance.new("Part")
Model0.Parent = char
Part1.Parent = Model0
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(1.03999996, 0.27000007, 1.03999996)
Part1.CFrame = CFrame.new(28, 17.125, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Position = Vector3.new(28, 17.125, 83.5)
Part1.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part2.Parent = Model0
Part2.Anchored = true
Part2.CanCollide = false
Part2.Size = Vector3.new(1.01999998, 1.91000009, 1.01999998)
Part2.CFrame = CFrame.new(28, 18.0550003, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part2.BottomSurface = Enum.SurfaceType.Smooth
Part2.TopSurface = Enum.SurfaceType.Smooth
Part2.Position = Vector3.new(28, 18.0550003, 83.5)
Part2.Color = Color3.new(0.411765, 0.25098, 0.156863)
Part3.Name = "asd"
Part3.Parent = Model0
Part3.Transparency = 1
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(1, 2, 1)
Part3.CFrame = CFrame.new(28, 18, 83.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.TopSurface = Enum.SurfaceType.Smooth
Part3.Position = Vector3.new(28, 18, 83.5)
weld(Model0)
Model1=Model0:Clone()
Model1.Parent=char
newWeld(lleg,Model0.asd,0,0,0)
newWeld(rleg,Model1.asd,0,0,0)
]]
----------------------------------------------------------------------------
HitBox = Instance.new("Part",DebrisModel)
HitBox.Size = Vector3.new(0.5,0.5,2.45)
HitBox.CanCollide = false
HitBox:BreakJoints()
HitBox.Transparency = 1
newWeld(rarm,HitBox,0,-0.95,-1.9)
atch0 = Instance.new("Attachment",HitBox)
atch0.Position = Vector3.new(0,0,HitBox.Size.Z/2)
atch1 = Instance.new("Attachment",HitBox)
atch1.Position = Vector3.new(0,0,-HitBox.Size.Z/2)
trail = Instance.new("Trail",HitBox)
trail.Attachment0 = atch0
trail.Attachment1 = atch1
trail.Lifetime = 0.2
trail.Enabled = true
trail.LightEmission = 1
trail.LightInfluence = 0
trail.Color = ColorSequence.new(Color3.new(1,0,0))
trail.Transparency = NumberSequence.new(0,1)

function ded(model)
kills = kills + 1
	
--[[	model.Archivable = true
model.Head:ClearAllChildren()
local clone = model:Clone()
clone.Parent = workspace
clone.Name = "DED"
model:Destroy()
clone:FindFirstChildOfClass("Humanoid"):Destroy()
local emitters={}
for i,v in pairs(clone:GetChildren()) do
if v:IsA("Accoutrement") then
v:Destroy()
end
if v:IsA("Part") then
v.Anchored = true
v.CanCollide = false
v.Transparency = 1
local emitter = Instance.new("ParticleEmitter",v)
emitter.LightEmission = 1
emitter.Transparency = NumberSequence.new(0,1)
emitter.Size = NumberSequence.new(0,0.8)
emitter.SpreadAngle = Vector2.new(360,360)
emitter.Speed = NumberRange.new(0.5)
emitter.Lifetime = NumberRange.new(0.75)
emitter.Texture = "rbxassetid://744949545"
emitter.Rate = 20
emitter.Color = ColorSequence.new(Color3.new(1,1,1))
emitter.LockedToPart = false
table.insert(emitters,emitter)
end
end
delay(1, function()
sound(427025525,clone.Head.Position,10,1)
for i,v in pairs(emitters) do
v.Speed = NumberRange.new(4)
v.Acceleration = Vector3.new(0,10,0)
delay(0.5, function()
v.Enabled = false
debris:AddItem(clone,0.75) 
end)
end
end)]]
end

local alreadytouched = {}
HitBox.Touched:connect(function(ht)
coroutine.resume(coroutine.create(function()
local hit = ht.Parent
if mode == "determination" and hit.Name ~= "DED" and attacking == true and checkIfNotPlayer(ht) and hit:FindFirstChildOfClass("Humanoid") and hit:FindFirstChildOfClass("Humanoid").Health > 0 then
local hurt = true
for i,v in pairs(alreadytouched) do if v == hit then hurt = false end end
if hurt == true then
table.insert(alreadytouched,hit)
sound(388826051,ht.Position,10,1)
ded(hit)
end
end
end))
end)

function createknife()
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
BlockMesh2 = Instance.new("BlockMesh")
Part3 = Instance.new("Part")
BlockMesh4 = Instance.new("BlockMesh")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
BlockMesh7 = Instance.new("BlockMesh")
Part8 = Instance.new("Part")
Part9 = Instance.new("Part")
Part10 = Instance.new("Part")
SpecialMesh11 = Instance.new("SpecialMesh")
Part12 = Instance.new("Part")
Model0.Parent = char
Part1.Parent = Model0
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(0.280000031, 0.0500000007, 0.0500000007)
Part1.CFrame = CFrame.new(49.5, 20.7350044, 52.3199997, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Position = Vector3.new(49.5, 20.7350044, 52.3199997)
Part1.Color = Color3.new(0.972549, 0.972549, 0.972549)
BlockMesh2.Parent = Part1
BlockMesh2.Scale = Vector3.new(1, 0.399999797, 0.400000781)
BlockMesh2.Scale = Vector3.new(1, 0.399999797, 0.400000781)
Part3.Parent = Model0
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(0.220000014, 0.0500000007, 0.0500000007)
Part3.CFrame = CFrame.new(49.5, 20.6250038, 53.6199989, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.TopSurface = Enum.SurfaceType.Smooth
Part3.Position = Vector3.new(49.5, 20.6250038, 53.6199989)
Part3.Color = Color3.new(0.972549, 0.972549, 0.972549)
BlockMesh4.Parent = Part3
BlockMesh4.Scale = Vector3.new(1, 0.399999797, 0.400000781)
BlockMesh4.Scale = Vector3.new(1, 0.399999797, 0.400000781)
Part5.Parent = Model0
Part5.Anchored = true
Part5.CanCollide = false
Part5.Size = Vector3.new(0.159999996, 0.400000006, 1.70000005)
Part5.CFrame = CFrame.new(49.5, 20.5750046, 51.4300003, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part5.BottomSurface = Enum.SurfaceType.Smooth
Part5.TopSurface = Enum.SurfaceType.Smooth
Part5.Position = Vector3.new(49.5, 20.5750046, 51.4300003)
Part5.Color = Color3.new(1, 0, 0)
Part6.Parent = Model0
Part6.Anchored = true
Part6.CanCollide = false
Part6.Size = Vector3.new(0.280000031, 0.0500000007, 0.0500000007)
Part6.CFrame = CFrame.new(49.5, 20.4150047, 52.3199997, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.Position = Vector3.new(49.5, 20.4150047, 52.3199997)
Part6.Color = Color3.new(0.972549, 0.972549, 0.972549)
BlockMesh7.Parent = Part6
BlockMesh7.Scale = Vector3.new(1, 0.399999797, 0.400000781)
BlockMesh7.Scale = Vector3.new(1, 0.399999797, 0.400000781)
Part8.Name = "asd"
Part8.Parent = Model0
Part8.Anchored = true
Part8.CanCollide = false
Part8.Size = Vector3.new(0.200000003, 0.200000003, 1.30000007)
Part8.CFrame = CFrame.new(49.5, 20.6250038, 52.9300003, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part8.BottomSurface = Enum.SurfaceType.Smooth
Part8.TopSurface = Enum.SurfaceType.Smooth
Part8.Position = Vector3.new(49.5, 20.6250038, 52.9300003)
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part8.Transparency = 1
Part9.Parent = Model0
Part9.Anchored = true
Part9.CanCollide = false
Part9.Size = Vector3.new(0.200000003, 0.25999999, 0.100000039)
Part9.CFrame = CFrame.new(49.5, 20.595005, 53.6199989, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part9.BottomSurface = Enum.SurfaceType.Smooth
Part9.TopSurface = Enum.SurfaceType.Smooth
Part9.Position = Vector3.new(49.5, 20.595005, 53.6199989)
Part9.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part10.Parent = Model0
Part10.Rotation = Vector3.new(0, 0, 180)
Part10.Anchored = true
Part10.CanCollide = false
Part10.Size = Vector3.new(0.159999996, 0.400000006, 0.800000012)
Part10.CFrame = CFrame.new(49.5, 20.5750046, 50.1800003, -0.99999994, -8.74227766e-08, 3.82137093e-15, 8.74227695e-08, -1, 3.17865059e-08, 1.04250613e-15, 3.17865059e-08, 1)
Part10.BottomSurface = Enum.SurfaceType.Smooth
Part10.TopSurface = Enum.SurfaceType.Smooth
Part10.Position = Vector3.new(49.5, 20.5750046, 50.1800003)
Part10.Color = Color3.new(1, 0, 0)
SpecialMesh11.Parent = Part10
SpecialMesh11.MeshType = Enum.MeshType.Wedge
Part12.Parent = Model0
Part12.Anchored = true
Part12.CanCollide = false
Part12.Size = Vector3.new(0.25999999, 0.460000008, 0.100000039)
Part12.CFrame = CFrame.new(49.5, 20.5750046, 52.3199997, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.Position = Vector3.new(49.5, 20.5750046, 52.3199997)
Part12.Color = Color3.new(0.105882, 0.164706, 0.207843)
weld(Model0)
for i,v in pairs(Model0:GetChildren()) do
if v:IsA("Part") and v.Color == Color3.new(1,0,0) then
			v.Material = Enum.Material.Neon
			v.Transparency = 1
end
end
return Model0
end

local knifehat = gp(gp(gp(cnnnnn, "Red SS", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local knifennn = gp(gp(cnnnnn, "Red SS", "Accessory"), "Handle", "BasePart")
local knifennnn = gp(gp(cnnnnn.Model, "Red SS", "Accessory"), "Handle", "BasePart")

local pistolhat = gp(gp(gp(cnnnnn, "Meshes/1911RightAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local pistolnnn = gp(gp(cnnnnn, "Meshes/1911RightAccessory", "Accessory"), "Handle", "BasePart")


knife = createknife()
newWeld(rarm,knife.asd,0,-1,0)
knifehat.Parent = knife.asd
knifehat.Position = Vector3.new(0, 0, -1)
knifehat.Rotation = Vector3.new(45, 0, -0)


spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if mode == "justice" and attacking == true then

			if debounce == true then
				GlobalFunctions.fling(mouse.Hit.p, 0.05)
			end



		end
		if mode == "determination" then

			

			GlobalFunctions.fling(knifennnn, 0)


		end
	end
end)

----------------------------------------------------------------------------------------

function createpistol()
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
BlockMesh2 = Instance.new("BlockMesh")
Part3 = Instance.new("Part")
Part4 = Instance.new("Part")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
Part7 = Instance.new("Part")
Part8 = Instance.new("Part")
Part9 = Instance.new("Part")
Part10 = Instance.new("Part")
Part11 = Instance.new("Part")
Part12 = Instance.new("Part")
Part13 = Instance.new("Part")
Part14 = Instance.new("Part")
Part15 = Instance.new("Part")
Part16 = Instance.new("Part")
Part17 = Instance.new("Part")
Part18 = Instance.new("Part")
Part19 = Instance.new("Part")
Model0.Name = "Pistol"
Model0.Parent = char
Part1.Name = "ShootPos"
Part1.Parent = Model0
Part1.BrickColor = BrickColor.new("Really black")
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(0.100000001, 0.100000001, 0.0500000007)
Part1.CFrame = CFrame.new(-90, 10.5000019, 13.8957434, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part1.Position = Vector3.new(-90, 10.5000019, 13.8957434)
Part1.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
BlockMesh2.Parent = Part1
BlockMesh2.Scale = Vector3.new(1, 1, 0.199999988)
BlockMesh2.Scale = Vector3.new(1, 1, 0.199999988)
Part3.Parent = Model0
Part3.BrickColor = BrickColor.new("Pearl")
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(0.100000001, 0.550000012, 0.0500000007)
Part3.CFrame = CFrame.new(-90.0999985, 10.3750019, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.TopSurface = Enum.SurfaceType.Smooth
Part3.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part3.Position = Vector3.new(-90.0999985, 10.3750019, 13.8757429)
Part3.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part4.Parent = Model0
Part4.BrickColor = BrickColor.new("Pearl")
Part4.Anchored = true
Part4.CanCollide = false
Part4.Size = Vector3.new(0.300000012, 0.349999994, 0.0500000007)
Part4.CFrame = CFrame.new(-90, 10.2750025, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part4.BottomSurface = Enum.SurfaceType.Smooth
Part4.TopSurface = Enum.SurfaceType.Smooth
Part4.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part4.Position = Vector3.new(-90, 10.2750025, 13.8757429)
Part4.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part5.Parent = Model0
Part5.BrickColor = BrickColor.new("Pearl")
Part5.Rotation = Vector3.new(15, 0, 0)
Part5.Anchored = true
Part5.CanCollide = false
Part5.Size = Vector3.new(0.200000003, 0.25, 0.150000006)
Part5.CFrame = CFrame.new(-90, 10.4379425, 15.8274469, 1, 0, 0, 0, 0.965925753, -0.258819252, 0, 0.258819252, 0.965925753)
Part5.BottomSurface = Enum.SurfaceType.Smooth
Part5.TopSurface = Enum.SurfaceType.Smooth
Part5.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part5.Position = Vector3.new(-90, 10.4379425, 15.8274469)
Part5.Orientation = Vector3.new(15, 0, 0)
Part5.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part6.Parent = Model0
Part6.BrickColor = BrickColor.new("Pearl")
Part6.Anchored = true
Part6.CanCollide = false
Part6.Size = Vector3.new(0.300000012, 0.550000012, 1.89999998)
Part6.CFrame = CFrame.new(-90, 10.3750019, 14.8507433, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part6.Position = Vector3.new(-90, 10.3750019, 14.8507433)
Part6.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part7.Parent = Model0
Part7.BrickColor = BrickColor.new("Pearl")
Part7.Anchored = true
Part7.CanCollide = false
Part7.Size = Vector3.new(0.100000001, 0.0500000007, 0.0500000007)
Part7.CFrame = CFrame.new(-90.0999985, 10.6750021, 15.6257429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part7.BottomSurface = Enum.SurfaceType.Smooth
Part7.TopSurface = Enum.SurfaceType.Smooth
Part7.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part7.Position = Vector3.new(-90.0999985, 10.6750021, 15.6257429)
Part7.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part8.Parent = Model0
Part8.BrickColor = BrickColor.new("Black")
Part8.Rotation = Vector3.new(-15, 0, 0)
Part8.Anchored = true
Part8.CanCollide = false
Part8.Size = Vector3.new(0.220000014, 0.5, 0.209999993)
Part8.CFrame = CFrame.new(-90, 9.71499538, 15.4898481, 1, 0, 0, 0, 0.965925872, 0.258818835, 0, -0.258818835, 0.965925872)
Part8.BottomSurface = Enum.SurfaceType.Smooth
Part8.TopSurface = Enum.SurfaceType.Smooth
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part8.Position = Vector3.new(-90, 9.71499538, 15.4898481)
Part8.Orientation = Vector3.new(-15, 0, 0)
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part9.Parent = Model0
Part9.BrickColor = BrickColor.new("Pearl")
Part9.Anchored = true
Part9.CanCollide = false
Part9.Size = Vector3.new(0.100000001, 0.550000012, 0.0500000007)
Part9.CFrame = CFrame.new(-89.9000015, 10.3750019, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part9.BottomSurface = Enum.SurfaceType.Smooth
Part9.TopSurface = Enum.SurfaceType.Smooth
Part9.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part9.Position = Vector3.new(-89.9000015, 10.3750019, 13.8757429)
Part9.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part10.Parent = Model0
Part10.BrickColor = BrickColor.new("Pearl")
Part10.Anchored = true
Part10.CanCollide = false
Part10.Size = Vector3.new(0.100000001, 0.0500000007, 0.0500000007)
Part10.CFrame = CFrame.new(-89.9000015, 10.6750021, 15.6257429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part10.BottomSurface = Enum.SurfaceType.Smooth
Part10.TopSurface = Enum.SurfaceType.Smooth
Part10.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part10.Position = Vector3.new(-89.9000015, 10.6750021, 15.6257429)
Part10.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part11.Parent = Model0
Part11.BrickColor = BrickColor.new("Pearl")
Part11.Anchored = true
Part11.CanCollide = false
Part11.Size = Vector3.new(0.200000003, 0.150000006, 0.600000024)
Part11.CFrame = CFrame.new(-90, 9.37500191, 15.6007433, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part11.BottomSurface = Enum.SurfaceType.Smooth
Part11.TopSurface = Enum.SurfaceType.Smooth
Part11.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part11.Position = Vector3.new(-90, 9.37500191, 15.6007433)
Part11.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part12.Parent = Model0
Part12.BrickColor = BrickColor.new("Pearl")
Part12.Rotation = Vector3.new(-30, 0, 0)
Part12.Anchored = true
Part12.CanCollide = false
Part12.Size = Vector3.new(0.100000001, 0.150000006, 0.0500000007)
Part12.CFrame = CFrame.new(-90, 9.97165203, 15.1132431, 1, 0, 0, 0, 0.866025448, 0.5, 0, -0.5, 0.866025448)
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part12.Position = Vector3.new(-90, 9.97165203, 15.1132431)
Part12.Orientation = Vector3.new(-30, 0, 0)
Part12.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part13.Parent = Model0
Part13.BrickColor = BrickColor.new("Pearl")
Part13.Anchored = true
Part13.CanCollide = false
Part13.Size = Vector3.new(0.300000012, 0.100000001, 0.0500000007)
Part13.CFrame = CFrame.new(-90, 10.6000023, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part13.BottomSurface = Enum.SurfaceType.Smooth
Part13.TopSurface = Enum.SurfaceType.Smooth
Part13.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part13.Position = Vector3.new(-90, 10.6000023, 13.8757429)
Part13.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part14.Parent = Model0
Part14.BrickColor = BrickColor.new("Pearl")
Part14.Rotation = Vector3.new(-30, 0, 0)
Part14.Anchored = true
Part14.CanCollide = false
Part14.Size = Vector3.new(0.200000003, 0.100000001, 0.25)
Part14.CFrame = CFrame.new(-90, 10.5216522, 15.9065447, 1, 0, 0, 0, 0.866025329, 0.49999997, 0, -0.49999997, 0.866025329)
Part14.BottomSurface = Enum.SurfaceType.Smooth
Part14.TopSurface = Enum.SurfaceType.Smooth
Part14.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part14.Position = Vector3.new(-90, 10.5216522, 15.9065447)
Part14.Orientation = Vector3.new(-30, 0, 0)
Part14.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part15.Parent = Model0
Part15.BrickColor = BrickColor.new("White")
Part15.Rotation = Vector3.new(-105, 0, 0)
Part15.Anchored = true
Part15.CanCollide = false
Part15.Size = Vector3.new(0.100000001, 0.200000003, 0.0500000007)
Part15.CFrame = CFrame.new(-90, 9.92812252, 15.2373915, 1, 0, 0, 0, -0.258819371, 0.965925813, 0, -0.965925813, -0.258819371)
Part15.BottomSurface = Enum.SurfaceType.Smooth
Part15.TopSurface = Enum.SurfaceType.Smooth
Part15.Color = Color3.new(0.94902, 0.952941, 0.952941)
Part15.Position = Vector3.new(-90, 9.92812252, 15.2373915)
Part15.Orientation = Vector3.new(-75, 180, 180)
Part15.Color = Color3.new(0.94902, 0.952941, 0.952941)
Part16.Name = "asd"
Part16.Parent = Model0
Part16.BrickColor = BrickColor.new("Pearl")
Part16.Rotation = Vector3.new(-15, 0, 0)
Part16.Anchored = true
Part16.CanCollide = false
Part16.Size = Vector3.new(0.200000003, 1.14999998, 0.400000006)
Part16.CFrame = CFrame.new(-90, 9.93709087, 15.5425692, 1, 0, 0, 0, 0.965925872, 0.258818835, 0, -0.258818835, 0.965925872)
Part16.BottomSurface = Enum.SurfaceType.Smooth
Part16.TopSurface = Enum.SurfaceType.Smooth
Part16.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part16.Position = Vector3.new(-90, 9.93709087, 15.5425692)
Part16.Orientation = Vector3.new(-15, 0, 0)
Part16.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part17.Parent = Model0
Part17.BrickColor = BrickColor.new("Pearl")
Part17.Anchored = true
Part17.CanCollide = false
Part17.Size = Vector3.new(0.100000001, 0.100000001, 0.0500000007)
Part17.CFrame = CFrame.new(-90, 10.0500021, 15.0757437, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part17.BottomSurface = Enum.SurfaceType.Smooth
Part17.TopSurface = Enum.SurfaceType.Smooth
Part17.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part17.Position = Vector3.new(-90, 10.0500021, 15.0757437)
Part17.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part18.Parent = Model0
Part18.BrickColor = BrickColor.new("Pearl")
Part18.Anchored = true
Part18.CanCollide = false
Part18.Size = Vector3.new(0.100000001, 0.0500000007, 0.0500000007)
Part18.CFrame = CFrame.new(-90, 10.6750021, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part18.BottomSurface = Enum.SurfaceType.Smooth
Part18.TopSurface = Enum.SurfaceType.Smooth
Part18.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part18.Position = Vector3.new(-90, 10.6750021, 13.8757429)
Part18.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part19.Parent = Model0
Part19.BrickColor = BrickColor.new("Pearl")
Part19.Anchored = true
Part19.CanCollide = false
Part19.Size = Vector3.new(0.400000006, 0.200000003, 1.05000007)
Part19.CFrame = CFrame.new(-90, 10.1500015, 14.4757433, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part19.BottomSurface = Enum.SurfaceType.Smooth
Part19.TopSurface = Enum.SurfaceType.Smooth
Part19.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part19.Position = Vector3.new(-90, 10.1500015, 14.4757433)
Part19.Color = Color3.new(0.905882, 0.905882, 0.92549)
for i,v in pairs(Model0:GetChildren()) do
if v:IsA("Part") then
v.Color = Color3.new(1,1,0)
v.Material = Enum.Material.Neon
v.Transparency = 1 --0
v.CanCollide = false
end
end
weld(Model0)
return Model0
end

mode = "determination"
function justice()
mode = "justice"
for i=1,5 do ArtificialHB.Event:wait()
local asd = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,math.random(-10000,10000)/10000)
Effect(Enum.MeshType.Brick,Vector3.new(1,1,1),0,Enum.Material.Neon,Color3.new(1,1,0),rarm.RightGripAttachment.WorldPosition+(asd*1),asd*360,Vector3.new(0.5,0.5,0.5),asd*1,0.1,0.0005)
end
	knifehat.Parent = knifennn
	knifehat.Position = Vector3.new()
	knifehat.Rotation = Vector3.new()
knife:Destroy()
pistol = createpistol()
newWeld(rarm,pistol.asd,0,-1,0)
pistol.asd.Weld.C1 = CFrame.Angles(math.rad(110),0,0)
	pistolhat.Parent = pistol.asd
	pistolhat.Position = Vector3.new(0, 0.5, -0.3)
	pistolhat.Rotation = Vector3.new(105, -90, 0)
end

function determination()
mode = "determination"
for i=1,5 do ArtificialHB.Event:wait()
local asd = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,math.random(-10000,10000)/10000)
Effect(Enum.MeshType.Brick,Vector3.new(1,1,1),0,Enum.Material.Neon,Color3.new(1,0,0),rarm.RightGripAttachment.WorldPosition+(asd*1),asd*360,Vector3.new(0.5,0.5,0.5),asd*1,0.1,0.0005)
end
	pistolhat.Parent = pistolnnn
	pistolhat.Position = Vector3.new()
	pistolhat.Rotation = Vector3.new()
pistol:Destroy()
knife = createknife()
newWeld(rarm,knife.asd,0,-1,0)
	knifehat.Parent = knife.asd
	knifehat.Position = Vector3.new(0, 0, -1)
	knifehat.Rotation = Vector3.new(45, 0, -0)
end

debounce = false
mouse.KeyDown:connect(function(key)
if debounce == false then
debounce = true
if key == "e" then
sound(462606062,root.Position,10,1)
if mode == "determination" then
justice()
elseif mode == "justice" then
determination()
end
end
delay(0.3,function() debounce = false end)
end
end)

----------------------------------------------------------------------------------------

function slash()
local spd = 0.2
for i=1,15 do ArtificialHB.Event:wait()
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(-30),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(160),math.rad(0),math.rad(10)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(-50),math.rad(10)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(50),math.rad(-10)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
end
sound(357417055,root.Position,10,1)
attacking = true
local spd = 0.4
for i=1,5 do ArtificialHB.Event:wait()
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(80),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-20)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(80),math.rad(-20)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(-80),math.rad(20)), spd)
end
end

mouse.Button1Down:connect(function()
if debounce == false and mode == "determination" then
alreadytouched = {}
noidle = true
debounce = true
slash()
attacking = false
noidle = false
delay(0.05,function() debounce = false end)
end
end)

-----------------------------
local jumped = false
function boom()
attacking = true
freeze = true
sound(446961725,root.Position,10,1)
local bg = Instance.new("BodyGyro",root)
bg.Name = "lolnochara"
bg.P = 10000
bg.D = 100
bg.MaxTorque = Vector3.new(9e9,9e9,9e9)
if jumped == false then
root.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
else
root.CFrame = CFrame.new(root.Position,mouse.Hit.p)
bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
end

local spd = 0.2
for i=1,20 do ArtificialHB.Event:wait()
if jumped == false then
bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
else
bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
end
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(45),math.rad(0),math.rad(90)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(-5),math.rad(0)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(-20),math.rad(0)), spd)
end

bg:Destroy()

sound(470245800,root.Position,10,1)

local Part0 = Instance.new("Part",DebrisModel)
Part0.Name = "Bullet"
Part0.Material = Enum.Material.Neon
Part0.Color = Color3.new(1,1,0)
Part0.Anchored = true
local mesh = Instance.new("SpecialMesh",Part0)
mesh.MeshType = Enum.MeshType.Brick
Part0.CanCollide = false
local Position = rarm.Position
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local ray = Ray.new(Position, (Target-Position).unit*1048)
local part, endPoint = workspace:FindPartOnRay(ray, char)
Part0.Size = Vector3.new(5,1,5)
mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude+5,1)
local pos = Position + (direction * (mesh.Scale.Y/2))
Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
local loop = nil
local i = 0
rs:connect(function()
local lole = (i/10)
mesh.Scale = Vector3.new(lole,mesh.Scale.Y,lole)
Part0.Transparency = Part0.Transparency + 0.1
i = i + 1
if Part0.Transparency >= 1 then
Part0:Destroy()
end
end)

if part and part.Parent:FindFirstChildOfClass("Humanoid") and checkIfNotPlayer(part) == true then
coroutine.resume(coroutine.create(function()
sound(388826051,part.Position,10,1)
ded(part.Parent)
end))
end

local spd = 0.5
for i=1,10 do ArtificialHB.Event:wait()
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(45),math.rad(40),math.rad(90)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(-5),math.rad(0)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(-20),math.rad(0)), spd)
end

freeze = false
attacking = false
end

mouse.Button1Down:connect(function()
if debounce == false and mode == "justice" then
alreadytouched = {}
noidle = true
debounce = true
boom()
noidle = false
delay(0.05,function() debounce = false end)
end
end)

----------------------------------------------------------------------------------------
velocityYFall=0
velocityYFall2=0
velocityYFall3=0
velocityYFall4=0
neckrotY=0
neckrotY2=0
torsorotY=0
torsorotY2=0
torsoY=0
torsoY2=0
colored = 0
sine = 0
change=0.4
movement=5
timeranim=0
running = false
glitched = false
backup = hed.Weld.C1
glitchedC1 = hed.Weld.C1

mouse.KeyDown:connect(function(key)
key = string.lower(key)
if string.byte(key) == 48 then
running = true
local keyup = mouse.KeyUp:connect(function(key)
if string.byte(key) == 48 then
running = false
end
end)
repeat ArtificialHB.Event:wait() until running == false
keyup:disconnect()
end
end)

icolor=1
imode=false

didjump = false
jumppower = 0
freeze = false
debounceimpact = false

function jumpimpact()
if debounceimpact == false then
debounceimpact = true
if jumppower < -150 then jumppower = -150 end
shake(-jumppower/5)
for i=1,-jumppower/20 do ArtificialHB.Event:wait()
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0,0,0), 0.05)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, (jumppower/20)*size-hum.HipHeight, 0) * CFrame.Angles(math.rad(0),math.rad(0), math.rad(0)), 0.05)
end
debounceimpact = false
end
end

local sond = nil
while true do
	rswait()

if not torso:FindFirstChild("STATICSOUND") then
sond=Instance.new("Sound",torso)
sond.Name = "STATICSOUND"
sond.SoundId = "rbxassetid://223103466"
sond.Looped = true
sond:Play()
end

if icolor > 1 then
imode = false
elseif icolor < 0 then
imode = true
end

if imode == true then
icolor = icolor + 0.01
else
icolor = icolor - 0.01
end

for i,v in pairs(emitters) do
v.Acceleration = root.CFrame.upVector*(666/100)
end
--[[
if p.Character.Parent == nil then
--local model = Instance.new("Model")
--model.Name = p.Name
--p.Character = model
for i,v in pairs(char:GetChildren()) do
--v.Parent = p.Character
end
end

char = p.Character
if p.Character.Parent ~= workspace then
--p.Character.Parent = workspace
end
for i,v in pairs(char:GetChildren()) do
if v:IsA("Accoutrement") then
if v.Handle:FindFirstChild("Mesh") then
v.Handle:FindFirstChild("Mesh").Offset = Vector3.new()
v.Handle.Transparency = 0
end
elseif v:IsA("BasePart") then
v.Anchored = false
if v:FindFirstChildOfClass("BodyPosition") then
v:FindFirstChildOfClass("BodyPosition"):Destroy()
end
if v:FindFirstChildOfClass("BodyVelocity") then
v:FindFirstChildOfClass("BodyVelocity"):Destroy()
end
if v:FindFirstChildOfClass("BodyGyro") and v:FindFirstChildOfClass("BodyGyro").Name ~= "lolnochara" then
v:FindFirstChildOfClass("BodyGyro"):Destroy()
end
if v:FindFirstChild("Mesh") then
v:FindFirstChild("Mesh").Offset = Vector3.new()
end
if not DebrisModel:FindFirstChild(v.Name.."FORCEFIELD") then
local force = Instance.new("Part",DebrisModel)
force.Name = v.Name.."FORCEFIELD"
force.Size = v.Size+(Vector3.new(1,1,1)*0.2)
force.CanCollide = false
force.Transparency = 1
newWeld(v,force,0,0,0)
else
if not DebrisModel:FindFirstChild(v.Name.."FORCEFIELD"):FindFirstChildOfClass("Weld") then
newWeld(v,DebrisModel:FindFirstChild(v.Name.."FORCEFIELD"),0,0,0)
end
end
if v.Name ~= "HumanoidRootPart" then
v.Transparency = 0
else
v.Transparency = 1
end
end
end
]]
if mode == "determination" then
trail.Enabled = true
else
trail.Enabled = false
end

if freeze == false then
if running == false then
hum.WalkSpeed = 12*size
change=0.4
movement=5
else
hum.WalkSpeed = (666/10)*size
if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5*size then
change=1
else
change=0.4
end
movement=15
end
else
hum.WalkSpeed = 1
change=0.4
movement=5
end

if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 150 then
velocityYFall = root.Velocity.Y/1.5
else
if -root.Velocity.Y/1.5 < -5 then
velocityYFall = 5
elseif -root.Velocity.Y/1.5 > 150 then
velocityYFall = -150
end
end

if -root.Velocity.Y/180 > 0 and -root.Velocity.Y/180 < 1.2 then
velocityYFall2 = root.Velocity.Y/180
else
if -root.Velocity.Y/180 < 0 then
velocityYFall2 = 0
elseif -root.Velocity.Y/180 > 1.2 then
velocityYFall2 = -1.2
end
end

if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 50 then
velocityYFall3 = root.Velocity.Y/1.5
else
if -root.Velocity.Y/1.5 < -5 then
velocityYFall3 = 5
elseif -root.Velocity.Y/1.5 > 50 then
velocityYFall3 = -50
end
end

if -root.Velocity.Y/1.5 > -50 and -root.Velocity.Y/1.5 < 20 then
velocityYFall4 = root.Velocity.Y/1.5
else
if -root.Velocity.Y/180 < -5 then
velocityYFall4 = 5
elseif -root.Velocity.Y/180 > 50 then
velocityYFall4 = -50
end
end

if root.RotVelocity.Y/6 < 1 and root.RotVelocity.Y/6 > -1 then
neckrotY = root.RotVelocity.Y/6
else
if root.RotVelocity.Y/6 < -1 then
neckrotY = -1
elseif root.RotVelocity.Y/6 > 1 then
neckrotY = 1
end
end

if root.RotVelocity.Y/8 < 0.6 and root.RotVelocity.Y/8 > -0.6 then
neckrotY2 = root.RotVelocity.Y/8
else
if root.RotVelocity.Y/8 < -0.6 then
neckrotY2 = -0.6
elseif root.RotVelocity.Y/8 > 0.6 then
neckrotY2 = 0.6
end
end

if root.RotVelocity.Y/6 < 0.2 and root.RotVelocity.Y/6 > -0.2 then
torsorotY = root.RotVelocity.Y/6
else
if root.RotVelocity.Y/6 < -0.2 then
torsorotY = -0.2
elseif root.RotVelocity.Y/6 > 0.2 then
torsorotY = 0.2
end
end

if root.RotVelocity.Y/8 < 0.2 and root.RotVelocity.Y/8 > -0.2 then
torsorotY2 = root.RotVelocity.Y/8
else
if root.RotVelocity.Y/8 < -0.2 then
torsorotY2 = -0.2
elseif root.RotVelocity.Y/8 > 0.2 then
torsorotY2 = 0.2
end
end

torsoY = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/20
torsoY2 = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/36

local ray1 = Ray.new(root.Position+Vector3.new(size,0,0),Vector3.new(0, -4*size, 0))
local part1, endPoint = workspace:FindPartOnRay(ray1, char)
local ray2 = Ray.new(root.Position-Vector3.new(size,0,0),Vector3.new(0, -4*size, 0))
local part2, endPoint = workspace:FindPartOnRay(ray2, char)
local ray3 = Ray.new(root.Position+Vector3.new(0,0,size/2),Vector3.new(0, -4*size, 0))
local part3, endPoint = workspace:FindPartOnRay(ray3, char)
local ray4 = Ray.new(root.Position-Vector3.new(0,0,size/2),Vector3.new(0, -4*size, 0))
local part4, endPoint = workspace:FindPartOnRay(ray4, char)
local ray = Ray.new(root.Position,Vector3.new(0, -6, 0))
local part, endPoint = workspace:FindPartOnRay(ray, char)

if part1 or part2 or part3 or part4 then jumped = false else endPoint = 0 jumped = true end

local rlegray = Ray.new(rleg.Position+Vector3.new(0,size/2,0),Vector3.new(0, -1.75*size, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)

local llegray = Ray.new(lleg.Position+Vector3.new(0,size/2,0),Vector3.new(0, -1.75*size, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)

if hum.Health > 0 and noidle == false then
if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new((change/5)*math.sin(sine/4), 1.5, -.2) * CFrame.Angles(math.rad((torso.Velocity*Vector3.new(1, 0, 1)).magnitude/35),torsorotY, math.rad(0)+torsorotY), 0.4)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles((change/10)*math.cos(sine/2)+0.1,-(change/10)*math.cos(sine/4)-(torsorotY/5),(change/2)*math.sin(sine/4)), 0.1)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62-(movement/40)*math.cos(sine/4)/3,(movement/150)+(movement/40)*math.cos(sine/4))*CFrame.Angles(math.rad(-5-(movement*2)*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+(movement/40)*math.cos(sine/4)/3,(movement/150)-(movement/40)*math.cos(sine/4))*CFrame.Angles(math.rad(-5+(movement*2)*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.05+(change/2)*math.cos(sine/2), 0) * CFrame.Angles(math.rad(-(change*20)-(movement/20)*math.cos(sine/2)), torsorotY2+math.rad(0-4*math.cos(sine/4)), torsorotY2+math.rad(0-1*math.cos(sine/4))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,(-0.85-(movement/15)*math.cos(sine/4)/2),-0.1+(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)-movement*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,(-0.85+(movement/15)*math.cos(sine/4)/2),-0.1-(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)+movement*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
elseif jumped == true then
didjump = true
jumppower = root.Velocity.Y
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.1) * CFrame.Angles(0,0,0), 0.4)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-velocityYFall3/5),0,0), 0.1)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55-velocityYFall3/70,0)*CFrame.Angles(math.rad(-velocityYFall3/10),math.rad(0),math.rad(velocityYFall)), 0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55-velocityYFall3/70,0)*CFrame.Angles(math.rad(-velocityYFall3/10),math.rad(0),math.rad(-velocityYFall)), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(velocityYFall3/10),math.rad(0), math.rad(0)), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.925,0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(-2)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,0,-0.8)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(2)), 0.2)
elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 5*size then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5*size, -.1*size) * CFrame.Angles(math.rad((torso.Velocity*Vector3.new(1, 0, 1)).magnitude/35),0, 0), 0.4)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0.05*math.cos(sine/16)+0.15,0.05*math.cos(sine/32),0.01*math.cos(sine/32)), 0.1)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5*size,0.55*size-(0.1*size)*math.cos(sine/16)/3,-0.05-0.1*size*math.cos(sine/16))*CFrame.Angles(math.rad(-2+4*math.cos(sine/16)),math.rad(-5-5*math.cos(sine/16)),math.rad(-6+2*math.cos(sine/16))), 0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5*size,0.55*size-(0.1*size)*math.cos(sine/16)/3,-0.05-0.1*size*math.cos(sine/16))*CFrame.Angles(math.rad(-2+4*math.cos(sine/16)),math.rad(5+5*math.cos(sine/16)),math.rad(6-2*math.cos(sine/16))), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1*size-(0.1*size)*math.cos(sine/16)-hum.HipHeight, 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(0,llegendPoint.Y-lleg.Position.Y,0)*CFrame.new(-0.5*size,0*size+(0.1*size)*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+2*math.cos(sine/16)),math.rad(10+2*math.cos(sine/16)),math.rad(-5+1*math.cos(sine/32))), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0,rlegendPoint.Y-rleg.Position.Y,0)*CFrame.new(0.5*size,0*size+(0.1*size)*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+2*math.cos(sine/16)),math.rad(-10-2*math.cos(sine/16)),math.rad(5+1*math.cos(sine/32))), 0.2)
end
end
if didjump == true and jumped == false and jumppower < 0 then
didjump = false
jumpimpact()
end

local chance = math.random(0,10000)/100
if chance <= 5 + (kills/2) then
if glitched == false then
backup = hed.Weld.C1
end
if torso:FindFirstChild("MusicRuin") then
equalizer.HighGain = 0
equalizer.MidGain = -20
equalizer.LowGain = -80
end
hed.Weld.C1 = glitchedC1
local glitch_color = Color3.fromHSV(math.random(0,1000)/1000,1,1)
hed.Color = glitch_color
torso.Color = glitch_color
rarm.Color = glitch_color
larm.Color = glitch_color
rleg.Color = glitch_color
lleg.Color = glitch_color
shake(5)
glitched = true
hed.face.Texture = "rbxassetid://435233416"
sond:Resume()
else
if glitched == true then
glitched = false
hed.Weld.C1 = backup
glitchedC1 = backup*CFrame.Angles(math.rad(math.random(-40,40)),math.rad(math.random(-40,40)),math.rad(math.random(-20,20)))
end
if torso:FindFirstChild("MusicRuin") then
equalizer.HighGain = 0
equalizer.MidGain = 0
equalizer.LowGain = 0
end
--[[
hed.BrickColor = skin_color
torso.BrickColor = skin_color
rarm.BrickColor = skin_color
larm.BrickColor = skin_color
rleg.BrickColor = skin_color
lleg.BrickColor = skin_color
hed.face.Texture = "rbxassetid://422627909" ]]
sond:Pause()
end

timeposition = soundz.TimePosition
sine = sine + change
hum.Health = math.huge
hum.MaxHealth = math.huge
end

print("Loaded")
end)
Section:NewButton("FE Mercenary", "ButtonInfo", function()
kon=game:GetService("Players").LocalPlayer
--kon=require(script[':flushed: magic'])
Mouse,mouse,UserInputService,RenderStepped,Player=kon:GetMouse(),kon:GetMouse(),game:service'UserInputService',game:GetService('RunService').Heartbeat,kon
script = game:GetObjects("rbxassetid://5177488826")[1].Soldier
GlobalFunctions = {}
loadstring(game:HttpGet(('https://pastebin.com/raw/uq6axDFA'),true))()
loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()
-- -gh 6198633506,7167966065
-- -gh 7604371176,6202097932
local cnnnnn = game.Players.LocalPlayer.Character
local function gp(parent, name, className)
	local ret = nil
	if parent then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
			end
		end
	end
	return ret
end

-----------------------------------------------------------------------
--weld fun by DrexxieTheLoaf
--Script Rikaku/RedSquid/Bean
--Nebula_Loafua for the footplanting n stuff
-- || VARIABLES || -- 
local Players = game:GetService("Players")
local Character = kon.Character
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local HUM = Character.Humanoid
local ROOT = HUM.Torso
script.Owner.Value = kon.Name
script.Owner.Parent = game:GetService("ReplicatedStorage")
Humanoid.WalkSpeed = 24
local Debris = game:GetService("Debris")
--script.Assets.Parent = game.ReplicatedStorage
local Assets = script.Assets
for i,v in pairs(Assets:GetDescendants()) do
	if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end
local DEAGLE = Assets.DeagleHandle:Clone()
local DEAGLESHOOT = false
local AK12 = Assets.AKHandle:Clone()
local AKSHOOT = false
local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
local SHOOTING = false
OrgnC0 = Neck.C0
local gunScale = (Torso.Size.y/2) * 1
Dist = nil
Diff = nil

Humanoid.HipHeight = 0.1

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
TAN=math.tan
ATAN=math.atan
ATAN2=math.atan2
CE=math.ceil
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--><

script.Controls.Parent = Player.PlayerGui
Player.PlayerGui.Controls.Enabled =true
Player.PlayerGui.Controls.Main.Position = UDim2.new(0.715, 0,0.725, 0)

Animation_Speed = 3
Animation_Speed2 = 5
Frame_Speed = 1 / 60

local SINE = 0
local CHANGE = 2 / Animation_Speed
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local ANIM = "Idle"
local GUN = "Deagle"
local ATTACK = false
local WALKINGANIM = false
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(1, .50, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(-1, .50, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local RIGHTHIPC0 = CF(1, -1,  0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTHIPC0 = CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))


local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
ROBLOXIDLEANIMATION.Parent = Humanoid

local Effects = IT("Folder", Character)
Effects.Name = "Effects"




-- || ARTIFICIAL HEARTBEAT || -- 


ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

-- || FUNCTIONS || -- 


function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
local NEWWELD = IT(TYPE)
NEWWELD.Part0 = PART0
NEWWELD.Part1 = PART1
NEWWELD.C0 = C0
NEWWELD.C1 = C1
NEWWELD.Parent = PARENT
return NEWWELD
end
local function WeldBetween(a, b)
        local weldd = Instance.new("ManualWeld")
        weldd.Part0 = a
        weldd.Part1 = b
        weldd.C0 = CFrame.new()
        weldd.C1 = b.CFrame:inverse() * a.CFrame
        weldd.Parent = a
        return weldd
   end
local d = CF(0,0,0)
--Humanoid:removeAccessories()
local akhat = gp(gp(gp(cnnnnn, "Police K4LAS [Back]", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local aknnn = gp(gp(cnnnnn, "Police K4LAS [Back]", "Accessory"), "Handle", "BasePart")

local pistolhat = gp(gp(gp(cnnnnn, "Meshes/1911RightAccessory", "Accessory"), "Handle", "BasePart"), "att1_Handle", "Attachment")
local pistolnnn = gp(gp(cnnnnn, "Meshes/1911RightAccessory", "Accessory"), "Handle", "BasePart")

if Head.face then
Head.face.Transparency = 1
end
local Morph = script.Morph
for i,v in pairs(Morph:GetDescendants()) do
	if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
		v.Transparency = 1
	end
end
local hw = CreateWeldOrSnapOrMotor("Weld",Head,Morph.hed.Main,Head,d,d)
local lw = CreateWeldOrSnapOrMotor("Weld",LeftArm,Morph.la.Main,LeftArm,d,d)
local rw = CreateWeldOrSnapOrMotor("Weld",RightArm,Morph.ra.Main,RightArm,d,d)
local llw = CreateWeldOrSnapOrMotor("Weld",LeftLeg,Morph.ll.Main,LeftLeg,d,d)
local rlw = CreateWeldOrSnapOrMotor("Weld",RightLeg,Morph.rl.Main,RightLeg,d,d)
local tw = CreateWeldOrSnapOrMotor("Weld",Torso,Morph.tors.Main,Torso,CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(-90)),d)
for i,v in pairs(Morph:GetDescendants()) do
if v:IsA("BasePart") then
v.Anchored = false
end
end
Morph.Parent = Character
function QuaternionSClerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = ACOS(-cosTheta)
		local invSinTheta = 1 / SIN(theta)
		startInterp = SIN((t - 1) * theta) * invSinTheta
		finishInterp = SIN(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or ROOT.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = NewSound({ID = SOUNDID,PARENT = EFFECT,VOLUME = SOUNDVOLUME,PITCH = SOUNDPITCH,LOOP = false,MAXDISTANCE = 200,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.CFrame = CF(EFFECT.Position)*ANGLES(RAD(ORI.X),RAD(ORI.Y),RAD(ORI.Z))
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end
function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "643098245", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end


function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						--local CAMSHAKER = script.CamShake:Clone()
						--CAMSHAKER.Shake.Value = INTENSITY
						--CAMSHAKER.Timer.Value = TIME
						--CAMSHAKER.Parent = CHILD
						--CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

function AttachmentCFrame(A)
	return A.Parent.CFrame*CF(A.Position)
end

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end


function OofOuchBlood(LOCATION,TO,AMOUNT)
	local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
	P.CFrame = CF(LOCATION,TO)
	local BLOOD = Assets.Blood:Clone()
	BLOOD.Enabled = true
	BLOOD.Parent = P
	BLOOD:Emit(AMOUNT)
	Debris:AddItem(P,0.5)
end

function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end


function Clerp(a, b, t)
    return a:lerp(b,t)
end

function ManSlaughter(MAN)
	if MAN then
		local ROOT = MAN:FindFirstChild("HumanoidRootPart")
		if ROOT then
			--ROOT:Remove()
		end
		local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
		if MANHUM then
			--MANHUM.BreakJointsOnDeath = false
			--MANHUM.Health = 0
		end
		if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
			if MAN:FindFirstChild("UpperTorso") then
				--local SCRIPT = script.R15Ragdoll:Clone()
				--SCRIPT.Parent = MAN
				--SCRIPT.Disabled = false
			else
				--local SCRIPT = script.R6Ragdoll:Clone()
				--SCRIPT.Parent = MAN
				--SCRIPT.Disabled = false
			end
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			if TORSO then
				NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			end
		end
		--MAN:BreakJoints()
		if MAN:FindFirstChild("Slaughtered") == nil then
			--local MARK = IT("Folder",MAN)
			--MARK.Name = "Slaughtered"
			--for index, CHILD in pairs(MAN:GetChildren()) do
				--if CHILD:IsA("Script") and CHILD.Name ~= "Respawn" then
					--CHILD:Remove()
				--end
			--end
		else
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					--TORSO.RotVelocity = VT(0,MRANDOM(-25,25),0)
				end
			end
		end
	end
end

if GUN == "Deagle" then
	local DEAGLE1 = DEAGLE:Clone()
	DEAGLE1.Parent = LeftArm
	WeldBetween(LeftArm,DEAGLE1)
	pistolhat.Parent = DEAGLE1
	pistolhat.Rotation = Vector3.new(180, 0, 90)
	pistolhat.Position = Vector3.new(0, 0.25, 0)
	local DEAGLELWeld = CreateWeldOrSnapOrMotor("Weld",LeftArm,DEAGLE1,LeftArm,CF(-0.9,0,-0.8)*ANGLES(RAD(90),RAD(0),RAD(110)),CF(0,0,0))
end

local SONGS = {172843187,241184313,0,0,0,0}
local CHOICE = MRANDOM(1,2)
local sick = Instance.new("Sound",Torso)
sick.SoundId = "rbxassetid://172843187"
sick.Looped = true
sick.Parent = Torso
sick.Volume = .5
sick.Pitch = 1
sick:Play()

-----------------------------------
--------------------------------->
-----------------------------------

local HOLDINGMOUSE = false
local DEBOUNCE = false

-- || MOVES || -- 

local function DEALGEEQUIP()
	if GUN ~= "Deagle" then
		akhat.Parent = aknnn
		akhat.Rotation = Vector3.new()
		akhat.Position = Vector3.new()
		for i,v in pairs (LeftArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Left Arm" then
				v:Destroy()
			end
		end
		for i,v in pairs (RightArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Right Arm" then
				v:Destroy()
			end
		end
		GUN = "Deagle"
		local DEAGLE1 = DEAGLE:Clone()
		DEAGLE1.Parent = LeftArm
		WeldBetween(LeftArm,DEAGLE1)
		pistolhat.Parent = DEAGLE1
		
		pistolhat.Rotation = Vector3.new(180, 0, 90)
		pistolhat.Position = Vector3.new(0, 0.25, 0)
		local DEAGLELWeld = CreateWeldOrSnapOrMotor("Weld",LeftArm,DEAGLE1,LeftArm,CF(-0.9,0,-0.8)*ANGLES(RAD(90),RAD(0),RAD(110)),CF(0,0,0))
	end
end


local HOLDINGMOUSE = false
local DEBOUNCE = false
local function DEAGLESHOOOT()
if DEBOUNCE == false then
	DEBOUNCE = true
		repeat
			local DETECTKILL = function(HIT,POS,FORCE)
				if HIT.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
--[[
						HIT.Parent.Humanoid:TakeDamage(50)
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(ROOT.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
						BV.Parent = HIT
						Debris:AddItem(BV,0.05)
						OofOuchBlood(POS,ROOT.Position,50) ]]
					else
						--ManSlaughter(HIT.Parent)
						--OofOuchBlood(POS,ROOT.Position,1)
					end
					NewSound({ID = 5138136368,PARENT = HIT,VOLUME = 1,PITCH = MRANDOM(1,3),LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
						--OofOuchBlood(POS,ROOT.Position,50)
					else
						--OofOuchBlood(POS,ROOT.Position,1)
						--ManSlaughter(HIT.Parent.Parent)
					end
				end
			end
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(LeftArm.DeagleHandle.Flame.Flame).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 131205975, SoundPitch = 0.75, SoundVolume = 2.5})
		local HIT,POS = CastProperRay(AttachmentCFrame(LeftArm.DeagleHandle.Flame.Flame).p,mouse.Hit.p,900,Character)
			local DISTANCE = (POS - AttachmentCFrame(LeftArm.DeagleHandle.Flame.Flame).p).Magnitude
			if HIT then
				--DETECTKILL(HIT,POS,50)
			end
			WACKYEFFECT({Time = 8, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.5,0.5,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(LeftArm.DeagleHandle.Flame.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			--WACKYEFFECT({Time = 8, EffectType = "Block", Size = VT(0,0,DISTANCE), Size2 = VT(0.8,0.8,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(mouse.Hit.p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1,0.01 do
			Swait()
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(10), RAD(0), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.3,-0.5) * ANGLES(RAD(145), RAD(0), RAD(20)) * LEFTSHOULDERC0, i)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.3,0) * ANGLES(RAD(135), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, i)
		end
		for i = 1,1,0.01 do
			Swait()
			LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90), RAD(0), RAD(20)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
		end
		wait(0.5)
		until HOLDINGMOUSE ~= true
	DEBOUNCE = false
	end
end

local function AKEQUIP()
	if GUN ~= "AK12" then
		pistolhat.Parent = pistolnnn
		pistolhat.Rotation = Vector3.new()
		pistolhat.Position = Vector3.new()
		for i,v in pairs (LeftArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Left Arm" then
				v:Destroy()
			end
		end
		for i,v in pairs (RightArm:GetChildren()) do
			if v:IsA("Part") and v.Name ~= "Right Arm" then
				v:Destroy()
			end
		end
		GUN = "AK12"
		local AK121 = AK12:Clone()
		AK121.Parent = RightArm
		WeldBetween(RightArm,AK121)
		akhat.Parent = AK121
		akhat.Rotation = Vector3.new(0, 90, 0)
		akhat.Position = Vector3.new(0.8, 0.4, 0)
		local DEAGLELWeld = CreateWeldOrSnapOrMotor("Weld",RightArm,AK121,RightArm,CF(-0.9,0,0.6)*ANGLES(RAD(90),RAD(0),RAD(90)),CF(0,0,0))
	end
end

local HOLDINGMOUSE1 = false
local DEBOUNCE1 = false

local function AKSHOOOT()
	if DEBOUNCE1 == false then
		DEBOUNCE1 = true
		repeat
			local DETECTKILL = function(HIT,POS,FORCE)
				if HIT.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
--[[
						HIT.Parent.Humanoid:TakeDamage(10)
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(ROOT.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
						BV.Parent = HIT
						Debris:AddItem(BV,0.05)
						OofOuchBlood(POS,ROOT.Position,50) ]]
					else
						--ManSlaughter(HIT.Parent)
						--OofOuchBlood(POS,ROOT.Position,1)
					end
					NewSound({ID = 5138136368,PARENT = HIT,VOLUME = 1,PITCH = MRANDOM(1,3),LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true}) 
				elseif HIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					if HIT.Parent.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
						--OofOuchBlood(POS,ROOT.Position,50)
					else
						--OofOuchBlood(POS,ROOT.Position,1)
						--ManSlaughter(HIT.Parent.Parent)
					end
				end
			end
			WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(RightArm.AKHandle.Flame.Flame).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 153230559, SoundPitch = math.random(1,1.5), SoundVolume = 2.5})
		local HIT,POS = CastProperRay(AttachmentCFrame(RightArm.AKHandle.Flame.Flame).p,mouse.Hit.p,900,Character)
			local DISTANCE = (POS - AttachmentCFrame(RightArm.AKHandle.Flame.Flame).p).Magnitude
			if HIT then
				--DETECTKILL(HIT,POS,25)
			end
			WACKYEFFECT({Time = 9, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.3,0.3,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.AKHandle.Flame.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			for i = 1,1,0.01 do
				Swait()
				RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(22.5), RAD(0), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(130 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(130 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			end
			for i = 1,1,0.01 do
				Swait()
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.25 / Animation_Speed)
			end
			wait(0.1)
		until HOLDINGMOUSE1 ~= true
		DEBOUNCE1 = false
	end
end

local DEBOUNCE2 = false

local function Dash()
	if DEBOUNCE2 == false then
		DEBOUNCE2 = true
		local bodyvel = Instance.new("BodyVelocity",RootPart)
		local pep = 10000000
		bodyvel.P = pep
		bodyvel.MaxForce = Vector3.new(pep,pep,pep)
		bodyvel.Velocity = RootPart.CFrame.lookVector*100
		CreateSound(536642316,Torso,1,MRANDOM(1,1.5),false)
		--WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(10,10,10), Transparency = 0.25, Transparency2 = 1, CFrame = CF(Torso.Position) * ANGLES(RAD(90),RAD(Torso.Orientation.Y),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(25,25,25), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1.1,0.01 do
			Swait()
			Neck.C0 = Neck.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)) * NECKC0, i / Animation_Speed)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(-30),RAD(10),RAD(0)) * ROOTC0, i / Animation_Speed)
			if GUN == "Deagle" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			elseif GUN == "AK12" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			end
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,-0.5,-2.25) * ANGLES(RAD(-70), RAD(0), RAD(0)) * LEFTHIPC0, i / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(-20), RAD(0), RAD(0)) * RIGHTHIPC0, i / Animation_Speed)
		end
		bodyvel:Destroy()
		DEBOUNCE2 = false
	end
end

local function LeftDash()
	if DEBOUNCE2 == false then
		DEBOUNCE2 = true
		local bodyvel = Instance.new("BodyVelocity",RootPart)
		local pep = 10000000
		bodyvel.P = pep
		bodyvel.MaxForce = Vector3.new(pep,pep,pep)
		bodyvel.Velocity = RootPart.CFrame.rightVector*-50
		CreateSound(536642316,Torso,1,MRANDOM(1,1.5),false)
		--WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(10,10,10), Transparency = 0.25, Transparency2 = 1, CFrame = CF(Torso.Position) * ANGLES(RAD(90),RAD(Torso.Orientation.Y),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(25,25,25), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1.1,0.01 do
			Swait()
			Neck.C0 = Neck.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)) * NECKC0, i / Animation_Speed)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(20)) * ROOTC0, i / Animation_Speed)
			if GUN == "Deagle" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,1.25,0) * ANGLES(RAD(175 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.85,-0.50,0) * ANGLES(RAD(0), RAD(0), RAD(50)) * RIGHTSHOULDERC0, i / Animation_Speed)
			elseif GUN == "AK12" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			end
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,-0.25,-1.5) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTHIPC0, i / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(20)) * RIGHTHIPC0, i / Animation_Speed)
		end
		bodyvel:Destroy()
		DEBOUNCE2 = false
	end
end

local function RightDash()
	if DEBOUNCE2 == false then
		DEBOUNCE2 = true
		local bodyvel = Instance.new("BodyVelocity",RootPart)
		local pep = 10000000
		bodyvel.P = pep
		bodyvel.MaxForce = Vector3.new(pep,pep,pep)
		bodyvel.Velocity = RootPart.CFrame.rightVector*50
		CreateSound(536642316,Torso,1,MRANDOM(1,1.5),false)
		--WACKYEFFECT({Time = 30, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(10,10,10), Transparency = 0.25, Transparency2 = 1, CFrame = CF(Torso.Position) * ANGLES(RAD(90),RAD(Torso.Orientation.Y),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(25,25,25), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1,1.1,0.01 do
			Swait()
			Neck.C0 = Neck.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(0)) * NECKC0, i / Animation_Speed)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(0),RAD(0),RAD(-20)) * ROOTC0, i / Animation_Speed)
			if GUN == "Deagle" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" then
				LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, i / Animation_Speed)
				RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, i / Animation_Speed)
			end
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(-20)) * LEFTHIPC0, i / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0.25,-1.5) * ANGLES(RAD(-45), RAD(0), RAD(0)) * RIGHTHIPC0, i / Animation_Speed)
		end
		bodyvel:Destroy()
		DEBOUNCE2 = false
	end
end


-- || MOVE ACTIVATORS || -- 
Mouse.KeyDown:Connect(function(key)
	if key == "x" then
		DEALGEEQUIP()
		HOLDINGMOUSE1 = false
	elseif key == "c" then
		if HOLDINGMOUSE1 ~= true then
			HOLDINGMOUSE = false
			AKEQUIP()
		end
	elseif key == "z" then
		Dash()
	elseif key == "q" then
		LeftDash()
	elseif key == "e" then
		RightDash()
	elseif key:lower() == "1" and ATTACK == false then
		if CHOICE ~= 1 then
			CHOICE = 1
			sick:Play()
		end
    elseif key:lower() == "2" and ATTACK == false then
		if CHOICE ~= 2 then
			CHOICE = 2
			sick:Play()
		end
        elseif key:lower() == "3" and ATTACK == false then
            if CHOICE ~= 3 then
                CHOICE = 3
                sick:Play()
			end
       --[[ elseif key:lower() == "4" and ATTACK == false then
            if CHOICE ~= 4 then
                CHOICE = 4
                sick:Play()
			end
		elseif key:lower() == "5" and ATTACK == false then
            if CHOICE ~= 5 then
                CHOICE = 5
                sick:Play()
			end
		elseif key:lower() == "6" and ATTACK == false then
            if CHOICE ~= 6 then
                CHOICE = 6
                sick:Play() 	
			end]]
	end
end)

Mouse.Button1Down:Connect(function()
	if GUN == "Deagle" then
		HOLDINGMOUSE = true
		DEAGLESHOOOT()
	end
	if GUN == "AK12" then
		HOLDINGMOUSE1 = true
		AKSHOOOT()
	end
end)

Mouse.Button1Up:Connect(function()
	if GUN == "Deagle" then
		HOLDINGMOUSE = false
		HOLDINGMOUSE1 = false
	elseif GUN == "AK12" then
		HOLDINGMOUSE = false
		HOLDINGMOUSE1 = false
	end
end)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		if HOLDINGMOUSE == true and GUN == "Deagle" then

			if DEBOUNCE == true then
				GlobalFunctions.fling(Mouse.Hit.p, 0.05)
			end
			
			
			
		end
		if HOLDINGMOUSE1 == true and GUN == "AK12" then


			
			GlobalFunctions.fling(Mouse.Hit.p, 0.01)
			
			
		end
	end
end)


--><
local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local WalkSpeed = 24
local Walking = Humanoid.MoveDirection.magnitude>0

while true do
	local sidevec = math.clamp((ROOT.Velocity*ROOT.CFrame.rightVector).X+(ROOT.Velocity*ROOT.CFrame.rightVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local forwardvec =  math.clamp((ROOT.Velocity*ROOT.CFrame.lookVector).X+(ROOT.Velocity*ROOT.CFrame.lookVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local sidevelocity = sidevec/Humanoid.WalkSpeed
	local forwardvelocity = forwardvec/Humanoid.WalkSpeed
	Swait()
--Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*4.8,0.55*4.8),math.random(-0.55*4.8,0.55*4.8),math.random(-0.55*4.8,0.55*4.8)),0.44)
		--script.Parent = GUI
ANIMATE.Parent = nil
	Humanoid.Parent = Character
	if Humanoid then
		local IDLEANIMATION = Humanoid:LoadAnimation(ROBLOXIDLEANIMATION)
		IDLEANIMATION:Play()
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		if ATTACK == false and DEBOUNCE2 == false then
			ANIM = "Idle"
				local _, Point = workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), workspace, false, true)
           	 	Dist = (Head.CFrame.p-Point).magnitude
            	Diff = Head.CFrame.Y-Point.Y
				if GUN == "Deagle" then
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,.05 + .05 * COS(SINE/30)) * ANGLES(RAD(-2 - 3 * COS(SINE/30)), RAD(0), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
					Neck.C0 = Neck.C0:lerp(CF(0,0,0 + .05 * COS(SINE/31)) * ANGLES(RAD(-2 - 5 * COS(SINE/31)), RAD(0), RAD(0)) * NECKC0, 0.15 / Animation_Speed)
					LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(-0 + 5.05 * COS(SINE/30)), RAD(10), RAD(-2)) * LEFTHIPC0, 0.55 / Animation_Speed)
					RightHip.C0 = RightHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(0 + 5.05 * COS(SINE/30)), RAD(-12), RAD(2.1)) * RIGHTHIPC0, 0.55 / Animation_Speed)
				elseif GUN == "AK12" then
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
					Neck.C0 = Neck.C0:lerp(CF(0,0,0 + .05 * COS(SINE/31)) * ANGLES(RAD(-2 - 5 * COS(SINE/31)), RAD(30), RAD(0)) * NECKC0, 0.15 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,.05 + .05 * COS(SINE/30)) * ANGLES(RAD(-2 - 3 * COS(SINE/30)), RAD(-30), RAD(0)) * ROOTC0, 0.15 / Animation_Speed)
					LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(-0 + 5.05 * COS(SINE/30)), RAD(10), RAD(-2)) * LEFTHIPC0, 0.15 / Animation_Speed)
					RightHip.C0 = RightHip.C0:lerp(CF(0,0,-.1 + .05 * COS(SINE/30)) * ANGLES(RAD(0 + 5.05 * COS(SINE/30)), RAD(-12), RAD(2.1)) * RIGHTHIPC0, 0.15 / Animation_Speed)
				end
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		if ATTACK == false and DEBOUNCE2 == false then 
			Change=.5
			ANIM = "Run"
			local _, Point = workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), workspace, false, true)
            Dist = (Head.CFrame.p-Point).magnitude
            Diff = Head.CFrame.Y-Point.Y
            --LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5+.5*COS(SINE/3), -.5) * ANGLES(RAD(90), RAD(0), RAD(70- 25 * SIN(SINE/.02))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			
			if GUN == "Deagle" and HOLDINGMOUSE == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.5)*forwardvec, RAD(-0 - 0.5 * COS(SINE/4))*forwardvec, RAD(-sidevec/2)) * ROOTC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "Deagle" and HOLDINGMOUSE == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.5)*forwardvec, RAD(-0 - 0.5 * COS(SINE/4))*forwardvec, RAD(-sidevec/2)) * ROOTC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.8)*forwardvec, RAD(-0 - 0.7 * COS(SINE/4))*forwardvec, RAD(-sidevec/1.5)) * ROOTC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					RootJoint.C0 = RootJoint.C0:lerp(CF(0,0 - .2 * SIN(SINE/1.75),-0 - .2 * SIN(SINE/1.75)) * ANGLES(RAD(-.8)*forwardvec, RAD(-0 - 0.7 * COS(SINE/4))*forwardvec, RAD(-sidevec/1.5)) * ROOTC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			end
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0 + 0.5 * COS(SINE/4.05)) * ANGLES(RAD(20 + 85 * COS(SINE/4.05)*forwardvelocity), RAD(-0 + 10 * COS(SINE/4)), RAD(sidevec*COS(SINE/4.05))) * RIGHTHIPC0, 0.15 / Animation_Speed)
			RightHip.C0 = RightHip.C0:lerp(CF(0,0 - 1 * SIN(SINE/4.05),0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTHIPC0, 0.15 / Animation_Speed)
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,0,0 - 0.5 * COS(SINE/4.05)) * ANGLES(RAD(20 - 85 * COS(SINE/4.05))*forwardvelocity, RAD(-0 - 10 * COS(SINE/4)), RAD(-sidevec*COS(SINE/4.05))) * LEFTHIPC0, 0.15 / Animation_Speed)
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,0 + 1 * SIN(SINE/4.05),0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTHIPC0, 0.15 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		if ATTACK == false and DEBOUNCE2 == false then
			ANIM = "Jump"
			if GUN == "Deagle" and HOLDINGMOUSE == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "Deagle" and HOLDINGMOUSE == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			end
		RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(-30), RAD(0), RAD(0)) * RIGHTHIPC0, 0.15 / 2)
		LeftHip.C0 = LeftHip.C0:lerp(CF(0,1,-.8) * ANGLES(RAD(-20), RAD(0), RAD(0)) * LEFTHIPC0, 0.15 / 2)
		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(20), RAD(0), RAD(0)) * ROOTC0, 0.15 / 2)
		end
	elseif TORSOVERTICALVELOCITY < -0 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false and DEBOUNCE2 == false then
			if GUN == "Deagle" and HOLDINGMOUSE == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(25 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.8,0) * ANGLES(RAD(20 + 1.02 * COS(SINE/31)), RAD(25 + 0 * COS(SINE/32)), RAD(-50 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "Deagle" and HOLDINGMOUSE == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,0.5,-0.5) * ANGLES(RAD(90 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.8,0.5,0) * ANGLES(RAD(90 + 1.02 * COS(SINE/31)), RAD(-0 + 0 * COS(SINE/32)), RAD(-45 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == false then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0,-0.25,-0.5) * ANGLES(RAD(50 - 1 * COS(SINE/31)), RAD(0 + 0 * COS(SINE/32)), RAD(-10 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.15,-0.1,0.1) * ANGLES(RAD(100 + 1.02 * COS(SINE/31)), RAD(45 + 0 * COS(SINE/32)), RAD(-70 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			elseif GUN == "AK12" and HOLDINGMOUSE1 == true then
					Neck.C0 = Neck.C0:lerp(ANGLES(0,0,0)* NECKC0, 0.25 / Animation_Speed)
					LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(0.5,0.5,-0.9) * ANGLES(RAD(90), RAD(0 + 0 * COS(SINE/32)), RAD(20 + .5 * COS(SINE/33))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightShoulder.C0 = RightShoulder.C0:lerp(CF(-0.2,0.5,-0.5) * ANGLES(RAD(90), RAD(-0 + 0 * COS(SINE/32)), RAD(-30 + .8 * COS(SINE/33))) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
			end
			RightHip.C0 = RightHip.C0:lerp(CF(0,0,0) * ANGLES(RAD(-30 + 20 * CE(SINE/100000)), RAD(0), RAD(0)) * RIGHTHIPC0, 0.05 / 2)
			LeftHip.C0 = LeftHip.C0:lerp(CF(0,1 - .5 * CE(SINE/100000),-.8 + 1 * CE(SINE/100000)) * ANGLES(RAD(-20 + 60 * CE(SINE/100000)), RAD(0), RAD(0)) * LEFTHIPC0, 0.05 / 2)
			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0) * ANGLES(RAD(20 - 40 * CE(SINE/100000)), RAD(0), RAD(0)) * ROOTC0, 0.05 / 2)
		end
	end
	sick.Parent = Torso
    sick:resume()
    sick.Volume = .5
    sick.Pitch = 1
    sick.SoundId = "rbxassetid://"..SONGS[CHOICE]
end
print("Loaded")
end)

local Tab = Window:NewTab("Hats")
local Section = Tab:NewSection("Clicking these will set the hats to your clipboard")

Section:NewButton("Maddox LC", "copies hat ids to clipboard", function()
setclipboard("4623059912")
end)


Section:NewButton("Halo", "copies hat ids to clipboard", function()
setclipboard("5064344615, 7167966065, 6114870953")
end)


Section:NewButton("Shotgun", "copies hat ids to clipboard", function()
setclipboard("5134896593")
end)

Section:NewButton("Cops", "copies hat ids to clipboard", function()
setclipboard("8590591043, 7168000945")
end)

Section:NewButton("Glove and Sword", "copies hat ids to clipboard", function()
setclipboard("9239416688")
end)

Section:NewButton("Zenith Rifle", "copies hat ids to clipboard", function()
setclipboard("6703871350, 8590591043")
end)

Section:NewButton("Exotic Cannon", "copies hat ids to clipboard", function()
setclipboard("4623059912")
end)

Section:NewButton("Andrfix Studio Dummy", "copies hat ids to clipboard", function()
setclipboard("5136154487")
end)

Section:NewButton("Studio Dummy v1", "copies hat ids to clipboard", function()
setclipboard("191101707")
end)

Section:NewButton("Studio Dummy v2", "copies hat ids to clipboard", function()
setclipboard("45136154487")
end)

Section:NewButton("Baseball Bat", "copies hat ids to clipboard", function()
setclipboard("7063113820")
end)

Section:NewButton("Snake Banisher v4", "copies hat ids to clipboard", function()
setclipboard("4623059912")
end)

Section:NewButton("Skidded Cannon v2", "copies hat ids to clipboard", function()
setclipboard("4623059912")
end)

Section:NewButton("Lightning Cannon v4", "copies hat ids to clipboard", function()
setclipboard("4623059912")
end)

Section:NewButton("Studio Dummy Switcher v2.1", "copies hat ids to clipboard", function()
setclipboard("5136154487")
end)

Section:NewButton("Suicide Gun", "copies hat ids to clipboard", function()
setclipboard("7542631784")
end)

Section:NewButton("Chara", "copies hat ids to clipboard", function()
setclipboard("7604371176, 7170689370")
end)

Section:NewButton("Mercenary", "copies hat ids to clipboard", function()
setclipboard("7604371176, 6202097932")
end)



local Tab = Window:NewTab("Credits")
local Section = Tab:NewSection("Credit to luvbxe#1893 for making the hub")
Section:NewButton("copy x2qiz server to clipboard", "title reads all", function()
setclipboard("https://discord.gg/TqejqctcPD")
end)
local Section = Tab:NewSection("copper#0001 for minor tweaks")